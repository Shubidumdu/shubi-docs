<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Organizing Data - Shubi Docs</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../../index.html">Introduction</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.</strong> Web</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../web/web-performance/index.html"><strong aria-hidden="true">1.1.</strong> 웹 성능 최적화 기법</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../web/web-performance/what-is-web-performance.html"><strong aria-hidden="true">1.1.1.</strong> 웹 성능이란 무엇인가?</a></li><li class="chapter-item "><a href="../../../web/web-performance/web-optimization.html"><strong aria-hidden="true">1.1.2.</strong> 웹 최적화</a></li><li class="chapter-item "><a href="../../../web/web-performance/basic-optimization.html"><strong aria-hidden="true">1.1.3.</strong> 웹 사이트 성능을 개선하는 기본적인 방법</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../js/index.html"><strong aria-hidden="true">2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../js/exec-ctx.html"><strong aria-hidden="true">2.1.</strong> 실행 컨텍스트</a></li><li class="chapter-item "><a href="../../../js/class.html"><strong aria-hidden="true">2.2.</strong> 클래스</a></li><li class="chapter-item "><a href="../../../js/arrow-func.html"><strong aria-hidden="true">2.3.</strong> 화살표 함수</a></li><li class="chapter-item "><a href="../../../js/binding-function.html"><strong aria-hidden="true">2.4.</strong> 함수 바인딩</a></li><li class="chapter-item "><a href="../../../js/call-apply.html"><strong aria-hidden="true">2.5.</strong> call, apply</a></li><li class="chapter-item "><a href="../../../js/closure.html"><strong aria-hidden="true">2.6.</strong> 클로저</a></li><li class="chapter-item "><a href="../../../js/func-exp-and-dec.html"><strong aria-hidden="true">2.7.</strong> 함수 표현식 vs 함수 선언문</a></li><li class="chapter-item "><a href="../../../js/event-loop.html"><strong aria-hidden="true">2.8.</strong> 이벤트 루프</a></li><li class="chapter-item "><a href="../../../js/new.html"><strong aria-hidden="true">2.9.</strong> new와 생성자 함수</a></li><li class="chapter-item "><a href="../../../js/properties.html"><strong aria-hidden="true">2.10.</strong> 프로퍼티</a></li><li class="chapter-item "><a href="../../../js/prototype.html"><strong aria-hidden="true">2.11.</strong> 프로토타입</a></li><li class="chapter-item "><a href="../../../js/this.html"><strong aria-hidden="true">2.12.</strong> this</a></li><li class="chapter-item "><a href="../../../js/var.html"><strong aria-hidden="true">2.13.</strong> var를 쓰지 않는 이유</a></li><li class="chapter-item "><a href="../../../js/babel.html"><strong aria-hidden="true">2.14.</strong> Babel</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.15.</strong> Web APIs</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../js/web-api/intersection.html"><strong aria-hidden="true">2.15.1.</strong> Intersection Observer</a></li><li class="chapter-item "><a href="../../../js/web-api/mutation.html"><strong aria-hidden="true">2.15.2.</strong> Mutation Observer</a></li><li class="chapter-item "><a href="../../../js/web-api/template.html"><strong aria-hidden="true">2.15.3.</strong> Template Element</a></li><li class="chapter-item "><a href="../../../js/web-api/shadow-dom/intro.html"><strong aria-hidden="true">2.15.4.</strong> Shadow DOM</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../js/web-api/shadow-dom/slot.html"><strong aria-hidden="true">2.15.4.1.</strong> Slot</a></li><li class="chapter-item "><a href="../../../js/web-api/shadow-dom/styling.html"><strong aria-hidden="true">2.15.4.2.</strong> Styling</a></li><li class="chapter-item "><a href="../../../js/web-api/shadow-dom/events.html"><strong aria-hidden="true">2.15.4.3.</strong> Events</a></li></ol></li><li class="chapter-item "><a href="../../../js/web-api/canvas/intro.html"><strong aria-hidden="true">2.15.5.</strong> Canvas API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../js/web-api/canvas/shapes.html"><strong aria-hidden="true">2.15.5.1.</strong> 도형 그리기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.16.</strong> Guides</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../js/guides/render-opt.html"><strong aria-hidden="true">2.16.1.</strong> 렌더링 최적화</a></li><li class="chapter-item "><a href="../../../js/guides/custom-el-checklist.html"><strong aria-hidden="true">2.16.2.</strong> Custom Element 체크리스트</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../ts/index.html"><strong aria-hidden="true">3.</strong> TypeScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/intro/index.html"><strong aria-hidden="true">3.1.</strong> 타입스크립트 알아보기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/intro/ts_js.html"><strong aria-hidden="true">3.1.1.</strong> TS와 JS의 관계</a></li><li class="chapter-item "><a href="../../../ts/intro/setting.html"><strong aria-hidden="true">3.1.2.</strong> TS 설정 이해하기</a></li><li class="chapter-item "><a href="../../../ts/intro/transpile.html"><strong aria-hidden="true">3.1.3.</strong> 코드 생성과 타입이 관계없음을 이해하기</a></li><li class="chapter-item "><a href="../../../ts/intro/typing.html"><strong aria-hidden="true">3.1.4.</strong> 구조적 타이핑에 익숙해지기</a></li><li class="chapter-item "><a href="../../../ts/intro/no_any.html"><strong aria-hidden="true">3.1.5.</strong> any 타입 지양하기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/types/index.html"><strong aria-hidden="true">3.2.</strong> 타입스크립트의 타입 시스템</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/types/use_editor.html"><strong aria-hidden="true">3.2.1.</strong> 편집기를 사용하여 타입 시스템 탐색하기</a></li><li class="chapter-item "><a href="../../../ts/types/set.html"><strong aria-hidden="true">3.2.2.</strong> 타입이 값들의 집합이라고 생각하기</a></li><li class="chapter-item "><a href="../../../ts/types/symbol.html"><strong aria-hidden="true">3.2.3.</strong> 타입 공간과 값 공간의 심벌 구분하기</a></li><li class="chapter-item "><a href="../../../ts/types/type-def.html"><strong aria-hidden="true">3.2.4.</strong> 타입 단언보다는 타입 선언을 사용하기</a></li><li class="chapter-item "><a href="../../../ts/types/wrapper.html"><strong aria-hidden="true">3.2.5.</strong> 객체 래퍼 타입 피하기</a></li><li class="chapter-item "><a href="../../../ts/types/excess-type-check.html"><strong aria-hidden="true">3.2.6.</strong> 잉여 속성 체크의 한계 인지하기</a></li><li class="chapter-item "><a href="../../../ts/types/function-expression.html"><strong aria-hidden="true">3.2.7.</strong> 함수 표현식에 타입 적용하기</a></li><li class="chapter-item "><a href="../../../ts/types/type-and-interface.html"><strong aria-hidden="true">3.2.8.</strong> 타입과 인터페이스의 차이점 알기</a></li><li class="chapter-item "><a href="../../../ts/types/generics.html"><strong aria-hidden="true">3.2.9.</strong> 타입 연산과 제너릭 사용으로 반복 줄이기</a></li><li class="chapter-item "><a href="../../../ts/types/index-signature.html"><strong aria-hidden="true">3.2.10.</strong> 동적 데이터에 인덱스 시그니처 사용하기</a></li><li class="chapter-item "><a href="../../../ts/types/no-index-signature.html"><strong aria-hidden="true">3.2.11.</strong> number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></li><li class="chapter-item "><a href="../../../ts/types/readonly.html"><strong aria-hidden="true">3.2.12.</strong> 변경 관련된 오류 방지를 위해 readonly 사용하기</a></li><li class="chapter-item "><a href="../../../ts/types/mapped-type.html"><strong aria-hidden="true">3.2.13.</strong> 매핑된 타입을 사용하여 값을 동기화하기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/type-inference/index.html"><strong aria-hidden="true">3.3.</strong> 타입 추론</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/type-inference/use-inferable-types.html"><strong aria-hidden="true">3.3.1.</strong> 추론 가능한 타입을 사용해 장황한 코드 방지하기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/use-const.html"><strong aria-hidden="true">3.3.2.</strong> 다른 타입에는 다른 변수 사용하기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/type-widening.html"><strong aria-hidden="true">3.3.3.</strong> 타입 넓히기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/type-narrowing.html"><strong aria-hidden="true">3.3.4.</strong> 타입 좁히기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/create-object-at-once.html"><strong aria-hidden="true">3.3.5.</strong> 한꺼번에 객체 생성하기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/avoid-aliasing.html"><strong aria-hidden="true">3.3.6.</strong> 일관성있는 별칭 사용하기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/use-async.html"><strong aria-hidden="true">3.3.7.</strong> 비동기 코드에는 콜백 대신 async 함수 사용하기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/context-inference.html"><strong aria-hidden="true">3.3.8.</strong> 타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></li><li class="chapter-item "><a href="../../../ts/type-inference/well-typed-lib.html"><strong aria-hidden="true">3.3.9.</strong> 함수형 기법과 라이브러리로 타입 흐름 유지하기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/design/index.html"><strong aria-hidden="true">3.4.</strong> 타입 설계</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/design/valid-states.html"><strong aria-hidden="true">3.4.1.</strong> 유효한 상태만 표현하는 타입을 지향하기</a></li><li class="chapter-item "><a href="../../../ts/design/loose-accept-strict-produce.html"><strong aria-hidden="true">3.4.2.</strong> 사용할 때는 너그럽게, 생성할 때는 엄격하게</a></li><li class="chapter-item "><a href="../../../ts/design/jsdoc-repeat.html"><strong aria-hidden="true">3.4.3.</strong> 문서에 타입 정보를 쓰지 않기</a></li><li class="chapter-item "><a href="../../../ts/design/null-values-to-perimeter.html"><strong aria-hidden="true">3.4.4.</strong> 타입 주변에 null값 배치하기</a></li><li class="chapter-item "><a href="../../../ts/design/union-of-interfaces.html"><strong aria-hidden="true">3.4.5.</strong> 유니온의 인터페이스보다는 인터페이스의 유니온 사용하기</a></li><li class="chapter-item "><a href="../../../ts/design/avoid-strings.html"><strong aria-hidden="true">3.4.6.</strong> string 타입보다 더 구체적인 타입 사용하기</a></li><li class="chapter-item "><a href="../../../ts/design/incomplete-over-innacurate.html"><strong aria-hidden="true">3.4.7.</strong> 부정확한 타입보다는 미완성 타입을 사용하기</a></li><li class="chapter-item "><a href="../../../ts/design/consider-codegen.html"><strong aria-hidden="true">3.4.8.</strong> 데이터가 아닌, API와 명세를 보고 타입 만들기</a></li><li class="chapter-item "><a href="../../../ts/design/language-of-domain.html"><strong aria-hidden="true">3.4.9.</strong> 해당 분야의 용어로 타입 이름 짓기</a></li><li class="chapter-item "><a href="../../../ts/design/brands.html"><strong aria-hidden="true">3.4.10.</strong> 공식 명칭에는 상표를 붙이기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/any/index.html"><strong aria-hidden="true">3.5.</strong> any 다루기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/any/narrowest-any.html"><strong aria-hidden="true">3.5.1.</strong> any 타입은 가능한 한 좁은 범위에서만 사용하기</a></li><li class="chapter-item "><a href="../../../ts/any/specific-any.html"><strong aria-hidden="true">3.5.2.</strong> any를 구체적으로 변형해서 사용하기</a></li><li class="chapter-item "><a href="../../../ts/any/hide-unsafe-casts.html"><strong aria-hidden="true">3.5.3.</strong> 함수 안으로 타입 단언문 감추기</a></li><li class="chapter-item "><a href="../../../ts/any/evolving-any.html"><strong aria-hidden="true">3.5.4.</strong> any의 진화를 이해하기</a></li><li class="chapter-item "><a href="../../../ts/any/never-unknown.html"><strong aria-hidden="true">3.5.5.</strong> 모르는 타입의 값에는 any 대신 unknown을 사용하기</a></li><li class="chapter-item "><a href="../../../ts/any/type-safe-monkey.html"><strong aria-hidden="true">3.5.6.</strong> 몽키 패치보다는 안전한 타입을 사용하기</a></li><li class="chapter-item "><a href="../../../ts/any/type-percentage.html"><strong aria-hidden="true">3.5.7.</strong> 타입 커버리지를 추적하여 타입 안정성 유지하기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/declarations/index.html"><strong aria-hidden="true">3.6.</strong> 타입 선언과 @types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/declarations/dev-dependencies.html"><strong aria-hidden="true">3.6.1.</strong> devDependencies에 typescript와 @types 추가하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/understand-ts-types.html"><strong aria-hidden="true">3.6.2.</strong> 타입 선언과 관련된 세 가지 버전 이해하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/export-your-types.html"><strong aria-hidden="true">3.6.3.</strong> 공개 API에 등장하는 모든 타입을 export하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/use-tsdoc.html"><strong aria-hidden="true">3.6.4.</strong> API 주석에 TSDoc 사용하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/this-in-callbacks.html"><strong aria-hidden="true">3.6.5.</strong> 콜백에서 this에 대한 타입 제공하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/conditional-overload.html"><strong aria-hidden="true">3.6.6.</strong> 오버로딩 타입보다는 조건부 타입을 사용하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/mirror-types-for-deps.html"><strong aria-hidden="true">3.6.7.</strong> 의존성 분리를 위해 미러 타입 사용하기</a></li><li class="chapter-item "><a href="../../../ts/declarations/test-your-types.html"><strong aria-hidden="true">3.6.8.</strong> 테스팅 타입의 함정에 주의하기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/write-run/index.html"><strong aria-hidden="true">3.7.</strong> 코드를 작성하고 실행하기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/write-run/avoid-non-ecma.html"><strong aria-hidden="true">3.7.1.</strong> 타입스크립트 기능보다는 ECMASCript 기능을 사용하기</a></li><li class="chapter-item "><a href="../../../ts/write-run/iterate-objects.html"><strong aria-hidden="true">3.7.2.</strong> 객체를 순회하는 노하우</a></li><li class="chapter-item "><a href="../../../ts/write-run/understand-the-dom.html"><strong aria-hidden="true">3.7.3.</strong> DOM 계층 구조 이해하기</a></li><li class="chapter-item "><a href="../../../ts/write-run/private-rely.html"><strong aria-hidden="true">3.7.4.</strong> 정보를 감추는 목적으로 private 사용하지 않기</a></li><li class="chapter-item "><a href="../../../ts/write-run/source-maps-debug.html"><strong aria-hidden="true">3.7.5.</strong> 소스맵을 사용하여 타입스크립트 디버깅하기</a></li></ol></li><li class="chapter-item "><a href="../../../ts/migrate/index.html"><strong aria-hidden="true">3.8.</strong> 타입스크립트로 마이그레이션하기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ts/migrate/write-modern-js.html"><strong aria-hidden="true">3.8.1.</strong> 모던 자바스크립트로 작성하기</a></li><li class="chapter-item "><a href="../../../ts/migrate/jsdoc-tscheck.html"><strong aria-hidden="true">3.8.2.</strong> 타입스크립트 도입 전에 @ts-check와 JsDoc으로 시험해 보기</a></li><li class="chapter-item "><a href="../../../ts/migrate/allow-js.html"><strong aria-hidden="true">3.8.3.</strong> allowJs로 타입스크립트와 자바스크립트 같이 사용하기</a></li><li class="chapter-item "><a href="../../../ts/migrate/convert-up-the-graph.html"><strong aria-hidden="true">3.8.4.</strong> 의존성 관계에 따라 모듈 단위로 전환하기</a></li><li class="chapter-item "><a href="../../../ts/migrate/start-loose.html"><strong aria-hidden="true">3.8.5.</strong> 마이그레이션의 완성을 위해 noImplicitAny 설정하기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> React</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../react/why.html"><strong aria-hidden="true">4.1.</strong> 왜 React인가?</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> Redux</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../redux/pure.html"><strong aria-hidden="true">5.1.</strong> 왜 Reducer는 순수해야 하는가?</a></li></ol></li><li class="chapter-item "><a href="../../../svelte/intro.html"><strong aria-hidden="true">6.</strong> Svelte</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../svelte/reactivity.html"><strong aria-hidden="true">6.1.</strong> Reactivity</a></li><li class="chapter-item "><a href="../../../svelte/props.html"><strong aria-hidden="true">6.2.</strong> Props</a></li><li class="chapter-item "><a href="../../../svelte/logic.html"><strong aria-hidden="true">6.3.</strong> Logic</a></li><li class="chapter-item "><a href="../../../svelte/events.html"><strong aria-hidden="true">6.4.</strong> Events</a></li><li class="chapter-item "><a href="../../../svelte/bindings.html"><strong aria-hidden="true">6.5.</strong> Bindings</a></li><li class="chapter-item "><a href="../../../svelte/lifecycle.html"><strong aria-hidden="true">6.6.</strong> Life Cycle</a></li><li class="chapter-item "><a href="../../../svelte/stores.html"><strong aria-hidden="true">6.7.</strong> Stores</a></li><li class="chapter-item "><a href="../../../svelte/motion.html"><strong aria-hidden="true">6.8.</strong> Motion</a></li><li class="chapter-item "><a href="../../../svelte/transition.html"><strong aria-hidden="true">6.9.</strong> Transitions</a></li><li class="chapter-item "><a href="../../../svelte/animations.html"><strong aria-hidden="true">6.10.</strong> Animations</a></li><li class="chapter-item "><a href="../../../svelte/actions.html"><strong aria-hidden="true">6.11.</strong> Actions</a></li><li class="chapter-item "><a href="../../../svelte/classes.html"><strong aria-hidden="true">6.12.</strong> Classes</a></li><li class="chapter-item "><a href="../../../svelte/composition.html"><strong aria-hidden="true">6.13.</strong> Component Composition</a></li><li class="chapter-item "><a href="../../../svelte/context.html"><strong aria-hidden="true">6.14.</strong> Context API</a></li><li class="chapter-item "><a href="../../../svelte/specials.html"><strong aria-hidden="true">6.15.</strong> Special Elements</a></li><li class="chapter-item "><a href="../../../svelte/module.html"><strong aria-hidden="true">6.16.</strong> Module Context</a></li><li class="chapter-item "><a href="../../../svelte/debug.html"><strong aria-hidden="true">6.17.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="../../../graphql/intro.html"><strong aria-hidden="true">7.</strong> GraphQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../graphql/execution.html"><strong aria-hidden="true">7.1.</strong> Execution</a></li><li class="chapter-item "><a href="../../../graphql/query-mutation.html"><strong aria-hidden="true">7.2.</strong> Query & Mutation</a></li><li class="chapter-item "><a href="../../../graphql/schema-type.html"><strong aria-hidden="true">7.3.</strong> Schema & Type</a></li><li class="chapter-item "><a href="../../../graphql/pagination.html"><strong aria-hidden="true">7.4.</strong> Pagination</a></li><li class="chapter-item "><a href="../../../graphql/http.html"><strong aria-hidden="true">7.5.</strong> HTTP에서의 GraphQL</a></li></ol></li><li class="chapter-item "><a href="../../../docker/setup.html"><strong aria-hidden="true">8.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../docker/sample.html"><strong aria-hidden="true">8.1.</strong> 샘플 애플리케이션</a></li><li class="chapter-item "><a href="../../../docker/update.html"><strong aria-hidden="true">8.2.</strong> 애플리케이션 수정</a></li><li class="chapter-item "><a href="../../../docker/share.html"><strong aria-hidden="true">8.3.</strong> 애플리케이션 공유</a></li><li class="chapter-item "><a href="../../../docker/persist.html"><strong aria-hidden="true">8.4.</strong> DB 유지</a></li><li class="chapter-item "><a href="../../../docker/bind-mounts.html"><strong aria-hidden="true">8.5.</strong> Bind Mounts</a></li><li class="chapter-item "><a href="../../../docker/multi.html"><strong aria-hidden="true">8.6.</strong> 멀티 컨테이너 앱</a></li><li class="chapter-item "><a href="../../../docker/docker-compose.html"><strong aria-hidden="true">8.7.</strong> Docker Compose</a></li><li class="chapter-item "><a href="../../../docker/best-practices.html"><strong aria-hidden="true">8.8.</strong> 실전 이미지 빌딩</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> Etc.</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../etc/ssh.html"><strong aria-hidden="true">9.1.</strong> SSH</a></li><li class="chapter-item "><a href="../../../etc/tdd.html"><strong aria-hidden="true">9.2.</strong> TDD</a></li><li class="chapter-item "><a href="../../../etc/fp.html"><strong aria-hidden="true">9.3.</strong> 함수형 프로그래밍</a></li><li class="chapter-item "><a href="../../../etc/rp.html"><strong aria-hidden="true">9.4.</strong> 반응형 프로그래밍</a></li></ol></li><li class="chapter-item "><a href="../../../ml/index.html"><strong aria-hidden="true">10.</strong> Machine Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ml/problem-framing/index.html"><strong aria-hidden="true">10.1.</strong> Problem Framing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ml/problem-framing/common-problems.html"><strong aria-hidden="true">10.1.1.</strong> Common ML Problems</a></li><li class="chapter-item "><a href="../../../ml/problem-framing/mindset.html"><strong aria-hidden="true">10.1.2.</strong> The ML Mindset</a></li><li class="chapter-item "><a href="../../../ml/problem-framing/good.html"><strong aria-hidden="true">10.1.3.</strong> Identifying Good Problems for ML</a></li><li class="chapter-item "><a href="../../../ml/problem-framing/hard.html"><strong aria-hidden="true">10.1.4.</strong> Hard ML Problems</a></li><li class="chapter-item "><a href="../../../ml/problem-framing/framing.html"><strong aria-hidden="true">10.1.5.</strong> Deciding on ML</a></li><li class="chapter-item "><a href="../../../ml/problem-framing/formulate.html"><strong aria-hidden="true">10.1.6.</strong> Formulate Your Problem as an ML Problem</a></li></ol></li><li class="chapter-item "><a href="../../../ml/crash-course/index.html"><strong aria-hidden="true">10.2.</strong> Crash Course</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../ml/crash-course/framing.html"><strong aria-hidden="true">10.2.1.</strong> Framing</a></li><li class="chapter-item "><a href="../../../ml/crash-course/descending-into-ml.html"><strong aria-hidden="true">10.2.2.</strong> Descending into ML</a></li><li class="chapter-item "><a href="../../../ml/crash-course/reducing-loss.html"><strong aria-hidden="true">10.2.3.</strong> Reducing Loss</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">11.</strong> AWS</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../aws/iam.html"><strong aria-hidden="true">11.1.</strong> IAM</a></li><li class="chapter-item "><a href="../../../aws/ec2.html"><strong aria-hidden="true">11.2.</strong> EC2</a></li><li class="chapter-item "><a href="../../../aws/ami.html"><strong aria-hidden="true">11.3.</strong> AMI</a></li><li class="chapter-item "><a href="../../../aws/ebs.html"><strong aria-hidden="true">11.4.</strong> EBS</a></li><li class="chapter-item "><a href="../../../aws/efs.html"><strong aria-hidden="true">11.5.</strong> EFS</a></li><li class="chapter-item "><a href="../../../aws/ebs-vs-efs.html"><strong aria-hidden="true">11.6.</strong> EBS vs. EFS</a></li><li class="chapter-item "><a href="../../../aws/elb.html"><strong aria-hidden="true">11.7.</strong> ELB</a></li><li class="chapter-item "><a href="../../../aws/rds.html"><strong aria-hidden="true">11.8.</strong> RDS</a></li><li class="chapter-item "><a href="../../../aws/route53.html"><strong aria-hidden="true">11.9.</strong> Route 53</a></li><li class="chapter-item "><a href="../../../aws/eb.html"><strong aria-hidden="true">11.10.</strong> Elastic Beanstalk</a></li><li class="chapter-item "><a href="../../../aws/s3.html"><strong aria-hidden="true">11.11.</strong> S3</a></li><li class="chapter-item "><a href="../../../aws/cf.html"><strong aria-hidden="true">11.12.</strong> CloudFront</a></li><li class="chapter-item "><a href="../../../aws/storage-extra.html"><strong aria-hidden="true">11.13.</strong> Storage Extras</a></li><li class="chapter-item "><a href="../../../aws/decouple-applications.html"><strong aria-hidden="true">11.14.</strong> Decoupling Applications</a></li><li class="chapter-item "><a href="../../../aws/containers.html"><strong aria-hidden="true">11.15.</strong> Containers</a></li><li class="chapter-item "><a href="../../../aws/serverless.html"><strong aria-hidden="true">11.16.</strong> Serverless</a></li><li class="chapter-item "><a href="../../../aws/databases.html"><strong aria-hidden="true">11.17.</strong> Databases</a></li><li class="chapter-item "><a href="../../../aws/data-analytics.html"><strong aria-hidden="true">11.18.</strong> Data & Analytics</a></li><li class="chapter-item "><a href="../../../aws/machine-learning.html"><strong aria-hidden="true">11.19.</strong> Machine Learning</a></li><li class="chapter-item "><a href="../../../aws/monitoring.html"><strong aria-hidden="true">11.20.</strong> Monitoring & Audit</a></li><li class="chapter-item "><a href="../../../aws/iam-advanced.html"><strong aria-hidden="true">11.21.</strong> IAM Advanced</a></li><li class="chapter-item "><a href="../../../aws/security.html"><strong aria-hidden="true">11.22.</strong> Security & Encryption</a></li><li class="chapter-item "><a href="../../../aws/vpc.html"><strong aria-hidden="true">11.23.</strong> Networking - VPC</a></li><li class="chapter-item "><a href="../../../aws/disaster-recovery.html"><strong aria-hidden="true">11.24.</strong> Disaster Recovery & Migrations</a></li><li class="chapter-item "><a href="../../../aws/more-solution-architectures.html"><strong aria-hidden="true">11.25.</strong> More Solution Architectures</a></li><li class="chapter-item "><a href="../../../aws/other-services.html"><strong aria-hidden="true">11.26.</strong> Other Services</a></li><li class="chapter-item "><a href="../../../aws/white-paper.html"><strong aria-hidden="true">11.27.</strong> WhitePapers and Architectures</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> Network</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../network/osi-model.html"><strong aria-hidden="true">12.1.</strong> OSI Model</a></li></ol></li><li class="chapter-item expanded "><a href="../../../refactoring/index.html"><strong aria-hidden="true">13.</strong> Refactoring</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../refactoring/what-is-refactoring.html"><strong aria-hidden="true">13.1.</strong> 리팩토링이란?</a></li><li class="chapter-item "><a href="../../../refactoring/code-smells/index.html"><strong aria-hidden="true">13.2.</strong> Code Smells</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../refactoring/code-smells/bloaters/index.html"><strong aria-hidden="true">13.2.1.</strong> Bloaters</a></li><li class="chapter-item "><a href="../../../refactoring/code-smells/object-orientation-abusers/index.html"><strong aria-hidden="true">13.2.2.</strong> Object-Orientation Abusers</a></li><li class="chapter-item "><a href="../../../refactoring/code-smells/change-preventers/index.html"><strong aria-hidden="true">13.2.3.</strong> Change Preventers</a></li><li class="chapter-item "><a href="../../../refactoring/code-smells/dispensables/index.html"><strong aria-hidden="true">13.2.4.</strong> Dispensables</a></li><li class="chapter-item "><a href="../../../refactoring/code-smells/couplers/index.html"><strong aria-hidden="true">13.2.5.</strong> Couplers</a></li><li class="chapter-item "><a href="../../../refactoring/code-smells/other-smells/index.html"><strong aria-hidden="true">13.2.6.</strong> Other Smells</a></li></ol></li><li class="chapter-item expanded "><a href="../../../refactoring/refactoring-techniques/index.html"><strong aria-hidden="true">13.3.</strong> Refactoring Techniques</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../refactoring/refactoring-techniques/composing-methods/index.html"><strong aria-hidden="true">13.3.1.</strong> Composing Methods</a></li><li class="chapter-item "><a href="../../../refactoring/refactoring-techniques/moving-features-between-objects/index.html"><strong aria-hidden="true">13.3.2.</strong> Moving Features Between Objects</a></li><li class="chapter-item expanded "><a href="../../../refactoring/refactoring-techniques/organizing-data/index.html" class="active"><strong aria-hidden="true">13.3.3.</strong> Organizing Data</a></li><li class="chapter-item "><a href="../../../refactoring/refactoring-techniques/simplifying-conditional-expressions/index.html"><strong aria-hidden="true">13.3.4.</strong> Simplifying Conditional Expressions</a></li><li class="chapter-item "><a href="../../../refactoring/refactoring-techniques/simplifying-method-calls/index.html"><strong aria-hidden="true">13.3.5.</strong> Simplifying Method Calls</a></li><li class="chapter-item "><a href="../../../refactoring/refactoring-techniques/dealing-with-generalization/index.html"><strong aria-hidden="true">13.3.6.</strong> Dealing with Generalization</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shubi Docs</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="organizing-data"><a class="header" href="#organizing-data">Organizing Data</a></h1>
<ul>
<li><a href="#organizing-data">Organizing Data</a>
<ul>
<li><a href="#%EC%9E%90%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%84%EB%93%9C-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EA%B8%B0-self-encapsulate-field">자체적으로 필드 캡슐화하기 (Self Encapsulate Field)</a></li>
<li><a href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%92%EC%9D%84-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EC%A0%84%ED%99%98%ED%95%98%EA%B8%B0-replace-data-value-with-object">데이터 값을 객체로 전환하기 (Replace Data Value with Object)</a></li>
<li><a href="#%EA%B0%92%EC%9D%84-%EC%B0%B8%EC%A1%B0%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0-change-value-to-reference">값을 참조로 바꾸기 (Change Value to Reference)</a></li>
<li><a href="#%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0-change-reference-to-value">참조를 객체로 바꾸기 (Change Reference to Value)</a></li>
<li><a href="#%EB%B0%B0%EC%97%B4%EC%9D%84-%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EB%8C%80%EC%B2%B4%ED%95%98%EA%B8%B0-replace-array-with-object">배열을 객체로 대체하기 (Replace Array with Object)</a></li>
<li><a href="#%EA%B4%80%EC%B0%B0%EB%90%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EB%B3%B5-duplicate-observed-data">관찰된 데이터 중복 (Duplicate Observed Data)</a></li>
<li><a href="#%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B2%B0%EC%9D%84-%EC%96%91%EB%B0%A9%ED%96%A5%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD-change-unidirectional-association-to-bidirectional">단방향 연결을 양방향으로 변경 (Change Unidirectional Association to Bidirectional)</a></li>
<li><a href="#%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B2%B0%EC%9D%84-%EB%8B%A8%EB%B0%A9%ED%96%A5%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD-change-bidirectional-association-to-unidirectional">양방향 연결을 단방향으로 변경 (Change Bidirectional Association to Unidirectional)</a></li>
<li><a href="#%EB%A7%A4%EC%A7%81-%EB%84%98%EB%B2%84%EB%A5%BC-%EA%B8%B0%ED%98%B8-%EC%83%81%EC%88%98%EB%A1%9C-%EB%8C%80%EC%B2%B4-replace-magic-number-with-symbolic-constant">매직 넘버를 기호 상수로 대체 (Replace Magic Number with Symbolic Constant)</a></li>
<li><a href="#%ED%95%84%EB%93%9C-%EC%BA%A1%EC%8A%90%ED%99%94-encapsulate-field">필드 캡슐화 (Encapsulate Field)</a></li>
<li><a href="#%EC%BB%AC%EB%A0%89%EC%85%98-%EC%BA%A1%EC%8A%90%ED%99%94-encapsulate-collection">컬렉션 캡슐화 (Encapsulate Collection)</a></li>
<li><a href="#%ED%83%80%EC%9E%85-%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EB%8C%80%EC%B2%B4-replace-type-code-with-class">타입 코드를 클래스로 대체 (Replace Type Code with Class)</a></li>
<li><a href="#%ED%83%80%EC%9E%85-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%84%9C%EB%B8%8C%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EB%8C%80%EC%B2%B4-replace-type-code-with-subclasses">타입 코드를 서브클래스로 대체 (Replace Type Code with Subclasses)</a></li>
<li><a href="#%ED%83%80%EC%9E%85-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%83%81%ED%83%9C%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EB%8C%80%EC%B2%B4-replace-type-code-with-statestrategy">타입 코드를 상태/전략 패턴으로 대체 (Replace Type Code with State/Strategy)</a></li>
<li><a href="#%EC%84%9C%EB%B8%8C%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%ED%95%84%EB%93%9C%EB%A1%9C-%EB%8C%80%EC%B2%B4-replace-subclass-with-fields">서브클래스를 필드로 대체 (Replace Subclass with Fields)</a></li>
</ul>
</li>
</ul>
<p>해당 범주의 리팩터링 기술은 데이터 처리를 도와주며, primitive 타입을 풍부한 클래스 기능으로 대체한다.</p>
<p>또 다른 중요한 결과는 클래스 간의 연결을 끊어 클래스의 이식성(portable)과 재사용성을 향상시킬 수 있다는 것이다.</p>
<h2 id="자체적으로-필드-캡슐화하기-self-encapsulate-field"><a class="header" href="#자체적으로-필드-캡슐화하기-self-encapsulate-field">자체적으로 필드 캡슐화하기 (Self Encapsulate Field)</a></h2>
<blockquote>
<p>어떤 클래스 내의 프라이빗 필드에 직접 접근하고 있는 경우</p>
</blockquote>
<p>해당 필드에 대한 getter/setter를 생성하여, 해당 필드에 접근할 때는 오직 이들만을 사용하도록 한다.</p>
<p>클래스 내 프라이빗 필드에 직접 액세스하는 것으로는 유연성이 충분하지 않을 수 있다. 쿼리가 수행될 때 필드값을 초기화하거나, 필드에 새로운 값을 할당할 때 부가적인 작업을 처리할 수 있는 등, getter/setter 사용 시 많은 경우에 더 유연한 대처가 가능해진다.</p>
<p>또한, 서브클래스에서 getter/setter를 재정의하는 것이 가능하다는 점도 큰 이점이다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Range {
  private low: number
  private high: number;
  includes(arg: number): boolean {
    return arg &gt;= this.low &amp;&amp; arg &lt;= this.high;
  }
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Range {
  private _low: number;
  private _high: number;
  includes(arg: number): boolean {
    return arg &gt;= this.low &amp;&amp; arg &lt;= this.high;
  }
  get low(): number {
    return this._low;
  }
  get high(): number {
    return this._high;
  }
}
</code></pre>
<h2 id="데이터-값을-객체로-전환하기-replace-data-value-with-object"><a class="header" href="#데이터-값을-객체로-전환하기-replace-data-value-with-object">데이터 값을 객체로 전환하기 (Replace Data Value with Object)</a></h2>
<blockquote>
<p>클래스(또는 여러 클래스)에 어떤 데이터 필드가 있고, 해당 필드가 고유한 역할을 수행하고 관련 데이터를 보유하는 경우</p>
</blockquote>
<p>새로운 클래스를 만들어, 기존 필드와 그것의 동작을 새 클래스로 옮긴 다음, 기존의 클래스에는 새로 만든 클래스의 객체를 보관한다.</p>
<p>이러한 리팩터링은 기본적으로 <a href="../moving-features-between-objects/index.html#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B6%94%EC%B6%9C-extract-class">클래스 추출</a>로부터 확장되는 특수한 케이스다. 이것의 차이점은 리팩터링의 원인에 있다.</p>
<p>&quot;클래스 추출&quot;의 경우 서로 다른 작업을 담당하는 단일 클래스가 있어 그 책임을 분리하고자 하는 것이 목적이다.</p>
<p>반면, &quot;데이터 값을 객체로 전환하기&quot;의 경우, 데이터 값이 primitive 필드로 존재함에 따라, 여러 클래스에서 해당 필드를 이용하고, 그에 대해 유사한 작업을 요구할 가능성이 있기 때문에, 중복 코드가 발생할 가능성이 생겨 이를 방지하고자 하는 것이다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Order {
  customer: string;
  // ...
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Order {
  customer: Customer;
  // ...
}

class Customer {
  name: string;
  // ...
}
</code></pre>
<h2 id="값을-참조로-바꾸기-change-value-to-reference"><a class="header" href="#값을-참조로-바꾸기-change-value-to-reference">값을 참조로 바꾸기 (Change Value to Reference)</a></h2>
<blockquote>
<p>하나의 객체로 대체해야 하는 하나의 클래스에 동일한 인스턴스가 여러 개 있는 경우</p>
</blockquote>
<p>매번 생성할 필요가 없는 동일한 객체 여러개 생성하고 있는 경우, 이를 하나의 참조 객체로 대체한다.</p>
<p>이 경우 참조 객체에서 변경이 일어나면, 이를 참조하는 다른 곳에서도 이러한 변경 사항에 액세스할 수 있게 된다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">const customer = new Customer(customerData);
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">const customer = customerRepository.get(customerData.id);
</code></pre>
<h2 id="참조를-객체로-바꾸기-change-reference-to-value"><a class="header" href="#참조를-객체로-바꾸기-change-reference-to-value">참조를 객체로 바꾸기 (Change Reference to Value)</a></h2>
<blockquote>
<p>참조 객체가 너무 작고 자주 변경되지 않아 라이프사이클 관리가 불필요하다고 느끼는 경우</p>
</blockquote>
<p>해당 참조 객체(Reference Object)를 값 객체(Value Object)로 변경한다.</p>
<p>보통 참조에서 객체로 전환하고자 하는 생각은 참조를 사용하는 작업에서 불편함을 느끼는 경우에서 온다. 참조를 사용하는 경우 다음에 대한 관리가 필요하다.</p>
<ul>
<li>항상 저장소로부터 필수 객체를 요청해야 한다.</li>
<li>메모리 내 참조는 작업에 불편할 수 있다.</li>
<li>분산 및 병렬 시스템에서는 참조를 다루는 것이 값에 비해 특히나 더 어렵다.</li>
</ul>
<p>값 객체는 수명 동안에 자주 변경되는 객체보다는, 변경할 수 없는 객체를 다루는 경우에 특히나 더 유용하다. 객체 값을 반환하는 각 쿼리의 결과가 매번 동일하다면, 동일한 것을 나타내는 객체가 여러개 있어도 문제가 발생하진 않는다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Product {
  applyDiscount(val: number) {
    this._price.amount -= val;
  }
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Product {
  applyDiscount(val: number) {
    this._price = new Money(this._price.amount - val, this._price.currency);
  }
}
</code></pre>
<h2 id="배열을-객체로-대체하기-replace-array-with-object"><a class="header" href="#배열을-객체로-대체하기-replace-array-with-object">배열을 객체로 대체하기 (Replace Array with Object)</a></h2>
<blockquote>
<p>여러 타입의 데이터를 담기 위한 용도로 배열을 사용하고 있는 경우</p>
</blockquote>
<p>각 요소를 따로 필드로 분리하도록 하여 이를 객체로 대체한다.</p>
<p>배열은 단일한 유형의 데이터와 컬렉션을 저장하는 데에 탁월한 자료구조인 반면, 저마다 다른 타입의 데이터를 보관하는 경우에는 치명적인 오류로 이어질 수 있다.</p>
<p>클래스의 필드는 배열의 요소보다 문서화하기가 훨씬 쉽고, 결과 클래스에는 메인 클래스 및 다른 곳에 저장되어 있던 모든 관련된 동작을 배치할 수 있다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">let row = new Array(2);
row[0] = &quot;Liverpool&quot;;
row[1] = &quot;15&quot;;
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">let row = new Performance();
row.setName(&quot;Liverpool&quot;);
row.setWins(&quot;15&quot;);
</code></pre>
<h2 id="관찰된-데이터-중복-duplicate-observed-data"><a class="header" href="#관찰된-데이터-중복-duplicate-observed-data">관찰된 데이터 중복 (Duplicate Observed Data)</a></h2>
<blockquote>
<p>클래스에 저장된 도메인 데이터가 GUI를 담당하고 있는 경우</p>
</blockquote>
<p>데이터를 별도의 클래스로 구분하고, 도메인 클래스와 GUI 간 연결을 구축하여 동기화가 이루어질 수 있도록 보장하는 것이 좋다.</p>
<p>동일한 데이터에 대한 여러 형태의 인터페이스(ex. 데스크톱/모바일)를 갖추고자 하는 경우, GUI를 도메인으로부터 분리하지 않으면 코드 중복 및 여러 실수를 피하기가 매우 어렵다.</p>
<ul>
<li>
<p>비즈니스 로직 클래스와 프레젠테이션 클래스 간에 책임을 분담(단일 책임 원칙)하여 프로그램을 더 읽기 쉽고, 이해하기 쉽게 만들 수 있다.</p>
</li>
<li>
<p>새로운 인터페이스 뷰를 추가해야 하는 경우, 새로운 프레젠테이션 클래스를 생성하기만 하면 되기 때문에, 비즈니스 로직 코드를 건들 필요가 없다. (개방/폐쇄 원칙)</p>
</li>
<li>
<p>여러 사람이 비즈니스 로직과 사용자 인터페이스를 작업할 수 있다.</p>
</li>
<li>
<p>Before</p>
</li>
</ul>
<pre><code class="language-ts">class IntervalWindow {
  startField: TextField;
  endField: TextField;
  lengthField: TextField;

  startFieldFocusLost() {
    // ...
  }
 
  endFieldFocusLost() {
    // ...
  }
 
  lengthFieldFocusLost() {
    // ...
  }

  calculateLength() {
    // ...
  }

  calculateEnd() {
    // ...
  }
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class IntervalWindow {
  startField: TextField;
  endField: TextField;
  lengthField: TextField;
  interval: Interval;

  startFieldFocusLost() {
    // ...
  }
 
  endFieldFocusLost() {
    // ...
  }
 
  lengthFieldFocusLost() {
    // ...
  }
}

class Interval {
  start: Date;
  end: Date;
  length: number;

  calculateLength() {
    // ...
  }

  calculateEnd() {
    // ...
  }
}
</code></pre>
<h2 id="단방향-연결을-양방향으로-변경-change-unidirectional-association-to-bidirectional"><a class="header" href="#단방향-연결을-양방향으로-변경-change-unidirectional-association-to-bidirectional">단방향 연결을 양방향으로 변경 (Change Unidirectional Association to Bidirectional)</a></h2>
<blockquote>
<p>서로의 기능을 필요로 하는 두 클래스가 있지만, 두 클래스 간의 연결은 단방향으로 이루어져 있는 경우</p>
</blockquote>
<p>클래스가 필요로 하는 연결을 추가해준다.</p>
<p>원래 클래스는 단방향의 연결을 가지지만, 시간이 지남에 따라 클라이언트 코드가 연결의 양쪽 모두에 액세스 가능해야 할 수 있다.</p>
<p>단, 양방향 연결을 단방향보다 구현 및 유지관리가 훨씬 더 어렵고, 클래스를 상호 의존적으로 만든다는 문제가 있다. 단방향 연결은 둘 중 하나를 다른 클래스로부터 독립적으로 사용할 수 있게 해준다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Customer {
  name: string;
  order: Order;
}

class Order {}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Customer {
  name: string;
  order: Order;
}

class Order {
  customer: Customer;
}
</code></pre>
<h2 id="양방향-연결을-단방향으로-변경-change-bidirectional-association-to-unidirectional"><a class="header" href="#양방향-연결을-단방향으로-변경-change-bidirectional-association-to-unidirectional">양방향 연결을 단방향으로 변경 (Change Bidirectional Association to Unidirectional)</a></h2>
<blockquote>
<p>두 클래스 간의 양방향 연결이 구성되어 있으나, 둘 중 하나의 클래스가 다른 클래스의 기능을 필요로 하지 않는 경우</p>
</blockquote>
<p>사용하지 않는 쪽의 연결을 없앤다.</p>
<p>양방향 연결을 일반적으로 단방향 연결보다 유지 관리가 어렵고, 관련된 객체를 올바르게 생성 및 삭제하기 위한 추가적인 코드가 필요하다. 이에 따라 프로그램이 더 복잡해진다. 또한 다음과 같은 문제점이 생길 수 있다.</p>
<p>또한, 양방향 연결을 잘못 구현하는 경우 가비지 컬렉션에 문제가 발생할 수 있으며, 결국 사용하지 않는 객체로 인해 메모리가 팽창할 수 있다.</p>
<p>또, 클래스의 상호 의존성 문제로, 클래스가 서로에 대해 알고있어야 하므로 분리되어 사용할 수 없고, 이러한 연결이 많아질 경우 프로그램의 여러 부분이 서로 지나치게 의존하게 됨에 따라 한 컴포넌트의 변경 사항이 다른 컴포넌트에 영향을 미칠 수 있다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Customer {
  name: string;
  order: Order;
}

class Order {
  customer: Customer;
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Customer {
  name: string;
  order: Order;
}

class Order {}
</code></pre>
<h2 id="매직-넘버를-기호-상수로-대체-replace-magic-number-with-symbolic-constant"><a class="header" href="#매직-넘버를-기호-상수로-대체-replace-magic-number-with-symbolic-constant">매직 넘버를 기호 상수로 대체 (Replace Magic Number with Symbolic Constant)</a></h2>
<blockquote>
<p>코드에 특정한 의미를 담고있는 수가 사용되고 있는 경우</p>
</blockquote>
<p>해당 수가 어떤 의미인지에 대해 설명해주는 인간 친화적인 이름을 부여한 상수에 이를 할당한다.</p>
<p>매직넘버는 소스에서 발견되지만 명확한 의미를 알 수 없는 숫자값으로, 이러한 안티 패턴은 프로그램의 이해와 리팩터링을 어렵게 만든다.</p>
<p>무엇보다도, 이 매직넘버를 변경해야 하는 상황에서 문제는 더 심각해지는데, 같은 숫자가 다른 위치에서 다른 용도로 사용될 수 있으므로, 이 숫자를 사용하는 모든 코드 라인을 확인해야만 한다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">potentialEnergy(mass: number, height: number): number {
  return mass * height * 9.81;
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">static const GRAVITATIONAL_CONSTANT = 9.81;

potentialEnergy(mass: number, height: number): number {
  return mass * height * GRAVITATIONAL_CONSTANT;
}
</code></pre>
<h2 id="필드-캡슐화-encapsulate-field"><a class="header" href="#필드-캡슐화-encapsulate-field">필드 캡슐화 (Encapsulate Field)</a></h2>
<blockquote>
<p>퍼블릭 필드를 보유하고 있는 경우</p>
</blockquote>
<p>필드를 프라이빗으로 만들고, 필드를 읽고 쓰는 접근자 메서드를 만든다.</p>
<p>OOP의 이점 중 하나는 캡슐화로, 객체의 데이터를 외부에게서 숨길 수 있다는 것이다. 모든 객체 데이터가 공개되는 경우, 객체가 서로 직접 데이터를 참조 및 수정할수 있게 되어 프로그램의 모듈성이 손상되고 유지 관리가 복잡해진다.</p>
<p>단, 경우에 따라서는 성능에 대한 고려사항으로 인해 캡슐화를 적용하는 것이 적절하지 않을 수도 있다. 이를테면, x/y 좌표축을 갖는 객체들이 무수하게 많이 포함된 그래픽 편집기가 있다고 가정하자. 이들 좌표에 액세스하는 별도의 메서드들을 각각 두기보다는, 좌표 필드에 직접 액세스할 수 있도록 구성한다면, 액세스 메서드를 호출할 때 차지할 상당한 CPU 사이클을 절약할 수 있다. (ex. Java의 Point 클래스)</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Person {
  name: string;
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Person {
  private _name: string;

  get name() {
    return this._name;
  }

  setName(name: string): void {
    this._name = name;
  }
}
</code></pre>
<h2 id="컬렉션-캡슐화-encapsulate-collection"><a class="header" href="#컬렉션-캡슐화-encapsulate-collection">컬렉션 캡슐화 (Encapsulate Collection)</a></h2>
<blockquote>
<p>클래스에 컬렉션 필드와 컬렉션 작업을 위한 간단한 getter/setter가 존재하는 경우</p>
</blockquote>
<p>getter가 반환하는 값을 읽기 전용으로 만들고 컬렉션 요소를 추가/삭제하는 메서드를 만든다.</p>
<p>클래스 내에 컬렉션을 포함하는 필드가 존재하는 경우, 이 때는 일반적인 필드와는 다르게 다루어야 한다. 만약 getter를 통해 컬렉션 자체가 직접 전달되는 경우, 클라이언트가 클래스도 모르게 임의로 컬렉션의 내용을 수정할 수도 있고, 필요 이상으로 많은 데이터가 클라이언트에게 노출되기 때문이다.</p>
<p>따라서, 컬렉션 요소를 가져오는 getter 메서드의 경우, 컬렉션을 변경할 수 없는 형태로 반환하거나, 컬렉션 구조에 대한 과도한 데이터를 공개하지 말아야 한다. 또한, 컬렉션 값을 할당하는 메서드 대신, 컬렉션 내에 요소를 추가/삭제할 수 있는 메서드를 제공해야 한다. 이를 통해 클라이언트가 아닌, 클래스 본인이 요소의 추가 및 삭제에 대한 제어권을 갖도록 할 수 있다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Person {
  private _courses: Set&lt;Course&gt;;

  getCourses() {
    return this._courses;
  }

  setCourses(courses: Set&lt;Course&gt;) {
    this._courses = courses;
  }
}

class Course {}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Person {
  private _courses: Set&lt;Course&gt;;

  getCourses() {
    return [...this._courses];
  }

  addCourse(course: Course) {
    this._courses.add(course);
  }

  removeCourse(course: Course) {
    this._courses.delete(course);
  }
}

class Course {}
</code></pre>
<h2 id="타입-코드를-클래스로-대체-replace-type-code-with-class"><a class="header" href="#타입-코드를-클래스로-대체-replace-type-code-with-class">타입 코드를 클래스로 대체 (Replace Type Code with Class)</a></h2>
<blockquote>
<p>어떤 클래스가 타입 코드를 포함하는 필드를 갖추었으나, 해당 타입 코드들은 연산자 조건에 사용되지 않고, 프로그램 동작에도 영향을 주지 않는 경우</p>
</blockquote>
<p>새로운 클래스를 생성하여, 타입 코드 대신 해당 클래스의 객체를 사용한다.</p>
<p>타입 코드가 필요한 일반적인 이유 중 하나는 숫자나 문자열로 코딩된 복잡한 개념이 있는 필드가 있는 데이터베이스 작업을 해야하는 경우다.</p>
<p>필드 설정자는 보통 어떤 값이 전달되는지에 대해서는 체크하지 않으므로, 누군가 의도치 않은 값이나 잘못된 값을 이들 필드에 전달하게 되면 커다란 문제가 발생할 수 있다.</p>
<p>타입 코드가 숫자/문자열 등 primitive 타입인 경우, 적절한 타입 체크가 이루어지지 않는다는 문제점도 있다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Person {
  static O = 0;
  static A = 1;
  static B = 2;
  static AB = 3;
  private _bloodGroup: number;

  get bloodGroup() {
    return this._bloodGroup;
  }

  set bloodGroup(bloodGroup: string) {
    this._bloodGroup = bloodGroup;
  }
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Person {
  private _bloodGroup: BloodGroup;

  get bloodGroup() {
    return this._bloodGroup;
  }

  set bloodGroup(bloodGroup: BloodGroup) {
    this._bloodGroup = bloodGroup;
  }
}

class BloodGroup {
  static O: BloodGroup;
  static A: BloodGroup;
  static B: BloodGroup;
  static AB: BloodGroup;
}
</code></pre>
<h2 id="타입-코드를-서브클래스로-대체-replace-type-code-with-subclasses"><a class="header" href="#타입-코드를-서브클래스로-대체-replace-type-code-with-subclasses">타입 코드를 서브클래스로 대체 (Replace Type Code with Subclasses)</a></h2>
<blockquote>
<p>프로그램 동작에 직접적인 영향을 미치는 타입 코드가 존재하는 경우 (해당 필드의 값이 조건부로 다양한 코드를 트리거하는 경우)</p>
</blockquote>
<p>코딩된 타입의 각 값에 대한 하위 클래스를 만든다. 이후 기존 클래스에서 새로 만든 하위 클래스로 관련 동작을 추출해낸다. 그리고 제어 흐름 코드를 다형성으로 대체한다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Employee {
  static ENGINEER: number = 0;
  static SALESMAN: number = 1;
  private _type: number;

  get employeeType() {
    return this._type;
  }

  set employeeType(type: number) {
    this._type = type;
  }
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Employee {
  // ...
}

class Engineer extends Employee {
  // ...
}

class Salesman extends Employee {
  // ...
}
</code></pre>
<h2 id="타입-코드를-상태전략-패턴으로-대체-replace-type-code-with-statestrategy"><a class="header" href="#타입-코드를-상태전략-패턴으로-대체-replace-type-code-with-statestrategy">타입 코드를 상태/전략 패턴으로 대체 (Replace Type Code with State/Strategy)</a></h2>
<blockquote>
<p>동작에 영향을 주는 타입 코드가 있지만, 서브클래스를 사용하여 타입 코드를 대체할 수 없는 경우</p>
</blockquote>
<p>타입 코드를 상태 객체로 대체한다. 만약 필드 값을 타입 코드로 바꾸는 것이 필수적인 경우 다른 상태 객체가 연결되도록 한다. 이는 아래와 같은 경우에 적절하다.</p>
<ol>
<li>
<p>타입 코드가 있고, 클래스의 동작에 영향을 미치고 있어 타입 코드를 클래스로 바꿀 수 없는 경우</p>
</li>
<li>
<p>타입 코드가 클래스의 동작에 영향을 주지만 기존 클래스 계층 구조 또는 다른 이유로 인해 타입 코드에 대한 서브클래스를 만들 수 없는 경우</p>
</li>
</ol>
<p>해당 리팩터링 테크닉은 타입 코드의 필드값이 객체의 라이프타임 동안에 변경되는 것을 막아준다. 이 때 값의 교체는 원래 클래스가 참조하는 상태 객체를 교체하여 이루어져야 한다.</p>
<p>코드 타입에 새로운 값을 추가해야 하는 경우, 기존 코드를 변경하지 않고 새로운 상태 하위 클래스를 추가하기만 하면 된다. (OCP ~ Open/Closed Principle)</p>
<p>다만 해당 리팩터링 테크닉은 불필요한 클래스가 많이 추가된다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">class Employee {
  static ENGINEER: number = 0;
  static SALESMAN: number = 1;
  private _type: number;

  get employeeType() {
    return this._type;
  }

  set employeeType(type: number) {
    this._type = type;
  }
}
</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">class Employee {
  private _type: EmployeeType;

  get employeeType() {
    return this._type;
  }

  set employeeType(type: EmployeeType) {
    this._type = type;
  }
}

class EmployeeType {
}

class Engineer extends EmployeeType {

}

class Salesman extends EmployeeType {

}
</code></pre>
<h2 id="서브클래스를-필드로-대체-replace-subclass-with-fields"><a class="header" href="#서브클래스를-필드로-대체-replace-subclass-with-fields">서브클래스를 필드로 대체 (Replace Subclass with Fields)</a></h2>
<blockquote>
<p>서브클래스들이 단순히 상수 데이터(반환이 항상 같음)를 반환하는 메서드만을 가지고 있을 때</p>
</blockquote>
<p>해당 메서드를 상위 클래스의 필드로 바꾸고, 하위 클래스를 삭제한다.</p>
<p>때때로 리팩터링은 타입 코드를 피하기 위한 단순한 티켓이 된다.</p>
<p>이러한 경우, 서브클래스의 계층 구조는 오직 특정한 메서드의 반환값에 대한 차이만 갖게된다. 이러한 메서드들은 어떤 연산의 결과도 아니며, 오직 메서드 자체적으로 엄격하게 설정된 값일 뿐이다. 클래스 구조를 단순화하기 위해서는 구조를 하나의 클래스로 압축하고 상황에 따라 필요한 값을 가진 하나 또는 여러 개의 필드를 추가한다.</p>
<p>이러한 테크닉은 클래스 계층 구조에서 다른 곳으로 많은 기능들을 이동하고 난 이후에 필요할 수 있다. 이 경우 계층 구조가 그다지 가치가 없어지고, 하위 클래스가 쓸모없어지는 경우가 생길 수 있기 때문이다.</p>
<ul>
<li>Before</li>
</ul>
<pre><code class="language-ts">type Code = 'M' | 'F';

abstract class Person {
  abstract getCode: () =&gt; Code;
}

class Male extends Person {
    getCode = (): Code =&gt; 'M';
}

class Female extends Person {
    getCode = (): Code =&gt; 'F';
}

</code></pre>
<ul>
<li>After</li>
</ul>
<pre><code class="language-ts">type Code = 'M' | 'F';

class Person {
  private _code: Code;

  getCode(): Code {
    return this._code;
  };
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../refactoring/refactoring-techniques/moving-features-between-objects/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../../refactoring/refactoring-techniques/simplifying-conditional-expressions/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../refactoring/refactoring-techniques/moving-features-between-objects/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../refactoring/refactoring-techniques/simplifying-conditional-expressions/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>

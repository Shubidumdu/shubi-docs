<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shubi Docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item "><a href="js/index.html"><strong aria-hidden="true">1.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/exec-ctx.html"><strong aria-hidden="true">1.1.</strong> 실행 컨텍스트</a></li><li class="chapter-item "><a href="js/class.html"><strong aria-hidden="true">1.2.</strong> 클래스</a></li><li class="chapter-item "><a href="js/arrow-func.html"><strong aria-hidden="true">1.3.</strong> 화살표 함수</a></li><li class="chapter-item "><a href="js/binding-function.html"><strong aria-hidden="true">1.4.</strong> 함수 바인딩</a></li><li class="chapter-item "><a href="js/call-apply.html"><strong aria-hidden="true">1.5.</strong> call, apply</a></li><li class="chapter-item "><a href="js/closure.html"><strong aria-hidden="true">1.6.</strong> 클로저</a></li><li class="chapter-item "><a href="js/func-exp-and-dec.html"><strong aria-hidden="true">1.7.</strong> 함수 표현식 vs 함수 선언문</a></li><li class="chapter-item "><a href="js/event-loop.html"><strong aria-hidden="true">1.8.</strong> 이벤트 루프</a></li><li class="chapter-item "><a href="js/new.html"><strong aria-hidden="true">1.9.</strong> new와 생성자 함수</a></li><li class="chapter-item "><a href="js/properties.html"><strong aria-hidden="true">1.10.</strong> 프로퍼티</a></li><li class="chapter-item "><a href="js/prototype.html"><strong aria-hidden="true">1.11.</strong> 프로토타입</a></li><li class="chapter-item "><a href="js/this.html"><strong aria-hidden="true">1.12.</strong> this</a></li><li class="chapter-item "><a href="js/var.html"><strong aria-hidden="true">1.13.</strong> var를 쓰지 않는 이유</a></li><li class="chapter-item "><a href="js/babel.html"><strong aria-hidden="true">1.14.</strong> Babel</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.15.</strong> Web APIs</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/web-api/intersection.html"><strong aria-hidden="true">1.15.1.</strong> Intersection Observer</a></li><li class="chapter-item "><a href="js/web-api/mutation.html"><strong aria-hidden="true">1.15.2.</strong> Mutation Observer</a></li><li class="chapter-item "><a href="js/web-api/template.html"><strong aria-hidden="true">1.15.3.</strong> Template Element</a></li><li class="chapter-item "><a href="js/web-api/shadow-dom/intro.html"><strong aria-hidden="true">1.15.4.</strong> Shadow DOM</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/web-api/shadow-dom/slot.html"><strong aria-hidden="true">1.15.4.1.</strong> Slot</a></li><li class="chapter-item "><a href="js/web-api/shadow-dom/styling.html"><strong aria-hidden="true">1.15.4.2.</strong> Styling</a></li><li class="chapter-item "><a href="js/web-api/shadow-dom/events.html"><strong aria-hidden="true">1.15.4.3.</strong> Events</a></li></ol></li><li class="chapter-item "><a href="js/web-api/canvas/intro.html"><strong aria-hidden="true">1.15.5.</strong> Canvas API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/web-api/canvas/shapes.html"><strong aria-hidden="true">1.15.5.1.</strong> 도형 그리기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">1.16.</strong> Guides</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/guides/render-opt.html"><strong aria-hidden="true">1.16.1.</strong> 렌더링 최적화</a></li><li class="chapter-item "><a href="js/guides/custom-el-checklist.html"><strong aria-hidden="true">1.16.2.</strong> Custom Element 체크리스트</a></li></ol></li></ol></li><li class="chapter-item "><a href="ts/index.html"><strong aria-hidden="true">2.</strong> TypeScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/intro/index.html"><strong aria-hidden="true">2.1.</strong> 타입스크립트 알아보기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/intro/ts_js.html"><strong aria-hidden="true">2.1.1.</strong> TS와 JS의 관계</a></li><li class="chapter-item "><a href="ts/intro/setting.html"><strong aria-hidden="true">2.1.2.</strong> TS 설정 이해하기</a></li><li class="chapter-item "><a href="ts/intro/transpile.html"><strong aria-hidden="true">2.1.3.</strong> 코드 생성과 타입이 관계없음을 이해하기</a></li><li class="chapter-item "><a href="ts/intro/typing.html"><strong aria-hidden="true">2.1.4.</strong> 구조적 타이핑에 익숙해지기</a></li><li class="chapter-item "><a href="ts/intro/no_any.html"><strong aria-hidden="true">2.1.5.</strong> any 타입 지양하기</a></li></ol></li><li class="chapter-item "><a href="ts/types/index.html"><strong aria-hidden="true">2.2.</strong> 타입스크립트의 타입 시스템</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/types/use_editor.html"><strong aria-hidden="true">2.2.1.</strong> 편집기를 사용하여 타입 시스템 탐색하기</a></li><li class="chapter-item "><a href="ts/types/set.html"><strong aria-hidden="true">2.2.2.</strong> 타입이 값들의 집합이라고 생각하기</a></li><li class="chapter-item "><a href="ts/types/symbol.html"><strong aria-hidden="true">2.2.3.</strong> 타입 공간과 값 공간의 심벌 구분하기</a></li><li class="chapter-item "><a href="ts/types/type-def.html"><strong aria-hidden="true">2.2.4.</strong> 타입 단언보다는 타입 선언을 사용하기</a></li><li class="chapter-item "><a href="ts/types/wrapper.html"><strong aria-hidden="true">2.2.5.</strong> 객체 래퍼 타입 피하기</a></li><li class="chapter-item "><a href="ts/types/excess-type-check.html"><strong aria-hidden="true">2.2.6.</strong> 잉여 속성 체크의 한계 인지하기</a></li><li class="chapter-item "><a href="ts/types/function-expression.html"><strong aria-hidden="true">2.2.7.</strong> 함수 표현식에 타입 적용하기</a></li><li class="chapter-item "><a href="ts/types/type-and-interface.html"><strong aria-hidden="true">2.2.8.</strong> 타입과 인터페이스의 차이점 알기</a></li><li class="chapter-item "><a href="ts/types/generics.html"><strong aria-hidden="true">2.2.9.</strong> 타입 연산과 제너릭 사용으로 반복 줄이기</a></li><li class="chapter-item "><a href="ts/types/index-signature.html"><strong aria-hidden="true">2.2.10.</strong> 동적 데이터에 인덱스 시그니처 사용하기</a></li><li class="chapter-item "><a href="ts/types/no-index-signature.html"><strong aria-hidden="true">2.2.11.</strong> number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></li><li class="chapter-item "><a href="ts/types/readonly.html"><strong aria-hidden="true">2.2.12.</strong> 변경 관련된 오류 방지를 위해 readonly 사용하기</a></li><li class="chapter-item "><a href="ts/types/mapped-type.html"><strong aria-hidden="true">2.2.13.</strong> 매핑된 타입을 사용하여 값을 동기화하기</a></li></ol></li><li class="chapter-item "><a href="ts/type-inference/index.html"><strong aria-hidden="true">2.3.</strong> 타입 추론</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/type-inference/use-inferable-types.html"><strong aria-hidden="true">2.3.1.</strong> 추론 가능한 타입을 사용해 장황한 코드 방지하기</a></li><li class="chapter-item "><a href="ts/type-inference/use-const.html"><strong aria-hidden="true">2.3.2.</strong> 다른 타입에는 다른 변수 사용하기</a></li><li class="chapter-item "><a href="ts/type-inference/type-widening.html"><strong aria-hidden="true">2.3.3.</strong> 타입 넓히기</a></li><li class="chapter-item "><a href="ts/type-inference/type-narrowing.html"><strong aria-hidden="true">2.3.4.</strong> 타입 좁히기</a></li><li class="chapter-item "><a href="ts/type-inference/create-object-at-once.html"><strong aria-hidden="true">2.3.5.</strong> 한꺼번에 객체 생성하기</a></li><li class="chapter-item "><a href="ts/type-inference/avoid-aliasing.html"><strong aria-hidden="true">2.3.6.</strong> 일관성있는 별칭 사용하기</a></li><li class="chapter-item "><a href="ts/type-inference/use-async.html"><strong aria-hidden="true">2.3.7.</strong> 비동기 코드에는 콜백 대신 async 함수 사용하기</a></li><li class="chapter-item "><a href="ts/type-inference/context-inference.html"><strong aria-hidden="true">2.3.8.</strong> 타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></li><li class="chapter-item "><a href="ts/type-inference/well-typed-lib.html"><strong aria-hidden="true">2.3.9.</strong> 함수형 기법과 라이브러리로 타입 흐름 유지하기</a></li></ol></li><li class="chapter-item "><a href="ts/design/index.html"><strong aria-hidden="true">2.4.</strong> 타입 설계</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/design/valid-states.html"><strong aria-hidden="true">2.4.1.</strong> 유효한 상태만 표현하는 타입을 지향하기</a></li><li class="chapter-item "><a href="ts/design/loose-accept-strict-produce.html"><strong aria-hidden="true">2.4.2.</strong> 사용할 때는 너그럽게, 생성할 때는 엄격하게</a></li><li class="chapter-item "><a href="ts/design/jsdoc-repeat.html"><strong aria-hidden="true">2.4.3.</strong> 문서에 타입 정보를 쓰지 않기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.</strong> React</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="react/why.html"><strong aria-hidden="true">3.1.</strong> 왜 React인가?</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> Redux</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="redux/pure.html"><strong aria-hidden="true">4.1.</strong> 왜 Reducer는 순수해야 하는가?</a></li></ol></li><li class="chapter-item "><a href="svelte/intro.html"><strong aria-hidden="true">5.</strong> Svelte</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="svelte/reactivity.html"><strong aria-hidden="true">5.1.</strong> Reactivity</a></li><li class="chapter-item "><a href="svelte/props.html"><strong aria-hidden="true">5.2.</strong> Props</a></li><li class="chapter-item "><a href="svelte/logic.html"><strong aria-hidden="true">5.3.</strong> Logic</a></li><li class="chapter-item "><a href="svelte/events.html"><strong aria-hidden="true">5.4.</strong> Events</a></li><li class="chapter-item "><a href="svelte/bindings.html"><strong aria-hidden="true">5.5.</strong> Bindings</a></li><li class="chapter-item "><a href="svelte/lifecycle.html"><strong aria-hidden="true">5.6.</strong> Life Cycle</a></li><li class="chapter-item "><a href="svelte/stores.html"><strong aria-hidden="true">5.7.</strong> Stores</a></li><li class="chapter-item "><a href="svelte/motion.html"><strong aria-hidden="true">5.8.</strong> Motion</a></li><li class="chapter-item "><a href="svelte/transition.html"><strong aria-hidden="true">5.9.</strong> Transitions</a></li><li class="chapter-item "><a href="svelte/animations.html"><strong aria-hidden="true">5.10.</strong> Animations</a></li><li class="chapter-item "><a href="svelte/actions.html"><strong aria-hidden="true">5.11.</strong> Actions</a></li><li class="chapter-item "><a href="svelte/classes.html"><strong aria-hidden="true">5.12.</strong> Classes</a></li><li class="chapter-item "><a href="svelte/composition.html"><strong aria-hidden="true">5.13.</strong> Component Composition</a></li><li class="chapter-item "><a href="svelte/context.html"><strong aria-hidden="true">5.14.</strong> Context API</a></li><li class="chapter-item "><a href="svelte/specials.html"><strong aria-hidden="true">5.15.</strong> Special Elements</a></li><li class="chapter-item "><a href="svelte/module.html"><strong aria-hidden="true">5.16.</strong> Module Context</a></li><li class="chapter-item "><a href="svelte/debug.html"><strong aria-hidden="true">5.17.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="graphql/intro.html"><strong aria-hidden="true">6.</strong> GraphQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graphql/execution.html"><strong aria-hidden="true">6.1.</strong> Execution</a></li><li class="chapter-item "><a href="graphql/query-mutation.html"><strong aria-hidden="true">6.2.</strong> Query &amp; Mutation</a></li><li class="chapter-item "><a href="graphql/schema-type.html"><strong aria-hidden="true">6.3.</strong> Schema &amp; Type</a></li><li class="chapter-item "><a href="graphql/pagination.html"><strong aria-hidden="true">6.4.</strong> Pagination</a></li><li class="chapter-item "><a href="graphql/http.html"><strong aria-hidden="true">6.5.</strong> HTTP에서의 GraphQL</a></li></ol></li><li class="chapter-item "><a href="docker/setup.html"><strong aria-hidden="true">7.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="docker/sample.html"><strong aria-hidden="true">7.1.</strong> 샘플 애플리케이션</a></li><li class="chapter-item "><a href="docker/update.html"><strong aria-hidden="true">7.2.</strong> 애플리케이션 수정</a></li><li class="chapter-item "><a href="docker/share.html"><strong aria-hidden="true">7.3.</strong> 애플리케이션 공유</a></li><li class="chapter-item "><a href="docker/persist.html"><strong aria-hidden="true">7.4.</strong> DB 유지</a></li><li class="chapter-item "><a href="docker/bind-mounts.html"><strong aria-hidden="true">7.5.</strong> Bind Mounts</a></li><li class="chapter-item "><a href="docker/multi.html"><strong aria-hidden="true">7.6.</strong> 멀티 컨테이너 앱</a></li><li class="chapter-item "><a href="docker/docker-compose.html"><strong aria-hidden="true">7.7.</strong> Docker Compose</a></li><li class="chapter-item "><a href="docker/best-practices.html"><strong aria-hidden="true">7.8.</strong> 실전 이미지 빌딩</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> Etc.</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="etc/ssh.html"><strong aria-hidden="true">8.1.</strong> SSH</a></li><li class="chapter-item "><a href="etc/tdd.html"><strong aria-hidden="true">8.2.</strong> TDD</a></li><li class="chapter-item "><a href="etc/fp.html"><strong aria-hidden="true">8.3.</strong> 함수형 프로그래밍</a></li><li class="chapter-item "><a href="etc/rp.html"><strong aria-hidden="true">8.4.</strong> 반응형 프로그래밍</a></li></ol></li><li class="chapter-item "><a href="ml/index.html"><strong aria-hidden="true">9.</strong> Machine Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/problem-framing/index.html"><strong aria-hidden="true">9.1.</strong> Problem Framing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/problem-framing/common-problems.html"><strong aria-hidden="true">9.1.1.</strong> Common ML Problems</a></li><li class="chapter-item "><a href="ml/problem-framing/mindset.html"><strong aria-hidden="true">9.1.2.</strong> The ML Mindset</a></li><li class="chapter-item "><a href="ml/problem-framing/good.html"><strong aria-hidden="true">9.1.3.</strong> Identifying Good Problems for ML</a></li><li class="chapter-item "><a href="ml/problem-framing/hard.html"><strong aria-hidden="true">9.1.4.</strong> Hard ML Problems</a></li><li class="chapter-item "><a href="ml/problem-framing/framing.html"><strong aria-hidden="true">9.1.5.</strong> Deciding on ML</a></li><li class="chapter-item "><a href="ml/problem-framing/formulate.html"><strong aria-hidden="true">9.1.6.</strong> Formulate Your Problem as an ML Problem</a></li></ol></li><li class="chapter-item "><a href="ml/crash-course/index.html"><strong aria-hidden="true">9.2.</strong> Crash Course</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/crash-course/framing.html"><strong aria-hidden="true">9.2.1.</strong> Framing</a></li><li class="chapter-item "><a href="ml/crash-course/descending-into-ml.html"><strong aria-hidden="true">9.2.2.</strong> Descending into ML</a></li><li class="chapter-item "><a href="ml/crash-course/reducing-loss.html"><strong aria-hidden="true">9.2.3.</strong> Reducing Loss</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shubi Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>각 문서의 순서는 그다지 상관이 없습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>실제 코드를 작성하다보면 놓치기 쉬운 JS의 개념들에 대해 작성합니다.</p>
<p>거의 모든 문서는 <a href="js/ko.javascript.info">ko.javascript.info</a>를 참고했습니다. (제 생각엔 진짜 최고의 JS 참고서입니다.)</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">여기</a>의 문서를 번역하여, 임의로 정리한 내용입니다.</p>
<h1 id="실행-컨텍스트-execution-context"><a class="header" href="#실행-컨텍스트-execution-context">실행 컨텍스트 (Execution Context)</a></h1>
<p>JS에서의 호스팅, 스코프, 클로저와 같은 개념들을 이해하기 위해서는 실행 컨텍스트(Execution Context)와 실행 스택(Execution Stack)에 대해서 이해해야 합니다.</p>
<h2 id="실행-컨텍스트란"><a class="header" href="#실행-컨텍스트란">실행 컨텍스트란?</a></h2>
<p>단순히 말해서, 실행 컨텍스트는 JS 코드가 평가되고 실행되는 환경의 추상적인 개념입니다. 어떤 코드가 JS에서 실행될 때, 이는 실행 컨텍스트 내에서 실행됩니다.</p>
<h2 id="실행-컨텍스트의-종류"><a class="header" href="#실행-컨텍스트의-종류">실행 컨텍스트의 종류</a></h2>
<p>다음 세 종류의 실행 컨텍스트가 있습니다.</p>
<ul>
<li>
<p><strong>전역 실행 컨텍스트</strong> : 기본 실행 컨텍스트로서, 어떤 함수에도 포함되어 있지 않은 코드의 경우, 전역 실행 컨텍스트에 포함됩니다. 브라우저를 기준으로, <code>window</code>에 해당하는 글로벌 객체를 생성하고, 해당 글로벌 객체를 <code>this</code>로 설정합니다. 하나의 프로그램에는 하나의 전역 실행 컨텍스트만 존재할 수 있습니다.</p>
</li>
<li>
<p><strong>함수 실행 컨텍스트</strong> : 함수가 실행될 때마다, 해당 함수에 대한 새로운 실행 컨텍스트가 생성됩니다. 각 함수들은 자신의 실행 컨텍스트를 보유하지만, 이는 해당 함수가 실행될 때에 생성됩니다. 함수 실행 컨텍스트는 여러개가 될 수 있습니다.</p>
</li>
<li>
<p><strong>Eval 함수 실행 컨텍스트</strong> : <code>eval</code>함수 내에서 실행되는 코드들도 자신의 실행 컨텍스트를 보유합니다. 다만, <code>eval</code>은 JS 개발자들 사이에 자주 사용되지 않으므로, 여기에서 언급하지 않겠습니다.</p>
</li>
</ul>
<h2 id="실행-스택"><a class="header" href="#실행-스택">실행 스택</a></h2>
<p><strong>호출 스택</strong>이라고도 불리는 실행 스택은, LIFO(후입선출) 스택 구조로 이루어진 하나의 스택입니다. 실행 스택은 코드 실행 중에 생성되는 모든 실행 컨텍스트를 담고 있습니다.</p>
<p>JS 엔진이 처음으로 스크립트에 마주치면, 전역 실행 객체를 생성한 후, 이를 현재 실행 스택에 추가(push)합니다. 이후 JS 엔진이 함수 실행을 발견할 때마다, 새로운 실행 컨텍스트를 생성하여 스택의 최상단에 추가합니다.</p>
<p>엔진은 실행 컨텍스트가 스택의 최상단에 있는 함수를 실행합니다. 해당 함수가 완료되면, 실행 스택은 스택으로부터 제거(pop)되며, 그 다음 컨텍스트로 넘어가게 됩니다.</p>
<pre><code class="language-js">let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
console.log('Inside Global Execution Context');
</code></pre>
<img src="https://miro.medium.com/max/2000/1*ACtBy8CIepVTOSYcVwZ34Q.png" />
<h2 id="실행-컨텍스트의-생성"><a class="header" href="#실행-컨텍스트의-생성">실행 컨텍스트의 생성</a></h2>
<p>이제 JS에서 실행 컨텍스트가 어떻게 생성도는지에 다루어보겠습니다.</p>
<p>실행 컨텍스트는 두 단계를 통해 생성됩니다. <strong>첫째는 생성 단계(Creation Phase)이고, 두번째는 실행 단계(Execution Phase)입니다.</strong></p>
<h2 id="생성-단계-creation-phase"><a class="header" href="#생성-단계-creation-phase">생성 단계 (Creation Phase)</a></h2>
<p>실행 컨텍스트는 생성 단계에서 생성됩니다. 해당 단계에서는 아래와 같은 일들이 일어납니다.</p>
<ol>
<li>렉시컬 환경(Lexical Environment)이 생성됩니다.</li>
<li>변수 환경(Variable Environment)이 생성됩니다.</li>
</ol>
<p>따라서, 실행 컨텍스트는 개념적으로 아래와 같이 나타낼 수 있습니다.</p>
<pre><code>ExecutionContext = {
  LexicalEnvironment = &lt;ref. to LexicalEnvironment in memory&gt;,
  VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;,
}
</code></pre>
<h3 id="렉시컬-환경lexical-environment"><a class="header" href="#렉시컬-환경lexical-environment">렉시컬 환경(Lexical Environment)</a></h3>
<p>렉시컬 환경은, 식별자-변수(Identifier-Variable) 매핑을 하는 자료구조입니다. (여기서, 식별자란 변수 또는 함수의 이름을 가리키며, 변수는 실제 객체에 대한 참조 또는 원시값을 가리킵니다.)</p>
<p>예를 들어, 아래의 코드를 살펴봅시다.</p>
<pre><code class="language-js">var a = 20;
var b = 40;
function foo() {
  console.log('bar');
}
</code></pre>
<p>위의 코드에서 렉시컬 환경은 다음과 같아질 것입니다.</p>
<pre><code>lexicalEnvironment = {
  a: 20,
  b: 40,
  foo: &lt;ref. to foo function&gt;
}
</code></pre>
<p>각각의 렉시컬 환경은 다음의 셋으로 구성되어 있습니다.</p>
<ol>
<li>환경 레코드 (Environment Record)</li>
<li>외부 환경에 대한 참조 (Reference to the outer environment)</li>
<li>This 바인딩</li>
</ol>
<h4 id="환경-레코드"><a class="header" href="#환경-레코드">환경 레코드</a></h4>
<p>환경 레코드는 렉시컬 환경 내에서 변수와 함수의 선언이 보관되는 장소입니다. 환경 레코드에는 두가지 타입이 있습니다.</p>
<ul>
<li>
<p>선언 환경 레코드(Declaration Environment Record) : 변수 및 함수 선언을 저장합니다. 함수 코드에 대한 렉시컬 환경은 선언 환경 레코드를 포함합니다.</p>
</li>
<li>
<p>객체 환경 레코드 (Object Environment Record) : 전역 코드에 대한 렉시컬 환경은 객체 환경 레코드를 포함합니다. 이는 변수와 함수 선언 외에도, 전역 바인딩 객체(Global binding object: 브라우저 상에서는 <code>window</code>)도 담고 있습니다. 따라서 레코드 내에 해당 바인딩 객체의 각 프로퍼티에 대한 새로운 항목이 생성됩니다.</p>
</li>
</ul>
<p>참고로, 함수 코드를 위해, 환경 레코드는 <code>arguments</code> 객체를 포함하고 있습니다. 이 <code>arguments</code>객체에는 인덱스와 함수에 전달되는 인수(arguments) 간의 매핑과, 함수에 넘겨지는 인수의 갯수(length)가 담겨있습니다. 예를 들어, 아래 함수에서 <code>argument</code> 객체는 다음과 같은 형태일 것입니다.</p>
<pre><code class="language-js">function foo(a, b) {
  var c = a + b;
}
foo(2, 3);
// argument object
Arguments: {0: 2, 1: 3, length: 2},
</code></pre>
<h4 id="외부-환경에-대한-참조"><a class="header" href="#외부-환경에-대한-참조">외부 환경에 대한 참조</a></h4>
<p>&quot;외부 환경에 대한 참조&quot;는 외부 렉시컬 환경에 대한 접근을 의미합니다. 이는 JS 엔진이 현재 렉시컬 환경에서 원하는 변수를 찾지 못하면, 외부 환경으로 뻗어나가 해당 변수를 찾을 수 있다는 것을 의미합니다.</p>
<h4 id="this-바인딩"><a class="header" href="#this-바인딩">This 바인딩</a></h4>
<p>전역 실행 컨텍스트에서, <code>this</code>의 값은 전역 객체에 바인딩됩니다. (브라우저 상에서 <code>window</code> 객체)</p>
<p>함수 실행 컨텍스트에서, <code>this</code>의 값은 어떻게 해당 함수가 호출되느냐에 따라 달라집니다. 객체 참조에 의해서 호출되는 경우 <code>this</code>의 값은 해당 객체가 됩니다. 그렇지 않은 경우에 <code>this</code>는 전역 객체가 되며, strict 모드 상에서는 <code>undefined</code>가 됩니다.</p>
<pre><code class="language-js">const person = {
  name: 'peter',
  birthYear: 1994,
  calcAge: function () {
    console.log(2018 - this.birthYear);
  },
};
person.calcAge();
// `this`는 `person`이 됩니다. `calcAge`가 `person` 객체 참조에 의해 호출되었기 때문입니다.
const calculateAge = person.calcAge;
calculateAge();
// `this`는 전역 객체에 해당하는 `window`입니다. 별도로 넘겨받은 객체 참조가 없기 때문입니다. strict 모드라면, `undefined`가 됩니다.
</code></pre>
<p>지금까지의 내용을 되짚어보자면, 렉시컬 환경은 추상적으로 다음과 같이 생겼을겁니다.</p>
<pre><code>GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // Identifier bindings go here
    }
    outer: &lt;null&gt;,
    this: &lt;global object&gt;
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Declarative&quot;,
      // Identifier bindings go here
    }
    outer: &lt;Global or outer function environment reference&gt;,
    this: &lt;depends on how function is called&gt;
  }
}
</code></pre>
<h3 id="변수-환경-variable-environment"><a class="header" href="#변수-환경-variable-environment">변수 환경 (Variable Environment)</a></h3>
<p>이 또한 실행 컨텍스트 내에서 <code>VariableStatements</code>를 통해 생성된 바인딩을 환경 레코드에 보관하는 렉시컬 환경입니다.</p>
<p>위에서 말했듯, 변수 환경 또한 렉시컬 환경입니다. 따라서 앞서 말했던 렉시컬 환경이 갖고 있는 모든 구성요소와 프로퍼티를 갖고 있습니다.</p>
<p>ES6 상에서, 렉시컬 환경과 변수 환경의 한가지 차이는, 렉시컬 환경이 함수 선언과 <code>let</code>, <code>const</code> 변수 바인딩에 사용되는 반면, 변수 환경은 오직 <code>var</code> 변수의 바인딩에만 사용된다는 것입니다.</p>
<h2 id="실행-단계-execution-phase"><a class="header" href="#실행-단계-execution-phase">실행 단계 (Execution Phase)</a></h2>
<p>이 단계에서 모든 변수에 대한 할당이 완료되고, 코드가 마침내 실행됩니다.</p>
<p>아래 예시 코드를 살펴봅시다.</p>
<pre><code class="language-js">let a = 20;
const b = 30;
var c;

function multiply(e, f) {
  var g = 20;
  return e * f * g;
}

c = multiply(20, 30);
</code></pre>
<p>위의 코드가 실행될 때, JS 엔진은 전역 코드를 실행하기 위해 전역 실행 컨텍스트를 먼저 생성합니다. 따라서 전역 실행 컨텍스트는 생성 단계를 거쳐 아래와 같아질 것입니다.</p>
<pre><code>GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // Identifier bindings go here
      a: &lt; uninitialized &gt;,
      b: &lt; uninitialized &gt;,
      multiply: &lt; func &gt;
    }
    outer: &lt;null&gt;,
    ThisBinding: &lt;Global Object&gt;
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // Identifier bindings go here
      c: undefined,
    }
    outer: &lt;null&gt;,
    ThisBinding: &lt;Global Object&gt;
  }
}
</code></pre>
<p>실행 단계에서는 변수 할당이 수행됩니다. 따라서 전역 실행 컨텍스트 실행 단계를 거쳐 아래와 같아질 것입니다.</p>
<pre><code>GlobalExectionContext = {
  LexicalEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Object&quot;,
        // Identifier bindings go here
        a: 20,
        b: 30,
        multiply: &lt; func &gt;
      }
      outer: &lt;null&gt;,
      ThisBinding: &lt;Global Object&gt;
    },
  VariableEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Object&quot;,
        // Identifier bindings go here
        c: undefined,
      }
      outer: &lt;null&gt;,
      ThisBinding: &lt;Global Object&gt;
    }
}
</code></pre>
<p>이후, <code>multiply(20, 30)</code> 함수의 호출을 마주치면, 해당 함수 코드를 실행하기 위해 새로운 함수 실행 컨텍스트가 생성됩니다. 따라서, 생성 단계를 거쳐 다음과 같이 새로운 함수 실행 컨텍스트가 만들어집니다.</p>
<pre><code>FunctionExectionContext = {
  LexicalEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        Arguments: {0: 20, 1: 30, length: 2},
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;,
    },
  VariableEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        g: undefined
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;
    }
}
</code></pre>
<p>그 다음, 실행 컨텍스트는 실행 단계를 거쳐 아래와 같이 변수 할당이 완수됩니다. 따라서, 함수 실행 컨텍스트는 실행 단계를 거쳐 다음과 같은 형태가 됩니다.</p>
<pre><code>FunctionExectionContext = {
  LexicalEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        Arguments: {0: 20, 1: 30, length: 2},
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;,
    },
  VariableEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        g: 20
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;
    }
}
</code></pre>
<p>이후 함수의 실행이 완료되면, 반환 값이 <code>c</code>에 보관됩니다. 따라서 전역 렉시컬 환경이 갱신됩니다. 이후, 전역 코드가 모두 완료되고, 프로그램은 종료됩니다.</p>
<p><strong>참고</strong> - 아마 위의 과정을 따라가면서, 최초에 <code>let</code>과 <code>const</code>에는 아무런 값도 할당되지 않은 것을 확인했을 것입니다. 반면에 <code>var</code>에는 <code>undefined</code>로 값이 할당됩니다.</p>
<p>이런 일이 발생하는 이유는, 생성 단계를 통해 코드의 변수 및 함수 선언에 대해 스캔하는 동안, 함수 선언은 환경에 전체적으로 저장되는 반면, 각 변수는 <code>undefined</code>로 설정되거나(<code>var</code>의 경우), 초기화되지 않은 상태(initialized)로 설정되기 때문입니다.(<code>let</code> 또는 <code>const</code>의 경우)</p>
<p>이것이 <code>var</code>를 사용할 때, <code>var</code>가 선언되기도 전에 상단에서 접근할 수 있게되는 이유입니다. 반면에 <code>let</code> 또는 <code>const</code>의 경우 이들이 선언되기 전에는 참조 에러를 발생시킬 것입니다.</p>
<p>그리고, <code>var</code>에 나타나는 이러한 현상을 우리는 <strong>호이스팅</strong>이라고 합니다.</p>
<p><strong>참고</strong> - 실행 단계에서, JS 엔진이 <code>let</code> 키워드로 선언된 변수의 값을 찾지 못하는 경우, <code>undefined</code>로 이를 할당합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="class"><a class="header" href="#class">Class</a></h1>
<h2 id="클래스와-기본-문법"><a class="header" href="#클래스와-기본-문법">클래스와 기본 문법</a></h2>
<p>클래스는 다음과 같은 문법을 통해 만들 수 있다.</p>
<pre><code class="language-js">class MyClass {
  constructor() {}
  method1() {}
  method2() {}
  ...
}
</code></pre>
<p>이렇게 클래스를 만들고, <code>new MyClass()</code>를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성된다.</p>
<p>객체의 기본 상태를 설정해주는 생성자 메서드 <code>constructor()</code>는 <code>new</code>에 의해 자동으로 호출되므로, 별다른 절차 없이 객체를 초기화할 수 있다.</p>
<pre><code class="language-js">class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
}

// 사용법:
let user = new User('John');
user.sayHi();
</code></pre>
<p>위에서 <code>new User(&quot;John&quot;)</code>을 호출하면 다음과 같은 일이 일어난다.</p>
<ol>
<li>새로운 객체가 생성된다.</li>
<li>넘겨받은 인수와 함께 <code>constructor</code>가 자동으로 실행된다. 이 때, 인수 <code>&quot;John&quot;</code>이 <code>this.name</code>에 할당된다.</li>
</ol>
<p>이런 과정을 거친 후에 <code>user.sayHi()</code> 같은 객체 메서드를 호출할 수 있다.</p>
<h3 id="그래서-클래스란"><a class="header" href="#그래서-클래스란">그래서 클래스란??</a></h3>
<p><code>class User {...}</code> 문법 구조가 진짜 하는 일은 다음과 같다.</p>
<ol>
<li><code>User</code>라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 <code>constructor</code>에서 가져온다. 생성자 메서드가 없으면 비워진 채로 함수가 만들어진다.</li>
<li><code>sayHi</code>같은 클래스 내에서 정의한 메서드를 <code>User.prototype</code>에 저장한다.</li>
</ol>
<p><code>new User</code>를 호출해 객체를 만들고, 이후 객체의 메서드가 호출되면 메서드를 프로토타입에서 가져온다. 이 덕분에 객체에서 클래스 메서드에 접근할 수 있다.</p>
<pre><code class="language-js">class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

// 클래스는 함수입니다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일합니다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장됩니다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개입니다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
</code></pre>
<h3 id="클래스는-단순-syntactic-sugar가-아니다"><a class="header" href="#클래스는-단순-syntactic-sugar가-아니다">클래스는 <strong>단순 Syntactic Sugar가 아니다.</strong></a></h3>
<p>이건 나도 잘못 알고있었던 내용이다. 아래처럼 <code>prototype</code>을 이용하면 순수 함수로도 클래스 역할을 하는 함수를 만들 수 있다. 때문에 <code>class</code>를 단순한 Syntactic Sugar로 여기고 있었다.</p>
<pre><code class="language-js">// class User와 동일한 기능을 하는 순수 함수를 만들어보겠습니다.

// 1. 생성자 함수를 만듭니다.
function User(name) {
  this.name = name;
}
// 모든 함수의 프로토타입은 'constructor' 프로퍼티를 기본으로 갖고 있기 때문에
// constructor 프로퍼티를 명시적으로 만들 필요가 없습니다.

// 2. prototype에 메서드를 추가합니다.
User.prototype.sayHi = function () {
  alert(this.name);
};

// 사용법:
let user = new User('John');
user.sayHi();
</code></pre>
<p>근데 둘 사이에는 중요한 차이가 몇 가지 있다.</p>
<ol>
<li><code>class</code>로 만든 함수엔 특수 내부 프로퍼티인 <code>[[FunctionKind]]: &quot;classConstructor&quot;</code>가 이름표처럼 붙는다. 이것만으로도 두 방법엔 차이가 있다. 이런 검증 과정 때문에, <strong>클래스 생성자는 <code>new</code>와 함께 호출하지 않으면 에러가 발생한다.</strong></li>
</ol>
<p>더불어, 대부분의 JS엔진에서 클래스 생성자를 문자열로 표현할 때 <code>class ...</code>로 시작하게 된다는 차이도 생긴다.</p>
<pre><code class="language-js">class User {
  constructor() {}
}

alert(typeof User); // function
User(); // TypeError: Class constructor User cannot be invoked without 'new'
</code></pre>
<pre><code class="language-js">class User {
  constructor() {}
}

alert(User); // class User { ... }
</code></pre>
<ol start="2">
<li>
<p>클래스 메서드는 열거할 수 없다.(non-enumerable) 클래스의 <code>prototype</code> 프로퍼티에 추가된 메서드 전체의 <code>enumerable</code> 플래그는 <code>false</code>이고, <code>for..in</code>으로 객체를 순회할 때, 이는 순회 대상에서 제외된다. 보통 메서드는 순회 대상에서 제외하고자 하므로, 이 특징은 제법 유용하다.</p>
</li>
<li>
<p>클래스는 항상 엄격모드로 실행된다.(<code>use strict</code>) 클래스 생성자 안 코드 전체엔 자동으로 엄격모드가 적용된다.</p>
</li>
</ol>
<h3 id="클래스-표현식"><a class="header" href="#클래스-표현식">클래스 표현식</a></h3>
<p>함수처럼 클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.
먼저 클래스 표현식을 만들어보자.</p>
<pre><code class="language-js">let User = class {
  sayHi() {
    alert('Hello');
  }
};
</code></pre>
<p>기명 함수 표현식(Named Function Expression)과 유사하게 클래스 표현식에도 이름을 붙일 수 있다.
클래스 표현식에 이름을 붙이면, 이 이름은 오직 클래스 내부에서만 사용할 수 있다.</p>
<pre><code class="language-js">// 기명 클래스 표현식(Named Class Expression)
// (명세서엔 없는 용어이지만, 기명 함수 표현식과 유사하게 동작합니다.)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass라는 이름은 오직 클래스 안에서만 사용할 수 있습니다.
  }
};

new User().sayHi(); // 제대로 동작합니다(MyClass의 정의를 보여줌).

alert(MyClass); // ReferenceError: MyClass is not defined, MyClass는 클래스 밖에서 사용할 수 없습니다.
</code></pre>
<p>필요에 따라 동적인 생성 역시 가능하다.</p>
<pre><code class="language-js">function makeClass(phrase) {
  // 클래스를 선언하고 이를 반환함
  return class {
    sayHi() {
      alert(phrase);
    }
  };
}

// 새로운 클래스를 만듦
let User = makeClass('Hello');

new User().sayHi(); // Hello
</code></pre>
<h3 id="getter와-setter"><a class="header" href="#getter와-setter">getter와 setter</a></h3>
<p>리터럴을 사용해 만든 객체처럼 클래스도 getter나 setter, 계산된 프로퍼티(computed property)를 포함할 수 있다.</p>
<pre><code class="language-js">class User {
  constructor(name) {
    // setter를 활성화합니다.
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length &lt; 4) {
      alert('이름이 너무 짧습니다.');
      return;
    }
    this._name = value;
  }
}

let user = new User('John');
alert(user.name); // John

user = new User(''); // 이름이 너무 짧습니다.
</code></pre>
<p>이런 방법으로 클래스를 선언하면 <code>User.prototype</code>에 getter와 setter가 만들어지는 것과 동일하다.</p>
<h3 id="계산된-메서드명-"><a class="header" href="#계산된-메서드명-">계산된 메서드명 [...]</a></h3>
<p>대괄호 <code>[...]</code>을 이용해 계산된 메서드 이름(computed method name)을 만드는 예시도 있다.</p>
<pre><code class="language-js">class User {
  ['say' + 'Hi']() {
    alert('Hello');
  }
}

new User().sayHi();
</code></pre>
<h3 id="클래스-필드"><a class="header" href="#클래스-필드">클래스 필드</a></h3>
<p>이는 비교적 최근에 생겨난 기능으로, 구식 브라우저에서는 폴리필이 필요할 수도 있다.</p>
<p>지금까지 살펴본 예시엔 메서드가 하나만 있었다.</p>
<p>'클래스 필드(Class Field)'라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.</p>
<p>클래스 <code>User</code>에 <code>name</code> 프로퍼티를 추가해보자.</p>
<pre><code class="language-js">class User {
  name = 'John';

  sayHi() {
    alert(`Hello, {this.name}!`);
  }
}

new User().sayHi(); // Hello, John!
</code></pre>
<p>클래스를 정의할 때 <code>&lt;프로퍼티명&gt; = &lt;값&gt;</code>을 써주면 간단히 클래스 필드를 만들 수 있다.]</p>
<p>클래스 필드의 중요한 특징 중 하나는 <code>User.prototype</code>이 아닌 개별 객체에<strong>만</strong> 클래스 필드가 설정된다는 점이다.</p>
<pre><code class="language-js">class User {
  name = 'John';
}

let user = new User();
alert(user.name); // John
alert(User.prototype.name); // undefined
</code></pre>
<p>클래스 필드는 생성자가 그 역할을 다 한 이후에 처리된다. 따라서 복잡한 표현식이나 함수 호출 결과를 사용할 수 있다.</p>
<pre><code class="language-js">class User {
  name = prompt('이름을 알려주세요.', '보라');
}

let user = new User();
alert(user.name); // 보라
</code></pre>
<h3 id="클래스-필드로-바인딩-된-메서드-만들기"><a class="header" href="#클래스-필드로-바인딩-된-메서드-만들기">클래스 필드로 바인딩 된 메서드 만들기</a></h3>
<p>JS의 함수는 알다시피 동적인 <code>this</code>를 갖는다.</p>
<p>따라서 객체 메서드를 여기저기 전달해 다른 컨텍스트에서 호출하게 되면 <code>this</code>는 원래 객체를 참조하지 않는다.</p>
<p>관련 예시를 살펴보자. 예시를 실행하면 <code>undefined</code>가 출력된다.</p>
<pre><code class="language-js">class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button('hello');

setTimeout(button.click, 1000); // undefined
</code></pre>
<p>이렇게 <code>this</code>의 컨텍스트를 알수 없게 되어버리는 문제를 <strong>Losing this</strong>라고 한다.</p>
<p>문제를 해결하기 위해선 두 개의 방법이 있다.</p>
<ol>
<li><code>setTimeout(() =&gt; button.click(), 1000)</code>같이 래퍼 함수를 전달</li>
<li>생성자 안 등에서 메서드를 객체에 바인딩</li>
</ol>
<p>여기에 더해, 클래스 필드는 또 다른 훌륭한 방법을 제공한다.</p>
<pre><code class="language-js">class Button {
  constructor(value) {
    this.value = value;
  }
  click = () =&gt; {
    alert(this.value);
  };
}

let button = new Button('hello');

setTimeout(button.click, 1000); // hello
</code></pre>
<p>클래스 필드 <code>click = () =&gt; {...}</code>는 각 <code>Button</code> 객체마다 독립적인 함수를 만들고 함수의 <code>this</code>를 해당 객체에 바인딩시켜준다. 따라서 개발자는 <code>button.click</code>과 같은 메서드를 아무 곳에나 전달할 수 있고, <code>this</code>에는 항상 의도한 값이 들어가게 된다.</p>
<p>대체로 클래스 필드의 이런 기능은 <strong>브라우저 환경에서 메서드를 이벤트 리스너로 설정해야 할 때 특히 유용하다.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="화살표-함수-다시보기"><a class="header" href="#화살표-함수-다시보기">화살표 함수 다시보기</a></h1>
<p>화살표 함수(Arrow Function)에 대해 다시 생각해보자.</p>
<p>화살표 함수는 단순히 함수를 짧게 쓰기 위해 쓰지 않는다. 화살표 함수는 몇 가지 독특하고 유용한 기능을 제공한다.</p>
<h2 id="화살표-함수에는-this가-없다"><a class="header" href="#화살표-함수에는-this가-없다">화살표 함수에는 <code>this</code>가 없다.</a></h2>
<p>화살표 함수 본문에서 <code>this</code>에 접근하면 외부에서 값을 가져온다.</p>
<p>이런 특징은 객체의 메서드(<code>showList()</code>)안에서 동일 객체의 프로퍼티(<code>students</code>)를 대상으로 순회를 하는 데 사용할 수 있다.</p>
<pre><code class="language-js">let group = {
  title: '1모둠',
  students: ['보라', '호진', '지민'],

  showList() {
    this.students.forEach((student) =&gt; alert(this.title + ': ' + student));
  },
};

group.showList();
</code></pre>
<p>예시의 <code>forEach</code>에서 화살표 함수를 사용했기 때문에 화살표 함수 본문에 있는 <code>this.title</code>은 화살표 함수 바깥에 있는 메서드인 <code>showList</code>가 가리키는 대상과 동일해진다. 즉 <code>this.title</code>은 <code>group.title</code>과 같다.</p>
<p>위 예시에서 화살표 함수 대신 일반 함수를 사용했다면 에러가 발생했을 것이다.</p>
<pre><code class="language-js">let group = {
  title: '1모둠',
  students: ['보라', '호진', '지민'],

  showList() {
    this.students.forEach(function (student) {
      // TypeError: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student);
    });
  },
};

group.showList();
</code></pre>
<p>이는 <code>forEach</code>에 전달되는 함수의 <code>this</code>가 <code>undefined</code>이기 때문에 발생한다. <code>alert</code> 함수에서 <code>undefined.title</code>에 접근하려 했기 때문에 에러가 발생한다.</p>
<p>반면, 화살표 함수에는 <code>this</code>라는 개념 자체가 없기 때문에 이런 에러가 발생하지 않는다.</p>
<p>또한, <code>this</code>가 없기 때문에 <code>new</code>와 함께 사용할 수 없기도 하다.</p>
<h2 id="화살표-함수에는-arguments가-없다"><a class="header" href="#화살표-함수에는-arguments가-없다">화살표 함수에는 <code>arguments</code>가 없다.</a></h2>
<p>화살표 함수는 일반 함수와 다르게 모든 인수에 접근할 수 있게 해주는 유사 배열(Array) 객체 <code>arguments</code>를 지원하지 않는다.</p>
<p>이런 특징은 현재 <code>this</code>값과 <code>arguments</code> 정보를 함께 실어 호출을 포워딩해주는 데코레이터를 만들 때 유용하게 사용된다.</p>
<pre><code class="language-js">function defer(f, ms) {
  return function () {
    setTimeout(() =&gt; f.apply(this, arguments), ms);
  };
}

function sayHi(who) {
  alert('안녕, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred('철수'); // 2초 후 &quot;안녕, 철수&quot;가 출력됩니다.
</code></pre>
<p>이것을 화살표 함수 없이 구현하려 했다면 아래와 같이 가독성이 떨어지는 형태가 된다.</p>
<pre><code class="language-js">function defer(f, ms) {
  return function (...args) {
    let ctx = this;
    setTimeout(function () {
      return f.apply(ctx, args);
    }, ms);
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-바인딩"><a class="header" href="#함수-바인딩">함수 바인딩</a></h1>
<p><code>setTimeout</code>에 메서드를 전달할 때처럼, 객체 메서드를 콜백으로 전달할 때는 <code>this</code>가 사라지는 문제가 생긴다.</p>
<h2 id="사라진-this"><a class="header" href="#사라진-this">사라진 <code>this</code></a></h2>
<p>앞서 다양한 예제를 통해 <code>this</code> 정보가 사라지는 문제를 경험했다. 객체 메서드가 객체 내부가 아닌 다른 곳에 전달되어 호출되면 <code>this</code>가 사라진다.</p>
<p>대표적인 예는 <code>setTimeout</code>등에서 콜백함수로 넘겨지는 경우에 발생하는 것이다.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
</code></pre>
<p>이런 문제는 콜백함수를 전달 할 때, 객체에서 메서드가 분리(<code>user.sayHi</code>)되어 하나의 함수로써 전달되기 때문이다.</p>
<h3 id="해결-1--래퍼wrapper-함수"><a class="header" href="#해결-1--래퍼wrapper-함수">해결 1 : 래퍼(Wrapper) 함수</a></h3>
<p>가장 간단한 해결책은 래퍼 함수를 사용하는 것이다.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

setTimeout(function () {
  user.sayHi(); // Hello, John!
}, 1000);
</code></pre>
<p>위 예시가 의도대로 동작하는 이유는, 외부 렉시컬 환경에서 <code>user</code>를 받아 보통 때와 똑같이 메서드를 호출하기 때문이다.</p>
<p>단, 이 경우 약간의 취약성이 생기는데, <code>setTimeout</code>이 트리거 되기 전, <code>user</code>에 변경이 가해지면, 변경된 상태의 객체 메서드를 호출한다는 점이다.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

setTimeout(() =&gt; user.sayHi(), 1000);

// 1초가 지나기 전에 user의 값이 바뀜
user = {
  sayHi() {
    alert('또 다른 사용자!');
  },
};

// setTimeout에 또 다른 사용자!
</code></pre>
<p>이런 문제는 두 번째 방법을 사용함으로써 방지할 수 있다.</p>
<h3 id="방법-2--bind"><a class="header" href="#방법-2--bind">방법 2 : bind</a></h3>
<p>모든 함수는 <code>this</code>를 수정하게 해주는 내장 메서드 <code>bind</code>를 제공한다.</p>
<p>기본 문법은 다음과 같다.</p>
<pre><code class="language-js">// 더 복잡한 문법은 뒤에 나옵니다.
let boundFunc = func.bind(context);
</code></pre>
<p><code>func.bind(context)</code>는 함수처럼 호출 가능한 '특수 객체(exotic object)'를 반환한다. 이 객체를 호출하면 <code>this</code>가 <code>context</code>로 고정된 함수 <code>func</code>이 반환된다.</p>
<p>이제 <code>boundFunc</code>를 호출하면 <code>this</code>가 고정된 <code>func</code>를 호출하는 것과 동일한 효과를 본다.</p>
<p>아래 <code>funcUser</code>에는 <code>this</code>가 <code>user</code>로 고정된 <code>func</code>이 할당된다.</p>
<p>이제 객체 메서드에 <code>bind</code>를 적용해보자.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

let sayHi = user.sayHi.bind(user); // (*)

// 이제 객체 없이도 객체 메서드를 호출할 수 있습니다.
sayHi(); // Hello, John!

setTimeout(sayHi, 1000); // Hello, John!

// 1초 이내에 user 값이 변화해도
// sayHi는 기존 값을 사용합니다.
user = {
  sayHi() {
    alert('또 다른 사용자!');
  },
};
</code></pre>
<h3 id="부분-적용-partial-application"><a class="header" href="#부분-적용-partial-application">부분 적용 (Partial Application)</a></h3>
<p>지금껏 <code>this</code>에 대해서만 이야기했지만, <code>this</code>뿐만 아니라 인수에 대해서도 바인딩이 가능하다. 이는 자주 쓰이진 않지만 가끔 유용하다.</p>
<p>```bind`의 전체 문법은 다음과 같다.</p>
<pre><code class="language-js">let bound = func.bind(context, [arg1], [arg2], ...);
</code></pre>
<p><code>bind</code>는 컨텍스트를 <code>this</code>로 고정하는 것 뿐만 아니라 함수의 인수도 고정해준다.</p>
<p>곱셈을 해주는 함수 <code>mul(a, b)</code>를 예시로 들어보고, <code>bind</code>를 통해 새로운 함수 <code>double</code>을 만들어본다.</p>
<pre><code class="language-js">function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert(double(3)); // = mul(2, 3) = 6
alert(double(4)); // = mul(2, 4) = 8
alert(double(5)); // = mul(2, 5) = 10
</code></pre>
<p>이처럼, <code>context</code>는 따로 넘겨주지 않고 인수에 대해서만 값을 전달해 고정해주는 방식을 **부분 적용(Partial Application)**이라고 한다.</p>
<p>이는 매우 포괄적인 함수를 기반으로 덜 포괄적인 변형 함수를 만들어 낼 수 있다는 점에서 유용하다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="call-apply-decorator-call-forwarding"><a class="header" href="#call-apply-decorator-call-forwarding">call, apply, decorator, call forwarding</a></h1>
<h2 id="데코레이터"><a class="header" href="#데코레이터">데코레이터</a></h2>
<p><strong>데코레이터(Decorator)는 특정 함수를 인수로 받아, 반환하는 값 자체는 동일하지만 그 외의 로직을 추가적으로 커스텀하는 함수를 의미한다.</strong></p>
<p>로직을 함수와 함수로 분리시킬 수 있기 때문에 한결 보기 편하다는 장점이 있다.</p>
<pre><code class="language-js">function slow(x) {
  // CPU 집약적인 작업이 여기에 올 수 있습니다.
  alert(`slow({x})을/를 호출함`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function (x) {
    if (cache.has(x)) {
      // cache에 해당 키가 있으면
      return cache.get(x); // 대응하는 값을 cache에서 읽어옵니다.
    }

    let result = func(x); // 그렇지 않은 경우엔 func를 호출하고,

    cache.set(x, result); // 그 결과를 캐싱(저장)합니다.
    return result;
  };
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1)이 저장되었습니다.
alert('다시 호출: ' + slow(1)); // 동일한 결과

alert(slow(2)); // slow(2)가 저장되었습니다.
alert('다시 호출: ' + slow(2)); // 윗줄과 동일한 결과
</code></pre>
<h2 id="funccall로-컨텍스트-지정하기"><a class="header" href="#funccall로-컨텍스트-지정하기"><code>func.call</code>로 컨텍스트 지정하기</a></h2>
<p>이러한 데코레이터는, 객체 메서드에서 사용하기에 적합하지 않다는 문제점이 있는데, 메서드가 기존 객체를 가리키던 <code>this</code>에 대한 컨텍스트를 잃어버리기 때문이다.</p>
<pre><code class="language-js">// worker.slow에 캐싱 기능을 추가해봅시다.
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // CPU 집약적인 작업이라 가정
    alert(`slow({x})을/를 호출함`);
    return x * this.someMethod(); // (*)
  },
};

// 이전과 동일한 코드
function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}

alert(worker.slow(1)); // 기존 메서드는 잘 동작합니다.

worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용

alert(worker.slow(2)); // 에러 발생!, Error: Cannot read property 'someMethod' of undefined
</code></pre>
<p><code>func.call</code>은 이때 사용할 수 있는데, 이는 <code>this</code>를 명시적으로 고정해 함수를 호출할 수 있게 해주는 내장 함수 메서드다. 기본적으로는 아래와 같은 형태다.</p>
<pre><code class="language-js">func.call(context, arg1, arg2, ...)
</code></pre>
<p>실제로 적용한다면 아래와 같아진다.</p>
<pre><code class="language-js">func(1, 2, 3);
func.call(obj, 1, 2, 3);
</code></pre>
<p>위의 두 실행은 거의 동일하다. 유일한 차이점은 <code>func.call</code>에서의 <code>this</code>는 <code>obj</code>로 고정된다는 점이다.</p>
<h2 id="funcapply도-동일한-역할을-한다"><a class="header" href="#funcapply도-동일한-역할을-한다">func.apply도 동일한 역할을 한다.</a></h2>
<p><code>func.apply</code>를 사용해도 된다. 이는 아래와 같은 형태다.</p>
<pre><code class="language-js">func.apply(context, args);
</code></pre>
<p><code>apply</code>는 <code>func</code>의 <code>this</code>를 <code>context</code>로 고정시켜주고, 유사 배열 객체 <code>args</code>를 인수로 사용할 수 있게 해준다. <code>call</code>과의 문법적 차이는 <code>call</code>이 여러 개의 인수들을 따로따로 받는 대신 <code>apply</code>는 배열을 인수로 받는 다는 점 뿐이다.</p>
<p>따라서 아래의 두 코드는 거의 같은 역할을 한다.</p>
<pre><code class="language-js">func.call(context, ...args);
func.apply(context, args);
</code></pre>
<p>이렇게 인수 전체를 다른 함수에 전달하는 것을 <strong>콜 포워딩(Call Forwarding)</strong> 이라고 한다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="closure와-변수의-유효범위"><a class="header" href="#closure와-변수의-유효범위">Closure와 변수의 유효범위</a></h1>
<h2 id="렉시컬-환경-lexical-environment"><a class="header" href="#렉시컬-환경-lexical-environment">렉시컬 환경 (Lexical Environment)</a></h2>
<p>렉시컬 환경은 JS가 어떻게 동작하는지 설명하기 위한 <strong>이론상의</strong> 객체이다.
이를 이해하는 것이 클로저에 대한 명확한 이해를 돕기 때문에, 먼저 이에 대해 익혀보자.</p>
<p>이는 두 부분으로 구성된다.</p>
<ol>
<li>환경 레코드(Environment Record) : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체. <code>this</code>값과 같은 기타 정보도 여기에 저장된다.</li>
<li>외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조(Reference) : 외부 코드와 연관</li>
</ol>
<p>즉, <strong>변수</strong>는 특수 내부 객체인 <strong>환경 레코드</strong>의 프로퍼티일 뿐이다. 때문에 <strong>변수를 가져오거나 변경</strong>하는 것은 곧 <strong>환경 레코드의 프로퍼티를 가져오거나 변경</strong>하는 것을 의미한다.</p>
<pre><code class="language-js">// phrase: &lt;uninitialized&gt;
let phrase = 'Hello';
// phrase: undefined
phrase = 'Hello';
// phrase: 'Hello'
phrase = 'Bye';
// phrase: 'Bye'
</code></pre>
<p><strong>함수</strong>는 변수와 마찬가지로 <strong>값</strong>인데, 다만 <strong>함수 선언문(Function Declaration)으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다는 점에서 차이가 있다.</strong> 즉, 변수는 선언 전까지 사용할 수 없지만, 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다. 물론, <strong>함수 표현식</strong>의 경우는 변수를 함수에 할당한 것이므로 변수와 동일하게 취급된다.</p>
<pre><code class="language-js">let phrase = 'Hello';

function say(name) {
  alert(`&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;se&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{name}`);
}
</code></pre>
<p><strong>함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다.</strong> 이 렉시컬 환경엔 함수 호출 시에 넘겨받은 매개변수와 함수의 지역 변수가 저장된다. 즉, 위에서 <code>say('John')</code>을 호출하면 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경에서 가리키는 외부(여기서는 전역) 렉시컬 환경으로 두개를 갖게 된다.</p>
<p>내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖는다.</p>
<p><strong>코드 내에서 변수에 접근하는 경우, 먼저 내부 렉시컬 환경을 검색하며, 여기서 원하는 변수를 찾지 못하는 경우 검색 범위를 확장하여 외부 렉시컬 환경을 참조한다. 이는 검색 범위가 전역 렉시컬 환경에 도달할 때까지 반복된다.</strong></p>
<h2 id="반환함수"><a class="header" href="#반환함수">반환함수</a></h2>
<p>자, 이제 아래의 예시를 보자.</p>
<pre><code class="language-js">function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCounter();
</code></pre>
<p><code>makeCounter()</code>를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어진다. 그리고 이 렉시컬 환경 객체에는 <code>makeCounter</code>를 실행하는데 필요한 변수들이 저장된다.</p>
<p>단, 위의 경우는 <code>makeCounter</code>가 실행되는 도중에 별도의 중첩 함수가 생성되었다. 현재는 <strong>생성</strong>까지만 하고, <strong>실행</strong>은 되지 않았다.</p>
<p>이제 중요한 사실이 하나 더 있다. <strong>모든 함수는 본인이 생성된 곳의 렉시컬 환경을 기억한다</strong>는 점이다. 함수는 <code>[[Environment]]</code>라는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 위치의 렉시컬 환경에 대한 참조가 저장된다.</p>
<p>따라서, 위의 변수 <code>counter</code>에 저장된 함수의 <code>[[Environment]]</code>에는 <code>{count: 0}</code>이 있는 렉시컬 환경에 대한 참조가 저장된다. 이를 통해 어디에서 호출되던 상관없이 자신이 어디에서 생성되었는지를 알 수 있으며, <code>[[Environment]]</code>는 함수가 생성될 때 처음 딱 한번 그 값이 생성되고, 이는 영원히 변하지 않는다.</p>
<p><code>counter()</code>를 호출하면 각 호출마다 새로운 렉시컬 환경이 만들어진다. 그리고 각 렉시컬 환경은 <code>[[Environment]]</code>에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조하게 되는데, 이는 모두 똑같이 <code>{count}</code>이 있는 렉시컬 환경이다.</p>
<p><strong>따라서, <code>counter()</code>를 여러번 호출하게 되면, <code>count</code> 변수가 <code>1, 2, 3...</code> 으로 점차 증가하게 된다.</strong></p>
<h2 id="클로저"><a class="header" href="#클로저">클로저</a></h2>
<p><strong>클로저(Closure)는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다.</strong></p>
<p>설명하기 용이하게는, <strong>선언될 당시의 환경을 기억했다가 나중에 호출되었을 때에 기억했던 환경에 따라 실행되는 함수</strong>가 되겠다.</p>
<p>JS에서는 모든 함수가 자연스럽게 클로저가 되는데, JS에서의 함수는 숨김 프로퍼티인 <code>[[Environment]]</code>를 통해서 본인이 어디서 생성되었는지를 기억하고 있으며, 함수 내부의 코드는 이 <code>[[Environment]]</code>를 향해 확장하며 외부 변수에 접근하기 때문이다.</p>
<h2 id="가비지-컬렉션"><a class="header" href="#가비지-컬렉션">가비지 컬렉션</a></h2>
<p>함수의 호출이 끝나면, 렉시컬 환경은 메모리에서 제거되며, 함수와 관련된 변수들은 이 시점에서 모두 사라진다.</p>
<p>다시 가비지 컬렉션을 떠올려보자. JS에서의 모든 객체는 <strong>도달 가능한 상태</strong>라면 메모리에 유지된다.</p>
<p>위와 같은 형태의 중첩 함수를 구현하게 되면, <code>[[Environment]]</code> 프로퍼티에 생성 당시의 외부 함수 렉시컬 환경에 대한 정보가 저장되고, 따라서 <strong>도달 가능한 상태</strong>가 되는데, 이 때문에 함수 호출 자체가 끝났어도 렉시컬 환경이 메모리에 여전히 유지될 수 있는 것이다.</p>
<h2 id="js엔진에-의한-최적화"><a class="header" href="#js엔진에-의한-최적화">JS엔진에 의한 최적화</a></h2>
<p>앞서 말했듯, 이론 상으로는 중첩함수를 통해 함수가 살아있는 경우에 모든 외부 변수들 역시 메모리에 유지된다.</p>
<p>그러나 실제로는 JS 엔진(특히 <strong>V8</strong>)이 이를 지속해서 최적화하게 되는데, 엔진이 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거하기 때문이다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-표현식-vs-함수-선언문-function-expression-vs-function-declaration"><a class="header" href="#함수-표현식-vs-함수-선언문-function-expression-vs-function-declaration">함수 표현식 vs. 함수 선언문 (Function Expression vs. Function Declaration)</a></h1>
<h3 id="1-문법에서의-차이"><a class="header" href="#1-문법에서의-차이">1. <strong>문법</strong>에서의 차이</a></h3>
<p>다음은 함수 선언문이다.</p>
<pre><code class="language-JS">// 함수 선언문은 독자적인 구문 형태로 존재한다.

function sum(a, b) {
  return a + b;
}
</code></pre>
<p>그리고 다음은 함수 표현식이다.</p>
<pre><code class="language-js">// 함수 표현식은 표현식(Expression)이나 구문 구성(Syntax construct) 내부에 생성된다.

let sum = function (a, b) {
  return a + b;
};
</code></pre>
<h2 id="2-언제-함수를-생성하는지의-차이"><a class="header" href="#2-언제-함수를-생성하는지의-차이">2. <strong>언제</strong> 함수를 생성하는지의 차이</a></h2>
<ul>
<li><strong>함수 표현식</strong>은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달하고 나서야 해당 함수를 사용할 수 있다.</li>
<li><strong>함수 선언문</strong>은 선언문이 정의되기 전에도 호출할 수 있다.</li>
</ul>
<h2 id="3-스코프에서의-차이"><a class="header" href="#3-스코프에서의-차이">3. <strong>스코프</strong>에서의 차이</a></h2>
<p><code>strict</code> 모드에서 <strong>함수 선언문</strong>이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근하지 못한다.</p>
<h3 id="그래서-둘-중에-무엇을-써야하는가"><a class="header" href="#그래서-둘-중에-무엇을-써야하는가">그래서 둘 중에 무엇을 써야하는가???</a></h3>
<p>일반적으로는 함수 선언문을 통해 함수를 만드는 것이 먼저 고려된다. 다음과 같은 장점이 있다.</p>
<blockquote>
<ol>
<li>함수가 선언되기 이전에 호출할 수 있어 코드 구성을 좀 더 자유롭게 할 수 있다.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>가독성 측면에서 조금 더 유리하다.</li>
</ol>
</blockquote>
<p>하지만 무조건적인 정답은 아니므로, 경우에 따라 필요한 경우 함수 표현식을 사용해야 한다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="js의-비동기성에-관하여"><a class="header" href="#js의-비동기성에-관하여">JS의 비동기성에 관하여</a></h2>
<p>JS는 싱글 스레드 언어입니다. 이는 다시 말해, JS는 하나의 콜 스택만을 활용하기 때문에, 한번에 하나의 코드만을 실행시킬 수 있다는 뜻입니다.</p>
<p>실제로, JS 엔진은 어떤 작업을 수행하고 있는 중에는 렌더링이나 새로운 이벤트에 대한 핸들링이 즉각적으로 일어나지 않습니다.</p>
<p>근데 이상하죠? 우리는 이미 JS의 콜백 함수나, 프라미스, async를 통해 비동기 함수들을 다루어왔는데 말이죠.</p>
<p>이것이 가능한 이유는 브라우저가 단순한 JS 런타임 그 이상을 갖추고 있기 때문입니다. JS 런타임은 실제로 싱글 스레드 언어이지만, 브라우저가 Web API와 같은 것들을 제공합니다. 이들은 JS에서 호출할 수 있는 스레드를 효과적으로 지원합니다.</p>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbfbD9D%2Fbtqw7vo9Ptt%2FkCkBhgG920sxKfg3NZsLN0%2Fimg.png" />
<h2 id="web-api"><a class="header" href="#web-api">Web API</a></h2>
<p>Web API는 브라우저가 제공하는 JS 런타임 내 별도의 API입니다.</p>
<p>여기에는 <code>setTimeout</code>이나, AJAX를 활용하는 <code>fetch</code> 등이 포함됩니다.</p>
<p>Web API에서 제공하는 이들 함수를 활용할 때, JS 엔진은, 해당 함수의 호출이 일어나면, Web API가 내부적으로 이들을 처리하도록 맡기고, 계속해서 코드를 진행해나갑니다.</p>
<h2 id="태스크-큐"><a class="header" href="#태스크-큐">태스크 큐</a></h2>
<p>이후, Web API는 해당 함수를 처리하고, (예를 들어, <code>setTimeout</code>을 실행하면, 정해놓은 시간이 지날때까지 기다리고, AJAX의 경우에는 적절한 응답을 받을때까지 기다립니다.) 이후 해당 함수에 전달했던 콜백을 태스크 큐로 넘깁니다.</p>
<h2 id="이벤트-루프"><a class="header" href="#이벤트-루프">이벤트 루프</a></h2>
<p>이제 이벤트 루프가 활약할 차례입니다. 사실 이벤트 루프가 하는 일은 굉장히 간단합니다. JS 엔진의 콜 스택이 빌 때까지 기다렸다가, 비고 나면, 태스크 큐의 태스크들을 먼저 들어온 순서대로 콜 스택에 넘깁니다.</p>
<p>결국 여기에는 &quot;콜 스택이 빌때까지&quot; 기다리는 시간도 포함되기 때문에, <code>setTimeout(cb, 1000)</code>은 결코 해당 <code>cb</code>가 정확히 1초 이후에 실행된다는 것을 의미하지 않습니다.</p>
<h2 id="매크로태스크와-마이크로태스크"><a class="header" href="#매크로태스크와-마이크로태스크">매크로태스크와 마이크로태스크</a></h2>
<img src="https://media.vlpt.us/images/dami/post/8e5c1b68-101c-4fff-8090-7024ff2730c0/%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A2%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3.gif" />
<p>기본적으로 <code>setTimeout</code>, <code>setInterval</code>, 그리고 이벤트 핸들러 등의 함수들은 매크로태스크에 해당됩니다.</p>
<p>반면, <strong>마이크로태스크</strong>는 우리가 종종 사용하는 프로미스와 같은 것들이 해당합니다.</p>
<p>마이크로태스크와 매크로태스크의 차이는 해당 태스크들의 실행 시점에서 발생한다고 할 수 있습니다.</p>
<p>브라우저는, <em>마이크로태스크 -&gt; 렌더링 -&gt; 매크로태스크</em>의 순서로 실행되며, 마이크로태스크는 결국, 브라우저의 렌더링이나 이벤트 핸들러의 처리 이전에 여러 마이크로태스크들이 실행되는 것을 보장합니다.</p>
<p>이것이 중요한 이유는, 마이크로태스크들이 모두 동일한 환경 내에서 처리되도록 보장하기 위해서입니다. 이를테면, 마우스 클릭 등의 다른 이벤트 핸들링에 의해서 마이크로태스크들을 처리하던 와중에 데이터의 변경이 일어나면, 여러 마이크로태스크들이 제각기 다른 환경에서 실행될 가능성이 있기 때문입니다.</p>
<h2 id="이벤트-루프의-활용"><a class="header" href="#이벤트-루프의-활용">이벤트 루프의 활용</a></h2>
<p>이러한 이벤트 루프의 동작 방식을 실제 업무에서는 어떻게 활용할 수 있을까요?</p>
<h3 id="1-무거운-작업을-쪼개서-수행"><a class="header" href="#1-무거운-작업을-쪼개서-수행">1. 무거운 작업을 쪼개서 수행</a></h3>
<pre><code class="language-js">let i = 0;

let start = Date.now();

function count() {
  // 스케줄링 코드를 함수 앞부분으로 옮김
  if (i &lt; 1e9 - 1e6) {
    setTimeout(count); // 새로운 호출을 스케줄링함
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert('처리에 걸린 시간: ' + (Date.now() - start) + 'ms');
  }
}

count();
</code></pre>
<p>기본적으로, JS 엔진은 싱글 스레드 기반이기 때문에, 동기적인 방식으로 동작하는 함수가 처리에 너무 오랜 시간이 걸린다면 그 동안에 새로운 이벤트나 렌더링 자체를 막아버리면서 유저와의 상호 작용을 무시하는 문제가 발생합니다.</p>
<p>이 경우, 이러한 작업들을 <code>setTimeout</code> 등을 통해 여러 태스크들로 쪼개서 처리한다면, 그 동안에 처리해야 할 이벤트 핸들링 및 렌더링을 막지 않으면서 거대한 작업을 수행할 수 있습니다.</p>
<p>이를 통해서 게임 로딩 등에서 활용되는 프로그레스 바와 같은 것도 구현할 수 있습니다.</p>
<h3 id="2-이벤트-처리가-끝난-이후에-작업하기"><a class="header" href="#2-이벤트-처리가-끝난-이후에-작업하기">2. 이벤트 처리가 끝난 이후에 작업하기</a></h3>
<pre><code class="language-js">menu.onclick = function () {
  // ...

  // 클릭한 메뉴 내 항목 정보가 담긴 커스텀 이벤트 생성
  let customEvent = new CustomEvent('menu-open', {
    bubbles: true,
  });

  // 비동기로 커스텀 이벤트를 디스패칭
  setTimeout(() =&gt; menu.dispatchEvent(customEvent));
};
</code></pre>
<p>이벤트 핸들러 내에 이벤트 버블링이 끝난 이후에 작동해야만 하는 액션이 존재하는 경우, 이를 <code>setTimout(cb, 0)</code>과 같이 콜백함수로 넘길 수 있습니다. 이 경우, 해당 이벤트의 버블링이 모두 완수된 이후에야 특정 콜백을 실행할 수 있게끔 할 수 있습니다.</p>
<h2 id="web-worker"><a class="header" href="#web-worker">Web Worker</a></h2>
<img src="https://assets.hongkiat.com/uploads/web-workers-javascript-api/web-workers.jpg" />
<p><code>setTimout</code>을 통해 여러 개의 태스크로 쪼개지 않더라도, 이벤트 루프를 막지 않아야 하는 거대한 작업의 경우에는 <strong>Web Worker</strong>를 사용할 수 있습니다.</p>
<p>이는 브라우저가 별도의 쓰레드를 통해, 백그라운드 상에서 코드를 실행할 수 있게끔 하는 Web API 스펙입니다.</p>
<p>Web Worker는 메인 쓰레드와 메시지를 교환하는 방식으로 소통할 수 있지만, 자신만의 변수와 이벤트 루프를 갖습니다.</p>
<p>또한, Web Worker는 DOM에 접근할 방법이 없기 때문에, 주로 여러 CPU 코어를 동시에 활용해야 하는, 계산적으로 버거운 작업을 처리해야 할때 유용합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="new와-생성자-함수"><a class="header" href="#new와-생성자-함수">new와 생성자 함수</a></h1>
<h2 id="1-생성자-함수"><a class="header" href="#1-생성자-함수">1. 생성자 함수</a></h2>
<p>생성자 함수 (Contructor function)와 일반 함수 사이의 기술적인 차이는 없다. 다만 생성자 함수는 아래의 두 관례를 따른다.</p>
<ol>
<li>함수 이름 첫 글자는 대문자</li>
<li>반드시 <code>new</code> 연산자를 붙여 사용한다.</li>
</ol>
<pre><code class="language-js">function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User('Jack');
</code></pre>
<p>위와 같은 관례를 따라 <code>new User(...)</code>를 써서 함수를 실행하면 아래와 같은 알고리즘이 동작한다.</p>
<ol>
<li>빈 객체를 만들어 <code>this</code>에 할당한다.</li>
<li>함수 본문을 실행하고 <code>this</code>에 새로운 프로퍼티를 추가해 <code>this</code>를 수정한다.</li>
<li><code>this</code>를 반환한다.</li>
</ol>
<p>즉, 내부적으로는 아래와 같은 일이 동작하는 것이다.</p>
<pre><code class="language-js">function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어짐)

  // 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // return this;  (this가 암시적으로 반환됨)
}
</code></pre>
<p>결국 생성자의 의의는 <strong>재사용할 수 있는</strong> 객체 생성 코드를 구현하기 위한 것이다.</p>
<p>모든 함수는 생성자 함수가 될 수 있다. <code>new</code>를 붙여 실행한다면 어떤 함수라도 위와 같은 일이 벌어진다. 첫 글자가 대문자인 함수는 <code>new</code>를 붙여 실행하는 것이 일종의 관례라는 점도 기억하자.</p>
<h3 id="new-function-"><a class="header" href="#new-function-">new function() {...}</a></h3>
<p>생성자를 이용해 함수에 <strong>캡슐화</strong>를 적용할 수도 있다.</p>
<pre><code class="language-js">let user = new (function () {
  this.name = 'John';
  this.isAdmin = false;

  // ...
})();
</code></pre>
<p>위의 생성자 함수는 익명함수이기 때문에, 어디에도 저장되지 않으며, 단 한번만 호출될 목적으로 만들어져 재사용이 불가능하다.</p>
<h3 id="이-없어도-된다"><a class="header" href="#이-없어도-된다">()이 없어도 된다.</a></h3>
<p>다만 좋은 코드 스타일은 아니다.</p>
<pre><code class="language-js">let user = new User(); // &lt;-- 괄호가 없음
// 아래 코드는 위 코드와 똑같이 동작합니다.
let user = new User();
</code></pre>
<h2 id="2-new-function"><a class="header" href="#2-new-function">2. <code>new Function()</code></a></h2>
<p>함수 표현식과 함수 선언문 이외에 함수를 만들 수 있는 방법이 하나 더 있다.</p>
<p>이는 자주 사용하는 방법은 아니지만, 마땅한 대안이 없을 때 사용될 수 있다.</p>
<p><code>new Function</code>을 이용은 다음과 같다.</p>
<pre><code class="language-js">let func = new Function([arg1, arg2, ...argN], functionBody);
</code></pre>
<p><code>new Function</code>을 이용하는 방법의 가장 큰 차이는 런타임 시점에 받는 문자열을 사용해 함수를 만들 수 있다는 점이다.</p>
<pre><code class="language-js">let sum = new Function('a', 'b', 'return a + b');

alert(sum(1, 2)); // 3
</code></pre>
<h3 id="클로저와의-미묘한-관계"><a class="header" href="#클로저와의-미묘한-관계">클로저와의 미묘한 관계</a></h3>
<p>클로저를 떠올려보자, 반환받은 중첩함수는 <code>[[Environment]]</code> 프로퍼티 덕분에 본인이 생성된 렉시컬 외부 환경을 기억할 수 있었다.</p>
<p>그런데, <code>new Function</code>을 이용해 함수를 만들게 되면 함수의 <code>[[Environment]]</code> 프로퍼티가 현재의 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 된다.</p>
<p>따라서, <code>new Function</code>을 통해 만든 함수는 외부 블록의 변수에 접근할 수 없고, 오직 전역 변수에만 접근할 수 있다.</p>
<pre><code class="language-js">function getFunc() {
  let value = 'test';

  let func = new Function('alert(value)');

  return func;
}

getFunc()(); // ReferenceError: value is not defined
</code></pre>
<p>이러한 특징은, 특정 함수 내부에서 이름이 겹치는 변수들을 사용해도 충돌을 하지 않는다는 이점이 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="properties프로퍼티"><a class="header" href="#properties프로퍼티">Properties(프로퍼티)</a></h1>
<p>알다시피, 객체에는 프로퍼티가 저장된다. 지금까지는 단순히 'key-value'의 관점에서 보일 수 있었겠지만, 사실 프로퍼티는 생각보다 더 유연하고 강력한 자료구조다.</p>
<p>프로퍼티 플래그를 사용하면 손쉽게 <code>getter</code>나 <code>setter</code>함수를 구현할 수 있다.</p>
<h2 id="프로퍼티-플래그-property-flag"><a class="header" href="#프로퍼티-플래그-property-flag">프로퍼티 플래그 (Property flag)</a></h2>
<ul>
<li>객체 프로퍼티는 <strong>값(value)</strong> 뿐만 아니라, **플래그(flag)**라 불리는 특별한 속성 세 가지를 갖는다.</li>
</ul>
<blockquote>
<p><strong>writable</strong> - <code>true</code>라면 값을 수정할 수 있다. 그렇지 않다면 읽기 전용이 된다.
<strong>enumarable</strong> - <code>true</code>라면 반복문을 통해 나열될 수 있다. 그렇지 않다면 나열되지 않는다.
<strong>configurable</strong> - <code>true</code>라면 프로퍼티 삭제나 플래그 수정이 가능하다. 그렇지 않다면 프로퍼티 삭제와 플래그 수정이 불가능하다.</p>
</blockquote>
<p>프로퍼티 플래그는 특별한 경우가 아니라면 쓰이지 않는다. 평범한 방식으로 프로퍼티를 만들면 해당 프로퍼티 플래그는 모두 <code>true</code>가 되고, 이렇게 설정된 플래그는 언제든 수정할 수 있다.</p>
<p>먼저 플래그를 얻는 방법에 대해 알아보자.</p>
<p><code>Object.getOwnPropertyDescriptor</code> 메서드는 특정 프로퍼티에 대한 정보를 모두 얻을 수 있게 해준다.</p>
<pre><code class="language-js">let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
</code></pre>
<p>해당 메서드를 호출하면 프로퍼티 설명자(descriptor)라고 불리는 객체가 반환되며, 여기에는 프로퍼티 값과 세 플래그에 대한 정보가 모두 담겨있다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert(JSON.stringify(descriptor, null, 2));
/* property descriptor:
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: true,
  &quot;enumerable&quot;: true,
  &quot;configurable&quot;: true
}
*/
</code></pre>
<p><code>Object.defineProperty</code>를 사용하면 플래그를 변경할 수 있다.</p>
<pre><code class="language-js">Object.defineProperty(obj, propertyName, descriptor);
</code></pre>
<p>이는 해당 프로퍼티가 이미 존재한다면, 해당 프로퍼티를 인자로 넘긴 플래그에 따라 변경해주고, 프로퍼티가 없으면 인수로 넘겨받은 정보를 통해 새로운 프로퍼티를 만든다. 플래그 정보가 따로 없는 경우는 자동으로 <code>false</code>가 된다.</p>
<p><code>Object.defineProperties</code>는 앞선 프로퍼티 정의 여러개를 한꺼번에 할 수 있다.</p>
<pre><code class="language-js">Object.defineProperties(user, {
  name: { value: 'John', writable: false },
  surname: { value: 'Smith', writable: false },
  // ...
});
</code></pre>
<p><code>Object.getOwnPropertyDescriptors</code>는 프로퍼티 설명자를 전부 한꺼번에 가져올 수 있게 한다. <code>Object.defineProperties</code>와 함께 사용하면 객체 복사 시 플래그도 함께 복사할 수 있다.</p>
<pre><code class="language-js">let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
</code></pre>
<h2 id="접근자-프로퍼티-getter--setter"><a class="header" href="#접근자-프로퍼티-getter--setter">접근자 프로퍼티 (Getter &amp; Setter)</a></h2>
<p>객체 프로퍼티는 두 종류로 나뉜다.</p>
<blockquote>
<ol>
<li><strong>데이터 프로퍼티(data property)</strong> - 지금껏 사용한 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li><strong>접근자 프로퍼티(accessor property)</strong> - 접근자 프로퍼티의 본질은 함수인데, 이 함수는 값을 획득(get)하고, 설정(set)하는 역할을 담당한다. 그러나 외부 코드에서는 함수가 아닌 일반적인 프로퍼티처럼 <strong>보인다</strong>.</li>
</ol>
</blockquote>
<p>객체 리터럴 안에서 <code>getter</code>와 <code>setter</code> 메서드는 <code>get</code>과 <code>set</code>으로 나타낼 수 있다.</p>
<pre><code class="language-js">let obj = {
  get propName() {
    // getter, obj.propName을 실행할 때 실행되는 코드
  },

  set propName(value) {
    // setter, obj.propName = value를 실행할 때 실행되는 코드
  },
};
</code></pre>
<p><code>getter</code>를 구현하면, 마치 일반 프로퍼티인것처럼 동작한다. 이는 함수처럼 <strong>호출</strong>하지 않으며, 일반 프로퍼티에 접근하듯 평범히 <code>user.fullName</code>을 통해 값을 얻어올 수 있다. 실질적으로는 메서드를 호출하는 것이지만.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  surname: 'Smith',

  get fullName() {
    return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{this.surname}`;
  },
};

alert(user.fullName); // John Smith

user.fullName = 'Test'; // Error (프로퍼티에 getter 메서드만 있어서 에러가 발생합니다.)
</code></pre>
<p>또한, <code>getter</code>만 있는 경우는 값을 직접 할당할 수 없어 위와 같은 에러가 발생한다.</p>
<p>여기에 <code>setter</code>도 추가로 구현한다면 다음과 같아진다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  surname: 'Smith',

  get fullName() {
    return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(' ');
  },
};

// 주어진 값을 사용해 set fullName이 실행됩니다.
user.fullName = 'Alice Cooper';

alert(user.name); // Alice
alert(user.surname); // Cooper
</code></pre>
<p><code>getter</code>와 <code>setter</code> 메서드를 구현하면 객체에는 <code>fullName</code>이라는 가상 프로피터가 생기며, 이는 읽고 쓸수는 있지만 실제로 존재하진 않는다.</p>
<h3 id="접근자-프로퍼티의-설명자descriptor"><a class="header" href="#접근자-프로퍼티의-설명자descriptor">접근자 프로퍼티의 설명자(descriptor)</a></h3>
<p>데이터 프로퍼티의 설명자와 접근자 프로퍼티의 설명자는 다르다.
접근자 프로퍼티에는 <code>value</code>와 <code>writable</code> 대신에 <code>get</code>과 <code>set</code>이 있다.</p>
<blockquote>
<p><strong>get</strong> – 인수가 없는 함수로, 프로퍼티를 읽을 때 동작함
<strong>set</strong> – 인수가 하나인 함수로, 프로퍼티에 값을 쓸 때 호출됨
<strong>enumerable</strong> – 데이터 프로퍼티와 동일함
<strong>configurable</strong> – 데이터 프로퍼티와 동일함</p>
</blockquote>
<p>이는 앞서 <code>defineProperty</code>메서드 등을 사용할 때도 똑같이 적용된다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  surname: 'Smith',
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(' ');
  },
});

alert(user.fullName); // John Smith

for (let key in user) alert(key); // name, surname
</code></pre>
<p>프로퍼티는 접근자 프로퍼티나 데이터 프로퍼티 중 한 종류에만 속하고, 둘 다에 속할 수는 없다는 점을 유의하자.</p>
<h3 id="getter와-setter-똑똑하게-써먹기"><a class="header" href="#getter와-setter-똑똑하게-써먹기">getter와 setter 똑똑하게 써먹기</a></h3>
<p><code>getter</code>와 <code>setter</code>를 실제 프로퍼티 값을 감싸 래퍼(wrapper)처럼 활용하면 프로퍼티값을 원하는대로 통제할 수 있다.</p>
<pre><code class="language-js">let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length &lt; 4) {
      alert(
        '입력하신 값이 너무 짧습니다. 네 글자 이상으로 구성된 이름을 입력하세요.',
      );
      return;
    }
    this._name = value;
  },
};

user.name = 'Pete';
alert(user.name); // Pete

user.name = ''; // 너무 짧은 이름을 할당하려 함
</code></pre>
<p>위에서 <code>user</code>의 이름은 <code>_name</code>에 저장되고, 프로퍼티에 접근하는 것은 getter와 setter를 통해 이루어진다. <code>_name</code>과 같이 밑줄 <code>_</code>로 시작하는 프로퍼티는 관습 상 외부에서 건드리지 않는다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="프로토타입"><a class="header" href="#프로토타입">프로토타입</a></h1>
<h2 id="1-프로토타입-상속"><a class="header" href="#1-프로토타입-상속">1. 프로토타입 상속</a></h2>
<p>개발을 하다보면 기존에 있는 기능을 가져와 확장을 해야하는 경우가 생긴다.</p>
<p>이는 자바스크립트의 고유 기능인 포로토타입 상속(Prototypal Inheritance)를 이용하면 실현할 수 있다.</p>
<h3 id="prototype"><a class="header" href="#prototype">[[Prototype]]</a></h3>
<p>자바스크립트의 객체는 <code>[[Prototype]]</code>이라는 숨김 프로퍼티를 갖는다. 이 숨김 프로퍼티는 <code>null</code>이거나, 다른 객체에 대한 참조가 되는데 (<strong>그 외의 자료형은 무시된다.</strong>), 이것이 참조하는 대상을 **프로토타입(prototype)**이라고 부른다.</p>
<p>JS는 객체에서 프로퍼티를 찾다가, 해당 프로퍼티가 없으면 <strong>자동으로 프로토타입에서 프로퍼티를 찾는다.</strong> 프로그래밍에서는 이런 동작 방식을 <strong>프로토타입 상속</strong>이라 부른다.</p>
<p><code>[[Prototype]]</code> 프로퍼티는 내부 프로퍼티면서 숨김 프로퍼티지만, 다양한 방법을 사용해 개발자가 값을 설정할 수 있다.</p>
<p>그 중 하나는, <code>__proto__</code>를 사용해 값을 설정하는 것이다.</p>
<blockquote>
<p>참고로, <code>__proto__</code>는 <code>[[Prototype]]</code>용 getter / setter라는 점을 이해하자.
요즘에는 <code>__proto__</code>를 직접 쓰는 경우는 드물고, <code>Object.getPrototypeOf</code>나 <code>Object.setPrototypeOf</code>를 써서 프로토타입을 획득 혹은 설정한다. 왜 <code>__proto__</code>를 요즘은 쓰지 않는지에 대해서는 추후에 다루자.</p>
</blockquote>
<p><code>obj.hasOwnProperty(key)</code>는 해당 객체의 <code>key</code>에 해당하는 프로퍼티가 상속받은 것이 아닌, 직접 구현된 프로퍼티일 경우 <code>true</code>를 반환한다. <strong>프로토타입으로 부터의 프로퍼티인지</strong>를 체크하는 역할을 한다고 보면 되겠다.</p>
<h2 id="2-prototype-프로퍼티"><a class="header" href="#2-prototype-프로퍼티">2. <code>prototype</code> 프로퍼티</a></h2>
<p><code>new F()</code>와 같은 생성자 함수를 사용하면 새로운 객체를 만들 수 있다는 것을 앞서 배웠다. 그런데, 이 <code>F.prototype</code>이 객체라면, <code>new</code> 연산자는 <code>F.prototype</code>을 사용해 새롭게 생성된 객체의 <code>[[Prototype]]</code>을 설정한다.</p>
<p>과거엔 프로토타입에 직접 접근할 방법이 없었고, 그나마 믿고 사용할 수 있는 방법이 해당 방법 뿐이었다. 여전히 이 문법이 남아있는 이유다.</p>
<p>여기서 <code>F.prototype</code>은 그저 일반 프로퍼티라는 점에 주의해야 한다.</p>
<pre><code class="language-js">let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit('White Rabbit'); //  rabbit.__proto__ == animal

alert(rabbit.eats); // true
</code></pre>
<h2 id="contructor-프로퍼티"><a class="header" href="#contructor-프로퍼티"><code>contructor</code> 프로퍼티</a></h2>
<p>사실, 개발자가 따로 할당하지 않더라도, 모든 함수는 <code>prototype</code> 프로퍼티를 갖는다. 기본 프로퍼티인 <code>prototype</code>은 <code>constructor</code> 프로퍼티 하나만 있는 객체를 가리키는데, 이 <code>constructor</code> 프로퍼티는 함수 자신을 가리킨다. 이 관계를 코드로 나타내면 다음과 같다.</p>
<pre><code class="language-js">function Rabbit() {}

/* 기본 prototype
Rabbit.prototype = { constructor: Rabbit };
*/
</code></pre>
<pre><code class="language-js">function Rabbit() {}
// 기본 prototype:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // {constructor: Rabbit}을 상속받음

alert(rabbit.constructor == Rabbit); // true (프로토타입을 거쳐 접근함)
</code></pre>
<p><code>constructor</code>프로퍼티를 사용하면, 기존에 있던 객체의 <code>constructor</code>를 사용해서 새로운 객체를 만들 수 있다.</p>
<pre><code class="language-js">function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit('White Rabbit');

let rabbit2 = new rabbit.constructor('Black Rabbit');
</code></pre>
<p>이 <code>constructor</code>는 객체가 있는데, 이 객체를 만드는데 어떤 생성자가 사용되었는지 알수 없는 경우에 사용된다. <strong>단, 가장 중요한점은 JS가 알맞은 <code>constructor</code>값을 보장하진 않는다는 점이다.</strong> 함수에 기본으로 <code>prototype</code>값이 설정되지만 그것이 전부다. <code>constructor</code>에 벌어지는 모든 일은 전적으로 개발자에게 맡겨지며, 만약 함수의 기본 <code>prototype</code>값을 다른 객체로 바꾼다면 이 객체엔 <code>constructor</code>가 없어진다.</p>
<p>이를 방지하고 알맞은 <code>constructor</code>를 유지하기 위해서는 <code>prototype</code> 전체를 덮어쓰지 말고 기본 <code>prototype</code>에 원하는 프로퍼티를 추가/제거해야 한다. (참조 관계를 끊지 않기 위해서)</p>
<pre><code class="language-js">function Rabbit() {}

// Rabbit.prototype 전체를 덮어쓰지 말고
// 원하는 프로퍼티는 그냥 추가하세요.
Rabbit.prototype.jumps = true;
// 이렇게 하면 기본 Rabbit.prototype.constructor가 유지됩니다.
</code></pre>
<p>수동으로 <code>constructor</code> 프로퍼티를 다시 만들어주는 것도 대안이 된다.</p>
<pre><code class="language-js">Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit,
};

// 수동으로 추가해 주었기 때문에 알맞은 constructor가 유지됩니다.
</code></pre>
<h2 id="3-네이티브-프로토타입"><a class="header" href="#3-네이티브-프로토타입">3. 네이티브 프로토타입</a></h2>
<p><code>prototype</code> 프로퍼티는 JS 내부에서도 광범위하게 사용되는데, 모든 내장 생성자 함수에서 <code>prototype</code> 프로퍼티를 사용한다.</p>
<h3 id="objectprototype"><a class="header" href="#objectprototype">Object.prototype</a></h3>
<pre><code class="language-js">let obj = {};
alert(obj); // &quot;[object Object]&quot; ?
</code></pre>
<p>여기서 <code>&quot;[object Object]&quot;</code>를 생성하는 코드는 대체 어디에 있을까?? <code>obj</code>는 비어있는데.</p>
<p>참고로 <code>obj = {}</code>는 <code>obj = new Object()</code>를 줄인 것이다. 여기서 <code>Object</code>는 내장 객체 생성자 함수인데, 이 객체의 <code>prototype</code>은 <code>toString</code>을 비롯해 다양한 메서드들이 구현된 거대한 객체를 참조한다. 따라서 <code>obj.toString()</code>을 호출하면 <code>Object.prototype</code>에서 해당 메서드를 찾아 가져오게 된다.</p>
<pre><code class="language-js">let obj = {};

alert(obj.__proto__ === Object.prototype); // true

alert(obj.toString === obj.__proto__.toString); //true
alert(obj.toString === Object.prototype.toString); //true
</code></pre>
<p>단, 이때 <code>Object.prototype</code> 위에는 그 이상의 <code>[[Prototype]]</code>이 존재하지 않는다는 점을 주의하자.</p>
<pre><code class="language-js">alert(Object.prototype.__proto__); // null
</code></pre>
<h3 id="모든-것은-객체를-상속받는다"><a class="header" href="#모든-것은-객체를-상속받는다"><strong>모든 것은 객체를 상속받는다</strong></a></h3>
<p><code>Array</code>, <code>Date</code>, <code>Function</code>을 비롯한 내장 객체들 역시 프로토타입에 메서드를 저장해놓는다.</p>
<p>명세서 상에서는 모든 내장 프로토타입의 꼭대기에는 <code>Object.prototype</code>이 있어야 한다고 규정한다. 이 때문에 <strong>모든 것은 객체를 상속받는다</strong>는 말을 하기도 한다.</p>
<p>체인 상의 프로토타입에는 중복 메서드가 있을 수도 있는데, 이 경우, 체인 상에서 가까운 메서드를 사용하며, <code>Array</code>의 경우, <code>Array.prototype</code>의 메서드가 <code>Object.prototype</code>의 메서드보다 가깝기 때문에 해당 메서드가 사용된다.</p>
<h3 id="원시값primitive-value"><a class="header" href="#원시값primitive-value">원시값(Primitive Value)</a></h3>
<p>그럼 원시값은요?? 이들을 프로토타입을 통해 다루는 것은 상당히 까다롭다.</p>
<p>문자열과 숫자, 불린은 객체가 아니다. 그런데 이런 원시값들의 프로퍼티에 접근하려고 하면 내장 생성자 <code>String</code>, <code>Number</code>, <code>Boolean</code>을 사용하는 <strong>임시 래퍼(Wrapper) 객체가 생성</strong>된다. 이 래퍼 객체는 해당 메서드만 제공하고 나면 사라진다.</p>
<p>래퍼 객체는 보이지 않는 곳에서 만들어지고, 엔진에 의해 최적화된다.</p>
<p>참고로 <code>null</code>과 <code>undefined</code>에 대응하는 래퍼 객체는 없다. 떄문에 메서드와 프로퍼티는 물론, 당연히 프로토타입도 사용할 수 없다.</p>
<h3 id="네이티브-프로토타입-변경"><a class="header" href="#네이티브-프로토타입-변경">네이티브 프로토타입 변경</a></h3>
<p>이런 네이티브 프로토타입을 직접 변경할 수도 있다.</p>
<pre><code class="language-js">String.prototype.show = function () {
  alert(this);
};

'BOOM!'.show(); // BOOM!
</code></pre>
<p>다만, 이는 좋은 생각이 아닌데, 기본적으로 네이티브 프로토타입은 전역으로 영향을 미치기 때문이다. 때문에 이런식으로 네이티브 프로토타입을 수정하게 되면 다른 라이브러리의 메서드와 충돌할 가능성이 크다.</p>
<p>네이티브 프로토타입 변경이 허용되는 유일한 경우는 딱 하나인데, 바로 <strong>폴리필을 만들 때</strong>다.</p>
<p>폴리필은 JS 명세서에는 정의되어 있으나 특정 JS 엔진에서 해당 기능이 구현되지 않았을 경우 만들어 사용한다.</p>
<h3 id="프로토타입에서-빌려오기"><a class="header" href="#프로토타입에서-빌려오기">프로토타입에서 빌려오기</a></h3>
<p>네이티브 프로토타입에 구현된 메서드를 빌려와서 사용할 수도 있다.</p>
<p>다음은 객체 <code>obj</code>에 <code>Array</code>의 <code>join</code> 메서드를 구현하는 내용이다.</p>
<pre><code class="language-js">let obj = {
  0: 'Hello',
  1: 'world!',
  length: 2,
};

obj.join = Array.prototype.join;

alert(obj.join(',')); // Hello,world!
</code></pre>
<h2 id="모던하게-프로토타입을-다루기"><a class="header" href="#모던하게-프로토타입을-다루기"><strong>모던</strong>하게 프로토타입을 다루기</a></h2>
<p><code>__proto__</code>는 브라우저를 대상으로 개발한다면 구식의 방법이기에 더는 사용하지 않는다.</p>
<p>이를 대체할 아래의 모던한 메서드들이 있다.</p>
<p><strong>Object.create(proto, [descriptors])</strong> – [[Prototype]]이 proto를 참조하는 빈 객체를 만든다. 이때 프로퍼티 설명자({ value, enumarable, ...})를 추가로 넘길 수 있다.
<strong>Object.getPrototypeOf(obj)</strong> – obj의 [[Prototype]]을 반환한다.
<strong>Object.setPrototypeOf(obj, proto)</strong> – obj의 [[Prototype]]이 proto가 되도록 설정한다.</p>
<pre><code class="language-js">let animal = {
  eats: true,
};

// 프로토타입이 animal인 새로운 객체를 생성합니다.
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {}); // rabbit의 프로토타입을 {}으로 바꿉니다.
</code></pre>
<p>앞서 말한것처럼 프로퍼티 설명자를 선택적으로 전달할 수도 있다.</p>
<pre><code class="language-js">let animal = {
  eats: true,
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true,
  },
});

alert(rabbit.jumps); // true
</code></pre>
<p><code>Object.create</code>를 통해 객체를 효율적으로 (얕게) 복제할 수도 있다.
아래 코드는 <code>obj</code>의 모든 프로퍼티를 포함한 완벽한 사본을 만든다.</p>
<pre><code class="language-js">let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj),
);
</code></pre>
<p>주의해야 할 점은, 앞선 메서드들로 객체의 <code>[[Prototype]]</code>을 수정하는데 기술적인 문제는 전혀 없으나, 이는 권장되는 사항이 아니다. 이는 객체 프로퍼티 접근 관련 최적화를 망치기 때문에, JS 엔진의 속도를 매우 느리게 한다. 때문에 <code>[[Prototype]]</code>은 객체를 처음 생성할 때만 설정하는 것이 일반적이다.</p>
<h3 id="아주-단순한very-plain-객체"><a class="header" href="#아주-단순한very-plain-객체">아주 단순한(Very plain) 객체</a></h3>
<p><code>Object.create()</code>는 인자의 <code>[[Prototype]]</code>을 상속받은 객체를 생성한다. 이 때, 상속받는 객체 자체가 없다면 어떻게 될까??</p>
<p><code>Object.create(null)</code>은 <code>__proto__</code>를 상속받지 않는다. 때문에 <code>__proto__</code>가 키 값이 되어도 일반 데이터 프로퍼티처럼 처리하므로 버그가 발생하지 않는다.</p>
<p>이런 객체는 아주 단순한(Very plain), 혹은 순수 사전식(Pure dictionary) 객체라고 부른다. 일반 객체 <code>{...}</code>보다도 훨씬 단순하기 때문이다.</p>
<p>단, 이 단순한 객체는 프로토타입 자체가 없기 때문에 <strong>내장 메서드조차 없다.</strong></p>
<pre><code class="language-js">let obj = Object.create(null);

alert(obj); // Error: Cannot convert object to primitive value (toString이 없음)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="this와-메서드"><a class="header" href="#this와-메서드">this와 메서드</a></h1>
<h2 id="what-is-this"><a class="header" href="#what-is-this">what is <code>this</code>?</a></h2>
<p>JS에서 <code>this</code>는 이따금씩 개발자를 헷갈리게 만드는 존재다. 이는 쓰이는 상황에 따라 각각 다른 것을 가리키게 되는데, 일반적으로는 다음과 같은 상황들이 있다.</p>
<h2 id="1-메서드에서"><a class="header" href="#1-메서드에서">1. 메서드에서</a></h2>
<p>메서드 내부에서 사용하는 <code>this</code>는 해당 메서드가 선언된 객체를 가리킨다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  age: 30,

  sayHi() {
    alert(this.name);
  },
};

user.sayHi(); // John
</code></pre>
<h2 id="2-일반-함수에서"><a class="header" href="#2-일반-함수에서">2. 일반 함수에서</a></h2>
<p>다른 언어와 달리 JS는 모든 함수에서 <code>this</code>를 사용할 수 있는데, 이 경우는 런타임 시점에 <code>this</code>가 가리키는 것이 결정된다. 즉, <strong>컨텍스트</strong>에 따라 달라진다.</p>
<pre><code class="language-js">// 같은 함수라도 다른 객체에서 호출한다면 `this`가 달라진다.

let user = { name: 'John' };
let admin = { name: 'Admin' };

function sayHi() {
  alert(this.name);
}

// 별개의 객체에서 동일한 함수를 사용함
user.f = sayHi;
admin.f = sayHi;

// 'this'는 '점(.) 앞의' 객체를 참조하기 때문에
// this 값이 달라짐
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (점과 대괄호는 동일하게 동작함)
</code></pre>
<h2 id="3-화살표-함수에서"><a class="header" href="#3-화살표-함수에서">3. 화살표 함수에서</a></h2>
<p>화살표 함수는 일반 함수와 달리 고유한 <code>this</code>를 가지지 않는다. 화살표에서 <code>this</code>를 사용하면 외부 컨텍스트를 통해 <code>this</code>를 가져온다. 때문에 별도로 <code>this</code>를 만들기는 원치 않은 반면, 외부 컨텍스트의 <code>this</code>를 이용하고자 하는 경우는 화살표 함수를 이용하면 된다.</p>
<pre><code class="language-js">let user = {
  firstName: '보라',
  sayHi() {
    let arrow = () =&gt; alert(this.firstName);
    arrow();
  },
};

user.sayHi(); // 보라
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="var를-쓰지-않는-이유"><a class="header" href="#var를-쓰지-않는-이유"><code>var</code>를 쓰지 않는 이유</a></h1>
<h2 id="var에는-블록-스코프가-없다"><a class="header" href="#var에는-블록-스코프가-없다"><code>var</code>에는 <strong>블록 스코프</strong>가 없다.</a></h2>
<p><code>var</code>로 선언한 변수의 스코프는 <code>function-scoped</code> 혹은 <code>global-scoped</code>다. 블록을 기준으로 스코프가 생기지 않기 때문에, 혼동을 일으키기 매우 좋다. 아래는 그 덕분에 작성가능한 괴상망측한 코드다.</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  // ...
}

alert(i);
</code></pre>
<p>코드 블럭이 함수 안에 있다면, <code>var</code>는 함수 스코프<strong>만</strong> 적용된 변수가 된다.</p>
<pre><code class="language-js">function sayHi() {
  if (true) {
    var phrase = 'Hello';
  }

  alert(phrase); // 제대로 출력됩니다.
}

sayHi();
alert(phrase); // Error
</code></pre>
<h2 id="var는-재선언이-되는-척을-한다"><a class="header" href="#var는-재선언이-되는-척을-한다"><code>var</code>는 재선언이 되는 <strong>척</strong>을 한다</a></h2>
<p>아래는 실행 상 아무 문제가 없다. 다만 중간의 <code>John</code>값으로 <code>user</code>를 다시 선언/할당한 내용은 무시된다.</p>
<h2 id="var는-선언도-하기-전에-사용할-수-있다-호이스팅-hoisting"><a class="header" href="#var는-선언도-하기-전에-사용할-수-있다-호이스팅-hoisting"><code>var</code>는 선언도 하기 전에 사용할 수 있다. <strong>(호이스팅: Hoisting)</strong></a></h2>
<p><code>var</code> 선언은 함수가 시작될 때 처리된다. 전역에서 선언한 변수라면 스크립트가 시작될 때 처리된다.</p>
<p><strong>때문에, <code>var</code>로 변수를 선언한다면, 그 위치랑 상관없이 함수 본문이 시작되는 지점에서 정의가 된다.</strong></p>
<p>이렇게 <strong><code>var</code>로 인하여 변수의 선언이 함수 최상위로 끌어올려지는</strong> 현상을 호이스팅(Hoisting)이라고 한다.</p>
<p>아래 코드에서 <code>if</code>블럭 안의 코드는 절대 실행되지 않겠지만, 이는 호이스팅 자체에 전혀 영향을 주지 않기 때문에, 에러가 발생하지 않는다.</p>
<pre><code class="language-js">function sayHi() {
  phrase = 'Hello'; // (*)

  if (false) {
    var phrase;
  }

  alert(phrase);
}
sayHi();
</code></pre>
<p>다만, <strong>선언</strong>만 호이스팅되고 <strong>할당</strong>은 호이스팅 되지 않는다.</p>
<pre><code class="language-js">function sayHi() {
  alert(phrase);

  var phrase = 'Hello';
}

sayHi();
</code></pre>
<p>위 예시는 <code>var</code>를 이용했기 때문에 사실상 아래와 같이 실행된다.</p>
<pre><code class="language-js">function sayHi() {
  var phrase; // 선언은 함수 시작 시 처리됩니다.

  alert(phrase); // undefined

  phrase = 'Hello'; // 할당은 실행 흐름이 해당 코드에 도달했을 때 처리됩니다.
}

sayHi();
</code></pre>
<h2 id="iife즉시-실행-함수-표현식--var가-남긴-폐해의-잔재"><a class="header" href="#iife즉시-실행-함수-표현식--var가-남긴-폐해의-잔재">IIFE(즉시 실행 함수 표현식) : <code>var</code>가 남긴 폐해의 잔재</a></h2>
<p>과거에는 <code>var</code>만 쓸 수 있었고, 이를 쓰기 위해서 과거의 개발자들은 블록 레벨 스코프를 구현하기 위해 여러 방안을 고려했다. 그 결과 만들어진 것이 IIFE(Immediately Invoked Function Expressions)다.</p>
<p>요즘에는 쓰지 않으나, 오래된 스크립트에서 만나볼 수 있다.</p>
<pre><code class="language-js">(function () {
  let message = 'Hello';

  alert(message); // Hello
})();
</code></pre>
<h2 id="결론"><a class="header" href="#결론">결론</a></h2>
<p>결국, 두가지 끔찍한 이유 때문에 <code>var</code>를 사용하지 않는다.</p>
<ol>
<li><code>var</code>는 함수 스코프를 갖는다.</li>
<li><code>var</code>는 호이스팅을 유발한다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>공식 <a href="https://babeljs.io/docs/en/">문서</a>를 재구성한 내용입니다.</p>
<hr />
<h1 id="babel이-뭔가요"><a class="header" href="#babel이-뭔가요">Babel이 뭔가요?</a></h1>
<p>Babel은 JS 컴파일러다. 이는 주로 ECMAScript6+ 코드를 이전 버전의 JS로 변환하여 구형 브라우저 및 환경에서 동작하도록 해준다. 아래는 Babel이 해주는 주된 역할이다.</p>
<ul>
<li>Syntax 변환</li>
<li>Target 환경에 존재하지 않는 기능에 대한 폴리필 추가 (<code>@babel/polyfill</code>)</li>
<li>소스 코드 변경 (codemods)</li>
<li>그 외 등등...</li>
</ul>
<pre><code class="language-js">// Babel Input: ES2015 arrow function
[1, 2, 3].map((n) =&gt; n + 1);

// Babel Output: ES5 equivalent
[1, 2, 3].map(function (n) {
  return n + 1;
});
</code></pre>
<h2 id="어떻게-쓸-수-있을까"><a class="header" href="#어떻게-쓸-수-있을까">어떻게 쓸 수 있을까?</a></h2>
<h3 id="es6-사양의-프로젝트"><a class="header" href="#es6-사양의-프로젝트">ES6+ 사양의 프로젝트</a></h3>
<p>Babel은 최신 버전의 JS 사용을 구문 변환을 통해 지원해준다. Babel이 제공하는 플러그인들을 통해, 브라우저가 지원하지 않는 사양의 문법까지 사용할 수 있도록 한다.</p>
<h3 id="jsx와-react"><a class="header" href="#jsx와-react">JSX와 React</a></h3>
<p>Babel은 마찬가지로 JSX 구문도 변환할 수 있다.</p>
<pre><code class="language-bash">npm install --save-dev @babel/preset-react
</code></pre>
<h3 id="type-annotations-flow--typescript"><a class="header" href="#type-annotations-flow--typescript">Type Annotations (Flow &amp; TypeScript)</a></h3>
<p>Babel은 타입 주석(Type Annotation)을 제거할 수 있다. 사실, Babel 자체는 타입체킹을 수행하지 않으며, 타입 체킹을 위해서는 별도로 Flow나 TypeScript를 사용해야 함을 명심하자.</p>
<pre><code class="language-bash">npm install --save-dev @babel/preset-flow
</code></pre>
<pre><code class="language-bash">npm install --save-dev @babel/preset-typescript
</code></pre>
<h3 id="pluggable"><a class="header" href="#pluggable">Pluggable</a></h3>
<p>Babel은 여러 플러그인들로 구성되어 있다. 존재하는 플러그인 혹은 본인이 직접 작성한 플러그인을 통해 자신만의 구문 변환 파이프라인을 구성할 수 있다. 더 쉽게는 preset을 만들거나 사용해서 일련의 플러그인들을 사용해도 된다.</p>
<pre><code>// 사실, 플러그인은 그냥 함수일 뿐이다.
export default function ({types: t}) {
  return {
    visitor: {
      Identifier(path) {
        let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ
        path.node.name = name.split('').reverse().join('');
      }
    }
  };
}
</code></pre>
<h3 id="debuggable"><a class="header" href="#debuggable">Debuggable</a></h3>
<p><strong>Souce map</strong>은 컴파일된 코드를 쉽게 디버깅할 수 있도록 도와준다.</p>
<h3 id="spec-compliant-규격-준수"><a class="header" href="#spec-compliant-규격-준수">Spec Compliant (규격 준수)</a></h3>
<p>Babel은 가능한 ECMAScript 표준을 준수하려고 한다. 성능이 좀 떨어지더라도 표준 준수를 위해 더 구체적인 옵션을 가질 수 있다.</p>
<h3 id="compact-압축"><a class="header" href="#compact-압축">Compact (압축)</a></h3>
<p>Babel은 용량이 큰 런타임에 의존하지 않고 최대한 작은 양의 코드를 사용하려고 한다.</p>
<p>이는 상황에 따라 이루어지기 어려울 수도 있으며, 가독성, 파일 크기, 속도에 대한 규격을 준수하도록 하는 구체적인 변환에 대한 &quot;느슨한&quot; 옵션들이 존재한다.</p>
<h1 id="usage-guide"><a class="header" href="#usage-guide">Usage Guide</a></h1>
<p>일반적으로 Babel을 사용하는 케이스처럼, ES2015+ 문법들을 현재 브라우저에 적합한 사양으로 변환하고자 한다.</p>
<p>이러한 작업은 문법을 새로운 형태로 작성하고, 없는 기능에 대한 폴리필을 추가함으로써 이루어질 수 있다.</p>
<p>이에 대한 전반적인 과정은 아래와 같다.</p>
<h2 id="일단-훑어보기"><a class="header" href="#일단-훑어보기">일단 훑어보기</a></h2>
<ol>
<li>패키지 인스톨</li>
</ol>
<pre><code class="language-sh">npm install --save-dev @babel/core @babel/cli @babel/preset-env
npm install --save @babel/polyfill
</code></pre>
<ol start="2">
<li>프로젝트 루트에 <code>babel.config.json</code> (<code>v7.8.0</code> 이상 요구) config 파일 생성</li>
</ol>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/env&quot;,
      {
        &quot;targets&quot;: {
          &quot;edge&quot;: &quot;17&quot;,
          &quot;firefox&quot;: &quot;60&quot;,
          &quot;chrome&quot;: &quot;67&quot;,
          &quot;safari&quot;: &quot;11.1&quot;
        },
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: &quot;3.6.5&quot;
      }
    ]
  ]
}
</code></pre>
<p>위의 설정은 하나의 예시일 뿐이고, 본인이 지원하고자 하는 브라우저 스펙에 따라 이를 적절히 설정해주어야 한다.</p>
<p><a href="https://babeljs.io/docs/en/babel-preset-env">여기</a>에서 <code>@babel/preset-env</code>가 보유한 옵션들을 확인하자.</p>
<p><code>v7.8.0</code> 미만 버전의 Babel에서는 대신에 <code>babel.config.js</code>를 사용할 수 있다.</p>
<pre><code class="language-js">const presets = [
  [
    '@babel/env',
    {
      targets: {
        edge: '17',
        firefox: '60',
        chrome: '67',
        safari: '11.1',
      },
      useBuiltIns: 'usage',
      corejs: '3.6.4',
    },
  ],
];

module.exports = { presets };
</code></pre>
<ol start="3">
<li>이후 <code>src</code> 디렉토리에 있는 모든 코드에 대해 컴파일링을 수행하여 <code>lib</code>에 작성하고자 하는 경우 아래와 같이 cli를 이용할 수 있다.</li>
</ol>
<pre><code class="language-sh">./node_modules/.bin/babel src --out-dir lib
</code></pre>
<p>npm@5.2.0 이후부터 <code>./node_modules/.bin/babel</code>은 <code>npx babel</code>로 대체될 수 있다.</p>
<h2 id="cli-기초"><a class="header" href="#cli-기초">CLI 기초</a></h2>
<p>모든 Babel모듈들은 <code>@babel</code> 이라는 이름 하에 여러 개의 npm 패키지들로 나누어져 있다. (v7 이후)</p>
<p>이렇게 각각의 모듈로 디자인되어 있는 덕분에에, 각각의 상황에 적절하게 사용할 수 있다.</p>
<h3 id="core-library"><a class="header" href="#core-library">Core Library</a></h3>
<p>Babel의 핵심 기능들은 <code>@babel/core</code> 모듈에 위치해 있다.</p>
<pre><code class="language-sh">npm install --save-dev @babel/core
</code></pre>
<p>이를 직접 JS 상에서 사용할 수 있다.</p>
<pre><code class="language-js">const babel = require('@babel/core');

babel.transformSync('code', optionsObject);
</code></pre>
<h3 id="cli-툴"><a class="header" href="#cli-툴">CLI 툴</a></h3>
<p><code>@babel/cli</code>는 터미널을 통해서 babel을 사용할 수 있게 해주는 툴이다. 아래와 같이 설치한다.</p>
<pre><code class="language-sh">npm install --save-dev @babel/core @babel/cli
</code></pre>
<p>그리고 아래와 같이 사용한다.</p>
<pre><code class="language-sh">./node_modules/.bin/babel src --out-dir lib
</code></pre>
<p>위 명령어는 <code>src</code> 디렉토리 내에 위치한 모든 JS 파일들을 파싱하여 지정된 모든 변환 작업들을 수행한다. 이후 각각의 파일들은 <code>lib</code> 디렉토리에 위치한다.</p>
<p>현재까지는 아무런 변환 작업을 지정해주지 않았기 때문에, 출력된 코드는 입력과 동일하게 될 것이다.</p>
<p>CLI 툴이 어떤 옵션들을 보유하고 있는지에 대해 알고 싶다면 <code>--help</code>를 이용하자.</p>
<h2 id="plugins--presets"><a class="header" href="#plugins--presets">Plugins &amp; Presets</a></h2>
<p>Babel에서의 모든 변환들은 <strong>Plugin</strong>(이하 플러그인)을 통해서 이루어집니다. 이는 하나의 작은 JS 프로그램인데, Babel에게 코드를 어떤 식으로 변환해야 하는지 지시해주는 역할을 한다.</p>
<p>심지어 플러그인은 본인이 직접 작성할 수도 있다.</p>
<p><code>@babel/plugin-transform-arrow-functions</code> 플러그인을 적용하는 간단한 예시를 확인해보자.</p>
<pre><code class="language-sh">npm install --save-dev @babel/plugin-transform-arrow-functions

./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions
</code></pre>
<p>이후, 변환된 코드는 아래와 같아진다.</p>
<pre><code class="language-js">const fn = () =&gt; 1;

// converted to

var fn = function fn() {
  return 1;
};
</code></pre>
<p>기본적으로는 이렇게 하나의 플러그인을 통해 변환을 수행할 수 있지만, 이렇게 플러그인을 하나하나씩 추가하는 것은 다소 귀찮아 보인다.</p>
<p>이런 경우에 사용할 수 있는 것이 <strong>Preset</strong>(이하 프리셋)이며, 이는 플러그인의 묶음이라고 이해할 수 있다.</p>
<p>플러그인과 마찬가지로, 이러한 프리셋 역시 자신이 원하는 플러그인들을 임의로 지정해 만들어낼 수 있다.</p>
<p>Babel에서 자주 사용되는 preset으로는 <code>env</code>가 있다.</p>
<pre><code class="language-sh">npm install --save-dev @babel/preset-env

./node_modules/.bin/babel src --out-dir lib --presets=@babel/env
</code></pre>
<p>별 다른 설정을 하지 않더라도, <code>preset-env</code>는 모던 JS를 지원하기 위한 모든 플러그인들을 추가한다.</p>
<p>물론 프리셋 역시 옵션을 지정할 수 있으며, 이는 CLI 상에서 지정하는 것이 번거롭기에 아래처럼 config 파일을 생성하는 방식을 많이 이용한다.</p>
<h2 id="plugins--presets-1"><a class="header" href="#plugins--presets-1">Plugins &amp; Presets</a></h2>
<p>CLI를 통해 모든 옵션을 지정하기보다는 별도의 설정 파일을 만드는 방식이 종종 사용된다.</p>
<p>본인이 원하는 형태에 따라 작성해야 할 Configuration 파일 형태들이 조금씩 달라질 수 있다.</p>
<p>상세 설정에 관련해서는 여기 <a href="https://babeljs.io/docs/en/configuration">문서</a>를 참고하도록 하자.</p>
<p>v7.8.0 이상에서는 일반적으로 <code>babel.config.json</code>을 생성한다.</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/env&quot;,
      {
        &quot;targets&quot;: {
          &quot;edge&quot;: &quot;17&quot;,
          &quot;firefox&quot;: &quot;60&quot;,
          &quot;chrome&quot;: &quot;67&quot;,
          &quot;safari&quot;: &quot;11.1&quot;
        }
      }
    ]
  ]
}
</code></pre>
<p>이제 <code>env</code> 프리셋은 위에서 우리가 지정한 target 브라우저들에서 지원하지 않는 기능들에 대한 플러그인들만을 사용할 것이다.</p>
<p>이로써 문법 변환에 대해서는 모두 알아봤다.</p>
<p><code>v7.4.0</code> 미만의 버전에 대해서는 <code>@babel/polyfill</code> 모듈이 별도로 사용되지만, 이들 내용이 <code>core-js/stable</code>과 <code>regenerator-runtime/runtime</code> 플러그인에 각각 추가되었으므로 별도로 사용할 필요가 없게 되었다.</p>
<p>혹시나 <code>v.7.4.0</code> 미만의 Babel을 사용해야 하는데, polyfill이 필요한 경우에는 여기 <a href="https://babeljs.io/docs/en/usage#polyfill">문서</a>를 따로 찾아보자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="intersection-observer"><a class="header" href="#intersection-observer">Intersection Observer</a></h1>
<p>Intersection Observer는 브라우저의 뷰포트와 요소의 교차점을 관찰하여, 요소가 현재 뷰포트 상으로 <strong>보이는 상태인지</strong>를 체크하는 기능을 제공한다.</p>
<p>대표적인 사용은 무한 스크롤, 레이지 로딩 등이다.</p>
<p>앞선 예처럼, 종종 <code>scroll</code> 이벤트를 대체하는 용도로 사용되는데 큰 이유는 두가지에서다.</p>
<ol>
<li>
<p><code>scroll</code> 이벤트의 경우, 말그대로 스크롤을 하는 내내 이벤트가 발생하기 때문에, 핸들러가 무수하게 많이 호출된다. 이는 결국 불필요한 호출들을 일으키고, 이 때문에 <strong>Debouncing</strong>, <strong>Throttling</strong>과 같은 호출 제한 테크닉이 요구되어 왔다. Intersection Observer는 특정 요소가 화면에 보이는 시점에만 한번 이벤트가 동작하기 때문에, 이벤트 호출 빈도를 확실히 줄일 수 있다.</p>
</li>
<li>
<p><code>scroll</code> 이벤트에서는 현재 높이 값을 얻기 위해 <code>offsetTop</code> 값을 확인하는데, 이를 얻기 위해선 매번 layout을 새로 그리게 된다. 이를 reflow라고 하며, 해당 과정을 반복함에 따라 렌더링 상의 성능 이슈가 발생할 수 있다.</p>
</li>
</ol>
<h2 id="사용법"><a class="header" href="#사용법">사용법</a></h2>
<p>기본적으로는 MutationObserver와 얼추 비슷한 듯 다르다.</p>
<pre><code class="language-js">const observer = new IntersectionObserver(callback, options);
observer.observe(element);
</code></pre>
<h3 id="callback"><a class="header" href="#callback">callback</a></h3>
<p>감시 타겟이 등록되거나, 가시성(visibility)에 변화가 생기면, 옵저버는 콜백을 실행한다. 이때 해당 콜백은 2개의 인수(<code>entries</code>, <code>observer</code>)를 갖는다.</p>
<h4 id="entries"><a class="header" href="#entries">entries</a></h4>
<p><code>entries</code>는 <code>IntersectionObserverEntry</code> 인스턴스의 배열이며, 각각의 인스턴스는 다음 일기 전용 프로퍼티들을 포함한다.</p>
<ul>
<li><code>boundingClientRect</code> : target의 사각형 정보</li>
<li><code>intersectionRect</code> : target이 보여지는(교차한) 영역의 정보</li>
<li><code>intersectionRatio</code> : 뷰포트 기준 target영역의 백분율(교차한 영역의 백분율) <code>0.0 ~ 1.0</code></li>
<li><code>isIntersecting</code> : target이 보여진 상태(교차한 상태)에 대한 boolean</li>
<li><code>rootBounds</code> : 지정 루트 요소의 사각형 정보</li>
<li><code>target</code> : target</li>
<li><code>time</code> : 변경이 발생한 시간 정보</li>
</ul>
<h4 id="observer"><a class="header" href="#observer">observer</a></h4>
<p><code>observer</code>는 콜백을 실행시킨 해당 옵저버 자체다.</p>
<h3 id="options"><a class="header" href="#options">options</a></h3>
<h4 id="root"><a class="header" href="#root">root</a></h4>
<p>target이 보여지는지를 검사할 때, 기본 설정인 뷰포트 대신 사용할 요소(루트 요소)를 지정한다. target보다 상위 요소여야 하고, 기본값은 <code>null</code>이다.</p>
<h4 id="rootmargin"><a class="header" href="#rootmargin">rootMargin</a></h4>
<p>바깥의 margin을 이용해 Root 범위를 확장하거나 축소할 수 있다. CSS margin값과 똑같은 형태로 값을 받으며, 반드시 <code>px</code> 혹은 <code>%</code>의 단위를 입력해줘야 한다.</p>
<h4 id="threshold"><a class="header" href="#threshold">threshold</a></h4>
<p>옵저버가 콜백을 실행시키려면 target 요소가 어느정도의 가시성(visibility)를 가져야하는지에 대한 설정이다. <code>0 ~ 1</code> 사이의 <code>Number</code> 배열값을 받는다. 기본값으로는 <code>[0]</code>이지만, <code>Number</code> 타입의 단일 값으로도 작성할 수 있다. 배열로 값을 받는 경우, 배열 각각의 가시성에 대해서 매번 콜백을 호출한다.</p>
<h2 id="메서드"><a class="header" href="#메서드">메서드</a></h2>
<h3 id="observeelement"><a class="header" href="#observeelement">.observe(element)</a></h3>
<p>target 요소의 감시를 시작한다.</p>
<h3 id="unobserveelement"><a class="header" href="#unobserveelement">.unobserve(element)</a></h3>
<p>target 요소의 감시를 중지한다. 애초에 감시하던 요소가 아닌 경우 아무 일도 일어나지 않는다.</p>
<p>기본적으로 콜백 실행 시에 두번째 인수로 <code>observer</code>자체를 가져오므로, 이를 이용해, 한번 콜백을 실행한 후에 감시를 중지하도록 할수도 있다.</p>
<pre><code class="language-js">const observer = new IntersectionObserver((entries, observer) =&gt; {
  entries.forEach((entry) =&gt; {
    if (!entry.isIntersecting) {
      return;
    }

    // ...

    observer.unobserve(entry.target);
  });
}, options);
</code></pre>
<h3 id="disconnect"><a class="header" href="#disconnect">.disconnect()</a></h3>
<p>해당 <code>observer</code>가 감시하고 있는 <strong>모든 요소</strong>의 감시를 중지한다.</p>
<h3 id="takerecords"><a class="header" href="#takerecords">.takeRecords()</a></h3>
<p>이는 MutationObserver에서도 있는 메서드와 비슷한데, 도중에 작동이 중지된 경우에 처리되지 않은 IntersectionObserverEntry 객체 배열을 가져온다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mutation-observer"><a class="header" href="#mutation-observer">Mutation Observer</a></h1>
<p><code>MutationObserver</code>는 DOM 요소를 감시하다가 변화를 감지하면 콜백을 호출하는 내장 객체이다.</p>
<h2 id="문법"><a class="header" href="#문법">문법</a></h2>
<p><code>MutationObserver</code>를 사용하는 것은 간단하다.</p>
<p>먼저, 콜백함수를 인자로 넘기는 옵저버를 만든다.</p>
<pre><code class="language-js">let observer = new MutationObserver(callback);
</code></pre>
<p>그리고, 이를 DOM 노드에 덧붙인다.</p>
<pre><code class="language-JS">observer.observe(node, config);
</code></pre>
<p><code>config</code>은 boolean 옵션들을 갖고 있는 객체인데, 이는 <strong>어떤 종류의 변화에 반응할 것인가</strong>를 나타낸다.</p>
<ul>
<li><code>childList</code> - <code>node</code> 본인의 바로 아래 자식 요소에서의 변화</li>
<li><code>subtree</code> - <code>node</code> 본인의 모든 자손</li>
<li><code>attributes</code> - <code>node</code>의 속성</li>
<li><code>attributeFilter</code> - 속성 이름들이 담긴 배열을 받는다. 오직 여기에 포함된 속성들만 감시한다.</li>
<li><code>characterData</code> - <code>node.data</code>(text content)를 감시할지에 대한 boolean</li>
</ul>
<p>그 밖에 다른 옵션들도 있다.</p>
<ul>
<li><code>attributeOldValue</code> - 만약 <code>true</code>라면, 콜백 함수 호출 시 '변경 전'과 '변경 후'의 값을 모두 넘겨준다. <code>false</code>라면 변경 후의 값만 넘긴다. (<code>attribute</code> 옵션이 필요하다.)</li>
<li><code>characterDataOldValue</code> - 만약 <code>true</code>라면, <code>node.data</code>의 '변경 전'과 '변경 후'의 값을 모두 넘겨준다. <code>false</code>라면 변경 후의 값만 넘겨준다. (<code>characterData</code> 옵션이 필요하다.)</li>
</ul>
<p>이후 어떤 변화라도 감지된다면, <code>callback</code>이 실행된다. 변경된 내용은 <code>MutationRecord</code> 객체의 배열로 첫번째 인자로 넘겨진다. 그리고 옵저버 자체는 두번째 인자가 된다.</p>
<p><code>MutaitonRecord</code> 객체는 다음과 같은 프로퍼티들을 갖는다.</p>
<ul>
<li><code>type</code> - 뮤테이션 타입이다. 다음 중 하나다.
<ul>
<li><code>attributes</code>: 수정된 속성</li>
<li><code>characterData</code>: 수정된 <code>node.data</code>, 텍스트 노드로 쓰인다.</li>
<li><code>childList</code>: 추가/삭제된 자식 요소들</li>
</ul>
</li>
<li><code>target</code> - 변화가 감지된 곳의 요소</li>
<li><code>addedNodes/removedNodes</code> - 추가/삭제된 노드들</li>
<li><code>previousSibling/nextSibling</code> - 추가/삭제된 노드들의 이전/다음 형제 노드</li>
<li><code>attributeName/attributeNamespace</code> - 변경된 속성의 이름/네임스페이스(XML에서 사용)</li>
<li><code>oldValue</code> - 속성이나 텍스트가 변경되기 전의 값. <code>attributeOldValue</code>/<code>characterDataOldValue</code>이 <code>true</code>여야한다.</li>
</ul>
<p>다음은 간단한 예시다.</p>
<pre><code class="language-html">&lt;div contenteditable id=&quot;elem&quot;&gt;Click and &lt;b&gt;edit&lt;/b&gt;, please&lt;/div&gt;

&lt;script&gt;
  let observer = new MutationObserver((mutationRecords) =&gt; {
    console.log(mutationRecords); // console.log(the changes)
  });

  // observe everything except attributes
  observer.observe(elem, {
    childList: true, // observe direct children
    subtree: true, // and lower descendants too
    characterDataOldValue: true, // pass old data to callback
  });
&lt;/script&gt;
</code></pre>
<p>그리고 위에서 변화를 감지할 때마다 콜백함수에서 넘겨받는 <code>mutationRecords</code>는 아래와 같다.</p>
<pre><code class="language-js">[{
  type: &quot;characterData&quot;,
  oldValue: &quot;edit&quot;,
  target: &lt;text node&gt;,
  // other properties empty
}];
</code></pre>
<p>만약, <code>&lt;b&gt;edit&lt;/b&gt;</code>를 한번에 지우는 것과 같이 여러 작업이 동시에 일어나면, <code>mutationRecords</code>에도 여러 객체가 담긴다.</p>
<pre><code>[{
  type: &quot;childList&quot;,
  target: &lt;div#elem&gt;,
  removedNodes: [&lt;b&gt;],
  nextSibling: &lt;text node&gt;,
  previousSibling: &lt;text node&gt;
  // other properties empty
}, {
  type: &quot;characterData&quot;
  target: &lt;text node&gt;
  // ...mutation details depend on how the browser handles such removal
  // it may coalesce two adjacent text nodes &quot;edit &quot; and &quot;, please&quot; into one node
  // or it may leave them separate text nodes
}];
</code></pre>
<p>즉, <code>MutationObserver</code>는 DOM subtree에 발생하는 어떤 변화든지 대응할 수 있다.</p>
<h2 id="활용-사례"><a class="header" href="#활용-사례">활용 사례</a></h2>
<p>그래서, 언제 이를 활용할 수 있을까?</p>
<p>만약, 서드파티 라이브러리를 사용하는데, 원치않는 광고가 포함되어 있다고 해보자. 이를테면 <code>&lt;div class='ads'&gt;...&lt;/ads&gt;</code>와 같이.</p>
<p><code>MutationObserver</code>를 사용하면, DOM에 생겨난 원치 않는 요소를 감지하여 제거할 수 있다.</p>
<p>그 밖에도, 여러가지를 감지하여 동적인 변화를 줄 수 있다. 이를 테면 어떤 요소의 사이즈를 변경한다던가.</p>
<h2 id="아키텍쳐에-활용"><a class="header" href="#아키텍쳐에-활용">아키텍쳐에 활용</a></h2>
<p><code>MutationObserver</code>가 구조적인 부분에서 유용하게 쓰이는 상황이 있다.</p>
<p>웹 프로그래밍과 관련한 웹사이트를 만들고자 한다고 하자. 각각의 문서들이 소스 코드 조각들을 담고 있을 것이다.</p>
<p>이때, 이 코드 조각들이 다음과 같은 모양을 띈다고 하자.</p>
<pre><code class="language-js">...
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code&gt;
  // here's the code
  let hello = &quot;world&quot;;
&lt;/code&gt;&lt;/pre&gt;
...
</code></pre>
<p>이를 더 가독성이 좋게 하기 위해서, 꾸미고 싶다고 하자. 이 경우 우리는 <strong>Prism.js</strong>와 같은 문장 하이라이팅 라이브러리를 사용할 수 있다. 이는 <code>Prism.highlightElem(pre)</code>와 같은 식으로 특정 요소에 대해 하이라이트를 적용해준다.</p>
<p>그래서, 이제 이 메서드를 정확히 <strong>언제</strong> 사용해야 할까? <code>DOMContentLoaded</code> 이벤트 발생 시에 사용하는 것을 고려해볼 수 있겠다. 이후 각각의 코드 조각들에 대해 다음과 같이 하이라이팅을 적용시킬 수 있다.</p>
<pre><code class="language-js">document
  .querySelectorAll('pre[class*=&quot;language&quot;]')
  .forEach(Prism.highlightElem);
</code></pre>
<p>지금까지는 수월해보인다. 근데, 만약에 서버를 통해 또 다른 코드 조각들을 가져와서 화면에 띄워주어야 한다면, 이는 어떻게 해결할 수 있을까?</p>
<pre><code class="language-js">let article =
  /* fetch new content from server */
  (articleElem.innerHTML = article);

let snippets = articleElem.querySelectorAll('pre[class*=&quot;language-&quot;]');
snippets.forEach(Prism.highlightElem);
</code></pre>
<p>위의 방법처럼, 해당 코드조각을 가져올 때 마다 다시 각각의 코드조각들에 대해 하이라이팅을 적용시켜줄 수 있다. 근데 이는 다소 비효율적인데, 코드 조각들이 있을만한 모든 요소들에 대해 위와 같은 코드를 추가해야 하기 때문이다.</p>
<p>결국, 이 역시 <code>MutationObserver</code>를 통해 페이지 내에 삽입되는 코드 조각들을 감지하여 처리할 수 있다.</p>
<pre><code class="language-js">let observer = new MutationObserver((mutations) =&gt; {
  for (let mutation of mutations) {
    // examine new nodes, is there anything to highlight?

    for (let node of mutation.addedNodes) {
      // we track only elements, skip other nodes (e.g. text nodes)
      if (!(node instanceof HTMLElement)) continue;

      // check the inserted element for being a code snippet
      if (node.matches('pre[class*=&quot;language-&quot;]')) {
        Prism.highlightElement(node);
      }

      // or maybe there's a code snippet somewhere in its subtree?
      for (let elem of node.querySelectorAll('pre[class*=&quot;language-&quot;]')) {
        Prism.highlightElement(elem);
      }
    }
  }
});

let demoElem = document.getElementById('highlight-demo');

observer.observe(demoElem, { childList: true, subtree: true });
</code></pre>
<h2 id="추가적인-메서드"><a class="header" href="#추가적인-메서드">추가적인 메서드</a></h2>
<p>노드를 감시하는 것을 멈추는 메서드가 있다.</p>
<ul>
<li><code>observer.disconnect()</code> - 감시를 멈춘다.</li>
</ul>
<p>감시가 멈출 때, 해당 옵저버가 특정 작업을 처리하던 중이었을 수도 있다. 이런 경우에는 아래 메서드를 통해 확인할 수 있다.</p>
<ul>
<li><code>observer.takeRecords()</code> - 처리되지 않은 <code>MutationRecord</code> 배열들을 가져온다. (변경은 감지했으나, 콜백이 호출되지 않은 경우를 말한다.)</li>
</ul>
<p>이 메서드들은 함께 쓰일 수 있다.</p>
<pre><code class="language-js">// get a list of unprocessed mutations
// should be called before disconnecting,
// if you care about possibly unhandled recent mutations
let mutationRecords = observer.takeRecords();

// stop tracking changes
observer.disconnect();
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="template-element"><a class="header" href="#template-element">Template Element</a></h1>
<p>내장 <code>&lt;template&gt;</code> 요소는 HTML 마크업 템플릿에 대한 저장요소로 취급된다. 브라우저는 이를 무시하고, 오로지 문법 상 온전한지만을 체크하는데, 우리가 우너한다면, 이를 이용해서 다른 요소들을 만들어낼 수도 있다.</p>
<p>사실, 우리는 이미 이론 상 보이지 않는 요소들을 어디서든 만들어 낼 수 있다. 대체 이 <code>&lt;template&gt;</code>가 특별한 점은 무엇일까?</p>
<p><strong>먼저</strong>, 이들의 내용(content)는 문법상 올바른 HTML이면 무엇이든 가능하다. 다시 말해, 적절히 태그만 열고닫았으면 문제가 없다.</p>
<p>무슨 소리냐고? 단순히 우리가 <code>&lt;tr&gt;</code>과 <code>&lt;td&gt;</code>만을 이용해서 테이블을 만들면, 브라우저는 부적절한 DOM 구조를 감지하고, 알아서 <code>&lt;table&gt;</code>을 추가해 DOM 구조를 수정해준다. 반면 <code>&lt;template&gt;</code>의 경우는 우리가 작성한 내용 그대로를 유지시켜준다.</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;tr&gt;
    &lt;td&gt;Contents&lt;/td&gt;
  &lt;/tr&gt;
&lt;/template&gt;
</code></pre>
<p>마찬가지로, <code>&lt;template&gt;</code>에는 스타일과 스크립트 태그가 포함될 수 있다.</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;style&gt;
    p { font-weight: bold; }
  &lt;/style&gt;
  &lt;script&gt;
    alert(&quot;Hello&quot;);
  &lt;/script&gt;
&lt;/template&gt;
</code></pre>
<p>브라우저는 <code>&lt;template&gt;</code>의 내용들을 <strong>문서와 상관없는 것</strong>으로 간주한다. 때문에 스타일은 적용되지 않고, 스크립트 역시 마찬가지다.</p>
<h2 id="템플릿-삽입하기"><a class="header" href="#템플릿-삽입하기">템플릿 삽입하기</a></h2>
<p>템플릿의 내용은 <code>content</code> 프로퍼티를 통해 이용할 수 있는데, 이는 <strong>DocumentFragment</strong>라는 특수한 DOM 노드 타입이다.</p>
<p>이는 다른 DOM 노드들과 거의 동일하게 다룰 수 있으나, 유일한 차이점은, 어딘가에 삽입되는 경우, 노드 본인이 아닌 자식들이 대신 삽입된다는 점이다.</p>
<pre><code class="language-HTML">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;script&gt;
    alert(&quot;Hello&quot;);
  &lt;/script&gt;
  &lt;div class=&quot;message&quot;&gt;Hello, world!&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  let elem = document.createElement('div');

  // 재사용을 위해 템플릿 컨텐츠를 복사하여 사용한다.
  elem.append(tmpl.content.cloneNode(true));

  document.body.append(elem);
  // append에 의해 body에 요소가 추가되고 나서야 위의 script가 동작한다.
&lt;/script&gt;
</code></pre>
<p>Shadow DOM과 함께 사용해보자.</p>
<pre><code class="language-HTML">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt; p { font-weight: bold; } &lt;/style&gt;
  &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;
&lt;/template&gt;

&lt;div id=&quot;elem&quot;&gt;Click me&lt;/div&gt;

&lt;script&gt;
  elem.onclick = function() {
    elem.attachShadow({mode: 'open'});

    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)

    elem.shadowRoot.getElementById('message').innerHTML = &quot;Hello from the shadows!&quot;;
  };
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom"><a class="header" href="#shadow-dom">Shadow DOM</a></h1>
<p>섀도우 DOM은 캡슐화를 위해 제공된다. 이는 하나의 컴포넌트가 스스로의 <strong>shadow DOM tree</strong>를 가질 수 있게 하며, 메인 문서에서 접근 할 수 없으며, 로컬 스타일 규칙을 보유할 수 있다.</p>
<h2 id="빌트인-섀도우-dom"><a class="header" href="#빌트인-섀도우-dom">빌트인 섀도우 DOM</a></h2>
<p><code>&lt;input type=&quot;range&quot;&gt;</code>과 같은 것들은 브라우저마다 다른 자체적인 스타일을 보유한다. 이는 섀도우 DOM을 통해 브라우저 자체적으로 스타일링을 하고 있기 때문인데, 기본적으로 이는 이용자들로부터 숨겨져있다. 이를 보고자 한다면 개발자 도구의 옵션을 건드려야 한다.</p>
<h2 id="섀도우-트리-shadow-tree"><a class="header" href="#섀도우-트리-shadow-tree">섀도우 트리 (Shadow Tree)</a></h2>
<p>하나의 DOM 요소에는 두가지 유형의 DOM 서브트리가 존재한다.</p>
<ol>
<li>Light Tree - 일반적인 DOM 서브트리. 우리가 기존에 알고 쓰던 모든 서브트리는 이에 해당한다.</li>
<li>Shadow Tree - 숨겨진 DOM 서브트리. HTML 상에 보여지지 않는다.</li>
</ol>
<p>만약, 두 가지 유형의 서브트리를 모두 갖는 요소가 있다면, 브라우저는 오직 섀도우 트리만을 렌더링한다. 물론 각각을 적절히 조합하도록 설정할 수도 있는데, 이에 대해선 추후에 설명한다.</p>
<p>섀도우 트리는 커스텀 요소 내에서 <strong>컴포넌트 내부 요소들을 숨기고</strong>, 컴포넌트 자체적인 <strong>로컬 스타일링</strong>을 위해 사용된다.</p>
<p>예를 들어, 아래와 같이 <code>&lt;show-hello&gt;</code>라는 커스텀 요소를 만들어낼 수 있다.</p>
<pre><code class="language-html">&lt;script&gt;
  customElements.define(
    'show-hello',
    class extends HTMLElement {
      connectedCallback() {
        const shadow = this.attachShadow({ mode: 'open' });
        shadow.innerHTML = `&lt;p&gt;
      Hello, {this.getAttribute('name')}
    &lt;/p&gt;`;
      }
    },
  );
&lt;/script&gt;

&lt;show-hello name=&quot;John&quot;&gt;&lt;/show-hello&gt;
</code></pre>
<p>커스텀 요소를 만들기 위해서는 먼저 <code>elem.attachShadow({mode: ...})</code>를 호출해야 한다. 여기엔 두 가지 제한이 있다.</p>
<ol>
<li>각 요소 당 하나의 섀도우 루트(shadow-root)만 가질 수 있다.</li>
<li><code>elem</code>은 반드시 커스텀 요소이거나, 다음 중 하나여야 한다. (“article”, “aside”, “blockquote”, “body”, “div”, “footer”, “h1…h6”, “header”, “main” “nav”, “p”, “section”, “span”)</li>
</ol>
<p><code>mode</code>옵션은 캡슐화 레벨을 설정한다. 다음의 둘 중 하나여야 한다.</p>
<ul>
<li><code>open</code> : 어디서든 해당 요소의 섀도우 루트에 <code>elem.shadowRoot</code>로 접근할 수 있다.</li>
<li><code>closed</code> : <code>elem.shadowRoot</code>가 항상 <code>null</code>이 된다.</li>
</ul>
<p>대부분의 브라우저 자체적인 섀도우 트리들은 <code>closed</code> 상태이며, 때문에 이들의 섀도우 트리에 접근할 방법이 없다.</p>
<p><code>attachShadow</code>를 통해 반환되는 **섀도우 루트(shadow root)**는 요소와 같다. <code>innerHTML</code>이나 <code>append</code> 같은 DOM 프로퍼티 및 메서드를 사용할 수 있다.</p>
<ul>
<li>섀도우 루트가 있는 요소는 **섀도우 트리 호스트(shadow tree host)**라고 불리며, 이는 섀도우 루트의 <code>host</code> 프로퍼티는 통해 접근할 수 있다.</li>
</ul>
<pre><code class="language-js">// assuming {mode: &quot;open&quot;}, otherwise elem.shadowRoot is null
alert(elem.shadowRoot.host === elem); // true
</code></pre>
<h2 id="캡슐화-encapsulation"><a class="header" href="#캡슐화-encapsulation">캡슐화 (Encapsulation)</a></h2>
<p>섀도우 DOM은 메인 문서(document)으로부터 완전히 구분된다.</p>
<ol>
<li>
<p>light DOM에서의 <code>querySelector</code>에 의해 탐색되지 않는다. 때문에 light DOM에 동일한 id가 존재하더라도 섀도우 트리 내에서만 고유하다면 상관없다.</p>
</li>
<li>
<p>섀도우 DOM은 스스로의 스타일시트를 보유한다. 그 외의 스타일 규칙은 이에 적용되지 않는다.</p>
</li>
</ol>
<p>이에 따라, 아래 예시를 보자.</p>
<pre><code class="language-html">&lt;style&gt;
  /* document style won't apply to the shadow tree inside #elem (1) */
  p {
    color: red;
  }
&lt;/style&gt;

&lt;div id=&quot;elem&quot;&gt;&lt;/div&gt;

&lt;script&gt;
  elem.attachShadow({ mode: 'open' });
  // shadow tree has its own style (2)
  elem.shadowRoot.innerHTML = `
    &lt;style&gt; p { font-weight: bold; } &lt;/style&gt;
    &lt;p&gt;Hello, John!&lt;/p&gt;
  `;

  // &lt;p&gt; is only visible from queries inside the shadow tree (3)
  alert(document.querySelectorAll('p').length); // 0
  alert(elem.shadowRoot.querySelectorAll('p').length); // 1
&lt;/script&gt;
</code></pre>
<ol>
<li>문서 자체에서 적용한 <code>style</code>은 섀도우 트리에 아무 영향도 미치지 않는다.</li>
<li>허나, <code>elem.shadowRoot.innerHTML</code>에서 직접 지정한 스타일링은 적용된다.</li>
<li>섀도우 트리에서 요소를 가져오고자 하는 경우, 반드시 섀도우 트리 내에서 <code>querySelector</code>와 같은 메서드를 사용해야 한다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom---slots-composition"><a class="header" href="#shadow-dom---slots-composition">Shadow DOM - slots, composition</a></h1>
<p>탭, 갤러리 등 많은 종류의 컴포넌트들은 렌더링할 <strong>내용</strong>들이 필요하다.</p>
<p>내장 <code>&lt;select&gt;</code> 태그가 <code>&lt;option&gt;</code> 태그들을 요구하는 것처럼, 우리가 임의로 만든 태그 역시 임의의 태그를 요구할 수 있다.</p>
<pre><code class="language-html">&lt;custom-menu&gt;
  &lt;title&gt;Candy menu&lt;/title&gt;
  &lt;item&gt;Lollipop&lt;/item&gt;
  &lt;item&gt;Fruit Toast&lt;/item&gt;
  &lt;item&gt;Cup Cake&lt;/item&gt;
&lt;/custom-menu&gt;
</code></pre>
<p>우리는 이것을 동적으로 요소들의 내용을 분석하고, DOM 노드들을 조작해서 구현할 수 있다. 하지만, shadow DOM의 경우, 문서에서의 스타일링이 적용되지 않으며, 때문에 어느 정도의 추가 코드을 요구한다.</p>
<p>다행히도 Shadow DOM은 여기서 <code>&lt;slot&gt;</code> 요소를 제공한다. 이는 light DOM으로부터 가져온 내용들로 Shadow DOM의 내용을 채울 수 있게 해준다.</p>
<h2 id="named-slots"><a class="header" href="#named-slots">Named slots</a></h2>
<p>간단한 예시로부터 살펴보자. 여기 <code>&lt;user-card&gt;</code> shadow DOM은 두개의 슬롯(slot)을 사용하며, 이는 light DOM으로부터 아래와 같이 채워질 수 있다.</p>
<pre><code class="language-HTML">&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      &lt;div&gt;Name:
        &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div&gt;Birthday:
        &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
});
&lt;/script&gt;

&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<p>섀도우 DOM에서, <code>&lt;slot name='X'&gt;</code>은 <strong>삽입 지점</strong>을 의미하며, 여기에는 추후 <code>slot='X'</code>를 light DOM에서 지정한 요소가 위치하게 된다.</p>
<p>이후 브라우저는 <strong>합성_composition</strong>을 수행하는데, 이는 light DOM에서 요소를 가져와 이에 대응하는 shadow DOM의 slot에 렌더링시키는 과정이다.</p>
<p>스크립트가 동작한 후, 아직 <strong>합성_composition</strong>이 동작하지 않은 상태의 DOM 구조는 아래와 같다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  #shadow-root
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<p>현 시점에서는, shadow DOM까지는 생성되었으나(이에 따라 <code>#shadow-root</code>가 보인다), 현재 요소는 light와 shadow DOM 모두를 갖고 있다.</p>
<p>렌더링을 하기 위해, shadow DOM에서의 각 <code>&lt;slot name=&quot;...&quot;&gt;</code>에서 브라우저는 light DOM에서 동일한 이름을 가진 <code>slot=&quot;...&quot;</code>을 찾는다. 이후 이 요소들은 각 slot 안에 렌더링된다.</p>
<p>그 결과로 만들어진 아래의 DOM 구조를 <strong>flatten DOM</strong> 이라고 한다.</p>
<pre><code class="language-html">&lt;user-card&gt;
  #shadow-root
  &lt;div&gt;
    Name:
    &lt;slot name=&quot;username&quot;&gt;
      &lt;!-- slotted element is inserted into the slot --&gt;
      &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
    &lt;/slot&gt;
  &lt;/div&gt;
  &lt;div&gt;
    Birthday:
    &lt;slot name=&quot;birthday&quot;&gt;
      &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
    &lt;/slot&gt;
  &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<p>다만, 유의해야 할 점이 있다. <strong>flatten DOM은 오직 렌더링과 이벤트 핸들링의 목적으로 존재한다</strong>. 이는 어떤 식으로 동작하는지를 보여주기 위한 것이며, 실제 문서의 노드들은 어디로도 이동하지 않는다.</p>
<p>이는 단순히 <code>querySelectorAll</code>를 통해 확인해볼 수 있다.</p>
<pre><code class="language-js">// light DOM &lt;span&gt; nodes are still at the same place, under `&lt;user-card&gt;`
alert(document.querySelectorAll('user-card span').length); // 2
</code></pre>
<p>결국, flatten DOM은 shadow DOM에서 slot에 대한 삽입을 통해 만들어진다. 브라우저는 이를 렌더링, 스타일 상속, 이벤트 전파의 목적으로 활용한다. 하지만, JS는 여전히 flatten이 이루어지기 전의 문서만을 볼 수 있다.</p>
<h3 id="유의"><a class="header" href="#유의"><strong>유의!</strong></a></h3>
<pre><code class="language-html">&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;div&gt;
    &lt;!-- invalid slot, must be direct child of user-card --&gt;
    &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
  &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<blockquote>
<p><code>slot-'...'</code> 속성을 가진 태그는 최상위의 자식 노드여야 한다. 보다 깊은 곳에 위치한 노드들은 무시된다.</p>
</blockquote>
<p>한편, 똑같은 slot에 지정된 여러개의 요소들이 light DOM에 존재한다면, <strong>이들은 갱신되는 것이 아니라, 순서대로 slot에 추가된다.</strong></p>
<p>예를 들어, 앞선 예시에 대해 아래와 같이 light DOM을 구성했다고 가정하자.</p>
<pre><code class="language-html">&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John&lt;/span&gt;
  &lt;span slot=&quot;username&quot;&gt;Smith&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<p>그렇다면, 그 결과 생겨난 flatten DOM의 결과는 아래와 같다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  #shadow-root
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;
        &lt;span slot=&quot;username&quot;&gt;John&lt;/span&gt;
        &lt;span slot=&quot;username&quot;&gt;Smith&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<h2 id="slot-fallback-content"><a class="header" href="#slot-fallback-content">Slot fallback content</a></h2>
<p>만약, <code>&lt;slot&gt;</code>태그에 어떤 값이 존재한다면, 이는 <strong>fallback</strong>(대비책)이 된다. 다시말해, <strong>default</strong>값이 된다. 브라우저는 light DOM에서 상응하는 <code>slot='...'</code> 요소를 찾지 못하는 경우 해당 기본값을 렌더링한다.</p>
<pre><code class="language-html">&lt;div&gt;
  Name:
  &lt;slot name=&quot;username&quot;&gt;Anonymous&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<h2 id="default-slot-first-unnamed"><a class="header" href="#default-slot-first-unnamed">Default slot: first unnamed</a></h2>
<p>shadow DOM에서 <code>name</code>이 존재하지 않는 첫번째 <code>&lt;slot&gt;</code>은 <strong>default slot</strong>이 된다. 여기에는 light DOM에서부터 slot 처리가 되지 않은 모든 요소들이 추가된다.</p>
<p>예를 들어, 아래처럼 <code>&lt;user-card&gt;</code>에 default slot을 추가해보면, 별도로 slot을 지정해주지 않은 모든 요소들을 자동으로 default slot에 추가시킨다.</p>
<pre><code class="language-html">&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;Other information&lt;/legend&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/fieldset&gt;
    `;
      }
    },
  );
&lt;/script&gt;

&lt;user-card&gt;
  &lt;div&gt;I like to swim.&lt;/div&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
  &lt;div&gt;...And play volleyball too!&lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<p>이 역시 기존의 slot과 마찬가지로 갱신을 하는 것이 아니라, 추가하는 방식으로 동작한다. 따라서 그 결과인 flatten DOM은 아래와 같아진다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  #shadow-root
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;
        &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;
        &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;About me&lt;/legend&gt;
      &lt;slot&gt;
        &lt;div&gt;Hello&lt;/div&gt;
        &lt;div&gt;I am John!&lt;/div&gt;
      &lt;/slot&gt;
    &lt;/fieldset&gt;
&lt;/user-card&gt;
</code></pre>
<h2 id="updating-slots"><a class="header" href="#updating-slots">Updating slots</a></h2>
<p>만약 외부의 코드를 통해 slot에 들어간 item들을 동적으로 추가/삭제하고 싶다면 어떻게 하면 좋을까?</p>
<p>기본적으로, <strong>브라우저가 slot들을 모니터링하며, 이에 따라 slot 처리된 요소들을 알아서 추가/삭제하여 렌더링해준다.</strong></p>
<p>또한, light DOM 노드들은 복제된 것이 아니라, 단순히 slot 안에 렌더링된 것이다. 때문에 변화가 즉시 가시적으로 반영된다.</p>
<p>따라서, 우리는 <strong>렌더링 업데이트에 대해 신경 쓸 필요 없다.</strong> 단, 만약 slot이 업데이트되는 <strong>특정 시점에 대해 이벤트를 적용하고 싶다면 <code>slotchange</code> 이벤트를 활용하면 된다.</strong></p>
<p><code>slotchange</code> 이벤트는, 최초에 1) 초기화 할 때 발생하고, 이후 2) slot에 변경이 생길 때마다 발생한다.</p>
<p>보다 상세한 처리가 요구되는 경우, <strong>MutationObserver</strong>를 사용할 수도 있다.</p>
<h2 id="slot-api"><a class="header" href="#slot-api">Slot API</a></h2>
<p>마지막으로, slot과 관련된 JS 메서드들을 살펴보자.</p>
<p>앞서 말했듯, JS는 오직 실제 DOM만을 바라본다. flatten DOM에 대해선 신경쓰지 않는다.</p>
<p>하지만, **만약 shadow tree가 `<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">:</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span class="mord">‘</span><span class="mord hangul_fallback">옵션을갖고있다면</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">요소로부터</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">을유추할수있고</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">반대의경우도가능하다</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">‘</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">Sl</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord hangul_fallback">노드가지정된</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">‘</span><span class="mord hangul_fallback">요소를반환한다</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">es</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span><span class="mclose">)</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">에지정된</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mord hangul_fallback">노드를가져온다</span><span class="mord">.</span><span class="mord hangul_fallback">기본적으로</span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">‘</span><span class="mord hangul_fallback">옵션은</span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mord">‘</span><span class="mord hangul_fallback">인데</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">만약</span><span class="mord">‘</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord">‘</span><span class="mord hangul_fallback">라면</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mord hangul_fallback">을통해처리가끝난형태를반환한다</span><span class="mord">.</span><span class="mord hangul_fallback">지정된노드가없다면</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord hangul_fallback">을반환한다</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span><span class="mclose">)</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">에지정된</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mord hangul_fallback">요소들을반환한다</span><span class="mord">.</span><span class="mord hangul_fallback">위와동일하지만</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord hangul_fallback">요소만</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∗</span><span class="mord hangul_fallback">반환한다는차이가있다</span><span class="mord">.</span><span class="mord hangul_fallback">위와같은메서드들은단순히브라우저를통해출력하는것외에</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">컨텐츠들을추적해야할필요가있는경우에유용하다</span><span class="mord">.</span><span class="mord hangul_fallback">예를들어</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">아래에서</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">‘</span><span class="mord hangul_fallback">는</span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">han</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord">‘</span><span class="mord hangul_fallback">이벤트핸들러를통해</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">에무엇이보여지고있는지를추적하고있다</span><span class="mord">.‘‘‘</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">an</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">tl</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">an</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">i</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">i</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">sse</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.08125em;">sH</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">nn</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">:</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">wR</span><span class="mord mathnormal">oo</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">inn</span><span class="mord mathnormal" style="margin-right:0.08125em;">erH</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">tl</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">‘</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">//</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">re</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ce</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">wR</span><span class="mord mathnormal">oo</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal" style="margin-right:0.01968em;">tEl</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.07153em;">tC</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">han</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">((</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">tC</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">t</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">:</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">+</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">//</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">1</span><span class="mord mathnormal">seco</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">im</span><span class="mord mathnormal">eo</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">((</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord">.</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.02778em;">ser</span><span class="mord mathnormal">t</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">ja</span><span class="mord mathnormal">ce</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ore</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct"><span class="mpunct">,</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.07153em;">pC</span><span class="mord mathnormal" style="margin-right:0.03148em;">ak</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">&gt;</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">;</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1000</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">i</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">‘‘‘</span></span></span></span></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom-styling"><a class="header" href="#shadow-dom-styling">Shadow DOM styling</a></h1>
<p>shadow DOM은 <code>&lt;style&gt;</code> 태그와 <code>&lt;link rel='stylesheet' href='...'&gt;</code> 태그를 모두 포함할 수 있다. 그 중 <code>&lt;link&gt;</code> 태그의 경우, <strong>HTTP 캐싱</strong>이 되며, 여러번 다운로드 되지 않는다.</p>
<p>일반적인 스타일 규칙으로는, shadow DOM은 오직 shadow tree 내의 로컬 스타일 규칙에만 영향을 받는다. 하지만 몇가지 예외가 존재한다.</p>
<h2 id="host"><a class="header" href="#host">:host</a></h2>
<p><code>:host</code> 선택자는 shadow 호스트(shadow tree를 보유한 요소)를 선택하는 것을 허용한다.</p>
<p>예를 들어, <code>&lt;custom-dialog&gt;</code>요소가 가운데에 위치하길 원한다면, 아래와 같은 방법으로 스타일을 추가할 수 있다.</p>
<pre><code class="language-html">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt;
    /* the style will be applied from inside to the custom-dialog element */
    :host {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  &lt;/style&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/template&gt;

&lt;script&gt;
  customElements.define(
    'custom-dialog',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' }).append(
          tmpl.content.cloneNode(true),
        );
      }
    },
  );
&lt;/script&gt;

&lt;custom-dialog&gt; Hello! &lt;/custom-dialog&gt;
</code></pre>
<h2 id="cascading"><a class="header" href="#cascading">Cascading</a></h2>
<p>shadow 호스트(<code>&lt;custom-dialog&gt;</code> 태그 그 자체)는 light DOM에 위치한다. 따라서, 이는 문서 자체의 CSS 규칙에 영향을 받는다.</p>
<p>만약, shadow tree에 로컬로 <code>:host</code> 스타일이 존재함과 동시에, 문서 자체에도 스타일이 존재한다면, 문서의 스타일링이 더 우선시된다.</p>
<p>따라서, 위의 코드에서 아래와 같이 문서에 스타일링을 추가하는 경우</p>
<pre><code class="language-html">&lt;style&gt;
  custom-dialog {
    padding: 0;
  }
&lt;/style&gt;
</code></pre>
<p><code>&lt;custom-dialog&gt;</code>는 더 이상 padding을 갖지 않는다.</p>
<p>이는 제법 편리한데, 이를 통해 <code>:host</code>에는 <strong>기본(default) 컴포넌트 스타일</strong>을 지정하고, 문서를 통해서 스타일링을 쉽게 덮어씌울 수 있기 때문이다.</p>
<p>예외는 로컬 스타일링에 <code>!important</code>를 적용하는 경우다.</p>
<h2 id="hostselector"><a class="header" href="#hostselector">:host(selector)</a></h2>
<p><code>:host</code>와 동일하되, 주어진 선택자(<code>selector</code>)에 해당하는 경우에만 적용된다.</p>
<p>예를 들어, 앞선 <code>&lt;custom-dialog&gt;</code>에서, <code>center</code> 속성(attribute)를 보유한 경우에만 가운데 정렬을 하고싶다면, 아래와 같이 활용할 수 있다.</p>
<pre><code class="language-html">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt;
    :host([centered]) {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-color: blue;
    }

    :host {
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  &lt;/style&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/template&gt;

&lt;script&gt;
  customElements.define(
    'custom-dialog',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' }).append(
          tmpl.content.cloneNode(true),
        );
      }
    },
  );
&lt;/script&gt;

&lt;custom-dialog centered&gt; Centered! &lt;/custom-dialog&gt;

&lt;custom-dialog&gt; Not centered. &lt;/custom-dialog&gt;
</code></pre>
<h2 id="host-contextselector"><a class="header" href="#host-contextselector">:host-context(selector)</a></h2>
<p><code>:host</code>와 동일하되, shadow 호스트 자신, 혹은 그 상위에 있는 요소 중 해당 <code>selector</code>에 해당하는 경우에만 적용된다.</p>
<p>예를 들어, <code>:host-context(.dark-theme)</code>를 사용한 아래 예시에서, <code>&lt;custom-dialog&gt;</code>에 <code>dark-theme</code> 클래스가 존재하는 경우에만 스타일링이 적용된다.</p>
<pre><code class="language-html">&lt;body class=&quot;dark-theme&quot;&gt;
  &lt;!--
    :host-context(.dark-theme) applies to custom-dialogs inside .dark-theme
  --&gt;
  &lt;custom-dialog&gt;...&lt;/custom-dialog&gt;
&lt;/body&gt;
</code></pre>
<p>요약하자면, <code>:host</code> 종류들은 컴포넌트의 메인 요소들을 스타일링 하기 위해 활용할 수 있는 선택자이다. 이를 활용해 적용한 스타일들은 문서 자체에서의 스타일링에 덮어씌여질 수 있다.</p>
<h2 id="slotted-content-스타일링"><a class="header" href="#slotted-content-스타일링">slotted content 스타일링</a></h2>
<p>이제, <code>slot</code>을 사용하는 경우를 보자.</p>
<p>slot 처리 된 요소 자체는 light DOM에서 온다. 따라서, 그들 요소는 문서의 스타일링을 따르며, shadow tree 측에서의 로컬 스타일링은 여기에 영향을 미치지 않는다.</p>
<p>예를 들어보자. 아래에 slot으로 삽입된 <code>&lt;span&gt;</code>은 문서 스타일링에 따라 <code>bold</code> 폰트 굵기를 갖는다. 하지만 shadow Root에서의 스타일링에 영향 받지 않기 때문에 붉은 바탕(<code>background: red</code>)이 아니다.</p>
<pre><code class="language-html">&lt;style&gt;
  span {
    font-weight: bold;
  }
&lt;/style&gt;

&lt;user-card&gt;
  &lt;div slot=&quot;username&quot;&gt;&lt;span&gt;John Smith&lt;/span&gt;&lt;/div&gt;
&lt;/user-card&gt;

&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
      &lt;style&gt;
      span { background: red; }
      &lt;/style&gt;
      Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    `;
      }
    },
  );
&lt;/script&gt;
</code></pre>
<p>만약, slot 처리된 요소들에 대해 컴포넌트 안에서 스타일링하고 싶다면, 두가지 선택지가 있다.</p>
<p><strong>첫번째는,</strong> 컴포넌트 내에서 CSS 상속에 기반해 <code>&lt;slot&gt;</code> 그 자체를 스타일링하는 것이다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  &lt;div slot=&quot;username&quot;&gt;&lt;span&gt;John Smith&lt;/span&gt;&lt;/div&gt;
&lt;/user-card&gt;

&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
      slot[name=&quot;username&quot;] { font-weight: bold; }
      &lt;/style&gt;
      Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    `;
  }
});
&lt;/script&gt;
</code></pre>
<p>이제 <code>&lt;p&gt;John Smith&lt;/p&gt;</code>는 bold 굵기가 된다. 왜냐하면 CSS 상속에 의해 하위 요소들에게도 영향을 미치기 때문이다. 단, CSS 자체의 속성들이 상속되지는 않는다.</p>
<p><strong>두번째 선택지는</strong> 바로 <code>::slotted(selector)</code> 의사 클래스를 사용하는 것이다. 이 때는 두가지 조건에 따라 해당하는 요소를 구분한다.</p>
<ol>
<li>light DOM를 통해서 전달된 slot 처리된 요소(<code>slot='...'</code>를 포함)여야 한다. <code>name</code> 자체는 중요하지 않다. 단, 오직 그 요소 자체에만 해당하며, 하위 요소들은 해당하지 않는다.</li>
<li>요소가 <code>selector</code> 선택자에 해당해야 한다.</li>
</ol>
<p>예를 들어, <code>::slotted(div)</code>는 정확히 <code>&lt;div slot='username'&gt;</code>에만 적용되며, 하위 요소들에는 적용되지 않는다.</p>
<pre><code class="language-html">&lt;user-card&gt;
  &lt;div slot=&quot;username&quot;&gt;
    &lt;div&gt;John Smith&lt;/div&gt;
  &lt;/div&gt;
&lt;/user-card&gt;

&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
      &lt;style&gt;
      ::slotted(div) { border: 1px solid red; }
      &lt;/style&gt;
      Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    `;
      }
    },
  );
&lt;/script&gt;
</code></pre>
<p>기억하자. <code>::slotted</code> 선택자는 하위 요소들을 확인하지 않는다.</p>
<pre><code class="language-css">::slotted(div span) {
  /* our slotted &lt;div&gt; does not match this */
}

::slotted(div) p {
  /* can't go inside light DOM */
}
</code></pre>
<h2 id="커스텀-프로퍼티를-이용한-css-hook"><a class="header" href="#커스텀-프로퍼티를-이용한-css-hook">커스텀 프로퍼티를 이용한 CSS Hook</a></h2>
<p>메인 문서를 통해 shadow DOM 컴포넌트 내부의 요소들을 스타일링하려면, 어떻게 해야할까?</p>
<p><code>:host</code> 선택자는 <code>&lt;custom-dialog&gt;</code> 자체에 대해서 스타일링을 적용할 수 있다. 그런데, 그것보다 깊숙히 위치한 요소들에 스타일링을 적용하고 싶다면 어떻게 할까?</p>
<p>사실, 문서에서 shadow DOM의 스타일에 직접 영향을 줄 수 있는 선택자는 없다. 그러나, 원한다면, CSS 변수(custom CSS properties)를 활용해 이를 구현할 수 있다.</p>
<p>왜냐하면, <strong>커스텀 CSS 프로퍼티는 light와 shadow 모두에 존재하기 때문이다.(공유한다)</strong></p>
<p>예를 들어, 먼저 아래처럼 <code>--user-card-field-color</code>라는 CSS 변수를 사용해 <code>.field</code>를 기본 스타일링할 수 있다.</p>
<pre><code class="language-html">&lt;style&gt;
  .field {
    color: var(--user-card-field-color, black);
    /* if --user-card-field-color is not defined, use black color */
  }
&lt;/style&gt;
&lt;div class=&quot;field&quot;&gt;Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
&lt;div class=&quot;field&quot;&gt;Birthday: &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
</code></pre>
<p>이후, 문서에서 <code>&lt;user-card&gt;</code>에 대해 앞서 만든 property를 활용하여 스타일링을 변경할 수 있다.</p>
<pre><code class="language-css">user-card {
  --user-card-field-color: green;
}
</code></pre>
<p>커스텀 CSS 프로퍼티는 shadow DOM 전반에 유효하기 때문에, 어디서든 활용할 수 있다.</p>
<pre><code class="language-HTML">&lt;style&gt;
  user-card {
    --user-card-field-color: green;
  }
&lt;/style&gt;

&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt;
    .field {
      color: var(--user-card-field-color, black);
    }
  &lt;/style&gt;
  &lt;div class=&quot;field&quot;&gt;Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;Birthday: &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));
  }
});
&lt;/script&gt;

&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom-and-events"><a class="header" href="#shadow-dom-and-events">Shadow DOM and events</a></h1>
<p>shadow tree에 담긴 기본 아이디어는 컴포넌트 내부적인 실행 세부사항에 대해 캡슐화를 적용하는 것이다.</p>
<p><code>&lt;user-card&gt;</code>의 shadow DOM 내부에 클릭 이벤트가 발생했다고 가정하자. 이 때, 메인 문서는 shadow DOM 내부에 대해 알 수 있는 방법이 없다. 이는 특히 서드파티 라이브러리로부터의 컴포넌트를 활용할 때 더 두드러진다.</p>
<p>따라서, 캡슐화를 유지하기 위해, 브라우저는 이벤트를 리타겟팅(<strong>retarget</strong>)한다.</p>
<p><strong>shadow DOM 내부에서 일어나는 이벤트들은 컴포넌트 외부에서 볼 때, 그들의 <strong>host</strong> 요소를 <code>target</code>으로 삼는다.</strong></p>
<p>말이 좀 헷갈릴 수 있는데, 다시 말해, shadow DOM 측에서 봤을 때는 <code>div</code>, <code>span</code> 등에서 이벤트가 발생했더라도, 메인 문서 측에서는 해당 이벤트의 타겟을 항상 <code>user-card</code>와 같은 host로 본다.</p>
<p>아래는 간단한 예시다.</p>
<pre><code class="language-html">&lt;user-card&gt;&lt;/user-card&gt;

&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `&lt;p&gt;
      &lt;button&gt;Click me&lt;/button&gt;
    &lt;/p&gt;`;
        this.shadowRoot.firstElementChild.onclick = (e) =&gt;
          alert('Inner target: ' + e.target.tagName);
      }
    },
  );

  document.onclick = (e) =&gt; alert('Outer target: ' + e.target.tagName);
&lt;/script&gt;
</code></pre>
<p>위 예시에서는, shadow DOM과 light DOM에서 바라보는 target이 달라지게 된다.</p>
<ol>
<li>
<p>내부 타겟: <code>BUTTON</code> - shadow DOM을 통한 컴포넌트 내부의 이벤트 핸들러는 올바른 <code>target</code>을 가져온다.</p>
</li>
<li>
<p>외부 타겟: <code>USER-CARD</code> - 문서에서 사용하는 이벤트 핸들러는 shadow host(<code>user-card</code>)를 타겟으로 가져온다.</p>
</li>
</ol>
<p>이벤트 리타겟팅은 마땅히 존재해야 하는데, 컴포넌트 내부에서 발생하는 일들에 대해 외부의 문서가 신경을 쓸 필요가 없기 떄문이다. 때문에, 문서의 관점에서는 단순히 <code>&lt;user-card&gt;</code>에서 발생한 이벤트라고만 인식하는 것이다.</p>
<p><strong>리타겟팅은 slot 처리된 요소에서는 발생하지 않는데, 왜냐하면 애초에 해당 요소는 light DOM에서부터 온 것이기 때문이다.</strong></p>
<p>예를 들어, 아래 예시에서 <code>&lt;span slot='username'&gt;</code>의 이벤트 타겟은 정확히 <code>span</code>이 된다. 이는 shadow와 light 이벤트 핸들러 양측이 동일하다.</p>
<pre><code class="language-HTML">&lt;user-card id=&quot;userCard&quot;&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
&lt;/user-card&gt;

&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `&lt;div&gt;
      &lt;b&gt;Name:&lt;/b&gt; &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;`;

    this.shadowRoot.firstElementChild.onclick =
      e =&gt; alert(&quot;Inner target: &quot; + e.target.tagName);
  }
});

userCard.onclick = e =&gt; alert(`Outer target: {e.target.tagName}`);
&lt;/script&gt;
</code></pre>
<p>단, 위 예시에서 <code>&lt;b&gt;Name:&lt;/b&gt;</code>과 같이 slot에 해당하지 않는 요소로부터 발생한 이벤트는 마찬가지로 host를 타겟으로 삼는다.</p>
<h2 id="버블링-eventcomposedpath"><a class="header" href="#버블링-eventcomposedpath">버블링, event.composedPath()</a></h2>
<p>flattened DOM은 이벤트 버블링을 위해서 사용된다.</p>
<p>따라서, 만약 slot 처리된 요소가 존재한다면, 그 안에서 발생한 이벤트는 <code>&lt;slot&gt;</code>을 거쳐 상위로 버블링된다.</p>
<p>shadow 요소들을 포함한 원래 이벤트 타겟에 대한 전체 경로(full-path)는 <code>event.composedPath()</code> 메서드를 통해 확인할 수 있다. 메서드의 이름에서부터 알 수 있듯이, 여기서 반환받는 경로는 composition 단계 이후의 path이다.</p>
<p>예를 들어, 아래의 flatten DOM이 있다고 가정하자.</p>
<pre><code class="language-HTML">&lt;user-card id=&quot;userCard&quot;&gt;
  #shadow-root
    &lt;div&gt;
      &lt;b&gt;Name:&lt;/b&gt;
      &lt;slot name=&quot;username&quot;&gt;
        &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<p>이제, <code>&lt;span slot='username'&gt;</code>을 클릭했을 때, <code>event.composedPath()</code>를 확인한다면, 다음 배열을 반환한다.</p>
<p><code>[span, slot, div, shadow-root, user-card, body, html, document, window]</code></p>
<p>이는 composition 이후 생성된 flatten DOM에서의 타겟 요소로부터 부모로 뻗어나가는 체이닝이다.</p>
<h3 id="주의"><a class="header" href="#주의">주의</a></h3>
<blockquote>
<p>shadow tree의 세부사항들은 오직 <code>{mode: 'open'}</code> 옵션이 있을 때만 제공된다.
만약, 그렇지 않다면 <code>event.composedPath()</code>역시 <code>user-card</code>에서부터 시작한다.
이는 shadow DOM이 동작하는 다른 메서드의 원칙과 유사한데, 닫힌(closed) 트리는 내부적으로 완전히 숨겨진다.</p>
</blockquote>
<h2 id="eventcomposed"><a class="header" href="#eventcomposed">event.composed</a></h2>
<p>대부분의 이벤트들은 shadow DOM 경계를 거쳐 완전히 버블링된다. 하지만 몇개의 예외가 존재한다.</p>
<p>이 경우 <code>composed</code> 이벤트 객체 프로퍼티에 의해 제어될 수 있는데, 만약 <code>true</code>에 해당하는 경우, 해당 이벤트는 shadow DOM의 경계를 넘어간다. <code>false</code>인 경우, 이벤트는 오직 shadow DOM 내부에서만 탐색된다.</p>
<p>아래 대부분의 이벤트는 <code>composed: true</code>이다.</p>
<ul>
<li><code>blur</code>, <code>focus</code>, <code>focusin</code>, <code>focusout</code></li>
<li><code>click</code>, <code>dblclick</code></li>
<li><code>mousedown</code>, <code>mouseup</code>, <code>mousemove</code>, <code>mouseout</code>, <code>mouseover</code></li>
<li><code>wheel</code></li>
<li><code>beforeinput</code>, <code>input</code>, <code>keydown</code>, <code>keyup</code></li>
</ul>
<p>모든 터치 이벤트와 포인터 이벤트 역시 <code>composed: true</code>로 설정된다.</p>
<p>아래는 <code>composed: false</code>에 해당하는 일부 이벤트들이다.</p>
<ul>
<li><code>mouseenter</code>, <code>mouseleave</code> (얘넨 애초에 버블링이 없다.)</li>
<li><code>load</code>, <code>unload</code>, <code>abort</code>, <code>error</code></li>
<li><code>select</code></li>
<li><code>slotchange</code></li>
</ul>
<p>해당 이벤트들은 오직 해당 요소가 동일하게 위치한 DOM 내에서만 확인될 수 있다.</p>
<h2 id="커스텀-이벤트"><a class="header" href="#커스텀-이벤트">커스텀 이벤트</a></h2>
<p>임의로 작성한 커스텀 이벤트를 발생시킬 때, <code>bubble</code>과 <code>composed</code> 프로퍼티를 설정할 수 있다.</p>
<p>예를 들어, 아래에서 <code>div#outer</code>의 shadow DOM에 <code>div#inner</code>을 만들고 거기에 두 이벤트를 트리거하자. 그러면, 오직 <code>composed: true</code>로 설정한 이벤트만이 DOM 경계를 넘어 문서 바깥으로 나올 수 있다.</p>
<pre><code class="language-HTML">&lt;div id=&quot;outer&quot;&gt;&lt;/div&gt;

&lt;script&gt;
outer.attachShadow({mode: 'open'});

let inner = document.createElement('div');
outer.shadowRoot.append(inner);

/*
div(id=outer)
  #shadow-dom
    div(id=inner)
*/

document.addEventListener('test', event =&gt; alert(event.detail));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: true,
  detail: &quot;composed&quot;
}));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: false,
  detail: &quot;not composed&quot;
}));
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Canvas API에 대한 정리는 <a href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API/Tutorial/Basic_usage#%3Ccanvas%3E_%EC%9A%94%EC%86%8C">MDN</a>의 문서를 쭉 따라갈 예정입니다.</p>
<p>먼저 <code>&lt;canvas&gt;</code> 태그의 형태에 대해 살펴봅시다.</p>
<pre><code class="language-html">&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p><code>width</code>와 <code>height</code> 어트리뷰트를 지정하지 않는 경우, 캔버스의 최초 너비는 <strong>300px</strong>이고, 높이는 <strong>150px</strong>이 됩니다. 해당 요소는 CSS에 의해 임의로 크기가 변경될 수 있으나, 비율이 고려되지 않는 경우 왜곡되어 보입니다.</p>
<blockquote>
<p>노트: 만약 렌더링이 왜곡된 것처럼 보인다면, CSS를 사용하지 않고, 직접 <code>&lt;canvas&gt;</code> 태그의 <code>width</code>와 <code>height</code> 어트리뷰트를 지정하는 것이 좋습니다.</p>
</blockquote>
<h2 id="대체-콘텐츠"><a class="header" href="#대체-콘텐츠">대체 콘텐츠</a></h2>
<p><code>&lt;canvas&gt;</code> 태그 안에 콘텐츠가 삽입된 경우, <code>&lt;canvas&gt;</code> 태그를 지원하지 않는 브라우저에 대해서는 해당 콘텐츠를 보여줍니다. 브라우저가 <code>&lt;canvas&gt;</code>태그를 지원하는 경우, 이는 무시됩니다. 참고로, <code>&lt;canvas&gt;</code>는, 이러한 방식으로 인해 반드시 닫는 태그가 필요합니다.</p>
<pre><code class="language-html">&lt;canvas id=&quot;stockGraph&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;
  current stock price: 3.15 +0.15
&lt;/canvas&gt;

&lt;canvas id=&quot;clock&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;
  &lt;img src=&quot;images/clock.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot; /&gt;
&lt;/canvas&gt;
</code></pre>
<h2 id="rendering-context"><a class="header" href="#rendering-context">Rendering Context</a></h2>
<p>캔버스는 최초에 비어있으며, 어떤 것을 표시하기 위해 스크립트를 통해 렌더링 컨텍스트에 접근하여, 이를 그려내야 합니다.</p>
<pre><code class="language-js">const canvas = document.getElementById('tutorial');
const ctx = canvas.getContext('2d');
</code></pre>
<h2 id="기본-예제"><a class="header" href="#기본-예제">기본 예제</a></h2>
<p>간단한 직사각형 두개를 그려낸 예제를 살펴보겠습니다. 현재는 아래를 통해 대략적인 형태에 대해서만 이해하면 됩니다.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script type=&quot;application/javascript&quot;&gt;
      function draw() {
        const canvas = document.getElementById('canvas');
        if (canvas.getContext) {
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'rgb(200,0,0)';
          ctx.fillRect(10, 10, 50, 50);
          ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';
          ctx.fillRect(30, 30, 50, 50);
        }
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload=&quot;draw();&quot;&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><canvas id="canvas"></canvas></p>
<script>
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgb(200,0,0)';
  ctx.fillRect(10, 10, 50, 50);
  ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';
  ctx.fillRect(30, 30, 50, 50);
</script>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="도형-그리기"><a class="header" href="#도형-그리기">도형 그리기</a></h1>
<p>기본적으로 캔버스 상의 좌표 공간은 아래의 형태를 따릅니다. 좌상단을 기준으로 x, y 좌표를 판단합니다.</p>
<img src="https://mdn.mozillademos.org/files/224/Canvas_default_grid.png" />
<h2 id="직사각형-그리기"><a class="header" href="#직사각형-그리기">직사각형 그리기</a></h2>
<p>캔버스 상에서 직사각형을 그리기는 데에는 세가지 함수가 있습니다.</p>
<ol>
<li><code>fillRect(x, y, width, height)</code></li>
</ol>
<ul>
<li>색칠된 직사각형을 그립니다.</li>
</ul>
<ol start="2">
<li><code>strokeRect(x, y, width, height)</code></li>
</ol>
<ul>
<li>직사각형 윤곽선을 그립니다.</li>
</ul>
<ol start="3">
<li><code>clearRect(x, y, width, height)</code></li>
</ol>
<ul>
<li>직사각형 모양으로 해당 부분들을 완전히 지웁니다.</li>
</ul>
<ol start="4">
<li><code>rect(x, y, width, height)</code></li>
</ol>
<ul>
<li>직사각형 모양으로 경로를 추가합니다. 이후 좌표가 해당 경로로 이동합니다.</li>
</ul>
<p>이들을 이용해 하나의 예제를 살펴봅시다.</p>
<pre><code class="language-js">ctx.fillRect(25, 25, 100, 100);
ctx.clearRect(45, 45, 60, 60);
ctx.strokeRect(50, 50, 50, 50);
</code></pre>
<p><canvas id="example1" ></canvas></p>
<script>
const ctx1 = example1.getContext('2d');
ctx1.fillRect(25, 25, 100, 100)
ctx1.clearRect(45, 45, 60, 60);
ctx1.strokeRect(50, 50, 50, 50);
</script>
<h2 id="경로-그리기"><a class="header" href="#경로-그리기">경로 그리기</a></h2>
<p>경로는 직사각형 외의 유일한 원시형(primitive) 도형입니다. 경로를 통해 도형을 그리기 위해서는 다음의 단계를 거치게 됩니다.</p>
<ol>
<li>경로를 생성</li>
<li>그리기 명령들을 통해 경로 상에 그립니다.</li>
<li>그린 경로에 대한 윤곽선을 그리거나 도형 내부를 채웁니다.</li>
</ol>
<p>이러한 단계들을 수행하게 아래의 함수들이 사용됩니다.</p>
<ol>
<li><code>beginPath()</code></li>
</ol>
<ul>
<li>새로운 경로를 만듭니다.</li>
</ul>
<ol start="2">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D#paths">여러 Path 메서드들</a></li>
</ol>
<ul>
<li>이후에 계속 살펴보겠지만, 여러 경로들을 설정하기 위해 사용됩니다.</li>
</ul>
<ol start="3">
<li><code>closePath()</code></li>
</ol>
<ul>
<li>현재 경로의 시작점과 연결되는 직선을 추가합니다. 이는 옵션 사항입니다.</li>
</ul>
<ol start="4">
<li><code>stroke()</code></li>
</ol>
<ul>
<li>윤곽선을 통해 도형을 그립니다.</li>
</ul>
<ol start="5">
<li><code>fill()</code></li>
</ol>
<ul>
<li>경로 내부를 채워 색칠된 도형을 그립니다. 이 경우 별도로 <code>closePath()</code>를 해줄 필요가 없습니다.</li>
</ul>
<p>이를 통해 간단한 삼각형을 그려봅시다.</p>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(75, 50);
ctx.lineTo(100, 75);
ctx.lineTo(100, 25);
ctx.fill();
</code></pre>
<p><canvas id='example2' ></canvas></p>
<script>
const ctx2 = example2.getContext('2d');
ctx2.beginPath();
ctx2.moveTo(75, 50);
ctx2.lineTo(100, 75);
ctx2.lineTo(100, 25);
ctx2.fill();
</script>
<h2 id="펜-이동하기"><a class="header" href="#펜-이동하기">펜 이동하기</a></h2>
<ul>
<li><code>moveTo(x, y)</code>
<ul>
<li>이를 이용하면, 펜을 해당 좌표로 옮기기만 하고, 그리진 않습니다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">ctx.beginPath();
ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
ctx.moveTo(110, 75);
ctx.arc(75, 75, 35, 0, Math.PI, false); // Mouth (clockwise)
ctx.moveTo(65, 65);
ctx.arc(60, 65, 5, 0, Math.PI * 2, true); // Left eye
ctx.moveTo(95, 65);
ctx.arc(90, 65, 5, 0, Math.PI * 2, true); // Right eye
ctx.stroke();
</code></pre>
<p><canvas id="example3"></canvas></p>
<script>
const ctx3 = example3.getContext('2d');
ctx3.beginPath();
ctx3.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
ctx3.moveTo(110, 75);
ctx3.arc(75, 75, 35, 0, Math.PI, false); // Mouth (clockwise)
ctx3.moveTo(65, 65);
ctx3.arc(60, 65, 5, 0, Math.PI * 2, true); // Left eye
ctx3.moveTo(95, 65);
ctx3.arc(90, 65, 5, 0, Math.PI * 2, true); // Right eye
ctx3.stroke();
</script>
<h2 id="선-그리기"><a class="header" href="#선-그리기">선 그리기</a></h2>
<ul>
<li><code>lineTo(x, y)</code>
<ul>
<li>이는 현재 위치에서 해당 좌표 위치까지 선을 그려냅니다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// Filled triangle
ctx.beginPath();
ctx.moveTo(25, 25);
ctx.lineTo(105, 25);
ctx.lineTo(25, 105);
ctx.fill();

// Stroked triangle
ctx.beginPath();
ctx.moveTo(125, 125);
ctx.lineTo(125, 45);
ctx.lineTo(45, 125);
ctx.closePath();
ctx.stroke();
</code></pre>
<p><canvas id="example4"></canvas></p>
<script>
  const ctx4 = example4.getContext('2d');
  // Filled triangle
  ctx4.beginPath();
  ctx4.moveTo(25, 25);
  ctx4.lineTo(105, 25);
  ctx4.lineTo(25, 105);
  ctx4.fill();

  // Stroked triangle
  ctx4.beginPath();
  ctx4.moveTo(125, 125);
  ctx4.lineTo(125, 45);
  ctx4.lineTo(45, 125);
  ctx4.closePath();
  ctx4.stroke();
</script>
<h2 id="호arc-또는-원-그리기"><a class="header" href="#호arc-또는-원-그리기">호(Arc) 또는 원 그리기</a></h2>
<ol>
<li><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code></li>
</ol>
<ul>
<li>해당 좌표에, 반지름 <code>radius</code>를 갖도록 <code>startAngle</code> 각도에서 <code>endAngle</code>각도까지 <code>anticlockwise</code> 방향으로 호를 그려냅니다.</li>
</ul>
<ol start="2">
<li><code>arcTo(x1, y1, x2, y2, radius)</code></li>
</ol>
<ul>
<li>주어진 각 제어점과 반지름으로 호를 그리고, 이전 점과 직선으로 연결합니다.</li>
<li>이에 대해서는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo">여기</a>를 살펴봅시다.</li>
</ul>
<p>&lt;img src=&quot;&gt;</p>
<blockquote>
<p><strong>주의!</strong>: <code>arc</code>함수에서의 각도는 degree가 아닌 radian 단위를 사용합니다. 따라서 degree 단위를 사용하려면 별도의 변환이 요구됩니다.</p>
<p><code>radians = (Math.PI/180)*degrees</code></p>
</blockquote>
<pre><code class="language-js">const startAngle = 0;
const endAngle = (Math.PI / 180) * 90;
ctx.beginPath();
ctx.arc(120, 120, 100, startAngle, endAngle, true);
ctx.stroke();
</code></pre>
<p><canvas id="example5" height="250"></canvas></p>
<script>
const ctx5 = example5.getContext('2d');
const startAngle = 0;
const endAngle = (Math.PI / 180) * 90;
ctx5.beginPath();
ctx5.arc(120, 120, 100, startAngle, endAngle, true);
ctx5.stroke();
</script>
<h2 id="베지어bezier-곡선과-이차quadratic-곡선"><a class="header" href="#베지어bezier-곡선과-이차quadratic-곡선">베지어(Bezier) 곡선과 이차(Quadratic) 곡선</a></h2>
<img src="https://mdn.mozillademos.org/files/223/Canvas_curves.png" />
<p>베지어 곡선은 주로 복잡한 형태를 그려내는데 사용됩니다.</p>
<ol>
<li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code></li>
</ol>
<ul>
<li><code>cp1x</code> 및 <code>cp1y</code>로 지정된 제어점을 통해 현재 펜 위치에서 <code>x</code>, <code>y</code>로 지정된 끝점까지 이차 베지어 곡선을 그립니다.</li>
</ul>
<ol start="2">
<li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code></li>
</ol>
<ul>
<li>각 제어점을 통해 <code>x</code>, <code>y</code>로 지정된 끝점까지 삼차 베지어 곡선을 그립니다.</li>
</ul>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(75, 25);
ctx.quadraticCurveTo(25, 25, 25, 62.5);
ctx.quadraticCurveTo(25, 100, 50, 100);
ctx.quadraticCurveTo(50, 120, 30, 125);
ctx.quadraticCurveTo(60, 120, 65, 100);
ctx.quadraticCurveTo(125, 100, 125, 62.5);
ctx.quadraticCurveTo(125, 25, 75, 25);
ctx.stroke();
</code></pre>
<p><canvas id="example6"></canvas></p>
<script>
const ctx6 = example6.getContext('2d');
ctx6.beginPath();
ctx6.moveTo(75, 25);
ctx6.quadraticCurveTo(25, 25, 25, 62.5);
ctx6.quadraticCurveTo(25, 100, 50, 100);
ctx6.quadraticCurveTo(50, 120, 30, 125);
ctx6.quadraticCurveTo(60, 120, 65, 100);
ctx6.quadraticCurveTo(125, 100, 125, 62.5);
ctx6.quadraticCurveTo(125, 25, 75, 25);
ctx6.stroke();
</script>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(75, 40);
ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);
ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);
ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);
ctx.fill();
</code></pre>
<p><canvas id="example7"></canvas></p>
<script>
const ctx7 = example7.getContext('2d');
ctx7.beginPath();
ctx7.moveTo(75, 40);
ctx7.bezierCurveTo(75, 37, 70, 25, 50, 25);
ctx7.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
ctx7.bezierCurveTo(20, 80, 40, 102, 75, 120);
ctx7.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
ctx7.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
ctx7.bezierCurveTo(85, 25, 75, 37, 75, 40);
ctx7.fill();
</script>
<h2 id="path2d-오브젝트"><a class="header" href="#path2d-오브젝트">Path2D 오브젝트</a></h2>
<ul>
<li><code>Path2D()</code>
<ul>
<li><code>new</code> 키워드와 함께 사용되어 새로운 <code>Path2D</code> 객체를 반환합니다. 기존 경로 혹은 SVG 경로를 인자로 받을 수도 있습니다.</li>
</ul>
</li>
</ul>
<p>SVG 경로 데이터를 활용하는 경우, 아래와 같은 형태가 됩니다.</p>
<pre><code class="language-js">const p = new Path2D('M10 10 h 80 v 80 h -80 Z');
</code></pre>
<p>이를 활용하면, 하나의 컨텍스트로 이리저리 옮겨가며 그리던 방식에서 벗어나, 객체의 형태로 각 경로를 변수에 저장할 수 있습니다.</p>
<pre><code class="language-js">const rectangle = new Path2D();
rectangle.rect(10, 10, 50, 50);

const circle = new Path2D();
circle.moveTo(125, 35);
circle.arc(100, 35, 25, 0, 2 * Math.PI);

ctx.stroke(rectangle);
ctx.fill(circle);
</code></pre>
<p><canvas id='example8'></canvas></p>
<script>
  const ctx8 = example8.getContext('2d');
  const rectangle = new Path2D();
  rectangle.rect(10, 10, 50, 50);

  const circle = new Path2D();
  circle.moveTo(125, 35);
  circle.arc(100, 35, 25, 0, 2 * Math.PI);

  ctx8.stroke(rectangle);
  ctx8.fill(circle);
</script>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<ul>
<li>해당 md는 <a href="https://developers.google.com/web/fundamentals">여기</a>의 글을 재구성한 것입니다.</li>
</ul>
<h1 id="렌더링-최적화"><a class="header" href="#렌더링-최적화">렌더링 최적화</a></h1>
<h2 id="픽셀-파이프라인"><a class="header" href="#픽셀-파이프라인">픽셀 파이프라인</a></h2>
<img src='https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg' />
<p>위 그림은 작업 시 유의해야하는 5가지 주요 영역이며, 픽셀 - 화면 파이프라인의 핵심 요소이다.</p>
<ul>
<li><strong>JS / CSS</strong> : JS 및 CSS를 통해 이루어지는 시각적 변화의 트리거를 가리킨다.</li>
<li><strong>Style</strong> : <code>.headline</code>과 같은 선택자에 따라 어떤 CSS 규칙을 어떤 요소에 적용할지 계산하는 프로세스이다.</li>
<li><strong>Layout</strong> : 브라우저가 각 요소에 어떤 규칙을 적용할 지 알고난 후, 실제로 어디에, 어느 정도의 공간을 차지하며 위치할지를 계산하는 과정. 한 요소가 다른 요소에 영향을 줄 수 있기 때문에 해당 과정이 필요하다.</li>
<li><strong>Paint</strong> : 실제로 화면의 픽셀을 채우는 과정. 텍스트 / 색 / 경계 및 그림자 등 요소의 모든 시각적 부분을 그려낸다. 일반적으로 레이어라고 하는 여러 개의 표면에서 수행된다.</li>
<li><strong>Composition</strong> : 페이지의 각 부분들이 여러 레이어를 통해 그려졌기 때문에, 페이지가 정확히 렌더링되기 위해 정확한 순서대로 화면에 그려내는 과정.</li>
</ul>
<p>JS / CSS를 통해 시각적인 변경이 이루어졌을 때, 파이프라인이 동작하는 세가지 형태가 존재한다.</p>
<h3 id="1-js--css---style---layout---paint---composition"><a class="header" href="#1-js--css---style---layout---paint---composition"><strong>1. JS / CSS -&gt; Style -&gt; Layout -&gt; Paint -&gt; Composition</strong></a></h3>
<img src='https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg' />
<ul>
<li>너비 / 높이 / 위치 등 요소의 기하학적 형태에 영향을 주는 Layout 속성들을 변경하면 브라우저가 다른 요소들을 확인하고 페이지에 대해 <strong>리플로우(Reflow)</strong> 작업을 수행해야 한다. 이후 영향을 받은 영역이 있다면 다시 페인트해야 하고, 최종적으로 페인트한 요소는 다시 합성이 이루어져야 한다.</li>
</ul>
<h3 id="2-js--css---style---paint---composition"><a class="header" href="#2-js--css---style---paint---composition"><strong>2. JS / CSS -&gt; Style -&gt; Paint -&gt; Composition</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg" />
<ul>
<li>페이지의 레이아웃에 영향을 주지 않는 배경 이미지, 텍스트 색상 또는 그림자 등 Paint Only 속성을 변경하면, 브라우저가 레이아웃 작업을 건너뛰고 페인트 작업부터 수행한다.</li>
</ul>
<h3 id="3-js--css---style---composition"><a class="header" href="#3-js--css---style---composition"><strong>3. JS / CSS -&gt; Style -&gt; Composition</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg" />
<ul>
<li>레이아웃과 페인트 모두 필요없는 속성을 변경하게 되면 브라우저가 바로 합성 단계로 건너뛴다.</li>
</ul>
<p>각 속성을 변경함에 있어 위 중 어떤 과정을 거치게 되는지에 대해 알고 싶다면 <a href="https://csstriggers.com/">CSS Triggers</a>를 참조하자.</p>
<p>아래부터는 파이프라인의 각 부분에 있어서 발생할 수 있는 일반적인 문제와 그 진단 / 해결방법에 대해 살펴보자.</p>
<h2 id="js-실행-최적화"><a class="header" href="#js-실행-최적화">JS 실행 최적화</a></h2>
<p>실행 타이밍이 안좋거나, 실행 시간이 긴 JS는 렌더링 성능에 영향을 미칠 수 있다.</p>
<h3 id="시각적-업데이트에-settimeout-또는-setinterval을-피하고-대신-항상-requestanimationframe을-사용하라"><a class="header" href="#시각적-업데이트에-settimeout-또는-setinterval을-피하고-대신-항상-requestanimationframe을-사용하라"><strong>시각적 업데이트에 setTimeout 또는 setInterval을 피하고 대신 항상 requestAnimationFrame을 사용하라.</strong></a></h3>
<p><code>setTimeout</code>에 의해 특정 시점에 콜백이 실행되는 경우, 종종 프레임이 누락되어 버벅거리는 현상이 발생할 수 있다. <code>requestAnimationFrame</code>을 이용한 방법은 JS가 프레임 시작 시에 실행되도록 보장한다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/optimize-javascript-execution/settimeout.jpg" />
<pre><code class="language-js">/**
 * If run as a requestAnimationFrame callback, this
 * will be run at the start of the frame.
 */
function updateScreen(time) {
  // Make visual updates here.
}

requestAnimationFrame(updateScreen);
</code></pre>
<h3 id="메인-스레드를-벗어나-오래-실행되는-자바스크립트를-web-workers로-이전하라"><a class="header" href="#메인-스레드를-벗어나-오래-실행되는-자바스크립트를-web-workers로-이전하라"><strong>메인 스레드를 벗어나 오래 실행되는 자바스크립트를 Web Workers로 이전하라.</strong></a></h3>
<p>원하는 작업에 DOM 액세스가 필요하지 않은 경우에는 Web Worker의 사용을 고려해볼 수 있다. 정렬 / 검색 또는 순회(traversal)는 대개 이 모델에 적합하며, 로드 및 모델 생성도 마찬가지다.</p>
<pre><code class="language-js">const dataSortWorker = new Worker('sort-worker.js');
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function (evt) {
  const sortedData = evt.data;
  // Update data on screen...
});
</code></pre>
<h3 id="마이크로-작업을-사용하여-여러-프레임을-통해-dom을-변경하라"><a class="header" href="#마이크로-작업을-사용하여-여러-프레임을-통해-dom을-변경하라"><strong>마이크로 작업을 사용하여 여러 프레임을 통해 DOM을 변경하라.</strong></a></h3>
<p>단, 반대로 말해서 DOM 액세스를 요구하는 작업의 경우 이런 방식이 적합하지 않다. 이와 같이 작업이 메인 스레드에 있어야 한다면, 큰 작업을 몇 개의 마이크로 작업으로 세분화하여, 각각의 프레임에서 <code>requestAnimationFrame</code> 핸들러를 통해 실행하는 방식을 고려해볼 수 있다.</p>
<pre><code class="language-js">const var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
  const taskFinishTime;

  do {
    // Assume the next task is pushed onto a stack.
    const nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
    taskFinishTime = window.performance.now();
  } while (taskFinishTime - taskStartTime &lt; 3);

  if (taskList.length &gt; 0) requestAnimationFrame(processTaskList);
}
</code></pre>
<p>이러한 접근 방식을 활용하는 경우, UX/UI를 통해 특정 작업을 계속 수행하고 있음을 이용자에게 나타내는 것이 중요하다. 또한 앱의 메인 스레드를 계속해서 사용 가능한 상태를 유지하여 사용자의 상호작용에 계속 반응할 수 있도록 해야한다.</p>
<h3 id="chrome-devtools의-timeline-및-자바스크립트-프로파일러를-사용하여-자바스크립트의-영향을-평가한다"><a class="header" href="#chrome-devtools의-timeline-및-자바스크립트-프로파일러를-사용하여-자바스크립트의-영향을-평가한다"><strong>Chrome DevTools의 Timeline 및 자바스크립트 프로파일러를 사용하여 자바스크립트의 영향을 평가한다.</strong></a></h3>
<p>프레임별로 JS 코드의 실행 비용을 평가하는 것 역시 중요한데, 이는 특히 트랜지션이나 스크롤처럼 성능이 중요한 애니메이션 작업 시에 더욱 중요하다.</p>
<p>JS 비용 및 성능 프로필을 측정하기 위한 가장 좋은 방법은 DevTools를 사용하는 것이다. (Timeline, Profiler)</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/optimize-javascript-execution/high-js-detail.jpg" />
<h3 id="js-미세-최적화micro-optimization를-피하라"><a class="header" href="#js-미세-최적화micro-optimization를-피하라"><strong>JS 미세 최적화(Micro Optimization)를 피하라.</strong></a></h3>
<p><code>offsetTop</code>이 <code>getBoundingClientRect()</code> 계산보다 빠른 것처럼, 브라우저는 일부 작업을 다른 작업보다 100배 가까이 빨리 처리할 수 있다. 하지만 실제로 함수 호출 시의 프레임 당 시간은 거의 항상 짧기 때문에, JS의 성능적인 측면에 중점을 두는 것은 일반적으로 시간 낭비에 가깝다. 이러한 노고를 통해 절약되는 시간이 거의 밀리초의 일부에 불과하기 때문이다. 단, 게임이나 컴퓨팅 비용이 비싼 앱의 경우엔 예외인데, 일반적으로 많은 계산이 단일 프레임에 적용되고, 이 경우에는 모든 것이 도움이 되기 때문이다. 거꾸로 말하면, 그렇지 않은 경우(게임 등을 개발하는 것이 아닌 경우)에는 적절하지 않으므로 피해야 한다.</p>
<h2 id="style-계산의-스코프--복잡성-최적화"><a class="header" href="#style-계산의-스코프--복잡성-최적화">Style 계산의 스코프 / 복잡성 최적화</a></h2>
<p>요소의 스타일링 규칙을 정하는 단계에서, 더 간단한 규칙을 지닌 더 작은 트리가 큰 트리나 복잡한 규칙보다 더 효율적으로 처리된다.</p>
<p>다음의 각각은 동일한 요소를 대상으로 하기 위해 지정한 선택자지만, 브라우저가 이를 계산하는데에 드는 시간 비용에는 차이가 생긴다.</p>
<pre><code class="language-css">.box:nth-last-child(-n + 1) .title {
  /* styles */
}
</code></pre>
<pre><code class="language-css">.final-box-title {
  /* styles */
}
</code></pre>
<p>BEM과 같은 CSS 아키텍처 역시 이러한 선택기 매칭의 성능 이점에서 구현된다.</p>
<pre><code>.list { }
.list__list-item { }
.list__list-item--last-child {}
</code></pre>
<h2 id="레이아웃-최적화"><a class="header" href="#레이아웃-최적화">레이아웃 최적화</a></h2>
<p>레이아웃은 브라우저가 요소의 기하학적인 정보를 파악하는 장소이며, 각 요소는 사용한 CSS, 요소의 컨텐츠 또는 상위 요소에 따라 명시적 / 암시적인 크기 지정 정보를 갖게된다. 해당 프로세스를 Chrome, Opera, Safari 및 IE에서는 레이아웃이라고 하며, Firefox에서는 리플로우(Reflow)라고 한다.</p>
<h3 id="레이아웃의-범위는-거의-항상-전체-문서로-지정된다"><a class="header" href="#레이아웃의-범위는-거의-항상-전체-문서로-지정된다"><strong>레이아웃의 범위는 거의 항상 전체 문서로 지정된다.</strong></a></h3>
<p>요소가 많은 경우 모든 요소의 위치와 크기를 파악하는데 오랜 시간이 걸린다. 레이아웃을 피할 수 없는 경우, DevTools의 Timeline을 통해 해당 레이아웃에 시간이 얼마나 걸리는지에 대한 파악이 필요하다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/big-layout.jpg" />
<p>위의 예에서는 레이아웃 내부에서 20ms 이상 소요된 것을 확인할 수 있는데, 애니메이션 화면에서 프레임당 16ms가 필요한 경우 이에 비해 훨씬 높은 값이다. 또한 트리 크기(위에서는 1,618 요소) 및 레이아웃에 필요한 노드 수도 확인할 수 있다.</p>
<h3 id="flexbox는-동일한-수의-요소에-대해-레이아웃-시간을-훨씬-덜-소요한다"><a class="header" href="#flexbox는-동일한-수의-요소에-대해-레이아웃-시간을-훨씬-덜-소요한다"><strong>Flexbox는 동일한 수의 요소에 대해 레이아웃 시간을 훨씬 덜 소요한다.</strong></a></h3>
<p>브라우저에 따라 Flexbox를 지원하지 않는 경우도 있겠지만.. 결국 Flexbox의 사용 여부 이전에 레이아웃 트리거 자체를 완전히 피하려고 노력하는 것이 좋다. 아래는 float를 사용하는 레이아웃과 flex를 사용한 레이아웃 간의 처리시간 차이를 나타내는 결과다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-float.jpg" />
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-flex.jpg" />
<h3 id="강제-동기식-레이아웃을-피하라"><a class="header" href="#강제-동기식-레이아웃을-피하라"><strong>강제 동기식 레이아웃을 피하라</strong></a></h3>
<p>화면에 프레임을 추가하는 순서는 다음과 같다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/frame.jpg" />
<p>JS를 실행한 후 -&gt; 스타일 계산을 수행한 후에 -&gt; 레이아웃을 실행한다.</p>
<p>하지만, JS를 사용해 브라우저가 레이아웃을 더 일찍 수행하도록 하는 것도 가능한데, 이를 **강제 동기식 레이아웃(forced synchronous layouts)**이라고 한다.</p>
<p>JS가 실행될 때, <strong>이전</strong> 프레임의 모든 레이아웃 값은 알려져 있고, 이를 쿼리에 사용할 수 있다. 이를테면 프레임 시작 시 요소의 높이를 기록하려면 다음과 같이 작성할 수 있다.</p>
<pre><code class="language-js">// Schedule our function to run at the start of the frame.
requestAnimationFrame(logBoxHeight);

function logBoxHeight() {
  // Gets the height of the box in pixels and logs it out.
  console.log(box.offsetHeight);
}
</code></pre>
<p>헌데, 높이를 요청하기 <strong>전에</strong> 스타일을 먼저 변경한 경우 문제가 발생할 수 있다.</p>
<pre><code class="language-js">function logBoxHeight() {
  box.classList.add('super-big');

  // Gets the height of the box in pixels
  // and logs it out.
  console.log(box.offsetHeight);
}
</code></pre>
<p>이 경우, 정확한 높이를 구하기 위해 브라우저는 먼저 스타일을 변경한 후(<code>super-big</code>이 클래스에 추가되었기 때문에), 레이아웃을 실행해야 한다. 이는 불필요하고, 비용도 많이 드는 작업이다.</p>
<p>때문에, 항상 스타일 읽기를 일괄적으로 처리하여 먼저 수행한 다음, 스타일 쓰기를 작성해야 한다.</p>
<p>결국, 위의 코드를 올바르게 수정하자면 아래와 같아진다.</p>
<pre><code class="language-js">function logBoxHeight() {
  // Gets the height of the box in pixels
  // and logs it out.
  console.log(box.offsetHeight);

  box.classList.add('super-big');
}
</code></pre>
<p>대부분의 경우 스타일을 적용한 다음에 그 값을 쿼리할 필요가 없다. 이전의 프레임 값을 사용하면 충분하기 때문이다. 브라우저가 원하는 시간보다 일찍 스타일 계산과 레이아웃을 동시에 실행하지 않도록 하자.</p>
<h3 id="레이아웃-스래싱을-피하라"><a class="header" href="#레이아웃-스래싱을-피하라"><strong>레이아웃 스래싱을 피하라</strong></a></h3>
<p>많은 레이아웃을 연속적으로 빠르게 실행한다면 강제 동기식 레이아웃이 더 악화된다.</p>
<pre><code class="language-js">function resizeAllParagraphsToMatchBlockWidth() {
  // Puts the browser into a read-write-read-write cycle.
  for (let i = 0; i &lt; paragraphs.length; i++) {
    paragraphs[i].style.width = box.offsetWidth + 'px';
  }
}
</code></pre>
<p>위 코드는 매 루프마다 스타일 값(<code>box.offsetWidth</code>)을 읽은 다음 이 값을 즉시 사용해 너비(<code>paragraphs[i].style.width</code>)를 업데이트한다.</p>
<p>스타일링의 변경을 일으킨 직후에 <code>box.offsetWidth</code>를 요구하였기 때문에, 이 시점에서 강제 동기식 레이아웃이 발생한다.</p>
<p>이 경우, 바로 루프의 바로 다음부터 시작해 매 반복마다 스타일이 변경되었음을 확인하고, 이에 따라 스타일 변경을 적용하고, 레이아웃을 실행하게 된다.</p>
<p>이를 수정하려면, 기존 프레임의 하나의 값을 읽은 다음 계속해서 사용해야 한다.</p>
<pre><code class="language-js">// Read.
const width = box.offsetWidth;

function resizeAllParagraphsToMatchBlockWidth() {
  for (let i = 0; i &lt; paragraphs.length; i++) {
    // Now write.
    paragraphs[i].style.width = width + 'px';
  }
}
</code></pre>
<p>이런 레이아웃 스레싱(Layout thrashing)을 없애기 위해 <a href="https://github.com/wilsonpage/fastdom">fastDOM</a>이라는 라이브러리도 존재한다.</p>
<h2 id="페인트-최적화"><a class="header" href="#페인트-최적화">페인트 최적화</a></h2>
<p>페인트 과정은 최종적으로 사용자의 화면에 픽셀을 채우는 과정이며, 파이프라인의 모든 작업 중 대체로 실행시간이 가장 긴 작업이기 때문에 가급적 피해야 한다.</p>
<h3 id="언제-페인팅이-이루어지는가"><a class="header" href="#언제-페인팅이-이루어지는가"><strong>언제 페인팅이 이루어지는가??</strong></a></h3>
<p>페인트가 트리거되는 경우는 다음의 두가지이다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/frame.jpg"/>
<ol>
<li>레이아웃이 트리거되면, <strong>항상</strong> 페인트 역시 트리거된다.</li>
</ol>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/frame-no-layout.jpg" />
<ol start="2">
<li>레이아웃이 필요없는 비기하학적 속성(배경 / 텍스트 색상, 그림자)을 변경하는 경우에도 페인트가 트리거된다.</li>
</ol>
<h3 id="이동되거나-페이드되는-요소를-승격promote해라"><a class="header" href="#이동되거나-페이드되는-요소를-승격promote해라"><strong>이동되거나 페이드되는 요소를 승격(Promote)해라</strong></a></h3>
<p>페인트가 항상 메모리 상에 단일 이미지로 수행되는 것은 아닌데, 실제로 필요에 따라서 브라우저가 다중 이미지 혹은 컴포지터 레이어로 페인트를 할 수 있다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/layers.jpg" />
<p>이러한 접근방식의 이점은, 정기적으로 페인트하거나 변형에 의해 화면에서 움직이는 요소를 다른 요소에 영향을 주지 않으면서 처리할 수 있다는 것이다.</p>
<p>이는 Photoshop과 같은 툴에서 볼 수 있는 레이어의 개념과 유사한데, 최상위에서 개별 레이어를 처리 / 합성하여 최종적인 이미지를 생성할 수 있다.</p>
<p>새로운 레이어를 생성하는 가장 좋은 방법은 <code>will-change</code> CSS 속성을 사용하는 것이다. 이는 Chrome, Opera 및 Firefox에서 작동하며, <code>transform</code> 값으로 새 컴포지터 레이어를 생성한다.</p>
<pre><code class="language-css">.moving-element {
  will-change: transform;
}
</code></pre>
<p>Safari처럼 <code>will-change</code>를 지원하지는 않으나, 레이어 생성은 활용하는 브라우저의 경우 3D 변형을 사용해 새 레이어를 강제적으로 적용해야 한다.</p>
<pre><code class="language-css">.moving-element {
  transform: translateZ(0);
}
</code></pre>
<p>단, 각 레이어는 메모리와 관리가 요구되기 때문에 너무 많은 레이어를 생성하는 것은 오히려 독이 될 수 있다. 또한 요소를 새 레이어로 승격시키는 경우, 이렇게 하는 것이 성능 상으로 이점이 있는지부터 먼저 확인해야 한다.</p>
<h3 id="페인트-영역을-줄여라"><a class="header" href="#페인트-영역을-줄여라"><strong>페인트 영역을 줄여라</strong></a></h3>
<p>앞선 설명처럼 요소를 승격시켰음에도 불구하고 페인팅 작업이 여전히 요구되는 경우가 있다. 페인트의 커다란 문제점은 브라우저가 페인팅이 필요한 두 영역을 합치고 나면, 전체 스크린에 대해 다시 페인팅 작업을 수행할 수도 있다는 점이다. 예를 들어, 페이지 상단에 고정된(fixed) 헤더를 갖고 있더라도, 스크린 아래쪽에서 페인팅이 이루어진다면 그냥 스크린 전체가 리페인팅될 수 있다.</p>
<blockquote>
<p><strong>참고</strong>: 높은 DPI를 가진 디바이스의 경우 <code>fixed</code> position을 가진 요소는 자동으로 컴포지터 레이어(Compositor layer)로 승격된다. 반면, 낮은 DPI를 가진 경우는 해당하지 않는데, 이 경우 승격은 텍스트 렌더링을 서브픽셀(subfixel)에서 그레이스케일로 변경하고, 레이어 승격은 수동적으로 이루어져야 하기 때문이다.</p>
</blockquote>
<p><strong>페인트 영역을 줄이는 것</strong>은 일반적으로 다음과 같은 방법을 통해 이루어질 수 있다.</p>
<ol>
<li>애니메이션과 트랜지션이 가능한 겹치지 않도록 조율하는 것</li>
<li>한 페이지의 특정 부분에 애니메이션을 적용하는 것을 피하는 것</li>
</ol>
<h3 id="페인트-복잡성-단순화"><a class="header" href="#페인트-복잡성-단순화"><strong>페인트 복잡성 단순화</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/profiler-chart.jpg"/>
<p>페인트는 작업에 따라 그 비용에 차이가 있다. 다만, 이 기준이 CSS 관점에서 항상 명확한 것은 아니다.
페인트 프로파일러를 사용하면 현재 페인트 작업에 어느 정도의 비용이 드는지를 확인할 수 있고, 이를 대체하기 위한 스타일링에 대해 생각해볼 수 있다.</p>
<p>프레임 당 <strong>10ms</strong>는 일반적으로, 특히 모바일 디바이스에서는 페인팅 작업을 수행할 만큼 긴 시간이 아니다.
때문에 애니메이션 도중에는 항상 페인팅 작업을 피하기를 원할 수 있다.</p>
<h2 id="합성-composition-최적화"><a class="header" href="#합성-composition-최적화">합성 (Composition) 최적화</a></h2>
<p>합성은 화면에 표시하기 위해 페이지에서 페인트된 부분들을 합치는 과정이다.
이 영역에서 페이지 성능에 영향을 주는 두 가지 핵심 요소가 있다.</p>
<ol>
<li>관리가 필요한 컴포지터 레이어 수</li>
<li>애니메이션에 사용하는 속성</li>
</ol>
<h3 id="애니메이션에-변형transform-또는-불투명도opacity-변경을-사용하라"><a class="header" href="#애니메이션에-변형transform-또는-불투명도opacity-변경을-사용하라"><strong>애니메이션에 변형(<code>transform</code>) 또는 불투명도(<code>opacity</code>) 변경을 사용하라</strong></a></h3>
<p>앞서 레이아웃과 페인트를 모두 피하고 <strong>합성</strong>에 대한 변경만 요구하는 픽셀 파이프라인이 최고의 성능을 제공한다고 살펴봤었다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/stick-to-compositor-only-properties-and-manage-layer-count/frame-no-layout-paint.jpg"/>
<p>이를 위해서는 컴포지터가 혼자서 처리할 수 있는 변경 속성을 사용해야 하는데, 현재로서 <strong>이에 해당하는 것은 <code>transform</code>과 <code>opacity</code> 두 가지 속성 뿐이다.</strong></p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/stick-to-compositor-only-properties-and-manage-layer-count/safe-properties.jpg" />
<p>해당 속성들을 사용할 시에 주의할 점은 이러한 속성을 변경하는 요소가 자체적인 컴포지터 레이어에 있어야 하는데, <strong>즉, 레이어를 만들기 위해 요소를 승격해야 한다.</strong></p>
<blockquote>
<p><strong>참고</strong> : 애니메이션을 이 속성들로만 제한할 수 없을 것 같다고 생각되면 <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP 원칙</a>을 참조하라. 이는 비용이 많이 드는 속성을 <code>transform</code>과 <code>opacity</code>를 이용한 방법으로 다시 작성하도록 도와준다.</p>
</blockquote>
<h3 id="애니메이션-적용-요소를-승격해라"><a class="header" href="#애니메이션-적용-요소를-승격해라"><strong>애니메이션 적용 요소를 승격해라</strong></a></h3>
<p>위의 페인트 최적화 섹션에서 언급한 것처럼, 애니메이션 적용 요소에 대해 자체 레이어로 승격해야 한다.</p>
<pre><code class="language-css">.moving-element {
  will-change: transform;
}
</code></pre>
<p>또는 이전 브라우저나 <code>will-change</code>를 지원하지 않는 브라우저에 대해서는 다음을 사용한다.</p>
<pre><code class="language-css">.moving-element {
  transform: translateZ(0);
}
</code></pre>
<h3 id="레이어-관리-및-레이어-급증-피하기--요소를-불필요하게-레이어-승격하지-마라"><a class="header" href="#레이어-관리-및-레이어-급증-피하기--요소를-불필요하게-레이어-승격하지-마라"><strong>레이어 관리 및 레이어 급증 피하기 : 요소를 불필요하게 레이어 승격하지 마라</strong></a></h3>
<p>레이어 승격이 성능 개선에 도움이 된다고 해서 페이지 모든 요소를 승격시켜버리는 것이 자칫 이상적으로 들릴지 모른다.</p>
<pre><code class="language-css">* {
  will-change: transform;
  transform: translateZ(0);
}
</code></pre>
<p>이 경우의 문제는, 생성하는 모든 레이어가 메모리 및 관리가 요구되며, 이는 공짜로 생겨나는 것이 아니라는 점이다. 결국, 무작정 레이어를 생성하는 경우 오히려 안하느니만 못하다.</p>
<h2 id="입력-핸들러-디바운싱"><a class="header" href="#입력-핸들러-디바운싱">입력 핸들러 디바운싱</a></h2>
<p>입력 핸들러는 프레임 완성을 차단시킬 수 있기 때문에 불필요한 추가 레이아웃 작업을 유발할 수 있다.</p>
<h3 id="오래-걸리는-입력-핸들러를-피하라"><a class="header" href="#오래-걸리는-입력-핸들러를-피하라"><strong>오래 걸리는 입력 핸들러를 피하라</strong></a></h3>
<p>가장 빠른 경우의 예시를 먼저 들자면, 이용자가 페이지와 상호작용할 때, 페이지의 컴포지터 쓰레드가 이용자의 터치 입력을 감지하고, 컨텐츠를 단순히 이동시킨다.
이 경우, 메인 쓰레드에서 요구되는 동작(JS, 레이아웃, 스타일, 페인트)이 없다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/compositor-scroll.jpg" />
<p>그런데, 만약 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code>와 같은 입력 핸들러를 추가한다면, 컴포지터 쓰레드는 해당 핸들러의 처리과정이 끝날때까지 기다려야 한다.
왜냐하면 <code>preventDefault()</code>가 호출될지도 모르기 때문인데, 만약 호출되었다면 컴포지터 쓰레드는 기본 스크롤 동작을 멈춰야만 한다.</p>
<p>심지어 <code>preventDefault()</code>를 호출하지 않았더라도, 컴포지터는 기다려야만 한다. 이처럼 컴포지터가 기다리는 동안에 이용자의 스크롤 동작을 막게 되며, 이에 따라 버벅거리거나 프레임이 손실되는 결과가 나타난다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/ontouchmove.jpg" />
<p>쉽게 말해, <strong>입력 핸들러는 빠르게 처리되어야 한다.</strong> 그래야 컴포지터가 원래 해야하는 일을 할 수 있으니까.</p>
<h3 id="입력-핸들러-내에서의-스타일-변경을-피하라"><a class="header" href="#입력-핸들러-내에서의-스타일-변경을-피하라"><strong>입력 핸들러 내에서의 스타일 변경을 피하라</strong></a></h3>
<p>스크롤과 터치 같은 입력 핸들러들은 <code>requestAnimationFrame</code> 콜백 이전에 실행되도록 되어있다.
만약 이러한 핸들러 내부에서 스타일 변경을 시도한다면, <code>requestAnimationFrame</code>이 시작될 때 스타일 변경이 보류된다.</p>
<p>만약 <code>requestAnimationFrame</code> 콜백이 시작할 때 스타일 정보들을 읽어오고자 한다면, 위쪽에서 언급했던 **강제 동기 레이아웃(Forced synchronous layout)**이 발생한다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/frame-with-input.jpg" />
<h3 id="스크롤-핸들러-디바운스"><a class="header" href="#스크롤-핸들러-디바운스"><strong>스크롤 핸들러 디바운스</strong></a></h3>
<p>위의 두가지 문제(입력 핸들러 간소화 + 핸들러 내 스타일 변경 회피)를 해결하는 방법은 동일한데, 시각적 변경에 대해 항상 다음 <code>requestAnimationFrame</code> 콜백으로 디바운스 하는 것이다.</p>
<pre><code class="language-js">function onScroll(evt) {
  // Store the scroll value for laterz.
  lastScrollY = window.scrollY;

  // Prevent multiple rAF callbacks.
  if (scheduledAnimationFrame) return;

  scheduledAnimationFrame = true;
  requestAnimationFrame(readAndUpdatePage);
}

window.addEventListener('scroll', onScroll);
</code></pre>
<p>이 경우, 컴퓨팅 비용이 많이 드는 코드에서도 스크롤이나 터치를 차단하지 않으므로 입력 핸들러를 가볍게 유지할 수 있다는 이점이 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="custom-element-checklist"><a class="header" href="#custom-element-checklist">Custom Element CheckList</a></h1>
<blockquote>
<p>출처 : <a href="https://developers.google.com/web/fundamentals/web-components/best-practices?authuser=0">Google Developers</a></p>
</blockquote>
<p>커스텀 요소들은 HTML을 확장하여 본인 스스로의 태그를 갖게 해준다. 해당 기능은 어마어마하지만, 저수준의 기능이기도 해서, 어떻게 활용하는 것이 제일 좋은지 불명확한 경우가 많다.</p>
<p>커스텀 요소를 최적으로 활용하기 위해 해당 체크리스트를 확인하자. 제대로 동작하는 커스텀 요소들을 구성하는 내용들을 나눈 것이다.</p>
<h2 id="체크리스트"><a class="header" href="#체크리스트">체크리스트</a></h2>
<h3 id="shadow-dom-1"><a class="header" href="#shadow-dom-1"><strong>Shadow DOM</strong></a></h3>
<ul>
<li>
<p>스타일을 캡슐화하기 위해 섀도우 루트를 생성하라</p>
<blockquote>
<p>섀도우 루트에 스타일링을 캡슐화 시키는 것은 어디에서 해당 요소가 사용되든 해당 스타일링이 적용될 것을 보장한다.</p>
</blockquote>
</li>
<li>
<p>섀도우 루트는 <code>constructor</code> 내에서 생성하라</p>
<blockquote>
<p><code>constuctor</code>는 요소 본인에 관한 지식들을 보관하는 곳이다. 따라서 여기에는 다른 요소들을 활용하지 않는 구현 디테일들을 설정하기 적절하다. <br/> 만약, <code>connectedCallback</code>에서 이런 내용들을 수행하면, 요소가 분리/연결되는 경우의 상황을 고려해야 한다.</p>
</blockquote>
</li>
<li>
<p>커스텀 요소가 생성하는 하위 요소들은 섀도우 루트 안에 넣어라</p>
<blockquote>
<p>커스텀 요소에 의해 생성된 자식들은 <code>private</code>해야한다. 만약 섀도우 루트의 보호가 없다면, 해당 자식 요소들은 외부 JS에 의해 간섭받을 수 있다.</p>
</blockquote>
</li>
<li>
<p>light DOM에서의 자식들을 반영하기 위해 <code>&lt;slot&gt;</code>을 사용해라</p>
<blockquote>
<p><code>&lt;slot&gt;</code>을 활용하면 커스텀 요소가 담고 있는 요소들을 이용자들이 지정하기 편하게 만들 수 있다.</p>
</blockquote>
</li>
<li>
<p>기본적으로 <code>inline</code>으로 설정된 스타일링을 원하는 게 아니라면, <code>:host</code>의 <code>display</code> 스타일을 변경하라.</p>
</li>
</ul>
<blockquote>
<p>기본적으로 커스텀요소는 <code>display: inline</code> 설정을 갖는다. 따라서 단순히 <code>width</code>나 <code>height</code>를 설정하는 것은 아무 영향도 없다. 만약, 애초에 <code>inline</code> 디스플레이 설정을 의도하는 게 아니라면, 적절히 변경하라.</p>
</blockquote>
<ul>
<li><code>hidden</code> 속성에 대응하기 위한 <code>:host</code> 디스플레이 스타일을 추가하라
<blockquote>
<p>섀도우 루트에서 <code>:host</code>로 스타일링을 하게되면 이는 HTML 자체적인 <code>hidden</code> 속성을 덮어씌우게 된다. 때문에, <code>:host([hidden]) { display: none }</code>와 같은 식으로, <code>hidden</code>속성을 갖고 있는 경우에 대해 적절한 스타일링 처리가 필요하다.</p>
</blockquote>
</li>
</ul>
<h3 id="속성attributes와-프로퍼티"><a class="header" href="#속성attributes와-프로퍼티"><strong>속성(Attributes)와 프로퍼티</strong></a></h3>
<ul>
<li>글로벌 속성(global attributes)들을 덮어쓰지(override) 말아라
<blockquote>
<p>글로벌 속성들은 모든 HTML 요소들에 존재하는 것이다. 예를 들면 <code>tabindex</code>와 <code>role</code>이 이에 해당한다. 커스텀 요소가 기본적으로 <code>tabindex</code>를 0으로 초기화하게끔 설정하고 싶을 수도 있다. 그러나 항상 해당 커스텀 요소를 사용하는 개발자가 이를 다른 값으로 설정할 수 있음을 유의해라. 때문에 아래와 같은 체크가 필요하다.</p>
</blockquote>
</li>
</ul>
<pre><code class="language-js">connectedCallback() {
  if (!this.hasAttribute('role'))
    this.setAttribute('role', 'checkbox');
  if (!this.hasAttribute('tabindex'))
    this.setAttribute('tabindex', 0);
</code></pre>
<ul>
<li>
<p>항상 원시(primitive) 데이터들을 속성 혹은 프로퍼티 모두로 가져올 수 있게 하라.</p>
<blockquote>
<p>커스텀 요소들은 수정가능해야 한다. 그리고 이러한 수정은 속성 혹은 프로퍼티 어느쪽으로든 적절히 이루어질 수 있어야 한다. 결국, 이상적으로 모든 원시 속성들은 프로퍼티와 연결되어 있어야 한다.</p>
</blockquote>
</li>
<li>
<p>원시 데이터 속성과 프로퍼티들을 항상 동기화(sync)시키도록 해라. 프로퍼티는 속성에 반영되어야하고, 반대도 마찬가지다.</p>
<blockquote>
<p>요소를 활용하는 사람들이 어떤 식으로 해당 요소와 상호작용 할지는 알 수 없다. 때문에 속성과 프로퍼티가 서로를 항상 반영하도록 해야한다. 물론 예외도 존재한다. 비디오 플레이어의 <code>currentTime</code>과 같은 너무 변경 빈도가 잦은 프로퍼티는 매번 속성에 반영하는 것이 부적절하다.</p>
</blockquote>
</li>
<li>
<p>Object, Array와 같은 리치 데이터(rich data)들은 프로퍼티로만 받아와라</p>
<blockquote>
<p>사실,애초에 내장 HTML 요소에서 속성을 통해 이러한 류의 데이터를 받아들이는 예시 자체가 없다. 대신에 이런 데이터들은 메서드 호출이나 프로퍼티를 통해서 전달된다. 만약, 굳이 이들을 속성으로 전달하고자 하는 경우, 명확한 단점들이 몇가지 있다. 1) 거대한 객체를 문자열로 직렬화(Serialize)하는데에 너무 많은 비용이 들고, 2) 또한 이 문자열화(Stringify) 과정에서 객체에 대한 참조가 사라질 수도 있다.</p>
</blockquote>
</li>
<li>
<p>요소를 업그레이드하기 이전에, 이미 설정되었을지도 모르는 프로퍼티를 체크해봐라</p>
<blockquote>
<p>커스텀 요소를 활용하는 개발자들이 해당 요소를 불러오기 이전에 먼저 프로퍼티를 설정할지도 모른다. 이런 상황은 종종 로딩 컴포넌트를 핸들링하거나, 해당 컴포넌트를 페이지에 찍어내거나, 해당 프로퍼티를 모델에 바인딩하는 프레임워크를 사용하거나 할 때 종종 발생한다.</p>
</blockquote>
</li>
<li>
<p>클래스를 자동으로 적용시키지 마라</p>
<blockquote>
<p>요소들은 본인의 상태를 속성을 통해서 나타내야 한다. <code>class</code> 속성을 해당 요소를 사용하는 개발자들에 의한 것으로 간주되어야 하며, 이를 임의로 자동으로 설정하는 경우 개발자들의 <code>class</code> 관리를 망쳐버릴 수 있다.</p>
</blockquote>
</li>
</ul>
<h3 id="events"><a class="header" href="#events"><strong>Events</strong></a></h3>
<ul>
<li>내부 컴포넌트 활동에 따라 적절히 이벤트를 디스패치하라
<blockquote>
<p>오직 컴포넌트 본인만 알 수 있는 활동이 있을 수 있다. 이를테면 타이머나 애니메이션 완료, 혹은 로딩이 완료되는 시점과 같은 것들이다. 이러한 변화에 따라, 호스트에게 해당 컴포넌트의 상태가 변경되었음을 알려주게끔 이벤트를 전달하는 것이 좋다.</p>
</blockquote>
</li>
<li>프로퍼티 설정에 대해서는 별도로 이벤트를 디스패치할 필요없다.
<blockquote>
<p>호스트가 프로퍼티를 설정한 내용에 대해 이벤트를 전달하는 것은 불필요하다. 호스트가 직접 설정한 내용이기 때문에 현재 상태를 직접 인지할 수 있기 때문이다. 또한, 호스트가 프로퍼티를 설정한 것에 대한 반응으로 이벤트를 전달하는 경우, 데이터 바인딩과 함께 무한 루프를 유발할 수 있다.</p>
</blockquote>
</li>
</ul>
<h2 id="explainers"><a class="header" href="#explainers"><strong>Explainers</strong></a></h2>
<h3 id="프로퍼티를-lazy하게-만들어라"><a class="header" href="#프로퍼티를-lazy하게-만들어라">프로퍼티를 Lazy하게 만들어라</a></h3>
<p>개발자가 커스텀 요소를 불러오기 전에 먼저 프로퍼티를 설정하고자 할 수도 있다. 이는 로딩 컴포넌트를 다루는 프레임워크 등에서 특히 이루어진다.</p>
<p>아래 예시에서는, Angular가 <code>isChecked</code> 프로퍼티를 체크박스의 <code>checked</code> 프로퍼티에 바인딩하려고 한다. 만약 해당 커스텀 요소가 <strong>lazy-load</strong>된다면 Angular는 요소가 업그레이드되기 이전에 먼저 <code>checked</code>프로퍼티를 설정할 수 있을 것이다.</p>
<pre><code class="language-html">&lt;howto-checkbox [checked]=&quot;defaults.isChecked&quot;&gt;&lt;/howto-checkbox&gt;
</code></pre>
<p>커스텀 요소는 본인의 인스턴스에 어떤 요소가 이미 설정되어 있는지에 대해 확인함으로써 이러한 경우를 다룰 수 있다. 아래에서 <code>_upgradeProperty()</code> 메서드가 그러한 역할을 한다.</p>
<pre><code class="language-js">connectedCallback() {
  ...
  this._upgradeProperty('checked');
}

_upgradeProperty(prop) {
  if (this.hasOwnProperty(prop)) {
    let value = this[prop];
    delete this[prop];
    this[prop] = value;
  }
}
</code></pre>
<p><code>_upgradeProperty()</code>는 업그레이드되지 않은 인스턴스로부터 값을 가져온 후, 프로퍼티를 삭제하여 커스텀 요소가 자체적인 프로퍼티 <code>setter</code>를 사용하지 않도록 만든다. 이를 통해, 커스텀 요소가 최종적으로 로드되었을 때, 곧바로 수정된 상태를 반영할 수 있도록 만든다.</p>
<h3 id="재방문-이슈reentrancy-issues를-피해라"><a class="header" href="#재방문-이슈reentrancy-issues를-피해라">재방문 이슈(reentrancy issues)를 피해라</a></h3>
<p><code>attributeChangeCallback()</code>을 사용하여 상태를 기본 프로퍼티에 반영되도록 하자.</p>
<pre><code class="language-js">// When the [checked] attribute changes, set the checked property to match.
attributeChangedCallback(name, oldValue, newValue) {
  if (name === 'checked')
    this.checked = newValue;
}
</code></pre>
<p>헌데, 프로퍼티 설정자가 속성에도 반영되는 경우 무한 루프를 만들어내는 문제가 발생한다.</p>
<pre><code class="language-js">set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    // OOPS! This will cause an infinite loop because it triggers the
    // attributeChangedCallback() which then sets this property again.
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}
</code></pre>
<p>이에 대한 대안으로, 프로퍼티에 대한 setter와 getter를 모두 만들어 getter가 속성에 따라 값을 결정하도록 할 수 있다.</p>
<pre><code class="language-js">set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}

get checked() {
  return this.hasAttribute('checked');
}
</code></pre>
<p>이제, 속성을 삭제하거나 추가하는 작업은 프로퍼티에도 영향을 미칠 것이다.</p>
<p>끝으로, <code>attributeChangedCallback()</code>는 ARIA 상태를 적용하는 것과 같은 사이드 이펙트를 처리하는 데에 사용해라.</p>
<pre><code class="language-JS">attributeChangedCallback(name, oldValue, newValue) {
  const hasValue = newValue !== null;
  switch (name) {
    case 'checked':
      // Note the attributeChangedCallback is only handling the *side effects*
      // of setting the attribute.
      this.setAttribute('aria-checked', hasValue);
      break;
    ...
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>해당 문서에서는 <strong>이펙티브 타입스크립트</strong>를 읽고 스스로 정리해보도록 합니다. 제 개인적인 학습과 스터디를 목적으로 하고 있으며, 당연히 책의 모든 내용을 다루고 있지는 않습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트-알아보기"><a class="header" href="#타입스크립트-알아보기">타입스크립트 알아보기</a></h1>
<p>해당 챕터에서는 타입스크립트의 큰 그림을 이해하는데 도움이 될 내용을 다룹니다.</p>
<ul>
<li>타입스크립트는 무엇인지?</li>
<li>타입스크립트를 어떻게 여겨야 하는지?</li>
<li>자바스크립트와는 무슨 관계인지?</li>
<li>등등...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ts와-js의-관계"><a class="header" href="#ts와-js의-관계">TS와 JS의 관계</a></h1>
<p>많은 문서와, 웹 상의 여러 글들에서 타입스크립트는 다음과 같은 말로 정의됩니다.</p>
<blockquote>
<p>타입스크립트는 자바스크립트의 슈퍼셋(Superset = 상위집합)이다.</p>
</blockquote>
<p>이는 정확히 무엇을 의미할까요?</p>
<h2 id="실제로-ts는-문법적으로-js의-상위집합입니다"><a class="header" href="#실제로-ts는-문법적으로-js의-상위집합입니다">실제로 TS는 문법적으로 JS의 상위집합입니다.</a></h2>
<p>기존에 JS였던 파일의 확장자를 TS로 바꾼다고 해서 동작이 불가능하다거나 하지 않습니다. 하지만, 거꾸로 TS였던 파일들에 대해서는 JS로 확장자를 바꿀 때 모든 경우에 동작한다고 보장할 수 없습니다.</p>
<h2 id="타입스크립트는-정적-타입-시스템입니다"><a class="header" href="#타입스크립트는-정적-타입-시스템입니다">타입스크립트는 <strong>정적</strong> 타입 시스템입니다.</a></h2>
<p>기존 JS의 타입 체계는 동적입니다. 이러한 JS의 특징이 갖는 문제점은 바로 런타임 에러를 잡아내는 것이 쉽지않다는 것이죠. 타입 시스템의 목표 중 하나는 이러한 런타임 에러를 사전에 찾아내는 것입니다.
타입 스크립트가 정적 타입 시스템이라는 것은 바로 이 특징을 말하는 것인데, 그렇다고 해서 타입 체커가 모든 오류를 발견해낼 것이라고 보장할 수는 없죠.</p>
<p>기본적으로 타입스크립트에는 **타입 추론 (Type Inference)**이라는 것이 있어, 별도로 타입을 지정해주지 않더라도, 특정 변수의 타입이 명확한 경우에는 스스로 해당 타입을 정의해나갑니다.
이 덕분에 별도의 타입 구문 없이도 쓸만하지만, 직접 타입 구문을 추가해나간다면 훨씬 더 많은 오류를 사전에 잡아내고, 또 코드의 &quot;의도&quot;에 대해 타입스크립트에게 더 잘 전달해줄 수 있습니다.</p>
<h2 id="얼마나-엄격하게-작성할-것인가는-온전히-개발자의-몫입니다"><a class="header" href="#얼마나-엄격하게-작성할-것인가는-온전히-개발자의-몫입니다">'얼마나 엄격하게 작성할 것인가?'는 온전히 개발자의 몫입니다.</a></h2>
<p>확장자가 <code>.ts</code>인 파일을 작성하더라도, 편의를 위해 <code>any</code> 타입을 반복적으로 사용하고, 그저 JS를 쓰듯이 문법을 작성해나간다면, 굳이 TS를 쓸 이유가 없습니다.
거꾸로 완전 엄격한 형태로 TS를 작성하고자 하는 것도 쉬운 일이 아니죠. 그만큼 작성해야 할 타입 구문의 양이 많아지게 됩니다.
결국 얼마나 엄격한 형태로 개발을 해나갈 것이냐에 대한 문제는 온전히 취향의 차이이며, 우열을 가릴 수도 없는 문제라고 할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ts-설정-이해하기"><a class="header" href="#ts-설정-이해하기">TS 설정 이해하기</a></h1>
<p>아래의 코드는 오류 없이 타입 체커를 통과할 수 있을까요?</p>
<pre><code class="language-ts">function add(a, b) {
  return a + b;
}

add(10, null);
</code></pre>
<p>사실, 이건 설정이 어떻게 되어있으냐에 따라서 정답이 달라지는 문제입니다. TS 컴파일러는 무수한 설정을 갖고있습니다. 이는 CLI를 통해서, 또는 <code>tsconfig.json</code> 파일을 통해서 이루어질 수 있죠.</p>
<p>최초의 설정파일은 아래 CLI 명령으로 간단하게 생성할 수 있습니다.</p>
<pre><code>tsc --init
</code></pre>
<p>여기서는 100개가 넘는 TS 컴파일러의 설정들을 모두 짚고 넘어가지는 않을 겁니다. 대부분은 어디서 소스파일을 찾을지, 어떤 종류의 출력을 생성할지에 대해 제어하는 내용입니다.</p>
<p>반면, 언어 자체의 핵심 요소들을 제어하는 설정도 있는데, 대부분의 언어에서는 이를 허용하지 않는 고수준 설계의 설정입니다. 이를 어떻게 설정하느냐에 따라 완전히 다른 언어처럼 느낄 수도 있죠.</p>
<p>설정을 제대로 이해하려면 <code>noImplicitAny</code>와 <code>strictNullChecks</code> 설정에 대해 이해해야 합니다.</p>
<h2 id="noimplicitany"><a class="header" href="#noimplicitany">noImplicitAny</a></h2>
<p><code>noImplicitAny</code>는 변수들이 미리 정의된 타입을 가져야 하는지에 대한 여부를 제어합니다. 즉, 이를 설정할 경우 모든 변수들에 대해 직접 지정해주지 않는 한, <code>any</code> 타입을 허용하지 않습니다.
가급적 해당 설정은 기본적으로 가져가는 것이 좋습니다. 타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문이죠. 한 가지 예외라면, 기존에 JS로 작성되어 있던 프로젝트를 TS로 마이그레이션 해나가는 과정에서는 필요할 수도 있죠.
이 부분에 대해서는 추후에 다시 다뤄보도록 하겠습니다.</p>
<h2 id="strictnullchecks"><a class="header" href="#strictnullchecks">strictNullChecks</a></h2>
<p><code>strictNullChecks</code>는 <code>null</code>과 <code>undefined</code>가 모든 타입에서 허용되는지 확인하는 설정입니다. 이 경우, <code>string | null</code>과 같이 명시적으로 해당 변수가 <code>null</code> 타입이 될 수 있음을 알려주지 않으면, 에러가 발생합니다.</p>
<p>이러한 경우, 다음과 같은 Null Checking이나 Assertion이 필요하게 됩니다.</p>
<pre><code class="language-ts">// Null Check
if (el) {
  el.textContent = 'Ready';
}

// Type Assertion
el!.textContent = 'Ready';
</code></pre>
<p>해당 설정은 <code>null</code>과 <code>undefined</code>에 관련된 오류를 잡아 내는 데에 많은 도움을 주지만, 코드 작성이 비교적 어려워집니다. 프로젝트를 처음 생성한다면 이를 설정하는 것이 좋지만, JS 코드를 마이그레이션 해나가는 과정이라면 설정하지 않아도 괜찮습니다.
<code>strictNullCheck</code>를 설정하려면 <code>noImplicitAny</code>를 먼저 설정해야 합니다.</p>
<p>해당 설정이 필요한 이유는, 이것이 없을 경우 &quot;<strong><code>undefined</code>가 객체가 아닙니다</strong>&quot;라는 끔찍한 런타임 오류를 매번 마주할 수 있기 때문입니다. 프로젝트가 커질 수록 이러한 부분들이 훨씬 까다로워지기 때문에, 가능한 초기에 설정하는 것이 좋습니다.</p>
<p>그 밖에 언어에 의미적으로 영향을 미치는 설정(<code>noImplicitThis</code>, <code>strictFunctionTypes</code>)이 많지만, 앞의 두 설정만큼이나 중요한 것은 없습니다. 이 모든 타입 체크들을 설정하여 엄격한 환경 내에서 개발을 하고싶다면, <code>strict</code>를 설정하면 됩니다. 이 경우 대부분의 에러를 잡아냅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="코드-생성과-타입이-관계없음을-이해하기"><a class="header" href="#코드-생성과-타입이-관계없음을-이해하기">코드 생성과 타입이 관계없음을 이해하기</a></h1>
<p>큰 그림에서, 타입스크립트 컴파일러는 다음의 두 가지 역할을 수행합니다.</p>
<ul>
<li>최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 트랜스파일합니다.</li>
<li>코드의 타입 에러를 체크합니다.</li>
</ul>
<p>여기서 놀라운 점은, 위의 두가지는 완벽히 별개의 일이라는 겁니다. 즉 어느 한쪽이 제대로 이루어지지 않더라도 다른 한쪽이 이루어지는데는 문제가 없습니다.</p>
<h2 id="타입-에러가-있어도-컴파일이-가능합니다"><a class="header" href="#타입-에러가-있어도-컴파일이-가능합니다">타입 에러가 있어도 컴파일이 가능합니다</a></h2>
<p>타입 체크와 컴파일이 동시에 이루어지는 자바나 C 같은 언어에서는 이것이 굉장히 황당할 겁니다. TS에서의 타입 에러는 C나 자바에서의 경고(WARNING)에 가깝습니다.
즉, 문제가 될 부분을 알려주지만, 그렇다고 해서 빌드하는 것을 멈추지는 않습니다.</p>
<p>이런 부분 떄문에, 얼핏 TS가 엉성한 언어처럼 보일 수 있지만, 오히려 이런 특징은 도움이 됩니다. TS는 타입 에러가 발생하더라도 여전히 컴파일링을 진행할 수 있기 때문에, 해당 부분 외의 애플리케이션은 여전히 테스트할 수 있는 상태가 됩니다.
만약, 에러가 발생했을 때 컴파일을 진행하지 않고자 한다면, <code>noEmitOnError</code>를 설정해주면 됩니다.</p>
<h2 id="런타임에는-타입-체크가-불가능합니다"><a class="header" href="#런타임에는-타입-체크가-불가능합니다">런타임에는 타입 체크가 불가능합니다</a></h2>
<p>자바스크립트로 컴파일되는 과정을 거치게 되면, 그 과정에서 모든 인터페이스, 타입, 그 외의 타입 구문들은 모두 제거됩니다.</p>
<p>만약 런타임 시에도 타입 정보를 유지하고자 한다면 몇 가지 방법이 있습니다.</p>
<h3 id="1-태그-기법"><a class="header" href="#1-태그-기법">1. &quot;태그&quot; 기법</a></h3>
<pre><code class="language-ts">interface Square {
  kind: 'square';
  width: number;
}

interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}

type Shape = Square | Rectangle;
</code></pre>
<p>위와 같이 인터페이스에 <code>kind</code> 값을 지정해서 런타임에서도 타입 정보를 손쉽게 유지할 수 있습니다. 런타임 시에 객체의 <code>kind</code>가 어떤 값인지를 체크하는 방식으로 이를 활용할 수 있죠. 이는 타입스크립트에서 실제로 흔하게 볼 수 있는 기법입니다.</p>
<h3 id="2-클래스"><a class="header" href="#2-클래스">2. 클래스</a></h3>
<pre><code class="language-ts">class Square {
  constructor(public width: number) {}
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle
</code></pre>
<p>클래스를 사용한다면 타입(런타임 접근 불가)와 값(런타임 접근 가능)을 동시에 사용할 수 있습니다. 위와 같이 선언된 클래스는 타입과 값 모두로 사용할 수 있게되므로 <code>shape instanceof Rectangle</code> 과 같은 형태로 런타임 타입 체크를 할 수 있습니다.</p>
<h2 id="타입-연산은-런타임에-영향을-주지-않습니다"><a class="header" href="#타입-연산은-런타임에-영향을-주지-않습니다">타입 연산은 런타임에 영향을 주지 않습니다</a></h2>
<p><code>value as number</code>와 같은 타입 연산은 실제로 컴파일된 이후의 런타임에는 아무런 역할도 하지 않습니다. 단순히 타입 체커에게 해당 <code>value</code>를 어떤 타입으로 고려하라고 알려줄 뿐입니다.</p>
<h2 id="런타임-타입은-선언된-타입과-다를-수-있습니다"><a class="header" href="#런타임-타입은-선언된-타입과-다를-수-있습니다">런타임 타입은 선언된 타입과 다를 수 있습니다</a></h2>
<p>타입스크립트에서는 런타임 타입과 선언된 타입이 매치되지 않는 상황이 생길 수도 있습니다. 이러한 상황은 가능한 피하는게 좋지만요.</p>
<h2 id="타입스크립트-타입으로는-함수를-오버로드할-수-없습니다"><a class="header" href="#타입스크립트-타입으로는-함수를-오버로드할-수-없습니다">타입스크립트 타입으로는 함수를 오버로드할 수 없습니다</a></h2>
<p>타입스크립트에도 함수 오버로딩 기능이 있긴 하지만, 그것은 온전히 타입 수준에서 동작하는 것입니다. 실제로 아래의 예시는 오직 하나의 함수만을 생성하죠.</p>
<pre><code class="language-ts">function add(a: number, b: number): number;
function add(a: string, b: string): string;
</code></pre>
<h2 id="타입스크립트-타입은-런타임-성능에-영향을-주지-않습니다"><a class="header" href="#타입스크립트-타입은-런타임-성능에-영향을-주지-않습니다">타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다</a></h2>
<p>여러 타입 구문은 JS로 변환되면서 전부 제거되기 떄문에, 실제 런타임의 성능에는 아무런 영향도 주지 않습니다. 따라서 타입스크립트의 정적 타입은 비용이 전혀 들지 않죠.</p>
<p>대신, 타입스크립트 컴파일러는 &quot;빌드타임&quot; 오버헤드가 있습니다. 다만 기본적으로 TS 컴파일러는 상당히 빠른 편이며, 특히 증분(Incremental) 빌드 시에 더욱 두드러집니다.
너무 오버헤드가 커진다면, 빌드 도구에서 트랜스파일만 진행(transpile only)하도록 설정하여 타입 체크를 건너뛸 수 있습니다.</p>
<p>타입스크립트가 컴파일하는 코드는 호환성을 높이고 성능 오버헤드를 감안할지, 아니면 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택할지의 문제에 맞닥뜨릴 수도 있습니다.
어떤 경우든지 이러한 호환성과 성능 간의 선택은 컴파일 타깃과 언어 레벨의 문제이며, 여전히 타입과는 전혀 무관합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="구조적-타이핑에-익숙해지기"><a class="header" href="#구조적-타이핑에-익숙해지기">구조적 타이핑에 익숙해지기</a></h1>
<p>JS는 본질적으로 덕 타이핑(Duck Typing) 기반입니다. 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용합니다.</p>
<p>TS도 이러한 특징을 그대로 고려하고 있습니다.</p>
<pre><code class="language-ts">interface Vector2D {
  x: number;
  y: number;
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}
</code></pre>
<p>이와 같이 정의를 한 상황에서, 아래와 같이 작성을 하더라도 아무런 문제가 없습니다.</p>
<pre><code class="language-ts">const v: NamedVector = { x: 3, y: 4, name: 'Zee' };
calculateLength(v); // 5
</code></pre>
<p>여기서 유의할 점은, <code>NamedVector</code>와 <code>Vector2D</code>의 관계에 대해서는 전혀 선언한 바가 없다는 것입니다. 기본적으로 TS의 타입 시스템은 JS의 런타임 동작을 모델링합니다. <code>NamedVector</code>의 구조가 <code>Vector2D</code>와 호환되기 때문에, 위의 코드는 정상으로 간주됩니다.
이렇듯 JS의 덕 타이핑을 모델링하기 위해 TS가 활용하는 타이핑 체계를 **구조적 타이핑(Structural Typing)**이라고 합니다.</p>
<p>이러한 특징이 오히려 문제를 일으키는 경우도 있을 수 있습니다. 하지만 이것이 좋든, 싫든 간에 TS에서 모든 타입은 열려(Open)있고, 봉인(Sealed)되어 있지 않습니다.</p>
<p>다만, 이러한 특징은 테스트에서는 오히려 도움이 됩니다. 특정 함수가 받는 매개변수의 인터페이스 규격에 맞기만 한다면, 이를 작성하고 테스트하는데 문제가 없기 때문이죠.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="any-타입-지양하기"><a class="header" href="#any-타입-지양하기">any 타입 지양하기</a></h1>
<p>타입스크립트의 타입 시스템은 다음과 같습니다.</p>
<ul>
<li>점진적(Gradual) - 프로젝트 전체에 타입을 추가할 필요 없이, 일부에 대해서만 사용할 수 있습니다.</li>
<li>선택적(Optional) - 언제든지 타입 체커를 해제할 수 있습니다.</li>
</ul>
<p>위 기능들의 핵심은 <code>any</code> 타입입니다.</p>
<p>타입스크립트가 발견해내는 대부분의 오류들은 사실 <code>any</code> 타입을 사용한다면 거의 대부분 넘어갈 수 있습니다.
하지만, 일부 특별한 경우를 제외하고는 <code>any</code> 타입의 사용은 TS의 수많은 장점을 누릴 수 없게 만듭니다.</p>
<h2 id="any-타입에는-타입-안전성이-없습니다"><a class="header" href="#any-타입에는-타입-안전성이-없습니다">any 타입에는 타입 안전성이 없습니다</a></h2>
<pre><code class="language-ts">let age: number;
age = &quot;12&quot; as any; // 문제 없음
</code></pre>
<p>분명 <code>age</code>는 <code>number</code> 타입이지만, <code>any</code> 타입을 통해 <code>string</code>을 할당했습니다. 이 경우 타입을 지정한 의미 자체가 없어진 셈입니다.</p>
<h2 id="any는-함수-시그니처를-무시해버립니다"><a class="header" href="#any는-함수-시그니처를-무시해버립니다">any는 함수 시그니처를 무시해버립니다</a></h2>
<p>함수 작성 시에는 시그니처를 명시해야 합니다. 즉, 함수의 호출과 출력에는 각각 약속된 타입이 정해져있어야 합니다. <code>any</code>는 이 자체를 무시합니다. JS에서는 암묵적인 Type Coercion이 빈번하게 일어나기 때문에, 이런 상황에서 특히 문제가 될 수 있습니다.</p>
<h2 id="any-타입은-ide-상의-피드백을-받을-수-없습니다"><a class="header" href="#any-타입은-ide-상의-피드백을-받을-수-없습니다">any 타입은 IDE 상의 피드백을 받을 수 없습니다</a></h2>
<p>기본적으로 적절한 타입을 지정해준다면 에디터는 상황에 따라 적절한 자동완성 기능과 도움말을 제공합니다. 그런데 <code>any</code> 타입의 사용은 이러한 피드백을 전혀 받아볼 수 없게 만듭니다.</p>
<h2 id="any-타입은-코드-리팩토링-시-버그를-감춥니다"><a class="header" href="#any-타입은-코드-리팩토링-시-버그를-감춥니다">any 타입은 코드 리팩토링 시 버그를 감춥니다</a></h2>
<p>리팩토링 시 적절한 타입의 유추가 어렵다는 이유로 <code>any</code>를 사용하게 되면, 리팩토링을 진행하는 도중에 발견해야할 에러를 알아내기 어렵습니다. 리팩토링에 앞서 구체적인 타입의 지정이 요구되는 이유입니다.</p>
<h2 id="any는-타입-설계를-감춰버립니다"><a class="header" href="#any는-타입-설계를-감춰버립니다">any는 타입 설계를 감춰버립니다</a></h2>
<p>애플리케이션의 상태 객체의 정의는 상당히 복잡합니다. 상태 객체 안의 수많은 프로퍼티 타입을 일일이 작성해야 하는데, 이는 사실 <code>any</code> 하나로 뚝딱 해결해버릴 수도 있습니다.
물론 이 때도 <code>any</code>를 사용해선 안 됩니다. 상태 객체가 어떻게 구성되어 있는지에 대한 인터페이스 자체를 감춰버리기 때문이죠.</p>
<h2 id="any는-타입-시스템의-신뢰도를-떨어뜨립니다"><a class="header" href="#any는-타입-시스템의-신뢰도를-떨어뜨립니다">any는 타입 시스템의 신뢰도를 떨어뜨립니다.</a></h2>
<p>사람은 누구나 실수를 합니다. 그런 상황에서 타입스크립트를 도입한다는 것은 곧 실수를 줄이기 위하여 신뢰할 만한 타입 체커를 구축해나간다는 것입니다.
헌데, <code>any</code> 타입의 사용은 이러한 타입 시스템 자체를 신뢰할 수 없게 만들어, TS를 쓰는 의미 자체를 잃어버리게 만듭니다.
코드에 존재하는 수많은 <code>any</code> 타입은 오히려 JS보다도 개발을 어렵게 만들 수 있습니다.</p>
<p>다만, 어쩔 수 없이 <code>any</code>를 써야만 하는 상황도 있습니다. 이에 대해서는 추후에 다뤄보도록 합시다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트의-타입-시스템"><a class="header" href="#타입스크립트의-타입-시스템">타입스크립트의 타입 시스템</a></h1>
<p>타입스크립트의 가장 중요한 역할은 타입 시스템에 있습니다. 해당 챕터에서는 타입 시스템의 기초를 살펴봅니다.</p>
<ul>
<li>타입 시스템이란 무엇인지?</li>
<li>어떻게 사용해야 하는지?</li>
<li>무엇을 결정해야 하는지?</li>
<li>가급적 사용하지 말아야 할 기능은 무엇인지?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="편집기를-사용하여-타입-시스템-탐색하기"><a class="header" href="#편집기를-사용하여-타입-시스템-탐색하기">편집기를 사용하여 타입 시스템 탐색하기</a></h1>
<p>타입스크립트를 설치하고 나면 다음의 두 가지를 실행할 수 있습니다.</p>
<ul>
<li>타입스크립트 컴파일러(<code>tsc</code>) : 일반적으로 사용하는 것</li>
<li>타입스크립트 서버(<code>tsserver</code>) : 백그라운드 상에서 타입스크립트 컴파일러를 동작시킬 수 있는 일종의 툴
<ul>
<li><a href="https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29">여기</a>에 따르면, VS Code는 자체적으로 <code>tsserver</code>를 통한 TypeScript의 언어 서비스를 지원하고 있습니다.</li>
</ul>
</li>
</ul>
<p>우리는 타입스크립트의 &quot;언어 서비스&quot;를 사용할 수 있는데, 이는 보통 에디터를 통해서 이루어지며, 별도로 타입스크립트 서버를 구축해서 이를 제공할 수도 있습니다.
&quot;언어 서비스&quot;에는 코드 자동완성, 명세(사양, Specification) 검사, 검색, 리팩토링이 포함됩니다.</p>
<p>타입스크립트를 제대로 활용하기 위해서는 이러한 언어 서비스를 적극적으로 활용하는 것이 좋습니다. VS Code 상에서 이를 활용하는 방법에 있어서는 <a href="https://code.visualstudio.com/docs/languages/typescript">여기</a>를 살펴봅시다.</p>
<p>에디터를 통하여 타입스크립트의 타입 시스템에 익숙해지기 위해 다음과 같은 방법들을 활용하는 것이 좋습니다.</p>
<ul>
<li>변수 위에 마우스 커서를 대면 TS가 해당 타입을 어떻게 판단하고 있는지 확인할 수 있습니다.</li>
<li>에디터 상에서 발생하는 타입 에러를 살펴볼 수 있습니다.</li>
<li>TS가 동작을 어떻게 모델링하는지 파악하기 위해선 타입 선언 파일을 찾아보는 것이 좋습니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입이-값들의-집합이라고-생각하기"><a class="header" href="#타입이-값들의-집합이라고-생각하기">타입이 값들의 집합이라고 생각하기</a></h1>
<p>타입스크립트에서의 타입은 <strong>할당 가능한 값들의 집합</strong>이라고 생각하면 이해가 쉽습니다.</p>
<h2 id="never"><a class="header" href="#never">never</a></h2>
<p>가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, TS 상에서는 <code>never</code>가 됩니다. 여기에는 아무런 값도 할당할 수 없습니다.</p>
<pre><code class="language-ts">const x: never = 12; // ERROR: '12' 형식은 never 타입에 할당할 수 없습니다.
</code></pre>
<h2 id="literal"><a class="header" href="#literal">literal</a></h2>
<p>그 다음 작은 집합은 한 가지 값만 포함하는 타입입니다. 이들은 TS 상에서 유닛(unit) 타입이라고도 불리는 리터럴(literal) 타입입니다.</p>
<pre><code class="language-ts">type A = 'A';
type B = 'B';
type Twelve = 12;
</code></pre>
<h2 id="union"><a class="header" href="#union">union</a></h2>
<p>가능한 타입을 여러 개로 묶은 것을 유니온(union) <code>|</code> 타입이라고 합니다.</p>
<pre><code class="language-ts">type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
</code></pre>
<h2 id="intersection"><a class="header" href="#intersection">intersection</a></h2>
<p>인터섹션(intersection) <code>&amp;</code> 타입은 각 인터페이스에 해당하는 모든 프로퍼티를 갖고 있어야 함을 의미합니다.</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person &amp; Lifespan;
</code></pre>
<h2 id="extends"><a class="header" href="#extends">extends</a></h2>
<p>다만 좀 더 일반적으로는 <code>extends</code> 키워드를 사용합니다. 타입은 일종의 집합이라는 관점에서, <code>extends</code>는 곧 <em>~의 부분집합</em> 이라는 의미로 이해할 수 있습니다.</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
</code></pre>
<p><code>extends</code> 키워드를 제네릭 타입에서 한정자로 쓰이기도 하는데, 이 때도 <em>~의 부분집합</em>이라는 의미가 됩니다.</p>
<pre><code class="language-ts">// 제네릭 타입 K는 string의 부분집합에 해당해야 합니다.
function getKey&lt;K extends string&gt;(val: any, key: K) {
  // ...
}

getKey({}, 'x'); // 정상
getKey({}, 12); // 12는 number이기 때문에 에러
</code></pre>
<h2 id="타입스크립트에서의-타입은-상속보다는-집합으로-이해하는-것이-편합니다"><a class="header" href="#타입스크립트에서의-타입은-상속보다는-집합으로-이해하는-것이-편합니다">타입스크립트에서의 타입은 상속보다는 집합으로 이해하는 것이 편합니다.</a></h2>
<p>결국, &quot;TS 상에서 어떤 값을 할당할 수 있느냐?&quot;라는 것은 해당 변수가 요구하는 타입 집합에 할당하고자 하는 값의 타입 집합이 부분 집합으로 속하느냐를 판단하는 것입니다. 이건 앞선 아이템4인 &quot;구조적 타이핑&quot;에서 설명했던 바와 유사합니다. 타입스크립트의 타입은 엄격한 상속 관계가 아니라, 겹쳐지는 집합의 형태로 표현될 수 있습니다. </p>
<p>집합의 관점에서 타입 시스템들을 이해한다면 아래와 같은 코드들도 쉽게 이해하고 작성할 수 있을겁니다.</p>
<pre><code class="language-ts">interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; // 'x' | 'y'

// 제네릭 타입을 사용한 함수의 경우, 이를 사용하는 시점에야 구체적인 타입이 확정됩니다.
function sortBy&lt;K extends keyof T, T&gt;(vals: T[], key: K): T[] {
  // ...
}

const points = [{x: 1, y: 1}, {x: 2, y: -2}];

// type T = { x: number; y: number };
// type K = 'x' | 'y';
sortBy(points, 'y');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-공간과-값-공간의-심벌-구분하기"><a class="header" href="#타입-공간과-값-공간의-심벌-구분하기">타입 공간과 값 공간의 심벌 구분하기</a></h1>
<p>타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중 한 곳에 존재합니다. 
이름이 같은 심벌이더라도 속하는 공간에 따라 서로 다른 것을 의미할 수 있기 때문에 혼란스러울 수 있습니다.</p>
<pre><code class="language-ts">interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) =&gt; ({radius, height});
</code></pre>
<p>작성한 코드에 따라, 이후 상황에 따라서 <code>Cylinder</code>란 심벌은 값으로 쓰일 수도, 타입으로 쓰일 수도 있습니다.
이런 경우, 추후에 혼란을 일으킬 여지가 많습니다.</p>
<p>초기에 타입 공간과 값 공간, 각각에 대한 개념을 잡고자 한다면 <a href="https://www.typescriptlang.org/play">TS Playground</a>를 활용해보세요.
TS가 JS로 컴파일링된 이후에도 심벌이 남아있다면 값일테고, 그렇지 않다면 타입일 겁니다.</p>
<h2 id="타입과-값-구분하기"><a class="header" href="#타입과-값-구분하기">타입과 값 구분하기</a></h2>
<p>TS 코드 상에서 타입과 값 심벌은 번갈아 나올 수 있습니다. 
일반적으로 타입선언(<code>:</code>) 또는 단언문(<code>as</code>) 다음 나오는 심벌은 타입인 반면, <code>=</code> 다음 나오는 모든 심벌은 값이 됩니다.</p>
<h2 id="타입과-값-모두로-사용될-수-있는-경우"><a class="header" href="#타입과-값-모두로-사용될-수-있는-경우">타입과 값 모두로 사용될 수 있는 경우</a></h2>
<h3 id="class-1"><a class="header" href="#class-1">class</a></h3>
<p>한편, <code>class</code>는 타입과 값 모두로 사용될 수 있습니다.</p>
<pre><code class="language-ts">class Cylinder {
  radius = 1;
  height = 1;
}

// 여기서 Cylinder는 인터페이스로 사용되었습니다.
interface NamedCylinder extends Cylinder {
    name: string;
}

const namedCylinder: NamedCylinder = {
    radius: 1,
    height: 2,
    name: 'alan',
}

// 여기서 Cylinder는 생성자로 사용되었습니다.
const cylinder = new Cylinder();
</code></pre>
<p>클래스는 타입으로 쓰일 때 인터페이스로 사용되는 반면, 값으로 쓰일 때 생성자로 사용됩니다.</p>
<h3 id="typeof"><a class="header" href="#typeof">typeof</a></h3>
<p>연산자 <code>typeof</code>도 타입과 값 모두에서 사용될 수 있는데, 이는 비슷하면서도 상당히 다릅니다.</p>
<ul>
<li>타입의 관점에서 <code>typeof</code>는 TS 상에서의 타입을 반환합니다.</li>
<li>값의 관점에서 <code>typeof</code>는 JS 런타임의 연산자가 됩니다.</li>
</ul>
<p>위쪽의 예시의 연장선을 통해 이를 살펴보면 아래와 같습니다.</p>
<pre><code class="language-ts">const v = typeof Cylinder; // v는 'function' string value입니다.
type T = typeof Cylinder; // T는 Cylinder 생성자 함수의 Type입니다.
</code></pre>
<p>여기서 흥미로운 것은, 아래에 있는 타입 관점의 <code>typeof Cylinder</code>는 인스턴스의 타입이 아닌, 생성자 함수의 타입이 된다는 점입니다.
만약 이것을 인스턴스 타입으로 활용하고자 한다면 아래와 같이 전환해야 합니다.</p>
<pre><code class="language-ts">type T = typeof InstanceType&lt;typeof Cylindar&gt;;
</code></pre>
<h3 id="타입-프로퍼티-접근자-"><a class="header" href="#타입-프로퍼티-접근자-">타입 프로퍼티 접근자 <code>[]</code></a></h3>
<p>프로퍼티 접근자인 <code>[]</code>는 타입으로 쓰일 때에도 동일하게 동작합니다. 
하지만, <code>obj['field']</code>와 <code>obj.field</code>는 값이 동일하더라도 다른 타입을 가질 수 있기 때문에, 타입의 프로퍼티를 얻고자 한다면 반드시 첫 번째 방법을 사용해야 합니다.</p>
<pre><code class="language-ts">const myName: NamedCylinder['name'] = 'alan';
</code></pre>
<p>이에 대한 내용은 아이템 14에서 더 자세히 다룹니다.</p>
<h3 id="그-외에-두-공간-사이에서-다른-의미를-가지는-코드-패턴"><a class="header" href="#그-외에-두-공간-사이에서-다른-의미를-가지는-코드-패턴">그 외에 두 공간 사이에서 다른 의미를 가지는 코드 패턴</a></h3>
<ul>
<li><code>this</code> 
<ul>
<li>값으로 쓰일 때는 JS의 <code>this</code> 키워드</li>
<li>타입으로 쓰일 때는 <strong>다형성 this</strong>라고 불리는 TS 타입. 서브클래스의 메서드 체인을 구현할 때 유용합니다.</li>
</ul>
</li>
<li><code>&amp;</code>, <code>|</code>
<ul>
<li>값으로 쓰일 때는 AND와 OR 비트연산</li>
<li>타입으로 쓰일 때는 intersection과 union입니다.</li>
</ul>
</li>
<li><code>const</code>
<ul>
<li><code>const</code>는 새 변수를 선언하는 키워드이지만,</li>
<li><code>as const</code>는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿉니다.</li>
</ul>
</li>
<li><code>extends</code>
<ul>
<li>JS에서 그렇듯 서브클래스를 정의하는 데 사용되거나</li>
<li>TS 상에서 서브타입(<code>interface A extends B</code>) 또는 제너릭 타입의 한정자(<code>Generic&lt;T extends number&gt;</code>)를 정의할 수 있습니다.</li>
</ul>
</li>
</ul>
<p>이렇듯, 타입 공간과 값 공간에서 동일한 키워드로 사용되는 심벌들이 여럿 존재합니다. 그렇기 때문에 TS 코드가 본인이 의도한 대로 동작하지 않는다면, 타입 공간과 값 공간을 혼동하여 잘못 작성했을 가능성이 큽니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-단언보다는-타입-선언을-사용하기"><a class="header" href="#타입-단언보다는-타입-선언을-사용하기">타입 단언보다는 타입 선언을 사용하기</a></h1>
<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지 입니다.</p>
<pre><code class="language-ts">interface Person { name: string };
const alice: Person = { name: 'Alice' }; // Type Declaration -&gt; 타입 선언
const bob = { name: 'Bob' } as Person; // Type Assertion -&gt; 타입 단언
</code></pre>
<p>위의 둘은 비슷하면서도 다릅니다.</p>
<p>결론부터 말하자면, 우리는 Assertion 보다는 Declaration을 사용하는 편이 좋습니다. 
Assertion은 타입을 강제로 지정하여 타입 체커가 이로부터 비롯된 오류를 무시하게끔 만들기 때문입니다.
대부분의 상황에서는 안전성 체크까지 되는 Declaration을 사용하는 것이 맞습니다.</p>
<h3 id="언제-assertion을-쓸까요"><a class="header" href="#언제-assertion을-쓸까요">언제 Assertion을 쓸까요?</a></h3>
<p>Assertion은 타입 체커가 추론한 타입보다 우리가 생각하는 타입이 더 정확하다고 판단되는 경우에 사용되어야 합니다.</p>
<p>가령, 다음과 같은 상황입니다.</p>
<pre><code class="language-ts">document.querySelector('#myButton').addEventListener('click', e =&gt; {
  e.currentTarget; // EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button; // HTMLButtonElement
})
</code></pre>
<p>TS는 DOM에 접근할 수 없기 떄문에, <code>#myButton</code> id를 가진 요소가 버튼에 해당할 것이라는 것을 예상하지 못합니다.
이러한 상황에서는 직접 Assertion을 통해 타입을 지정해주는 것이 필요합니다.</p>
<p>이와 유사한 것으로, <code>!</code>를 통한 Assertion도 활용할 수 있습니다.</p>
<pre><code class="language-ts">const elNull = document.getElementById('foo'); // HTMLElement | null
const el = document.getElementById('foo')!; // HTMLElement
</code></pre>
<p><code>!</code>는 <code>null</code>이 아님을 확신하는 단언문입니다.
이 역시 특정 상황에서 해당 값은 <code>null</code>이 아니라고 확신을 할 수 있을 때 사용하여야 합니다.</p>
<p>덧붙여, Assertion은 단언하고자 하는 타입이 타입체커가 추론한 타입의 서브타입에 해당하지 않는다면 사용할 수 없습니다.
이를 무시하고 타입을 변환하고자 한다면 <code>unknown</code> 타입을 활용하면 됩니다.</p>
<pre><code class="language-ts">interface Person { name: string; }
const body = document.body;
const el = body as unknown as Person; 
</code></pre>
<p><code>unknown</code>은 모든 타입의 서브타입이기 때문에, 어떤 타입으로도 변환할 수 있습니다.
하지만 주의해야 합니다. <code>unknown</code> 타입을 사용한 이상 무엇인가 위험한 동작을 하고 있다는 뜻이니까요.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="객체-래퍼-타입-피하기"><a class="header" href="#객체-래퍼-타입-피하기">객체 래퍼 타입 피하기</a></h1>
<p>JS에는 객체 외에 일곱가지 기본형 값(Primitives)들이 있습니다.</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>symbol</code></li>
<li><code>bigint</code> -&gt; <code>number</code>의 최대치인 2^53-1보다 큰 값을 표현할 때 사용</li>
</ul>
<h3 id="기본형-값들의-특징"><a class="header" href="#기본형-값들의-특징">기본형 값들의 특징</a></h3>
<ul>
<li>불변(immutable)합니다.</li>
<li>메서드를 가지지 않습니다.</li>
</ul>
<p>이를 듣고 봤을 때, 언뜻 아래 코드는 앞서 설명한 바와 말이 다른 것처럼 보입니다.</p>
<pre><code class="language-js">'primitive'.charAt(3) // m
</code></pre>
<p>사실, <code>charAt</code>은 <code>string</code>의 메서드가 아닙니다. 
Primitive에 해당하는 <code>string</code>에는 메서드가 없는 대신, 이 <code>string</code>과 관련된 메서드를 지닌 <code>String</code> 객체 타입이 별도로 정의되어 있습니다.
여러모로 서로 간에 깊이 연관된 탓에, <code>string</code>과 <code>String</code>을 언뜻 동일한 것으로 이해하기 쉽지만, 둘 사이에는 분명한 차이가 있습니다.</p>
<p>대부분의 경우 사실 래퍼 객체들은 직접 사용할 일이 드뭅니다. 우리가 직접 사용하지 않더라도 내부적으로 필요한 경우에 사용되기 때문입니다.
이를테면 위에서 <code>string</code>에 <code>charAt</code>을 쓴 경우, 우리가 보지 못하는 다음의 일들이 일어납니다.</p>
<ol>
<li>기본값인 <code>string</code>을 <code>String</code> 객체로 래핑합니다.</li>
<li>이후 래핑한 <code>String</code> 객체에서 메서드를 호출합니다.</li>
<li>그리고나서 래핑한 객체를 버립니다.</li>
</ol>
<p>이러한 과정을 거치는 탓에, 아래와 같이 이상한 코드를 작성했을 때 에러는 발생하지 않지만, 그렇다고 의도대로 동작하지도 않습니다.</p>
<pre><code class="language-js">const x = 'hello';
x.language = 'English'
console.log(x.language) // undefined
</code></pre>
<h3 id="래퍼-객체는-오직-자기-자신하고만-동일합니다"><a class="header" href="#래퍼-객체는-오직-자기-자신하고만-동일합니다">래퍼 객체는 오직 자기 자신하고만 동일합니다.</a></h3>
<p>그렇기 때문에 아래의 코드는 틀린 내용입니다.</p>
<pre><code class="language-js">'hello' === new String('hello') // false
new String('hello') === new String('hello') // false
</code></pre>
<blockquote>
<p><strong>주의</strong> : 단, <code>new</code> 없이 호출된 객체 래퍼들은 기본형을 생성합니다.</p>
</blockquote>
<pre><code class="language-js">String('abc') === 'abc' // true
BigInt(1) === BigInt(1) // true
</code></pre>
<h3 id="래퍼-객체-타입보다는-기본형-타입을-사용하세요"><a class="header" href="#래퍼-객체-타입보다는-기본형-타입을-사용하세요">래퍼 객체 타입보다는 기본형 타입을 사용하세요.</a></h3>
<ul>
<li>string / String</li>
<li>number / Number</li>
<li>boolean / Boolean</li>
<li>symbol / Symbol</li>
<li>bigint / BigInt</li>
</ul>
<p>위처럼 TS에서도 기본형과 객체 래퍼 타입은 별도로 모델링되며, 엄연히 다른 타입입니다.
TS에서 타입을 다룰 때는 모든 경우에 기본형 타입을 사용하는 것이 옳습니다. <code>기본형 -&gt; 래퍼 객체</code>는 할당이 가능하지만, <code>래퍼 객체 -&gt; 기본형</code>은 할당이 불가능하기 때문입니다.
이 탓에 에러가 발생할 가능성이 높습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="잉여-속성-체크의-한계-인지하기"><a class="header" href="#잉여-속성-체크의-한계-인지하기">잉여 속성 체크의 한계 인지하기</a></h1>
<h2 id="잉여-속성-체크-excess-property-checking"><a class="header" href="#잉여-속성-체크-excess-property-checking">잉여 속성 체크 (Excess property checking)</a></h2>
<p>타입이 명시된 변수에 <strong>객체 리터럴</strong>을 할당할 때, TS는 해당 타입의 속성이 제대로 존재하는지, 그리고 <strong>그 외의 속성</strong>은 없는지 확인합니다.
이 <em>그 외의 속성이 없는지</em> 판단하는 과정을 **잉여 속성 체크(Excess property checking)**라고 합니다.</p>
<pre><code class="language-ts">interface Room {
  numDoors: number;
  ceilingHeightFn: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present', // 에러 발생
}
</code></pre>
<h3 id="잉여-속성-체크는-객체-리터럴에서만-발생합니다"><a class="header" href="#잉여-속성-체크는-객체-리터럴에서만-발생합니다">잉여 속성 체크는 객체 리터럴에서만 발생합니다.</a></h3>
<p>여기서 포인트는 <strong>객체 리터럴</strong>입니다. 다른 임시 변수를 통해 우회적으로 할당을 하는 경우에 이는 문제가 발생하지 않습니다.</p>
<pre><code class="language-ts">const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
}

const room: Room = obj; // 문제 없음
</code></pre>
<p>여기서 우리가 앞서 살펴봤던 덕 타이핑과 이에 따른 TS의 구조적 타이핑 체계를 떠올려봅시다. 
그러한 관점에서 생각해보면, 앞선 코드에서 문제가 발생하지 않는 것이 이상한 일은 아닙니다.</p>
<p>결국 중요한 포인트는, 일반적인 구조적 할당 가능성 체크와 <strong>잉여 속성 체크</strong>는 엄연히 별도의 과정으로써 동작한다는 점입니다.
그리고, 잉여 속성 체크는 <strong>객체 리터럴을 통해</strong> 할당 또는 함수에 값을 넘겨줄 경우에 발생한다는 것을 기억해야 합니다.</p>
<h3 id="잉여-속성-체크는-단언문assertion에서는-발생하지-않습니다"><a class="header" href="#잉여-속성-체크는-단언문assertion에서는-발생하지-않습니다">잉여 속성 체크는 단언문(Assertion)에서는 발생하지 않습니다.</a></h3>
<p>우리가 단언문(Assertion)보다는 선언문(Declaration)을 우선시 해야하는 단적인 이유 중 하나입니다.
객체 리터럴을 사용하더라도, 단언을 이용한 경우에는 잉여 속성 체크가 일어나지 않습니다.</p>
<pre><code class="language-ts">const room = { 
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
  } as Room; // 문제 없음
</code></pre>
<h3 id="잉여-속성-체크를-원치-않는다면-인덱스-시그니처를-사용하세요"><a class="header" href="#잉여-속성-체크를-원치-않는다면-인덱스-시그니처를-사용하세요">잉여 속성 체크를 원치 않는다면 인덱스 시그니처를 사용하세요.</a></h3>
<p>잉여 속성 체크를 원치 않는 상황, 다시 말해 추가적인 속성을 가질 수 있다고 판단되는 경우에는 인덱스 시그니처를 사용하면 됩니다.
이 인덱스 시그니처에 대해서는 아이템15에서 상세하게 다루겁니다.</p>
<pre><code class="language-ts">interface Options {
  darkMode?: boolean;
  [others: string]: unknown;
}

const options: Options = { darkmode: true }; // 문제 없음
</code></pre>
<h3 id="약한-타입에-대한-공통-속성-체크"><a class="header" href="#약한-타입에-대한-공통-속성-체크">약한 타입에 대한 공통 속성 체크</a></h3>
<p>선택적 속성만 가지는 <strong>약한(weak) 타입</strong>에도 유사한 체크가 동작하는데, 이는 잉여 속성이 아닌 공통 속성이 있는지를 확인한다는 점에서 조금 다릅니다.</p>
<pre><code class="language-ts">interface LineChartOptions {
  logscale?: boolean;
  inverteedYAxis?: boolean;
  areaChart?: boolean;
}

const opts = { logScale: true };

const options: LineChartOptions = opts; // 에러 발생
</code></pre>
<p>약한 타입에 대한 공통 속성 체크는 값과 타입 간에 공통된 속성이 있는지에 대해 확인하는 과정입니다.
그러나 잉여 속성 체크와는 다르게, 약한 타입과 관련된 할당마다 수행된다는 차이가 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-표현식에-타입-적용하기"><a class="header" href="#함수-표현식에-타입-적용하기">함수 표현식에 타입 적용하기</a></h1>
<p>JS 및 TS에서는 다음의 방법들로 함수를 나타낼 수 있습니다. 이는 큰 관점에서 Statement냐 Expression이냐로 나뉩니다.</p>
<pre><code class="language-ts">function rollDice1(sides: number): number { ... } // Statement
const rollDice2 = (sides: number): number =&gt; { ... } // Expression
const rollDice3 = function(sides: number): number { ... } // Expression
</code></pre>
<h2 id="ts에서는-함수-표현식function-expression을-사용하세요"><a class="header" href="#ts에서는-함수-표현식function-expression을-사용하세요">TS에서는 함수 표현식(Function Expression)을 사용하세요.</a></h2>
<p>결론부터 말하면, TS에서는 함수 표현식을 사용하는 것이 좋습니다.
함수 전체를 하나의 함수 타입으로 선언하여 여러 곳에 재사용할수 있다는 장점이 있기 때문입니다.</p>
<pre><code class="language-ts">type DiceRollFn = (sides: number) =&gt; number;
const rollDice: DiceRollFn = sides =&gt; { ... };
</code></pre>
<p>위의 예시가 짧아서 장점이 와닿지 않는다면 다음의 코드도 참고하세요.</p>
<pre><code class="language-ts">type BinaryFn = (a: number, b: number) =&gt; number;
const add: BinaryFn = (a, b) =&gt; a + b;
const sub: BinaryFn = (a, b) =&gt; a - b;
const mul: BinaryFn = (a, b) =&gt; a * b;
const div: BinaryFn = (a, b) =&gt; a / b;
</code></pre>
<h2 id="함수-타입에도-typeof를-사용할-수-있습니다"><a class="header" href="#함수-타입에도-typeof를-사용할-수-있습니다">함수 타입에도 typeof를 사용할 수 있습니다.</a></h2>
<p>함수 타입에도 <code>typeof</code>를 사용할 수 있는데, 이는 기존에 이미 작성되어 있던 네이티브 및 라이브러리 함수들의 타입을 재차 활용하고자 할 때 유용합니다.
아래 예시는 네이티브 <code>fetch</code> 함수에 대한 에러 핸들링을 추가하는 예시입니다.</p>
<pre><code class="language-ts">const checkedFetch: typeof fetch = async (input, init) =&gt; {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error('Request failed: ' + response.status);
  }
  return response;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입과-인터페이스의-차이점-알기"><a class="header" href="#타입과-인터페이스의-차이점-알기">타입과 인터페이스의 차이점 알기</a></h1>
<p>타입스크립트에서는 명명된 타입(named type)을 정의하기 위해 <b>타입 별칭(Type Alias, 이하 타입)</b>과 <b>인터페이스(Interface)</b>라는 두 가지 방법을 사용할 수 있습니다.</p>
<pre><code class="language-ts">// type
type TState = {
  name: string;
  capital: string;
}

// interface
interface IState {
  name: string;
  capital: string;
}
</code></pre>
<h2 id="타입과-인터페이스의-유사점"><a class="header" href="#타입과-인터페이스의-유사점">타입과 인터페이스의 유사점</a></h2>
<h3 id="인덱스-시그니처를-사용할-수-있습니다"><a class="header" href="#인덱스-시그니처를-사용할-수-있습니다">인덱스 시그니처를 사용할 수 있습니다.</a></h3>
<pre><code class="language-ts">type TDict = { [key: string]: string };

interface IDict {
  [key: string]: string;
}
</code></pre>
<h3 id="함수-타입을-정의할-수-있습니다"><a class="header" href="#함수-타입을-정의할-수-있습니다">함수 타입을 정의할 수 있습니다.</a></h3>
<pre><code class="language-ts">type TFn = (x: number) =&gt; string;

interface ifN {
  (X: number): string;
}
</code></pre>
<p>JS에서의 함수는 곧 객체라는 점을 떠올려보면, 아래처럼 추가로 프로퍼티를 정의할 수도 있습니다.</p>
<pre><code class="language-ts">type TFnWithProperties = {
  (x: number): number;
  prop: string;
}

interface IFnWithProperties {
  (x: number): number;
  prop: string;
}
</code></pre>
<h3 id="제네릭을-사용할-수-있습니다"><a class="header" href="#제네릭을-사용할-수-있습니다">제네릭을 사용할 수 있습니다.</a></h3>
<pre><code class="language-ts">type TPair&lt;T&gt; = {
  first: T;
  second: T;
}

interface IPair&lt;T&gt; {
  first: T;
  second: T;
}
</code></pre>
<h3 id="타입과-인터페이스는-서로-간에-확장이-가능합니다"><a class="header" href="#타입과-인터페이스는-서로-간에-확장이-가능합니다">타입과 인터페이스는 서로 간에 확장이 가능합니다.</a></h3>
<pre><code class="language-ts">interface IStateWithPop extends TState {
  population: number;
}

type TStateWithPop = IState &amp; { population: number; };
</code></pre>
<h3 id="클래스의-구현implements에-사용할-수-있습니다"><a class="header" href="#클래스의-구현implements에-사용할-수-있습니다">클래스의 구현(implements)에 사용할 수 있습니다.</a></h3>
<pre><code class="language-ts">class StateT implements TState {
  name: string = '';
  capital: string = '';
}

class StateI implements IState {
  name: string = '';
  capital: string = '';
}
</code></pre>
<h2 id="타입과-인터페이스의-차이점"><a class="header" href="#타입과-인터페이스의-차이점">타입과 인터페이스의 차이점</a></h2>
<h3 id="유니온은-타입으로만-표현할-수-있습니다"><a class="header" href="#유니온은-타입으로만-표현할-수-있습니다">유니온(<code>|</code>)은 타입으로만 표현할 수 있습니다.</a></h3>
<pre><code class="language-ts">type AorB = 'a' | 'b';
</code></pre>
<p>유니온을 인터페이스로 표현할 방법은 없습니다. 이러한 이유로 타입은 일반적으로 인터페이스보다 더 쓰임새가 많습니다.</p>
<pre><code class="language-ts">type Input = { /* ... */ };
type Output = { /* ... */ };

interface VariableMap {
  [name: string]: Input | Output;
}

type NamedVariable = (Input | Output) &amp; { name: string };
</code></pre>
<h3 id="튜플-배열-타입은-type-키워드를-이용해야-합니다"><a class="header" href="#튜플-배열-타입은-type-키워드를-이용해야-합니다">튜플, 배열 타입은 type 키워드를 이용해야 합니다.</a></h3>
<pre><code class="language-ts">type Pair = [number, number];
type Stringlist = string[];
type NamedNums = [string, ...number[]];
</code></pre>
<p>인터페이스로도 유사하게 구현할 수는 있으나, 이 경우엔 <code>.map</code>, <code>.concat</code> 등의 배열 메서드를 사용할 수 없게 됩니다.</p>
<pre><code class="language-ts">interface Tuple {
  0: number;
  1: number;
  length: 2;
}

const t: Tuple = [10, 20]; // 정상
t.concat([30, 40]); // ERROR : Property 'concat' does not exist on type 'Tuple'.
</code></pre>
<h3 id="인터페이스는-보강augment이-가능합니다"><a class="header" href="#인터페이스는-보강augment이-가능합니다">인터페이스는 보강(augment)이 가능합니다.</a></h3>
<pre><code class="language-ts">interface IState {
  name: string;
  capital: string;
}

interface IState {
  population: number;
}

const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 500_000,
}
</code></pre>
<p>위의 예제처럼 프로퍼티를 확장하는 것을 선언 병합(Declaration merging)이라고 합니다. 이는 주로 타입 선언 파일에서 사용됩니다. (일반 코드에서 쓰지 못하는 것은 아닙니다.) 다시 말해, 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 인터페이스를 사용해야 하며, 표준을 따라야 합니다.</p>
<h2 id="결론--그래서-둘-중-무엇을-써야-할까요"><a class="header" href="#결론--그래서-둘-중-무엇을-써야-할까요">결론 : 그래서 둘 중 무엇을 써야 할까요?</a></h2>
<ul>
<li>복잡한 타입의 정의가 필요한 경우 =&gt; <strong>타입</strong></li>
<li>보강의 가능성이 있는 경우 (ex. API) =&gt; <strong>인터페이스</strong></li>
</ul>
<p>그 외에 프로젝트의 일관된 스타일을 유지하게끔 일관적으로 타입 또는 인터페이스를 사용하면 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-연산과-제너릭-사용으로-반복-줄이기"><a class="header" href="#타입-연산과-제너릭-사용으로-반복-줄이기">타입 연산과 제너릭 사용으로 반복 줄이기</a></h1>
<p>같은 코드를 반복해서 작성하지 말라는 DRY(Don't Repeat Yourself) 원칙은 타입에 대해서도 유효합니다.</p>
<h3 id="타입에-이름-붙이기-named-type"><a class="header" href="#타입에-이름-붙이기-named-type">타입에 이름 붙이기 (Named Type)</a></h3>
<pre><code class="language-ts">function distanc(a: {x: number, y: number}, b: {x: number, y: number}) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
</code></pre>
<p>이를 별도의 이름을 가진 타입으로 쪼개어 작성하면 훨씬 보기 편해지고, 반복도 줄어듭니다.</p>
<pre><code class="language-ts">interface Point2D {
  x: number;
  y: number;
}

function distance(a: Point2D, b: point2D) { 
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
</code></pre>
<p>이는 함수에 있어서도 마찬가지입니다.</p>
<pre><code class="language-ts">type HTTPFunction = (url: string, opts: Options) =&gt; Promise&lt;Response&gt;;
const get: HTTPFunction = (url, opts) =&gt; { /* ... */ };
const post: HTTPFunction = (url, opts) =&gt; { /* ... */ };
</code></pre>
<h3 id="확장"><a class="header" href="#확장">확장</a></h3>
<p>이미 작성된 타입을 활용한 확장도 반복을 줄이는 방법 중 하나입니다. 이 중 <code>&amp;</code>을 이용하는 방법은 유니온 타입에서 확장을 하고자 하는 경우에 특히 유용한 패턴입니다. </p>
<pre><code class="language-ts">interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate extends Person {
  birth: Date;
}

// 또는
interface PersonWithBirthDate = Person &amp; { birth: Date };
</code></pre>
<h3 id="타입-인덱싱"><a class="header" href="#타입-인덱싱">타입 인덱싱</a></h3>
<p>기존에 존재하던 타입의 일부를 인덱싱으로 사용할 수도 있습니다. <code>Pick</code>, <code>Partial</code> 등 아래서 추가로 설명할 제너릭 타입들을 사용하면 더 쉽습니다.</p>
<pre><code class="language-ts">
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

type TopNavState = {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
};
</code></pre>
<p>단, 여전히 <code>State[...]</code>와 같이 반복되는 코드가 남아있는 데, 이부분에서 <a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html"><b>매핑된 타입</b></a>을 사용하면 더 나아집니다.</p>
<pre><code class="language-ts">type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]
};
</code></pre>
<p>유니온 타입에서 인덱싱을 사용하는 경우에도 유연하게 동작합니다.</p>
<pre><code class="language-ts">interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load';
  // ...
}
type Action = SaveAction | LoadAction;
type ActionType = Action['type'];  // Type is &quot;save&quot; | &quot;load&quot;
</code></pre>
<h3 id="typeof와-keyof"><a class="header" href="#typeof와-keyof"><code>typeof</code>와 <code>keyof</code></a></h3>
<p><code>keyof</code>는 특정 타입이 가진 프로퍼티 <code>key</code>들의 유니온을 반환합니다.</p>
<pre><code class="language-ts">interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
type OptionsKeys = keyof Options;
// Type is &quot;width&quot; | &quot;height&quot; | &quot;color&quot; | &quot;label&quot;
</code></pre>
<p>반면, <code>typeof</code>는 특정 <b>값(value)</b>의 형태에 대한 타입들을 가져올 수 있습니다. 여기서 <code>typeof</code> 뒤에 오는 것은 타입이 아닌 값임에 주의하세요.</p>
<pre><code class="language-ts">const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: '#00FF00',
  label: 'VGA',
};

type Options = typeof INIT_OPTIONS;

// interface Options {
//   width: number;
//   height: number;
//   color: string;
//   label: string;
// }
</code></pre>
<h2 id="표준-라이브러리의-제너릭을-활용하세요"><a class="header" href="#표준-라이브러리의-제너릭을-활용하세요">표준 라이브러리의 제너릭을 활용하세요.</a></h2>
<p>제너릭은 <strong>타입의 관점에서 사용하는 함수</strong>에 가깝습니다. 정의 시점에는 해당 타입이 명확하지 않지만, 이를 사용할 때 결과 타입을 반환받아 사용할 수 있게 됩니다. TS 표준 라이브러리에서는 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types</a>라는 이름으로 여러 제너릭을 제공하고 있습니다.</p>
<h3 id="partial"><a class="header" href="#partial">Partial</a></h3>
<p><code>Partial</code>는 기존 타입들의 프로퍼티를 선택적인 속성으로 만들어줍니다.</p>
<pre><code class="language-ts">interface Todo {
  title: string;
  description: string;
}

type UpdateTodoFields = Partial&lt;Todo&gt;; 

// interface UpdateTodoFields {
//  title?: string | undefined;
//  description?: string | undefined;
// }
</code></pre>
<h3 id="pick"><a class="header" href="#pick">Pick</a></h3>
<p><code>Pick</code>은 기존에 존재하던 타입 프로퍼티의 일부만을 가져와 새로 정의할 수 있도록 해줍니다.</p>
<pre><code class="language-ts">interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

type TopNavState = Pick&lt;State, 'userId' | 'pageTitle' | 'recentFiles'&gt;;

// interface State {
//   userId: string;
//   pageTitle: string;
//   recentFiles: string[];
// }
</code></pre>
<h3 id="returntype"><a class="header" href="#returntype">ReturnType</a></h3>
<p><code>ReturnType</code>은 기존의 함수 타입의 반환 타입을 가져올 수 있게 해주는 제너릭입니다.</p>
<pre><code class="language-ts">// 아래 getUserInfo는 함수 값(value)입니다.
type UserInfo = ReturnType&lt;typeof getUserInfo&gt;;
</code></pre>
<p>그 외에도 여러 유틸리티 타입들이 존재하는데, 여기선 모두 다루진 않도록 하겠습니다. 다른 유틸리티 함수에 대해서는 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">여기</a>를 참조하세요.</p>
<h2 id="제너릭의-매개변수를-extends를-통해-제한하세요"><a class="header" href="#제너릭의-매개변수를-extends를-통해-제한하세요">제너릭의 매개변수를 <code>extends</code>를 통해 제한하세요.</a></h2>
<p>TS 함수에서 매개변수의 값을 타입을 통해 제한하는 것처럼, TS의 제너릭에 있어서도 <code>extends</code>를 통해 타입을 제한할 수 있습니다. </p>
<pre><code class="language-ts">interface Name {
  first: string;
  last: string;
}
type DancingDuo&lt;T extends Name&gt; = [T, T];

const couple1: DancingDuo&lt;Name&gt; = [
  {first: 'Fred', last: 'Astaire'},
  {first: 'Ginger', last: 'Rogers'}
];  // OK
const couple2: DancingDuo&lt;{first: string}&gt; = [
                       // ~~~~~~~~~~~~~~~
                       // Property 'last' is missing in type
                       // '{ first: string; }' but required in type 'Name'
  {first: 'Sonny'},
  {first: 'Cher'}
];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="동적-데이터에-인덱스-시그니처-사용하기"><a class="header" href="#동적-데이터에-인덱스-시그니처-사용하기">동적 데이터에 인덱스 시그니처 사용하기</a></h1>
<p>JS의 장점을 객체 생성 문법이 간단하다는 것입니다. TS에서도 이렇게 유연한 형태로 객체 타입을 정의하고 싶다면 다음과 같이 사용하면 됩니다.</p>
<pre><code class="language-ts">type Rocket = {[property: string]: string};

const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
};
</code></pre>
<p>여기서 사용된 <code>[property: string]: string</code>이 <b>인덱스 시그니처</b>가 되며, 다음의 세 가지 의미를 담고 있습니다.</p>
<ul>
<li>키 이름(<code>property</code>): 키의 위치만 표시하며, 타입 체커에서는 실질적으로 사용하지 않습니다.</li>
<li>키 타입(<code>string</code>): <code>string</code>, <code>number</code> 또는 <code>symbol</code> 이어야하는데, 보통은 <code>string</code>을 사용합니다.</li>
<li>값 타입(<code>string</code>): 무엇이든 될 수 있습니다.</li>
</ul>
<p>다만, 위와 같은 방식으로 타입 체크를 수행하는 경우 다음의 문제들이 발생합니다.</p>
<ul>
<li>모든 키를 포함합니다. 즉, 의도와 다르게 키를 잘못 작성하더라도 에러가 발생하지 않습니다.</li>
<li>특정 키가 필요하지 않습니다. <code>{}</code>도 위의 <code>Rocket</code>타입에 유효합니다.</li>
<li>키마다 다른 타입을 가질 수 없습니다. 예를 들어 <code>thrust</code>는 <code>number</code>로도 표현될 여지가 있습니다.</li>
<li>TS 언어 서비스가 아무런 도움도 주지 못합니다. (자동 완성, 도움말 등..) 무엇이든 가능하기 때문입니다.</li>
</ul>
<p>결국, <strong>일반적인 상황에서는 인덱스 시그니처보다 그냥 인터페이스로 타입을 정의하는 것이 더 좋습니다.</strong></p>
<pre><code class="language-ts">interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}

const falconHeavy: Rocket = {
  name: 'Falcon Heavy',
  variant: 'v1',
  thrust_kN: 15_200
};
</code></pre>
<h2 id="인덱스-시그니처는-런타임-이전에-알-수-없는-동적인-데이터를-표현할-때-사용합니다"><a class="header" href="#인덱스-시그니처는-런타임-이전에-알-수-없는-동적인-데이터를-표현할-때-사용합니다">인덱스 시그니처는 런타임 이전에 알 수 없는 동적인 데이터를 표현할 때 사용합니다.</a></h2>
<p>아래 코드는 CSV 파일의 string을 받아 여러 개의 Row들을 가진 배열을 반환하는 함수입니다. 이 시점에서 우리는 어떤 CSV 파일이 사용될지 알 수 없기 때문에, 이러한 경우에는 인덱스 시그니처를 사용해야 합니다.</p>
<pre><code class="language-ts">// 현 시점에서 우리는 CSV 파일의 컬럼명이 무엇이 될지 알 수 없습니다.
function parseCSV(input: string): {[columnName: string]: string}[] {
  const lines = input.split('\n');
  const [header, ...rows] = lines;
  return rows.map(rowStr =&gt; {
    const row: {[columnName: string]: string} = {};
    rowStr.split(',').forEach((cell, i) =&gt; {
      row[header[i]] = cell;
    });
    return row;
  });
}
</code></pre>
<p>물론, 모든 열의 값들에 대해서 주어지지 않을 가능성이 있습니다. 이러한 부분을 염려하여 보다 엄격한 형태로 작성하고자 한다면 다음과 같이 활용해야 합니다. 물론 그만큼 추후 타입체킹이 더 번거로워 질 수는 있습니다.</p>
<pre><code class="language-ts">function safeParseCSV(
  input: string
): {[columnName: string]: string | undefined}[] {
  return parseCSV(input);
}
</code></pre>
<p>만약, 반환받은 값의 형태에 대해 명확히 알고 있는 경우라면 다음과 같이 Assertion을 활용하여 강제로 타입을 변환시킬 수 있습니다.</p>
<pre><code class="language-ts">interface ProductRow {
  productId: string;
  name: string;
  price: string;
}

let csvData: string;
const products = parseCSV(csvData) as unknown as ProductRow[];
</code></pre>
<h2 id="가능한-필드가-제한적이라면-인덱스-시그니처를-쓰지-마세요"><a class="header" href="#가능한-필드가-제한적이라면-인덱스-시그니처를-쓰지-마세요">가능한 필드가 제한적이라면 인덱스 시그니처를 쓰지 마세요.</a></h2>
<p>동적인 데이터를 다루더라도, 사용될 수 있는 필드가 제한되어 있는 경우라면 인덱스 시그니처를 쓰지 말아야 합니다. 너무 광범위하기 때문입니다. 이 때는 선택적 프로퍼티(Optional Property)나 유니온 타입(<code>|</code>)을 사용하는 편이 좋습니다.</p>
<pre><code class="language-ts">interface Row1 { [column: string]: number }  // 너무 광범위
interface Row2 { a: number; b?: number; c?: number; d?: number }  // 최선
type Row3 =
    | { a: number; }
    | { a: number; b: number; }
    | { a: number; b: number; c: number;  }
    | { a: number; b: number; c: number; d: number }; // 가장 정확하지만 번거로움
</code></pre>
<h2 id="키-타입에-제한두기"><a class="header" href="#키-타입에-제한두기">키 타입에 제한두기</a></h2>
<p>어떤 객체의 키 타입을 인덱스 시그니처를 통해 모두 <code>string</code>으로 정의해버리기 보다는, 더 명확하게 정의하고 사용하는 편이 좋습니다. 이에 대해 두 가지 대안을 고려해볼 수 있습니다.</p>
<h3 id="record-제너릭"><a class="header" href="#record-제너릭">Record 제너릭</a></h3>
<p>Record는 키 타입에 유연성을 제공하는 제너릭 타입으로, <code>string</code>의 부분 집합을 사용할 수 있습니다.</p>
<pre><code class="language-ts">type Vec3D = Record&lt;'x' | 'y' | 'z', number&gt;;
// Type Vec3D = {
//   x: number;
//   y: number;
//   z: number;
// }
</code></pre>
<h3 id="mapped-types-매핑된-타입"><a class="header" href="#mapped-types-매핑된-타입">Mapped Types (매핑된 타입)</a></h3>
<p>매핑된 타입은 Record 제네릭과 동일하게 사용할 수 있고, 조건부 타입(<code>?</code>)를 통해 키마다 별도의 타입을 사용하게 할 수도 있습니다. 조건부 타입에 대해서는 아이템 50에서 다룰 예정입니다.</p>
<pre><code class="language-ts">type Vec3D = {[k in 'x' | 'y' | 'z']: number};
// Type Vec3D = {
//   x: number;
//   y: number;
//   z: number;
// }

type ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number};
// Type ABC = {
//   a: number;
//   b: string;
//   c: number;
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기"><a class="header" href="#number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기">number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></h1>
<p>JS에서 배열은 하나의 객체입니다. <code>number</code> 타입의 인덱스를 사용하지만, JS 내부적으로 사실 이는 문자열로 변환되어 사용된다는 특이점이 있습니다.
실제로도 배열에서의 인덱싱을 문자열로 하더라도 아무런 문제 없이 동작합니다.</p>
<pre><code class="language-js">const arr = ['a', 'b', 'c'];
console.log(arr[0]) // 'a'
console.log(arr['1']) // 'b'
</code></pre>
<p>TS의 경우, <strong>이와 같은 코드를 작성했을 때 에러를 발생해야 한다</strong>라고 책에는 적혀있는데, 현 시점의 <code>v4.4</code> 이상의 TS에서는 이러한 에러가 출력되지 않습니다.</p>
<pre><code class="language-ts">const xs = [1, 2, 3];
const x0 = xs[0];  // OK
const x1 = xs['1'];
           // 책(&lt; v4.4)에서는 아래와 같은 에러가 출력된다고 이야기하지만, v4.4 이상에서는 그렇지 않습니다.
           // ~~~ Element implicitly has an 'any' type
           //      because index expression is not of type 'number'

function get&lt;T&gt;(array: T[], k: string): T {
  return array[k];
            // 이 경우는 현 시점에서도 에러가 발생합니다.
            // ~ Element implicitly has an 'any' type
            //   because index expression is not of type 'number'
}
</code></pre>
<h2 id="인덱스-시그니처에-number를-사용하지-마세요"><a class="header" href="#인덱스-시그니처에-number를-사용하지-마세요">인덱스 시그니처에 number를 사용하지 마세요.</a></h2>
<p>다시 본론으로 돌아와서, <code>number</code> 타입을 통해 인덱싱을 해야하는 상황이라면, 굳이 객체에 인덱스 시그니처를 사용하기보다, Array 또는 Tuple 타입을 사용하세요.</p>
<pre><code class="language-ts">// 굳이 이렇게 만들지 말고
type MyArray = {
  [index: number]: string;
}

const myArr: MyArray = {
  1: 'a',
  2: 'b',
}

// 그냥 Array나 Tuple을 쓰세요.
const arr: Array&lt;string&gt; = ['a', 'b'];
const tup: [string, string] = ['a', 'b'];
</code></pre>
<p>만약 Array 프로토타입의 프로퍼티들을 갖는 것을 원치 않는 상황이라면, <code>ArrayLike&lt;T&gt;</code> 타입을 사용하면 됩니다.</p>
<pre><code class="language-ts">const tupleLike: ArrayLike&lt;string&gt; = {
  0: 'A',
  1: 'B',
  length: 2,
};

tupleLike[0] // 'A'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="변경-관련된-오류-방지를-위해-readonly-사용하기"><a class="header" href="#변경-관련된-오류-방지를-위해-readonly-사용하기">변경 관련된 오류 방지를 위해 readonly 사용하기</a></h1>
<h2 id="readonly"><a class="header" href="#readonly">readonly</a></h2>
<p>Array 또는 Tuple 타입을 <code>readonly</code>로 선언하면 다음과 같은 일이 생깁니다.</p>
<ul>
<li><code>length</code>를 포함한 해당 배열 요소들을 참조할 수는 있지만, 추가로 작성하거나 수정할 수는 없습니다.</li>
<li>배열에 변경을 가하는 <code>pop</code>, <code>push</code> 등의 메서드를 사용할 수 없습니다. (한편 <code>map</code>, <code>concat</code> 등은 가능합니다.)</li>
</ul>
<p>이는 함수의 매개변수 또는 새로운 값을 선언할 때 배열의 불변성(Immutability)을 명시적으로 유지하고자 하는 경우에 활용될 수 있습니다.
이 경우, 어떤 동작에서 해당 배열을 변경하려고 하는 경우 즉각적으로 피드백을 받을 수 있어 즉각적으로 대처가 가능합니다.</p>
<pre><code class="language-ts">function arraySum(arr: readonly number[]) {
  let sum = 0, num;
  while ((num = arr.pop()) !== undefined) {
                 // ~~~ 'pop' does not exist on type 'readonly number[]'
    sum += num;
  }
  return sum;
}
</code></pre>
<h3 id="readonly는-얕게shallow-동작한다는-점을-유의하세요"><a class="header" href="#readonly는-얕게shallow-동작한다는-점을-유의하세요">readonly는 얕게(shallow) 동작한다는 점을 유의하세요.</a></h3>
<p><code>readonly</code>는 얕게 동작합니다. 다시 말해, 아래 예시와 같이 보다 깊게 위치한 배열에 대해서는 불변성을 보장할 수 없습니다.</p>
<pre><code class="language-ts">const arrInArr: readonly string[][] = [[], ['a', 'b']];
arrInArr[1]?.pop(); // 문제 없음
</code></pre>
<h3 id="인덱스-시그니처에서도-사용할-수-있습니다"><a class="header" href="#인덱스-시그니처에서도-사용할-수-있습니다">인덱스 시그니처에서도 사용할 수 있습니다.</a></h3>
<p>인덱스 시그니처에서도 <code>readonly</code>를 사용할 수 있는데, 이 경우 객체의 프로퍼티가 변경되는 것을 방지할 수 있습니다.</p>
<pre><code class="language-ts">let obj: {readonly [k: string]: number} = {};
// Or Readonly&lt;{[k: string]: number}
obj.hi = 45;
//  ~~ Index signature in type ... only permits reading
obj = {...obj, hi: 12};  // OK
obj = {...obj, bye: 34};  // OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="매핑된-타입을-사용하여-값을-동기화하기"><a class="header" href="#매핑된-타입을-사용하여-값을-동기화하기">매핑된 타입을 사용하여 값을 동기화하기</a></h1>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html">매핑된 타입(Mapped Type)</a>은 기존에 작성한 다른 타입에 기반하여 새로운 타입을 쉽게 작성할 수 있는 방법입니다. 주로 <code>keyof</code> 키워드와 함께 사용됩니다.</p>
<pre><code class="language-ts">type FeatureFlags = {
  darkMode: () =&gt; void;
  newUserProfile: () =&gt; void;
};

type OptionsFlags&lt;Type&gt; = {
  [Property in keyof Type]: boolean;
};

type FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;;
// type FeatureOptions = {
//     darkMode: boolean;
//     newUserProfile: boolean;
// }
</code></pre>
<p>이는 꼭 제네릭으로 사용되어야 하는 것은 아닙니다. 인덱스 시그니처에서도 매핑된 타입을 사용할 수 있습니다.</p>
<pre><code class="language-ts">const options: {[k in keyof FeatureFlags]: boolean} = {
  darkMode: false,
  newUserProfile: true,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-추론"><a class="header" href="#타입-추론">타입 추론</a></h1>
<p>3장에서는 타입 추론에서 발생할 수 있는 몇 가지 문제와 그 해법을 안내합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="추론-가능한-타입을-사용해-장황한-코드-방지하기"><a class="header" href="#추론-가능한-타입을-사용해-장황한-코드-방지하기">추론 가능한 타입을 사용해 장황한 코드 방지하기</a></h1>
<p>TS의 타입 추론은 생각보다 훨씬 정확해서, 일반적으로는 명시적인 타입 구문 자체가 필요하지 않습니다.
그렇기 때문에, 이러한 &quot;불필요한 타입 구문&quot;들은 가능한 줄이는 것이 좋습니다. 
tslint를 사용하고 있다면, <a href="https://palantir.github.io/tslint/rules/no-inferrable-types/"><code>no-inferrable-types</code></a> 옵션을 통해 작성된 모든 타입 구문이 정말로 필요한지에 대해 확인할 수 있습니다.</p>
<pre><code class="language-ts">const person = {
  name: 'Sojourner Truth',
  born: {
    where: 'Swartekill, NY',
    when: 'c.1797',
  },
  died: {
    where: 'Battle Creek, MI',
    when: 'Nov. 26, 1883'
  }
};

// typeof person: {
//     name: string;
//     born: {
//         where: string;
//         when: string;
//     };
//     died: {
//         where: string;
//         when: string;
//     };
// }
</code></pre>
<h2 id="함수와-메서드의-시그니처에는-타입-구문을-쓰세요"><a class="header" href="#함수와-메서드의-시그니처에는-타입-구문을-쓰세요">함수와 메서드의 시그니처에는 타입 구문을 쓰세요.</a></h2>
<p>타입스크립트에게 직접 타입을 명시적으로 지정해주어야 하는 경우는, 말 그대로 타입스크립트가 스스로 타입을 판단하기 어려운 경우입니다.
함수가 그 대표적인 예시가 되는데, <strong>이상적인 TS 코드는 함수 및 메서드 시그니처에 타입 구문을 포함하지만, 그 내부의 지역 변수들에서는 타입 구문을 넣지 않습니다.</strong></p>
<pre><code class="language-ts">interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const {id, name, price} = product;
  console.log(id, name, price);
}
</code></pre>
<p>물론 함수임에도 이러한 타입 구문이 필요하지 않은 경우도 있습니다.</p>
<h3 id="매개변수에-대한-기본값을-통해-타입-추론이-가능한-경우"><a class="header" href="#매개변수에-대한-기본값을-통해-타입-추론이-가능한-경우">매개변수에 대한 기본값을 통해 타입 추론이 가능한 경우</a></h3>
<pre><code class="language-ts">// `base`는 타입 추론에 따라 `number` 타입이 됩니다.
function parseNumber(str: string, base = 10) {
  // ...
}
</code></pre>
<h3 id="콜백함수로-넘겨짐에-따라-타입-추론이-가능한-경우"><a class="header" href="#콜백함수로-넘겨짐에-따라-타입-추론이-가능한-경우">콜백함수로 넘겨짐에 따라 타입 추론이 가능한 경우</a></h3>
<pre><code class="language-ts">// axios.get에 넘겨지는 콜백함수는 이미 본인의 매개변수 타입을 알고 있습니다.
app.get('/health', (request, response) =&gt; {
  response.send('OK');
});
</code></pre>
<h2 id="타입-추론이-가능하더라도-타입을-명시해야-하는-경우"><a class="header" href="#타입-추론이-가능하더라도-타입을-명시해야-하는-경우">타입 추론이 가능하더라도, 타입을 명시해야 하는 경우</a></h2>
<p>타입이 추론 가능하더라도, 여전히 직접 타입을 명시하는게 좋은 상황이 있습니다.</p>
<h3 id="객체-리터럴을-정의할-때"><a class="header" href="#객체-리터럴을-정의할-때">객체 리터럴을 정의할 때</a></h3>
<p>객체 리터럴을 정의할 때, 타입 구문이 없다면 앞선 아이템 11에서 살펴봤던 잉여 속성 체크가 동작하지 않고, 이 경우 속성에 대한 오타를 해당 시점에 잡아내지 못합니다.
이 경우, 추후 해당 객체가 직접 사용될 때 이르러서야 해당 객체를 사용한 곳에서 타입 에러가 발생하기에 혼동을 주기 쉽습니다.</p>
<pre><code class="language-ts">interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: string = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}

const furby = {
  name: 'Furby',
  id: 630509430963,
  price: 35,
};

logProduct(furby);
        // ~~~~~ Argument .. is not assignable to parameter of type 'Product'
        //         Types of property 'id' are incompatible
        //         Type 'number' is not assignable to type 'string'
</code></pre>
<h3 id="함수의-반환-타입"><a class="header" href="#함수의-반환-타입">함수의 반환 타입</a></h3>
<p>함수의 반환 타입 역시 알아서 추론이 가능하지만, 본인이 의도한 반환 타입과 다른 경우가 발생할 수 있으므로, 이를 미리 명시하고 제때 잡아내는 것이 필요합니다.
그렇지 않다면 구현 상의 문제가 <a href="https://github.com/grepp/hera-webapp/pull/2487/files">해당 함수를 사용하는 시점에서야 발견</a>됩니다.</p>
<pre><code class="language-ts">const cache: {[ticker: string]: number} = {};
function getQuote(ticker: string): Promise&lt;number&gt; {
  if (ticker in cache) {
    return cache[ticker];
        // ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'
  }
  // COMPRESS
  return Promise.resolve(0);
  // END
}
</code></pre>
<p>함수의 반환 타입을 명시해야 하는 두 번째 이유는 명명된 타입(Named Type)을 사용하기 위해서입니다. 구조 상으로는 동일하더라도, 타입이 일관적이지 않으면 당황스러울 수 있기 때문이죠.</p>
<pre><code class="language-ts">interface Vector2D { x: number; y: number; }
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y };
}
// function add(a: Vector2D, b: Vector2D): {
//     x: number;
//     y: number;
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="다른-타입에는-다른-변수-사용하기"><a class="header" href="#다른-타입에는-다른-변수-사용하기">다른 타입에는 다른 변수 사용하기</a></h1>
<p>JS는 <code>let</code>을 통해 하나의 변수를 여러 타입으로 수번에 걸쳐 재할당하여 사용해도 무방합니다. 
타입스크립트 상에서도 이를 시스템 상으로 막고있지는 않지만, 에러가 발생할 여지가 많습니다.</p>
<pre><code class="language-ts">function fetchProduct(id: string) {}
function fetchProductBySerialNumber(id: number) {}

let id = &quot;12-34-56&quot;; // 이건 string
fetchProduct(id);

id = 123456; // number로 재할당하려니 에러가 발생
// ~~ '123456' is not assignable to type 'string'.
fetchProductBySerialNumber(id);
                        // ~~ Argument of type 'string' is not assignable to
                        //    parameter of type 'number'
</code></pre>
<p>근본적인 이유는 값은 재할당되지만, 타입은 바뀌지 않기 때문인데, 이는 타입체커는 물론, 협업을 하는 동료에게도 혼란을 주기 쉽습니다.
기본적으로 TS에서는 <strong>하나의 타입에 대해 하나의 변수</strong>를 사용하는 것이 이상적인데, 그 이유는 다음과 같습니다.</p>
<ul>
<li>서로 관련 없는 두 개의 값을 분리합니다.</li>
<li>변수명을 더 구체적으로 지을 수 있습니다.</li>
<li>타입 추론을 향상시키며, 불필요한 타입 구문을 줄일 수 있습니다..</li>
<li>타입이 더 간결해집니다. (<code>string | number</code>를 쪼개서 <code>string</code>, <code>number</code>로 따로 쓰는 쪽을 권장)</li>
<li><code>let</code> 대신에 <code>const</code> 변수를 선언하게 됩니다.
<ul>
<li><code>const</code>로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋습니다.</li>
</ul>
</li>
</ul>
<p>앞선 예시의 &quot;재사용되는 변수&quot;와 아래 예시의 &quot;가려지는(shadowed) 변수&quot;는 엄연히 다릅니다.
아래의 경우는 TS 상에서 문제없이 동작하겠지만, 여전히 다른 동료 개발자들에게 혼란을 주기 쉽습니다.
실제 이러한 이유로 별도의 린팅 규칙을 통해 스타일 규칙으로 이를 막는 개발팀도 많습니다.</p>
<pre><code class="language-ts">function fetchProduct(id: string) {}
function fetchProductBySerialNumber(id: number) {}
const id = &quot;12-34-56&quot;;
fetchProduct(id);

{
  const id = 123456;  // OK
  fetchProductBySerialNumber(id);  // OK
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-넓히기"><a class="header" href="#타입-넓히기">타입 넓히기</a></h1>
<p>TS에서의 각 변수들은 정적 분석 시점에 &quot;가능한 값&quot;들의 집합에 해당하는 <strong>타입</strong>을 갖게 됩니다.
변수를 초기화할 때 타입을 직접 명시하지 않는 경우, 타입 체커가 스스로 타입을 결정하게 되죠.
다시 말해, 지정된 타입 값들을 바탕으로 할당 가능한 값들의 집합을 유출해야 한다는 의미로, TS에서는 이를 <b>넓히기(widening)</b>이라는 명칭으로 부릅니다.</p>
<p>타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 합니다.
그래서 별도로 타입을 명시하지 않은 경우에는, 충분히 구체적으로 타입을 추론하려 하지만, 잘못된 추론(false positive)을 할 정도로 구체적으로 수행하지는 않습니다.
가령 아래와 같은 예시를 들 수 있습니다.</p>
<pre><code class="language-ts">interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
let x = 'x'; // 이 경우 `x` 변수는 string 타입이 됩니다.
let vec = {x: 10, y: 20, z: 30};
getComponent(vec, x);
               // ~ Argument of type 'string' is not assignable to
               //   parameter of type '&quot;x&quot; | &quot;y&quot; | &quot;z&quot;'
</code></pre>
<p>위 예시에서, <code>x</code>는 추후 재할당될 가능성이 있으므로, <code>string</code> 타입으로 추론되며, 이에 따라, <code>'x' | 'y' | 'z'</code> 타입만 할당 가능한 <code>axis</code> 매개변수에 할당할 수 없습니다.</p>
<p>이를 해결할 가장 간단한 방법은 <code>let</code>이 아닌 <code>const</code>를 사용하는 것입니다.
<code>x</code> 변수는 &quot;재할당할 수 없음&quot;이라는 정보를 전달해줌에 따라 TS가 확신을 갖고 <code>x</code> 리터럴 타입으로 추론할 수 있게 됩니다.</p>
<h2 id="타입-추론의-강도를-직접-제어하기"><a class="header" href="#타입-추론의-강도를-직접-제어하기">타입 추론의 강도를 직접 제어하기</a></h2>
<p>타입 추론의 강도를 직접 제어하기 위해서는 TS의 기본 동작을 재정의해야 하는데, 여기에는 세 가지 방법이 있습니다.</p>
<h3 id="타입-명시"><a class="header" href="#타입-명시">타입 명시</a></h3>
<p>첫번째는 직접 변수의 타입을 명시해주는 방법입니다.</p>
<pre><code class="language-ts">const v: { x: 1|3|5 } = {
  x: 1, // type v.x = 1|3|5
};
</code></pre>
<h3 id="추가적인-문맥-제공하기"><a class="header" href="#추가적인-문맥-제공하기">추가적인 문맥 제공하기</a></h3>
<p>두번째는 추가적인 문맥을 제공하는 방법입니다. 아래에서 매개변수로 넘겨지는 객체의 형태는 동일하지만, 문맥에 따라 에러의 발생 여부가 다릅니다.</p>
<pre><code class="language-ts">type User = {
  type: 'customer' | 'guest';
  name: string;
  age: number;
}

const printUser = (user: User) =&gt; console.log(user);

const user = {
  type: 'customer', // string
  name: 'alan',
  age: 21,
};
printUser(user); 
// Argument of type '{ type: string; name: string; age: number; }' is not assignable to parameter of type 'User'.
//   Types of property 'type' are incompatible.
//     Type 'string' is not assignable to type '&quot;customer&quot; | &quot;guest&quot;'.(2345)

printUser({
  type: 'customer',
  name: 'alan',
  age: 21,
}) // 문제 없음
</code></pre>
<h3 id="const-단언문-사용"><a class="header" href="#const-단언문-사용">const 단언문 사용</a></h3>
<p><code>const</code> 단언문은 변수 선언에 쓰이는 <code>let</code>과 <code>const</code>와는 별개의 것이므로 혼동해서는 안됩니다.
<code>as const</code> 단언을 사용하면 TS는 최대한 좁은 타입으로 이를 추론하고자 합니다.</p>
<pre><code class="language-ts">interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
const v1 = {
  x: 1,
  y: 2,
};  // type = { x: number; y: number; }

const v2 = {
  x: 1 as const,
  y: 2,
};  // type = { x: 1; y: number; }

const v3 = {
  x: 1,
  y: 2,
} as const;  // type = { readonly x: 1; readonly y: 2; }
</code></pre>
<p>이를 배열을 튜플 타입으로 만들고자 할 때도 사용할 수 있습니다.</p>
<pre><code class="language-ts">interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
const a1 = [1, 2, 3];  // Type is number[]
const a2 = [1, 2, 3] as const;  // Type is readonly [1, 2, 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-좁히기"><a class="header" href="#타입-좁히기">타입 좁히기</a></h1>
<p>타입 넓히기의 반대는 타입 좁히기(Type narrowing)입니다.
타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말합니다.</p>
<h3 id="null-체킹"><a class="header" href="#null-체킹"><code>null</code> 체킹</a></h3>
<p>가장 일반적인 예시는 <code>null</code> 체킹입니다.
TS가 문맥 상 해당 변수가 <code>null</code>이 아님을 확신할 수 있을 경우, 타입에서 <code>null</code>이 제거됩니다.</p>
<pre><code class="language-ts">const el = document.getElementById('foo'); // Type is HTMLElement | null
if (el) {
  el // Type is HTMLElement
  el.innerHTML = 'Party Time'.blink();
} else {
  el // Type is null
  alert('No element #foo');
}
</code></pre>
<pre><code class="language-ts">const el = document.getElementById('foo'); // Type is HTMLElement | null
if (!el) throw new Error('Unable to find #foo');
el; // Now type is HTMLElement
el.innerHTML = 'Party Time'.blink();
</code></pre>
<h3 id="instanceof"><a class="header" href="#instanceof">instanceof</a></h3>
<pre><code class="language-ts">function contains(text: string, search: string|RegExp) {
  if (search instanceof RegExp) {
    search  // Type is RegExp
    return !!search.exec(text);
  }
  search  // Type is string
  return text.includes(search);
}
</code></pre>
<h3 id="프로퍼티-체크"><a class="header" href="#프로퍼티-체크">프로퍼티 체크</a></h3>
<pre><code class="language-ts">interface A { a: number }
interface B { b: number }
function pickAB(ab: A | B) {
  if ('a' in ab) {
    ab // Type is A
  } else {
    ab // Type is B
  }
  ab // Type is A | B
}
</code></pre>
<h3 id="내장함수-사용"><a class="header" href="#내장함수-사용">내장함수 사용</a></h3>
<pre><code class="language-ts">function contains(text: string, terms: string|string[]) {
  const termList = Array.isArray(terms) ? terms : [terms];
  termList // Type is string[]
  // ...
}
</code></pre>
<h3 id="tagged-union-discriminated-union"><a class="header" href="#tagged-union-discriminated-union">Tagged Union (Discriminated Union)</a></h3>
<pre><code class="language-ts">interface UploadEvent { type: 'upload'; filename: string; contents: string }
interface DownloadEvent { type: 'download'; filename: string; }
type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case 'download':
      e  // Type is DownloadEvent
      break;
    case 'upload':
      e;  // Type is UploadEvent
      break;
  }
}
</code></pre>
<h2 id="user-defined-type-guards-사용자-정의-타입-가드"><a class="header" href="#user-defined-type-guards-사용자-정의-타입-가드">User-Defined Type Guards (사용자 정의 타입 가드)</a></h2>
<p>TS가 타입을 적절히 식별하도록 하기 위해, 커스텀 함수를 직접 작성하여 타입 좁히기에 관여할 수 있습니다.</p>
<pre><code class="language-ts">// 해당 함수가 true를 반환한다면 `el`은 HTMLInputElement 타입으로 좁혀집니다.
function isInputElement(el: HTMLElement): el is HTMLInputElement {
  return 'value' in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    el; // Type is HTMLInputElement
    return el.value;
  }
  el; // Type is HTMLElement
  return el.textContent;
}
</code></pre>
<pre><code class="language-ts">const jackson5 = ['Jackie', 'Tito', 'Jermaine', 'Marlon', 'Michael'];

function isDefined&lt;T&gt;(x: T | undefined): x is T {
  return x !== undefined;
}

const members = ['Janet', 'Michael'].map(
  who =&gt; jackson5.find(n =&gt; n === who) // Type is (string | undefined)[]
).filter(isDefined);  // Type is string[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="한꺼번에-객체-생성하기"><a class="header" href="#한꺼번에-객체-생성하기">한꺼번에 객체 생성하기</a></h1>
<p>타입스크립트의 타입은 일반적으로 변경되지 않기 때문에, 객체를 생성할 때는 속성을 하나씩 추가하기 보다는 여러 프로퍼티를 포함해 한꺼번에 생성해야 타입 추론에 유용합니다.</p>
<pre><code class="language-ts">interface Point { x: number; y: number; }

// Don't
const pt = {};
pt.x = 3; // Property 'x' does not exist on type '{}'.
pt.y = 4; // Property 'y' does not exist on type '{}'.

// Don't
const pt: Point = {}; // Type '{}' is missing the following properties from type 'Point': x, y
pt.x = 3;
pt.y = 4;

// Do
const pt: Point = {
  x: 3,
  y: 4,
};
</code></pre>
<p>객체 전개 연산자(Spread operator) <code>...</code>를 사용하면 여러 객체들을 통해 하나의 새로운 객체를 만들어내기에 용이합니다.</p>
<pre><code class="language-ts">interface Point { x: number; y: number; }
const pt = {x: 3, y: 4};
const id = {name: 'Pythagoras'};
const namedPoint = {...pt, ...id};
// type {
//     name: string;
//     x: number;
//     y: number;
// }
</code></pre>
<p>이를 통해 별도로 타입 명시를 하지 않고도 조건부 속성을 추론하게끔 할 수도 있습니다.
(아래 예시는 책에서 이야기한 것과는 다르게 의도한대로 추론됩니다.)</p>
<pre><code class="language-ts">declare let hasDates: boolean;
const nameTitle = { name: 'Khufu', title: 'Pharaoh' };
const pharaoh = {
    ...nameTitle,
    ...(hasDates ? {start: -2589, end: -2566}: {}),
}
// type {
//     start?: number | undefined;
//     end?: number | undefined;
//     name: string;
//     title: string;
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="일관성있는-별칭-사용하기"><a class="header" href="#일관성있는-별칭-사용하기">일관성있는 별칭 사용하기</a></h1>
<p>별칭(alias)을 남발해서 사용하면 제어 흐름을 분석하기 어렵습니다.
TS에서도 마찬가지로 별칭을 신중하게 사용해야합니다.
그래야 코드를 잘 이해할 수 있고, 오류도 쉽게 찾을 수 있기 때문입니다.</p>
<pre><code class="language-ts">interface Coordinate {
  x: number;
  y: number;
}

interface BoundingBox {
  x: [number, number];
  y: [number, number];
}

interface Polygon {
  exterior: Coordinate[];
  holes: Coordinate[][];
  bbox?: BoundingBox;
}
</code></pre>
<p>위와 같은 자료 구조가 있고, 이에 대해 아래와 같은 함수가 있다고 가정합시다.
현 시점에서 이는 타입에러도 없고, 잘 동작하지만 코드가 반복되는 부분이 존재합니다.</p>
<pre><code class="language-ts">function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  if (polygon.bbox) {
    if (pt.x &lt; polygon.bbox.x[0] || pt.x &gt; polygon.bbox.x[1] ||
        pt.y &lt; polygon.bbox.y[1] || pt.y &gt; polygon.bbox.y[1]) {
      return false;
    }
  }

  // ... more complex check
}
</code></pre>
<p>여기서 중복되는 부분들을 없애기 위해 별도로 <code>box</code>라는 이름의 별칭으로 <code>polygon.bbox</code>를 참조하도록 하는 방법을 사용할 수 있습니다.</p>
<pre><code class="language-ts">function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (box) {
    if (pt.x &lt; box.x[0] || pt.x &gt; box.x[1] ||
        pt.y &lt; box.y[1] || pt.y &gt; box.y[1]) {  // OK
      return false;
    }
  }
  // ...
}
</code></pre>
<p>사실 제일 이상적인 방법은 Destructuring(비구조화) 문법을 통해 <code>bbox</code>라는 일관된 이름을 사용하도록 하는 것입니다. 이를 적용하면 아래와 같아집니다.</p>
<pre><code class="language-ts">function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  // Destructuring을 통해 일관된 이름을 사용할 수 있도록 합니다.
  const { bbox } = polygon;
  if (bbox) {
    const { x, y } = bbox;
    if (pt.x &lt; x[0] || pt.x &gt; x[1] ||
        pt.y &lt; x[0] || pt.y &gt; y[1]) {
      return false;
    }
  }
  // ...
}
</code></pre>
<p>객체 프로퍼티에 직접 접근하지 않고 별도의 지역변수로 분리해낸다는 점은 타입 관점에서 더 안전합니다. 아래와 같이 프로퍼티를 직접 참조하는 경우 기존에 좁혀졌던 타입이 함수 호출 등으로 신뢰할 수 없는 상태가 될 수 있기 때문입니다.</p>
<pre><code class="language-ts">const deletePolygonBox = (polygon: Polygon) =&gt; {
    polygon.bbox = undefined;
}

function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
    polygon.bbox  // Type is BoundingBox | undefined
    if (polygon.bbox) {
    polygon.bbox  // Type is BoundingBox
    deletePolygonBox(polygon); // polygon.bbox = undefined;
    polygon.bbox  // Type is BoundingBox
    }
}
</code></pre>
<p>단, 지역변수로 분리한 경우 기존 프로퍼티 <code>polygon.bbox</code>와 <code>bbox</code>가 항상 같음을 보장할 수 없다는 점에 주의해야합니다.</p>
<pre><code class="language-ts">const resetPolygonBox = (polygon: Polygon) =&gt; {
    polygon.bbox = {
      x: [0, 0],
      y: [0, 0],
    };
}

function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
    const { bbox } = polygon;
    if (bbox) {
    resetPolygonBox(polygon); 
    // 이제 bbox와 polygon.bbox는 동일하지 않습니다.
    // ...
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="비동기-코드에는-콜백-대신-async-함수-사용하기"><a class="header" href="#비동기-코드에는-콜백-대신-async-함수-사용하기">비동기 코드에는 콜백 대신 async 함수 사용하기</a></h1>
<p>비동기 동작을 다룰 때에, 콜백보다는 프로미스를 사용해야 합니다. 이유는 다음과 같습니다.</p>
<ul>
<li>콜백보다는 프로미스가 코드를 작성하기 쉽습니다.</li>
<li>콜백보다는 프로미스가 타입을 추론하기 쉽습니다.</li>
</ul>
<pre><code class="language-ts">function fetchPagesCB() {
  let numDone = 0;
  const responses: string[] = [];
  const done = () =&gt; {
    const [response1, response2, response3] = responses;
    // ...
  };
  const urls = [url1, url2, url3];
  urls.forEach((url, i) =&gt; {
    fetchURL(url, r =&gt; {
      responses[i] = url;
      numDone++;
      if (numDone === urls.length) done();
    });
  });
}
</code></pre>
<p>위와 같은 콜백 기반의 비동기 함수는 프로미스를 통해 아래와 같은 형태가 될 수 있습니다.</p>
<pre><code class="language-ts">async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([
    fetch(url1), fetch(url2), fetch(url3)
  ]);
  // ...
}
</code></pre>
<p>그리고 프로미스보다는 async/await를 사용하는 편이 좋습니다. 이유는 아래와 같습니다.</p>
<ul>
<li>일반적으로 더 간결하고 직관적인 코드가 됩니다.</li>
<li>async 함수는 항상 프로미스를 반환하도록 강제합니다.</li>
</ul>
<p>&quot;함수가 항상 프로미스를 반환하도록 강제&quot;하는 것은 각 함수가 항상 동기 또는 비동기로 실행되어야 한다는 원칙을 쉽게 지키도록 해줍니다.
콜백이나 프로미스를 사용하면 실수로 반(half)동기 코드를 작성할 수 있지만, async 함수에 기반하는 경우 항상 비동기 코드로 작성되기 때문입니다.</p>
<p>아래의 콜백 기반의 함수 <code>fetchWithCache</code>는 얼핏 제대로 만들어진 반동기 함수인 듯 하지만, 실제로 사용할 때 문제를 일으킬 가능성이 있습니다. 캐시가 되어있는 경우에는 <code>callback(..)</code>가 동기적으로 동작할 것이기 때문입니다.</p>
<pre><code class="language-ts">const _cache: {[url: string]: string} = {};

function fetchWithCache(url: string, callback: (text: string) =&gt; void) {
  if (url in _cache) {
    callback(_cache[url]);
  } else {
    fetchURL(url, text =&gt; {
      _cache[url] = text;
      callback(text);
    });
  }
}

let requestStatus: 'loading' | 'success' | 'error';

// 캐시가 있는 경우 =&gt; requestStatus는 'loading'
// 캐시가 없는 경우 =&gt; requestStatus는 'success'
function getUser(userId: string) {
  fetchWithCache(`/user/{userId}`, profile =&gt; {
    requestStatus = 'success';
  });
  requestStatus = 'loading';
}
</code></pre>
<p>이를 async 함수로 대체하면 보다 간결하고, 일관적인 형태로 사용할 수 있게 됩니다.</p>
<pre><code class="language-ts">const _cache: {[url: string]: string} = {};

async function fetchWithCache(url: string) {
  if (url in _cache) {
    return _cache[url];
  }
  const response = await fetch(url);
  const text = await response.text();
  _cache[url] = text;
  return text;
}

let requestStatus: 'loading' | 'success' | 'error';

async function getUser(userId: string) {
  requestStatus = 'loading';
  const profile = await fetchWithCache(`/user/{userId}`);
  requestStatus = 'success';
}
</code></pre>
<p>한가지 유의점으로, async 함수 내에서 프로미스를 반환한다고 해서 <code>Promise&lt;Promise&lt;T&gt;&gt;</code> 반환타입이 되지는 않습니다. 이 경우에도 동일하게 <code>Promise&lt;T&gt;</code>가 됩니다. 타입 체커를 통해서도 이를 확인할 수 있습니다.</p>
<pre><code class="language-ts">// Function getJSON(url: string): Promise&lt;any&gt;
async function getJSON(url: string) {
  const response = await fetch(url);
  const jsonPromise = response.json();  // Type is Promise&lt;any&gt;
  return jsonPromise;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-추론에-문맥이-어떻게-사용되는지-이해하기"><a class="header" href="#타입-추론에-문맥이-어떻게-사용되는지-이해하기">타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></h1>
<p>TS는 타입을 추론할 때 값 뿐만 아니라 문맥도 고려합니다. 함수로 값을 넘기는 경우가 대표적입니다.</p>
<h2 id="string-리터럴의-경우"><a class="header" href="#string-리터럴의-경우">string 리터럴의 경우</a></h2>
<pre><code class="language-ts">type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) { /* ... */ }

setLanguage('JavaScript');  // OK
// 'JavaScript' 리터럴은 `Language` 타입에 부합합니다.

let language = 'JavaScript'; // string으로 추론됩니다.
setLanguage(language);
// ~~~~~~~~ Argument of type 'string' is not assignable
//          to parameter of type 'Language'
</code></pre>
<p>이러한 문제를 해결하기 위해서는 크게 두가지 방법이 있습니다. 이는 당장의 string 리터럴 외에도 범용적으로 활용될 수 있습니다.</p>
<h3 id="타입-선언"><a class="header" href="#타입-선언">타입 선언</a></h3>
<p>하나는 직접 타입을 선언해서 해당 <code>language</code> 변수에 가능한 값을 제한시키는 방법입니다.</p>
<pre><code class="language-ts">let language: Language = 'JavaScript'; // type = Language
</code></pre>
<h3 id="상수로-만들기"><a class="header" href="#상수로-만들기">상수로 만들기</a></h3>
<p>다른 하나는 <code>const</code> 키워드를 통해 <code>language</code> 변수가 변경 가능성이 없음을 타입체커에게 알려줘 더 정확한 타입을 유추할 수 있도록 해주는 방법입니다.</p>
<pre><code class="language-ts">const language = 'JavaScript'; // type = `JavaScript`
</code></pre>
<h2 id="튜플의-경우"><a class="header" href="#튜플의-경우">튜플의 경우</a></h2>
<p>튜플의 경우에도 이러한 문제가 발생할 수 있어 주의해야 합니다.</p>
<pre><code class="language-ts">type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) { /* ... */ }
// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) { /* ... */ }

panTo([10, 20]);  // OK
// [10, 20]은 [number, number] 타입에 부합합니다.

const loc = [10, 20]; // number[]로 추론됩니다.
panTo(loc);
//    ~~~ Argument of type 'number[]' is not assignable to
//        parameter of type '[number, number]'
</code></pre>
<p>이 경우에도 마찬가지로 타입 선언을 통해 해결할 수 있습니다.</p>
<pre><code class="language-ts">const loc: [number, number] = [10, 20];
panTo(loc);  // OK
</code></pre>
<p>또는 해당 매개변수가 <strong>정말로 상수인 경우</strong>에는 <code>const</code> 단언을 사용할 수 있습니다. <code>const</code> 단언을 사용하면 해당 참조가 깊은(deeply) 상수라는 정보를 TS에 전달할 수 있습니다. 다만, 이 경우 해당 값이 <code>readonly</code>가 되어 전혀 변경할 수 없는 상태가 되기 때문에, 해당 값을 매개변수로 사용하는 함수 측에도 <code>readonly</code> 타입 정보를 추가해야 합니다.</p>
<pre><code class="language-ts">function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20] as const; // type = readonly [number, number]
panTo(loc);  // OK
</code></pre>
<p>다만, 해당 방식으로 문제를 해결하는 경우, <code>loc</code>에서 값을 할당하는 시점에 실수가 있었더라도, 정작 에러는 함수를 호출하는 곳에서 발생하기 때문에, 추후 혼란을 줄 수 있다는 문제가 있습니다.</p>
<pre><code class="language-ts">function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20, 30] as const;  // error is really here.
panTo(loc);
//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to
//        parameter of type 'readonly [number, number]'
//          Types of property 'length' are incompatible
//            Type '3' is not assignable to type '2'
</code></pre>
<h2 id="객체의-경우"><a class="header" href="#객체의-경우">객체의 경우</a></h2>
<p>객체의 경우에도 이러한 문제가 동일하게 발생할 수 있습니다.</p>
<pre><code class="language-ts">type Language = 'JavaScript' | 'TypeScript' | 'Python';
interface GovernedLanguage {
  language: Language;
  organization: string;
}

function complain(language: GovernedLanguage) { /* ... */ }

complain({ language: 'TypeScript', organization: 'Microsoft' });  // OK

const ts = {
  language: 'TypeScript', // type = string
  organization: 'Microsoft', // type = string
};
complain(ts);
//       ~~ Argument of type '{ language: string; organization: string; }'
//            is not assignable to parameter of type 'GovernedLanguage'
//          Types of property 'language' are incompatible
//            Type 'string' is not assignable to type 'Language'
</code></pre>
<p>이를 해결하고자 하는 경우에도 앞선 경우들과 마찬가지로 1)타입 선언을 추가하거나, 2)상수로 만들어주는 방법이 있습니다.</p>
<pre><code class="language-ts">// 1) 타입 선언을 추가하거나
const ts: GovernedLanguage = {
  language: 'TypeScript',
  organization: 'Microsoft',
};

// 2) 상수로 만드세요.
const ts = {
  language: 'TypeScript' as const,
  organization: 'Microsoft',
};
</code></pre>
<h2 id="콜백의-경우"><a class="header" href="#콜백의-경우">콜백의 경우</a></h2>
<p>TS는 콜백 함수의 매개변수를 유추하는 경우에도 문맥이 고려됩니다. 따라서 해당 콜백 함수를 따로 분리하는 경우에도 문제가 발생합니다.</p>
<pre><code class="language-ts">function callWithRandomNumbers(fn: (n1: number, n2: number) =&gt; void) {
  fn(Math.random(), Math.random());
}

// 콜백함수의 매개변수에 타입 명시를 하지 않더라도, 문맥으로 타입을 유추해냅니다.
callWithRandomNumbers((a, b) =&gt; {
  a;  // number
  b;  // number
});

// 하지만 아래의 경우는 문맥이 유실되어 타입 추론이 불가능합니다.
const fn = (a, b) =&gt; {
  // ~    Parameter 'a' implicitly has an 'any' type
  //    ~ Parameter 'b' implicitly has an 'any' type
}
callWithRandomNumbers(fn);
</code></pre>
<p>이 경우에도 타입 선언을 통해 해결해줄 수 있습니다.</p>
<pre><code class="language-ts">// 1) 매개변수에 타입을 명시하거나
const fn = (a: number, b: number) =&gt; {
  // ...
}

// 2) 함수 자체에 타입을 명시하세요.
type CallbackFn = (n1: number, n2: number) =&gt; void;
const fn: CallbackFn = (a, b) =&gt; {
  a // number
  b // number
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수형-기법과-라이브러리로-타입-흐름-유지하기"><a class="header" href="#함수형-기법과-라이브러리로-타입-흐름-유지하기">함수형 기법과 라이브러리로 타입 흐름 유지하기</a></h1>
<p>타입스크립트 상에서는 절차형(imperative) 프로그래밍의 형태로 구현하기 보다는, 내장된 함수형 기법이나 로대시 같은 유틸리티 라이브러리를 활용하는 것이 좋습니다.</p>
<ul>
<li>타입 흐름을 개선됩니다.</li>
<li>가독성이 높아집니다.</li>
<li>명시적인 타입 구문의 필요성이 줄어듭니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-설계"><a class="header" href="#타입-설계">타입 설계</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="유효한-상태만-표현하는-타입을-지향하기"><a class="header" href="#유효한-상태만-표현하는-타입을-지향하기">유효한 상태만 표현하는 타입을 지향하기</a></h1>
<p>효과적으로 타입을 설계하려면, <strong>유효한 상태만</strong> 표현할 수 있는 타입을 만들어 내는 것이 가장 중요합니다.
좋지 않은 예시를 하나 들어봅시다.</p>
<pre><code class="language-ts">interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
</code></pre>
<p>위와 같은 상태 구성은 다음과 같은 문제를 갖습니다.</p>
<ul>
<li>로딩 중이면서 동시에 에러가 발생할 수 있습니다.</li>
<li>상태 변경에 실수를 할 여지가 있습니다. (<code>error</code>는 선택 프로퍼티이며, <code>isLoading</code>은 단순한 <code>boolean</code>이기 때문에, 타입 관점에서 실수를 줄일 방법이 없습니다.)</li>
</ul>
<p>이 경우 상태를 좀 더 적절하게 표현하는 방법은 다음과 같습니다.</p>
<pre><code class="language-ts">interface RequestPending {
  state: 'pending';
}

interface RequestError {
  state: 'error';
  error: string;
}

interface RequestSuccess {
  state: 'ok';
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: {[page: string]: RequestState};
}
</code></pre>
<p>작성해야 하는 코드의 양 자체는 늘어났지만, 이는 유효한 상태만을 다루고 있습니다.
이 덕분에, 당장에 의미없는 상태 프로퍼티를 갖게되는 경우는 없게 되어, 이를 다루기가 훨씬 편해졌습니다.
이는 코드가 길어지고, 또 표현하기 어려운 작업이지만, 결국은 시간을 절약하고 고통을 줄일 수 있는 방법입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="사용할-때는-너그럽게-생성할-때는-엄격하게"><a class="header" href="#사용할-때는-너그럽게-생성할-때는-엄격하게">사용할 때는 너그럽게, 생성할 때는 엄격하게</a></h1>
<p>보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있으며, 실제로도 이 쪽이 사용하기 용이합니다.
이를 테면 다음과 같은 함수의 예를 들 수 있습니다.</p>
<pre><code class="language-ts">interface User {
  id: number;
  name?: string;
  age?: number;
}

const updateUser = (option: User) =&gt; {
  // ...
};
</code></pre>
<p>한편, 반환 타입의 경우에는 선택적인 프로퍼티 없이 더 명확하고 엄격해야 합니다.
실제로 넓은 타입 범위를 갖는 반환 타입은 사용하기가 굉장히 불편합니다.
값을 반환받은 이후에도 타입 체킹을 해주어야하는 일이 다분하기 때문입니다.</p>
<pre><code class="language-ts">const createUser = (option: User): User =&gt; {
  return {
    ...option,
  }
}

const { username } = createUser({ id: 1, username: '김앨런', age: 27 });
// type username = string | undefined

const firstName = username.charAt(0); 
// Object is possibly 'undefined'.
</code></pre>
<p>결국 이러한 문제를 해결하려면 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)으로 각각의 상황에 대한 타입을 별도로 두는 것이 좋습니다.</p>
<pre><code class="language-ts">// 기본 형태
interface User {
  id: number;
  name: string;
  age: number;
}

// 느슨한 형태
// type UserOptions = {
//     name?: string | undefined;
//     age?: number | undefined;
//   }
type UserOptions = Partial&lt;Omit&lt;User, 'id'&gt;&gt; 

const updateUser = (id: number, options: UserOptions) =&gt; {
  // ...
}

let id = 1;

const createUser = (options: UserOptions): User =&gt; ({
  id: id++,
  name: '이름없음',
  age: 1,
  ...options,
})

const user = createUser({ name: '김앨런', age: 27 });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="문서에-타입-정보를-쓰지-않기"><a class="header" href="#문서에-타입-정보를-쓰지-않기">문서에 타입 정보를 쓰지 않기</a></h1>
<p>기본적으로 주석은 코드와 동기화되지 않습니다. 다시 말해, 열심히 주석을 작성하더라도, 그것이 최신화된 것이며, 실제로 일치할 것이라는 보장이 없습니다.
또, TS의 타입 체커가 일일이 주석을 다는 것보다 훨씬 정교하기 때문에 때문에 주석을 일일이 작성하는 것은 의미가 없습니다.
결국, 한눈에 이해가 어려운 함수에 대한 설명을 위한 용도로만 주석을 간단하게 활용하는 것이 좋습니다.</p>
<pre><code class="language-ts">/** 애플리케이션 또는 특정 페이지의 배경색을 가져옵니다. */
function getForegroundColor(page?: string): Color {
  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};
}
</code></pre>
<p>불변성(Immutability)의 경우에도, 직접 주석으로 언급하기 보다는, 애초에 <code>readonly</code> 타입 선언으로 타입스크립트가 규칙을 강제하도록 하는 편이 더 좋습니다.</p>
<pre><code class="language-ts">// 이건 좋은 방법이 아닙니다.
/** nums를 변경하지 않습니다! XD */
function sort(nums: number[]) { /* ... */ }

// 주석보다는 타입의 관점에서 강제하세요.
function sort(nums: readonly number[]) { /* ... */ }
</code></pre>
<p>입출력에 대한 설명을 덧붙이고 싶다면 JSDoc을 활용하세요.</p>
<pre><code class="language-ts">/** 
 * @param {string} [page] optional.
*/
function getForegroundColor(page?: string) {
  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};
}
</code></pre>
<p>주석 뿐만 아니라 변수명에 대해서도 이를 그대로 적용할 수 있습니다. 변수명에 굳이 타입 정보를 넣을 필요는 없습니다.</p>
<pre><code class="language-ts">let ageNum; // 이러지 말고
let age: number; // 이렇게 하세요.
</code></pre>
<p>단, 단위가 존재하는 숫자들은 예외입니다. 단위가 무엇인지 확실하지 않은 경우에는 이를 변수명에 포함하여 명확하게 해주는 것이 좋습니다.</p>
<pre><code class="language-ts">let time = 1000 // 이것 보다는
let timeMs = 10000 // 이게 좋고

let temperature = 36.5 // 이것보다는
let temperatureC = 36.5 // 이게 좋습니다.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="왜-react인가"><a class="header" href="#왜-react인가">왜 React인가?</a></h1>
<blockquote>
<p><a href="https://medium.com/javascript-scene/the-missing-introduction-to-react-62837cb2fd76">여기</a>의 내용을 의역 및 일부 편집한 내용입니다.</p>
</blockquote>
<p><strong><em>컴포넌트는 비즈니스 로직, 애플리케이션 상태, 네트워크와 무관하게 있을 때 가장 이상적입니다. 동일한 props가 있다면, 동일한 형태로 렌더링되어야 하죠.</em></strong></p>
<p>다른 프레임워크들이 MVC, MVVM 과 같은 패턴을 따를 때, React는 View에 대한 렌더링을 Model과 완전히 떼어놓으려는 시도를 했습니다. 그 노력이 바로 Flux 패턴입니다.</p>
<p>그렇다면 왜 이것이 MVC보다도 낫다고 여겨졌을까요?</p>
<p>2013년에 페이스북은 채팅 기능을 통합하기 위해 많은 노력을 기울였습니다. 애플리케이션 환경 전반에 걸쳐 라이브가 가능하고, 사이트의 모든 페이지에 통합된 기능이었죠. 이미 복잡한 애플리케이션 내에서의 새로운 복잡한 앱이었고, DOM의 비제어(uncontrolled) 변경과 더불어 수많은 이용자들의 병렬적이고 비동기적인 I/O도 페이스북 팀에게 어려운 과제였습니다.</p>
<p>예를 들어, 그 무엇이든지 간에 DOM을 멋대로 조작하고, 그것을 마음대로 변형할 수 있다면, 과연 적절한 화면이 렌더링된 것인지 어떻게 알 방도가 없습니다.</p>
<p>React 이전에는 이러한 &quot;올바른 화면&quot;에 대한 보장을 그 어떤 프레임워크도 할 수 없었습니다. DOM의 경쟁 상태는 이전 웹 애플리케이션의 가장 흔한 버그 중 하나였습니다.</p>
<h2 id="비결정적--병행-처리--변형가능한-상태"><a class="header" href="#비결정적--병행-처리--변형가능한-상태">비결정적 = 병행 처리 + 변형가능한 상태</a></h2>
<p>React 팀이 가장 먼저 하고자 했던 것은 이러한 문제를 고치는 것이었고, 그러기 위해 두 가지 혁신이 필요했습니다.</p>
<ol>
<li>Flux 구조를 이용한 단방향 데이터 바인딩</li>
<li>Immutable한 컴포넌트 상태 : 일단 설정 되고 나면, 컴포넌트의 상태는 변하지 않습니다. 상태의 변화는 현재 View의 상태를 변경하는 것이 아니라, <strong>새로운 상태에 대한 새로운 View 렌더링을 유발합니다.</strong></li>
</ol>
<p>Flux 패턴을 통해, React는 통제 불가능한 변형의 문제를 다룰 수 있었습니다. 수많은 DOM의 업데이트를 위해 수많은 이벤트 리스너를 추가하는 대신에, React는 컴포넌트의 상태 조작을 위해서 유일한 방법을 사용합니다. 바로 액션을 <strong>Dispatch</strong>하는 것입니다. 이를 통해 Store의 상태가 변경되면, Store는 해당 컴포넌트를 리렌더링합니다.</p>
<img src="https://miro.medium.com/max/700/1*lNLcKqywLkrHadcA-zhgBA.png" />
<p>그래서, &quot;React를 왜 써야 하나요?&quot;에 대한 대답은 심플합니다. 바로 <strong>결정론적인(deterministic) View를 손쉽게 렌더링할 수 있기 때문</strong>입니다.</p>
<blockquote>
<p><em>주의</em> : 따라서, 우리가 VanillaJS를 다루는 것 처럼, DOM에 데이터를 보관하거나 조작하는 것은 안티패턴입니다. 이 경우 React를 쓰는 의미가 없어집니다.</p>
</blockquote>
<p>결정론적인 렌더링 방식은 React의 유일한 트릭이었음에도, 이는 이미 엄청난 혁신이었습니다. 그럼에도 불구하고, React는 계속해서 더 뛰어난 기능들을 선보이고 있습니다.</p>
<h2 id="jsx"><a class="header" href="#jsx">JSX</a></h2>
<p>JSX는 선언적인 형태로 커스텀 UI 컴포넌트를 생성할 수 있는 JS의 확장입니다. JSX는 다음과 같은 장점을 갖습니다.</p>
<ul>
<li>쉽고, 선언적인 마크업</li>
<li>컴포넌트와 함께 배치</li>
<li>관심사를 구분할 수 있음 (ex. UI vs 상태 로직 vs 사이드이펙트)</li>
<li>DOM의 차이를 추상화</li>
<li>내부적인 기술에 대한 추상화</li>
</ul>
<p>단, JSX에서는 명심해야할 부분이 몇가지 있습니다.</p>
<ul>
<li><code>class</code> 어트리뷰트는 JSX에서 <code>className</code>이 됩니다.</li>
<li>List item 형태의 요소들은 반드시 <code>key</code> 어트리뷰트를 가져야 합니다. (여기에 대해서는 이 <a href="https://ko.reactjs.org/docs/reconciliation.html#recursing-on-children">문서</a>를 읽어보세요!)</li>
</ul>
<h2 id="synthetic-events-합성-이벤트"><a class="header" href="#synthetic-events-합성-이벤트">Synthetic Events (합성 이벤트)</a></h2>
<p>React에서는 DOM 이벤트에 대한 래퍼를 제공하는데, 이는 Synthetic Events라고 합니다. 이는 다음과 같은 장점을 갖습니다.</p>
<ol>
<li>이벤트 핸들링 시에 플랫폼 간의 차이를 완화해줍니다.</li>
<li>자체적으로 메모리 관리가 자동으로 이루어집니다. 이를테면, 무한 스크롤 리스트를 만들 때, 메모리 누수를 방지하기 위해 이벤트 위임이 필요할 것입니다. 한편, Synthetic Event는 자동으로 최상단 부모 노드에 이벤트 위임을 적용하기 때문에, 이벤트 메모리 관리에 신경쓰지 않아도 됩니다.</li>
</ol>
<h2 id="컴포넌트-생명주기-component-lifecycle"><a class="header" href="#컴포넌트-생명주기-component-lifecycle">컴포넌트 생명주기 (Component Lifecycle)</a></h2>
<p>React의 컴포넌트 생명주기는 컴포넌트의 상태를 보호하기 위해 존재합니다. 컴포넌트 상태는 React가 컴포넌트를 그려내는 동안에는 변경되지 않아야 하기 때문입니다.</p>
<p>생명주기에 대한 이해는 곧 React가 동작하는 방식에 대한 이해입니다.</p>
<p>React의 컴포넌트 생명주기는 다음과 같이 나누어 볼 수 있습니다.</p>
<img src="https://miro.medium.com/max/336/1*xRzCfozCPTWXp8wgnZrXiA.png" />
<p>그리고, Update 시점은 다음과 같은 형태로 이루어집니다.</p>
<img src="https://miro.medium.com/max/360/1*9wk48udC9l884fOZydImiw.png"/>
<ul>
<li>
<p><strong>Render</strong> - <code>render</code> 함수는 결정론적이며, 사이드이펙트를 포함해서는 안됩니다. 이것을 props를 가져와 JSX를 반환하는 순수 함수로 이해할 수 있습니다.</p>
</li>
<li>
<p><strong>Pre-Commit</strong> - <code>getSnapShotBeforeUpdate</code> 생명주기 메서드를 이용해 DOM으로부터 데이터를 가져올 수 있습니다. 만약 스크롤 위치나 렌더링된 요소의 크기를 파악하고자 할 때 유용합니다.</p>
</li>
<li>
<p><strong>Commit</strong> - DOM과 ref들에 대한 갱신을 수행합니다. <code>componentDidUpdate</code> 또는 <code>useEffect</code> 훅을 통해 이를 이용할 수 있습니다. 여기에서는 사이드 이펙트를 유발하거나 DOM을 조작해도 괜찮습니다.</p>
</li>
</ul>
<p>다음 그림이 React 컴포넌트의 전반적인 흐름을 파악할 수 있게끔 도와 줄 겁니다.</p>
<img src="https://miro.medium.com/max/700/1*cEWErpe-oY-_S1dOaT1NtA.jpeg" />
<p>말했다시피, React에서의 컴포넌트는, &quot;변형&quot;을 가하는 것이 아니라, 상태의 변화에 따라 리렌더링 단계를 거쳐 새롭게 &quot;대체&quot;를 한다고 보는 것이 맞습니다. 이러한 단계를 통해 React의 &quot;결정론적인 View 렌더링&quot;을 쉽게 해줍니다.</p>
<p>다시 말해, React 컴포넌트의 대부분은 앞서 말한 것 처럼, props를 받아 JSX를 반환하는 순수함수로 생각될 수 있습니다.</p>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>React Hooks는 클래스형 컴포넌트가 아닌 경우에도 React 컴포넌트 생명주기를 활용하기 위한 함수들입니다. Hooks의 사용은 일반적으로 사이드 이펙트의 유발을 일으킵니다. 여기서 사이드 이펙트란 함수의 반환값 외에 발생하는 함수 외부 값의 상태 변화를 의미힙니다.</p>
<p>Hooks는 결국 다음과 같은 것들을 가능하게 합니다.</p>
<ul>
<li>클래스형 컴포넌트가 아니더라도 함수형 컴포넌트에서 생명주기 로직을 처리할 수 있습니다.</li>
<li>코드를 더 잘 정리할 수 있습니다.</li>
<li>다른 컴포넌트 간에 재사용할 수 있는 로직을 공유할 수 있습니다.</li>
<li>스스로 임의의 커스텀 훅을 만들 수 있습니다.</li>
</ul>
<h2 id="컨테이너-vs-프레젠테이션-컴포넌트"><a class="header" href="#컨테이너-vs-프레젠테이션-컴포넌트">컨테이너 vs 프레젠테이션 컴포넌트</a></h2>
<p>컴포넌트의 모듈화와 더 나은 재사용성을 위해 대체로 다음의 두 형태로 컴포넌트를 구분지을 수 있습니다.</p>
<ul>
<li><strong>컨테이너 컴포넌트</strong>는 데이터 스토어와 연결되어, 여러 사이드이펙트를 유발할 수 있습니다.</li>
<li><strong>프레젠테이션 컴포넌트</strong>는 <em>대부분</em> 순수 컴포넌트이며, 동일한 컨텍스트 내 동일한 props에 대해서는 항상 동일한 JSX를 반환합니다.</li>
</ul>
<p>프레젠테이션 컴포넌트는 다음과 같은 특징을 지닙니다.</p>
<ul>
<li>네트워크와 접촉하지 않습니다.</li>
<li>로컬 스토리지에 저장 또는 불러오지 않습니다.</li>
<li>랜덤 데이터를 생성하지 않습니다.</li>
<li>현재 시스템 시간을 가져오지 않습니다.(<code>Date.now()</code>)</li>
<li>데이터 스토어에 직접 접근하지 않습니다.</li>
<li>한편, form input과 같은 로컬 컴포넌트 상태를 사용할 수는 있습니다. 물론 이 경우, 최초 상태에서부터 결정론적인 유닛 테스트가 이루어져야 합니다.</li>
</ul>
<p>컨테이너 컴포넌트는 다음과 같은 특징을 지닙니다.</p>
<ul>
<li>상태 관리, I/O, 그 외의 사이드 이펙트를 유발합니다.</li>
<li>스스로에 대한 마크업을 렌더링하지 않아야 합니다.</li>
<li>프레젠테이션 컴포넌트의 래퍼로서 사용됩니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="왜-reducer는-순수해야-하는가"><a class="header" href="#왜-reducer는-순수해야-하는가">왜 Reducer는 순수해야 하는가?</a></h1>
<p><a href="https://medium.com/free-code-camp/why-redux-needs-reducers-to-be-pure-functions-d438c58ae468">여기</a>의 글을 참조했습니다.</p>
<p>Redux는 상태의 변경에 있어서 Reducer를 사용합니다. 그런데 이 Reducer는 아시다시피 기본적으로 <strong>순수함수</strong>입니다. 동일한 Input이 있다면, 항상 동일한 Output을 반환해야 합니다. 이는 다시 말해, 해당 함수가 항상 Immutable하게 동작해야 한다는 뜻이죠.</p>
<img src="https://miro.medium.com/max/700/1*BojNgnfwqAXdqJSsuNf0Sg.png" />
<p>다만, 단순히 생각해볼 때, 얼핏 이는 비효율적으로 보이기도 하죠. 왜 해당 상태를 직접 변경하지 않는 걸까요? 훨씬 더 간편할텐데요.</p>
<p>이는 기본적으로, Redux가 상태의 변경을 감지할 때, &quot;<strong>얕은 비교</strong>&quot;를 하기 때문입니다. 만약에 어떤 변화가 생겼다면, 해당 리듀서로부터 아예 새로운 객체를 반환받을 것이라 생각하는 것이죠.</p>
<p>그래서, Redux는 왜 이런 식으로 구현되어 있을까요?</p>
<p>사실, 답은 간단합니다. 이는 객체의 변화를 깊은 비교를 통해 감지하는 것보다 <strong>훨씬 빠르기 때문입니다.</strong> 만약 JS의 두 객체가 같은 프로퍼티를 가졌는지에 대해 판단하기 위해서는, 깊은 비교를 통해서 각각의 프로퍼티를 일일이 비교해나가야 합니다. 그런데 이 과정은 실제 애플리케이션에서는 굉장히 비용이 많이 드는 과정이죠. 이는 특히 애플리케이션의 규모가 커져 관리해야할 상태가 늘어나게 되면 더더욱 두드러집니다.</p>
<p>그래서 이를 대체하기 위한 방법으로, **개발자는 상태 변화가 생기면 매번 새로운 객체를 만들어 반환해줘야 한다.**라는 하나의 규칙이 Redux에 생겨난 것입니다. 만약 변화가 없다면, 기존의 객체를 반환하면 되는 것이죠. 다시 말해, 새로운 객체는 곧 새로운 상태를 의미합니다.</p>
<p>이러한 규칙이 존재한다면, Redux가 상태의 변화를 감지하는 것이 굉장히 쉬워집니다. 아시다시피 객체의 참조에 대한 비교는 직접 새로운 비교 알고리즘을 구현하지 않더라도 <code>!==</code> 만으로 쉽게 처리할 수 있거든요.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<h2 id="svelte란"><a class="header" href="#svelte란">Svelte란?</a></h2>
<p>Svelte는 React, Vue와 같이 유연하게 상호작용 가능한 UI를 구성하기 위한 JS 프레임워크다.</p>
<p>단, 한가지 중요한 차이가 있는데, Svelte가 런타임 시점에 코드를 해석하는 것이 아니라 <strong>빌드 과정</strong>을 거친다는 점이다. 즉, 프레임워크의 추상화에 따른 성능적인 비용이 없고, 최초 로딩에 있어 부담이 덜하다.</p>
<p>Svelte에서 애플리케이션은 하나 이상의 컴포넌트들로 구성된다. 컴포넌트는 HTML / CSS / JS를 하나로 재사용 가능하게 묶은 코드 블럭이며, 이는 <code>.svelte</code> 확장자 파일로 관리된다.</p>
<h2 id="data-추가"><a class="header" href="#data-추가">Data 추가</a></h2>
<pre><code class="language-svelte">&lt;script&gt;
  let name = 'world';
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>
<h2 id="동적-어트리뷰트"><a class="header" href="#동적-어트리뷰트">동적 어트리뷰트</a></h2>
<pre><code class="language-svelte">&lt;script&gt;
  let src = 'some-image.png';
&lt;/script&gt;

&lt;img src={src} alt=&quot;A man dances.&quot;&gt;
</code></pre>
<h2 id="스타일링"><a class="header" href="#스타일링">스타일링</a></h2>
<pre><code class="language-svelte">&lt;style&gt;
  p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
&lt;/style&gt;

&lt;p&gt;This is a paragraph.&lt;/p&gt;
</code></pre>
<h2 id="중첩-nested-컴포넌트"><a class="header" href="#중첩-nested-컴포넌트">중첩 (Nested) 컴포넌트</a></h2>
<pre><code class="language-svelte">&lt;script&gt;
	import Nested from './Nested.svelte';
&lt;/script&gt;

&lt;p&gt;This is a paragraph.&lt;/p&gt;
&lt;Nested/&gt;
</code></pre>
<h2 id="html-태그"><a class="header" href="#html-태그">HTML 태그</a></h2>
<p>JS에서 일반적인 string을 HTML 태그로서 삽입하고자 할 때 사용한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let string = `this string contains some &lt;strong&gt;HTML!!!&lt;/strong&gt;`;
&lt;/script&gt;

&lt;p&gt;{@html string}&lt;/p&gt;
</code></pre>
<h3 id="주의-1"><a class="header" href="#주의-1"><strong>주의!</strong></a></h3>
<blockquote>
<p>Svelte는 <code>{@html ...}</code> 내에 작성된 내용을 DOM에 추가하기 전에 그 어떤 처리도 하지 않는다. 다시 말해, 신뢰할 수 없는 출처를 통해 해당 기능을 적용하고자 하는 경우, 이에 대한 이스케이프를 직접 처리해주는 것이 매우 중요하다. 그렇지 않은 경우 XSS 공격의 위험이 있다.</p>
</blockquote>
<h2 id="프로젝트-세팅"><a class="header" href="#프로젝트-세팅">프로젝트 세팅</a></h2>
<p>Svelte는 Rollup이나 Webpack과 같은 빌드 툴과 함께 사용할 수 있다.</p>
<p>또, VS Code 상에서 Svelte 익스텐션을 설치하여 IDE 상의 피드백을 받을 수 있다.</p>
<p>Webpack을 통한 세팅이 완료가 되면, <code>svelte-loader</code>가 각각의 컴포넌트들을 JS 클래스로 변환한다. 해당 컴포넌트들은 <code>new</code> 키워드로 아래와 같이 사용할 수 있다.</p>
<pre><code class="language-js">import App from './App.svelte';

const app = new App({
  target: document.body,
  props: {
    // we'll learn about props later
    answer: 42,
  },
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="reactivity"><a class="header" href="#reactivity">Reactivity</a></h1>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>기본적인 이벤트 핸들링은 다음과 같이 할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = 0;

	function handleClick() {
		count += 1;
	}
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
	Clicked {count} {count === 1 ? 'time' : 'times'}
&lt;/button&gt;
</code></pre>
<h2 id="declarations"><a class="header" href="#declarations">Declarations</a></h2>
<p>Svelte는 컴포넌트의 상태가 변하면 자동으로 DOM을 업데이트한다. 종종 일부 상황에서, 특정 상태에 의존적인 다른 상태가 존재할 수 있는데, 이 경우 <strong>Reactive Declaration</strong> 기능을 통해 이를 처리할 수 있다. 정확한 원리는 JS의 [Label]을 참조하자. 다시 말해, 아래와 같이 `<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">‘</span><span class="mord hangul_fallback">를통해이를적용하는경우</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord hangul_fallback">참조하는다른값이변하는경우해당코드를다시실행하라</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∗</span><span class="mord hangul_fallback">는의미를전달할수있다</span><span class="mord">.‘‘‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">lt</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">i</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">;</span></span></span></span>: doubled = count * 2;</p>
<pre><code>function handleClick() {
	count += 1;
}
</code></pre>
</script>
<button on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
<p>{count} doubled is {doubled}</p>
```
<p>물론, 단순히 <code>doubled</code>를 새로 선언하지 않고 <code>{count * 2}</code>와 같이 사용해도 된다.</p>
<h2 id="statements"><a class="header" href="#statements">Statements</a></h2>
<p>Declaration 뿐 아니라 Statement를 처리할 수도 있다.</p>
<pre><code class="language-svelte">: {
	console.log(`the count is {count}`);
	alert(`I SAID THE COUNT IS {count}`);
}
</code></pre>
<p>if 문을 적용할 수도 있다.</p>
<pre><code class="language-svelte">: if (count &gt;= 10) {
	alert(`count is dangerously high!`);
	count = 9;
}
</code></pre>
<h2 id="updating-arrays-and-objects"><a class="header" href="#updating-arrays-and-objects">Updating arrays and objects</a></h2>
<p>React와 마찬가지로, 상태가 array 및 objects인 경우 <code>push</code>나 <code>splice</code> 같은 메서드들은 업데이트를 유발하지 않는다. 이를 해결하기 위한 방안 역시 동일하다.</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4];

function addNumber() {
  numbers = [...numbers, numbers.length + 1];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="props"><a class="header" href="#props">Props</a></h1>
<h2 id="declaring-props"><a class="header" href="#declaring-props">Declaring props</a></h2>
<p>특정 컴포넌트에서 하위 컴포넌트로 데이터를 전달해야할 때, 프로퍼티(props)를 지정해줄 필요가 있다.</p>
<p>Svelte에서는 해당 작업이 <code>export</code> 키워드를 통해서 이루어질 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	export let answer;
&lt;/script&gt;
</code></pre>
<p>이를 상위 컴포넌트에서 사용하려면, 아래와 같은 식이다.</p>
<pre><code class="language-svelte">&lt;Nested answer={42}/&gt;
</code></pre>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<p>아래와 같이 props가 전달되지 않은 경우에 대한 기본값을 지정해줄 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	export let answer = 'a mystery';
&lt;/script&gt;
</code></pre>
<h2 id="spread-props"><a class="header" href="#spread-props">Spread Props</a></h2>
<p>별도로 objects로 props들을 전달하려는 경우, spread 연산자로 이를 처리할 수 있다. React랑 똑같다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import Info from './Info.svelte';

	const pkg = {
		name: 'svelte',
		version: 3,
		speed: 'blazing',
		website: 'https://svelte.dev'
	};
&lt;/script&gt;

&lt;Info {...pkg}/&gt;
</code></pre>
<p>만약, 별도로 <code>export</code> 키워드를 통해 props를 지정하지 않았음에도, 전달받는 값을 사용해야 하는 경우, `<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord hangul_fallback">를통해컴포넌트에서접근할수있다</span><span class="mord">.</span></span></span></span></span></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="logic"><a class="header" href="#logic">Logic</a></h1>
<p>Svelte는 조건 혹은 루프와 같은 로직을 처리할 수 있다.</p>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p>조건에 따라 특정 컴포넌트를 렌더링하고자 하는 경우, 아래와 같이 <code>if</code>를 통해 감싸주자.</p>
<pre><code class="language-svelte">{#if user.loggedIn}
	&lt;button on:click={toggle}&gt;
		Log out
	&lt;/button&gt;
{/if}

{#if !user.loggedIn}
	&lt;button on:click={toggle}&gt;
		Log in
	&lt;/button&gt;
{/if}
</code></pre>
<h2 id="else"><a class="header" href="#else">else</a></h2>
<p>else에 대해서는 아래와 같이 처리할 수 있다.</p>
<pre><code class="language-svelte">{#if user.loggedIn}
	&lt;button on:click={toggle}&gt;
		Log out
	&lt;/button&gt;
{:else}
	&lt;button on:click={toggle}&gt;
		Log in
	&lt;/button&gt;
{/if}
</code></pre>
<ul>
<li><code>#</code> : 블럭을 여는 태그</li>
<li><code>/</code> : 블럭을 닫는 태그</li>
<li><code>:</code> : 블럭 내에서 사용되는 태그</li>
</ul>
<h2 id="else-if"><a class="header" href="#else-if">else-if</a></h2>
<pre><code class="language-svelte">{#if x &gt; 10}
	&lt;p&gt;{x} is greater than 10&lt;/p&gt;
{:else if 5 &gt; x}
	&lt;p&gt;{x} is less than 5&lt;/p&gt;
{:else}
	&lt;p&gt;{x} is between 5 and 10&lt;/p&gt;
{/if}
</code></pre>
<h2 id="each"><a class="header" href="#each">each</a></h2>
<p>여러 개의 데이터가 Array 형태로 있는 경우, <code>each</code> 를 사용해 각각에 대한 순회 로직을 처리할 수 있다.</p>
<p>여기서의 Array는 배열 혹은 유사배열 객체라면 뭐든 가능하다.</p>
<p>또한, 두번째 인자로 <code>index</code>가 전달되기 때문에, 추가적으로 이를 이용할 수 있다.</p>
<pre><code>{#each cats as cat, i}
	&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.youtube.com/watch?v={cat.id}&quot;&gt;
		{i + 1}: {cat.name}
	&lt;/a&gt;&lt;/li&gt;
{/each}
</code></pre>
<h2 id="keyed-each"><a class="header" href="#keyed-each">Keyed each</a></h2>
<p>기본으로, <code>each</code>의 값에 대한 수정이 이루어지는 경우, 이들은 아예 처음부터 리렌더링 된다.</p>
<p>이 경우, 성능 상으로도 우려가 있을 뿐더러, 의도대로 동작하지 않을 가능성이 다분하다.</p>
<p>때문에, <code>each</code> 블럭에 별도의 고유 <code>id</code>를 지정해줌으로써 변경되지 않는 item에 대해서는 리렌더링을 방지해줄 수 있다.</p>
<pre><code class="language-svelte">{#each things as thing (thing.id)}
	&lt;Thing current={thing.color}/&gt;
{/each}
</code></pre>
<p>사실 Svelte는 내부적으로 key 관리에 <code>Map</code>을 사용하기 때문에, 무엇이든지 <code>key</code>로써 사용할 수 있다. 다시말해, 위의 경우에는 굳이 <code>thing.id</code>가 아닌 <code>thing</code>을 사용해도 된다. <strong>하지만, 일반적으로는 string 혹은 number를 사용하는 것이 안전하다.</strong> key 변경 감지에 단순히 참조에 대한 동일성을 확인하기 때문.</p>
<h2 id="await"><a class="header" href="#await">Await</a></h2>
<p>대부분의 웹 애플리케이션은 비동기적으로 데이터를 다루어야만 하는 경우가 발생한다. Svelte는 마크업 내에서 직접적으로 promise를 다룰 수 있게끔 한다.</p>
<pre><code class="language-svelte">{#await promise}
	&lt;p&gt;...waiting&lt;/p&gt;
{:then number}
	&lt;p&gt;The number is {number}&lt;/p&gt;
{:catch error}
	&lt;p style=&quot;color: red&quot;&gt;{error.message}&lt;/p&gt;
{/await}
</code></pre>
<p>오직 가장 최신의 promise에 대해서만 고려되며, 다시 말해 race condition에 대해 신경 쓸 필요가 없다.</p>
<p>사용되는 promise가 rejected 상태가 될 염려가 없는 경우에는, <code>catch</code> 블럭을 제거할 수도 있으며, 심지어 resolved 상태 이전에 별도로 보여주고자 하는 내용이 없는 경우에는 이조차 없애도 상관없다.</p>
<pre><code class="language-svelte">{#await promise then value}
	&lt;p&gt;the value is {value}&lt;/p&gt;
{/await}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="events-1"><a class="header" href="#events-1">Events</a></h1>
<h2 id="dom-events"><a class="header" href="#dom-events">DOM events</a></h2>
<p>이미 앞서 살펴본 것 처럼, <code>on:</code> 명령어를 통해 특정 요소에 이벤트 핸들러를 부여할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
&lt;/script&gt;

&lt;div on:mousemove={handleMousemove}&gt;
	The mouse position is {m.x} x {m.y}
&lt;/div&gt;

&lt;style&gt;
	div { width: 100%; height: 100%; }
&lt;/style&gt;
</code></pre>
<h2 id="inline-handler"><a class="header" href="#inline-handler">Inline handler</a></h2>
<p>인라인으로 직접 부여할 수도 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
&lt;/script&gt;

&lt;div on:mousemove=&quot;{e =&gt; m = { x: e.clientX, y: e.clientY }}&quot;&gt;
	The mouse position is {m.x} x {m.y}
&lt;/div&gt;

&lt;style&gt;
	div { width: 100%; height: 100%; }
&lt;/style&gt;
</code></pre>
<p><code>&quot;</code> 따옴표는 선택사항이다. 없어도 상관 없다.</p>
<p>일부 프레임워크에서는 이러한 인라인 이벤트 핸들러를 사용하는 것을 지양하지만, Svelte의 경우 컴파일링 단계에서 성능 상의 최적화가 진행되므로 문제가 없다.</p>
<h2 id="event-modifiers"><a class="header" href="#event-modifiers">Event modifiers</a></h2>
<p>DOM 이벤트 핸들러들은 그들 동작을 변경해주는 Event modifier를 가질 수 있다. 이를테면, 아래처럼 <code>once</code>를 이벤트 핸들러에 덧붙인 경우 해당 이벤트 핸들러는 딱 한번만 동작한다.</p>
<pre><code class="language-svelte">&lt;button on:click|once={handleClick}&gt;
	Click me
&lt;/button&gt;
</code></pre>
<p>아래는 Event modifier의 전체 목록이다.</p>
<ul>
<li><code>preventDefault</code> - 핸들러를 동작시키기 전에 <code>event.preventDefault()</code>를 먼저 수행한다.</li>
<li><code>stopPropagation</code> - <code>event.stopPropagation()</code>을 호출한다. 다시 말해, 이벤트 버블링/캡처링을 막는다.</li>
<li><code>passive</code> - 터치 및 마우스 휠 이벤트에 대한 스크롤 성능을 향상시킨다. [<a href="https://ko.javascript.info/default-browser-action#ref-2368">참조</a>]</li>
<li><code>nonpassive</code> - <code>passive: false</code>를 의미한다.</li>
<li><code>capture</code> - 이벤트 핸들러의 동작에 있어 버블링이 아닌 캡처링 단계를 사용한다.</li>
<li><code>once</code> - 이벤트 핸들러를 딱 한번만 동작시키고 제거한다.</li>
<li><code>self</code> - 오직 해당 요소 본인에서 이벤트가 발생했을 때만 이벤트 핸들러를 동작시킨다. (event.target === currentTarget)</li>
</ul>
<p>이러한 Event modifier들은 <code>on:click|once|capture={...}</code>와 같이 여러 개를 한번에 체이닝할 수 있다.</p>
<h2 id="component-events"><a class="header" href="#component-events">Component events</a></h2>
<p>컴포넌트 역시 이벤트를 디스패치할 수 있다. 이를 위해서는 이벤트 디스패쳐를 만들어야한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();

	function sayHello() {
		dispatch('message', {
			text: 'Hello!'
		});
	}
&lt;/script&gt;
</code></pre>
<p>위에서의 <code>text</code>는 <code>event.detail.text</code>를 통해 접근할 수 있다.</p>
<h2 id="event-forwarding"><a class="header" href="#event-forwarding">Event forwarding</a></h2>
<p>DOM 이벤트와 다르게, 컴포넌트 이벤트는 버블링되지 않는다. 따라서, 상위 컴포넌트에서 이벤트를 전달받기 위해선 각 층의 컴포넌트마다 이벤트를 디스패치 해주어야 한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import Inner from './Inner.svelte';
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();

	function forward(event) {
		dispatch('message', event.detail);
	}
&lt;/script&gt;

&lt;Inner on:message={forward}/&gt;
</code></pre>
<p>단, 이러한 과정 자체가 너무 많은 코드를 작성하게 만드므로, Svelte에서는 이러한 내용을 다음과 같이 짧게 처리할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import Inner from './Inner.svelte';
&lt;/script&gt;

&lt;Inner on:message/&gt;
</code></pre>
<h2 id="dom-event-forwarding"><a class="header" href="#dom-event-forwarding">DOM event forwarding</a></h2>
<p>DOM 이벤트 역시 이벤트 포워딩을 처리할 수 있다. 해당 요소 본인이 처리할 이벤트 핸들러가 존재하지 않더라도, 상위 컴포넌트로 이를 전달해주는 역할을 한다.</p>
<pre><code class="language-svelte">&lt;button on:click&gt;
	Click me
&lt;/button&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bindings"><a class="header" href="#bindings">Bindings</a></h1>
<h2 id="text-inputs"><a class="header" href="#text-inputs">Text inputs</a></h2>
<p>일반적으로, Svelte에서의 데이터 흐름은 탑-다운 형식이다. 부모 컴포넌트에서 자식 컴포넌트에 props를 전달할 수 있고, 컴포넌트는 보유한 요소들에 대해 어트리뷰트를 설정할 수 있다.</p>
<p>가끔, 이러한 규칙을 깨야하는 경우가 있는데, 대표적인 경우가 컴포넌트 내에 <code>&lt;input&gt;</code> 태그를 보유한 경우다. 우리는 <code>on:input</code>에 대한 이벤트 핸들러를 추가하여 <code>event.target.name</code>에 따라 별도의 상태값을 변경하도록 구성할 수 있다. 다만, 이러한 과정 자체를 매번 반복하게 되면 너무 번거롭다.</p>
<p>대신에, 이러한 상황에 <code>bind:value</code> 명령을 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let name = 'world';
&lt;/script&gt;

&lt;input bind:value={name}&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>
<p><code>bind</code>를 사용하는 경우, <code>input</code>의 <code>value</code>값 변경에 따라 <code>name</code>의 값을 변경할 뿐만 아니라, <code>name</code>의 값이 변경됨에 따라 <code>value</code>값 역시 변경된다.</p>
<h2 id="numeric-inputs"><a class="header" href="#numeric-inputs">Numeric inputs</a></h2>
<p>DOM 상에서, 모든 값들은 string 으로 다루어진다. 이런 경우, <code>type=&quot;number&quot;</code> 혹은 <code>type=&quot;range&quot;</code>인 상황에서, 값을 다루기에 다소 까다로워지며, 별도로 데이터 타입을 변환해주어야 한다.</p>
<p>Svelte에서는 <code>bind:value</code>를 사용하면, 알아서 이러한 과정을 처리해준다.</p>
<pre><code class="language-svelte">&lt;input type=number bind:value={a} min=0 max=10&gt;
&lt;input type=range bind:value={a} min=0 max=10&gt;
</code></pre>
<h2 id="checkbox-inputs"><a class="header" href="#checkbox-inputs">Checkbox inputs</a></h2>
<p>체크박스들은 상태 값들을 토글링(toggling)하기 위해 사용된다. 이 경우, 이들의 상태값은 <code>value</code>가 아닌 <code>checked</code>가 되므로, 다음과 같이 사용해야 한다.</p>
<pre><code class="language-svelte">&lt;input type=checkbox bind:checked={yes}&gt;
</code></pre>
<h2 id="group-inputs"><a class="header" href="#group-inputs">Group inputs</a></h2>
<p>동일한 값에 대한 여러 input들이 존재한다면, <code>bind:group</code>을 사용할 수 있다. 대표적으로 <code>radio</code> 혹은 <code>checkbox</code> 태그가 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let scoops = 1;
	let flavours = ['Mint choc chip'];

	let menu = [
		'Cookies and cream',
		'Mint choc chip',
		'Raspberry ripple'
	];

	function join(flavours) {
		if (flavours.length === 1) return flavours[0];
		return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.001892em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ce&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05724em;&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.751892em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.751892em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{flavours[flavours.length - 1]}`;
	}
&lt;/script&gt;

&lt;h2&gt;Size&lt;/h2&gt;

&lt;label&gt;
	&lt;input type=radio bind:group={scoops} value={1}&gt;
	One scoop
&lt;/label&gt;

&lt;label&gt;
	&lt;input type=radio bind:group={scoops} value={2}&gt;
	Two scoops
&lt;/label&gt;

&lt;label&gt;
	&lt;input type=radio bind:group={scoops} value={3}&gt;
	Three scoops
&lt;/label&gt;

&lt;h2&gt;Flavours&lt;/h2&gt;

{#each menu as flavour}
	&lt;label&gt;
		&lt;input type=checkbox bind:group={flavours} value={flavour}&gt;
		{flavour}
	&lt;/label&gt;
{/each}

{#if flavours.length === 0}
	&lt;p&gt;Please select at least one flavour&lt;/p&gt;
{:else if flavours.length &gt; scoops}
	&lt;p&gt;Can't order more flavours than scoops!&lt;/p&gt;
{:else}
	&lt;p&gt;
		You ordered {scoops} {scoops === 1 ? 'scoop' : 'scoops'}
		of {join(flavours)}
	&lt;/p&gt;
{/if}
</code></pre>
<h2 id="textarea-inputs"><a class="header" href="#textarea-inputs">Textarea inputs</a></h2>
<p><code>&lt;textarea&gt;</code> 요소는 <code>&lt;text&gt;</code>와 거의 동일하게 동작하며, <code>bind:value</code>를 사용하면 된다.</p>
<pre><code class="language-svelte">&lt;textarea bind:value={value}&gt;&lt;/textarea&gt;
</code></pre>
<p>만약, 변경할 상태의 변수명이 똑같이 <code>value</code>로 일치한다면, 아래와 같이 약식으로 작성할 수 있다.</p>
<pre><code class="language-svelte">&lt;textarea bind:value&gt;&lt;/textarea&gt;
</code></pre>
<h2 id="select-bindings"><a class="header" href="#select-bindings">Select bindings</a></h2>
<p><code>&lt;select&gt;</code> 요소에도 <code>bind:value</code>를 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;select bind:value={selected} on:change=&quot;{() =&gt; answer = ''}&quot;&gt;
</code></pre>
<p><code>&lt;select&gt;</code> 하위에 있는 <code>&lt;option&gt;</code> 값들이 string이 아닌 object임을 주의하자.</p>
<p><code>selected</code>에 대한 기본값을 설정하지 않았기 때문에, binding 시에 기본적으로 <code>select</code>는 리스트의 첫번째 값을 <code>selected</code>로 설정해준다.</p>
<h2 id="select-multiple"><a class="header" href="#select-multiple">Select multiple</a></h2>
<p><code>&lt;select&gt;</code>는 <code>multiple</code> 어트리뷰트를 사용할 수 있으며, 이 경우 하나 이상의 값들을 <strong>Array 형태로 받아올 수 있게 된다.</strong></p>
<pre><code class="language-svelte">&lt;h2&gt;Flavours&lt;/h2&gt;

&lt;select multiple bind:value={flavours}&gt;
	{#each menu as flavour}
		&lt;option value={flavour}&gt;
			{flavour}
		&lt;/option&gt;
	{/each}
&lt;/select&gt;
</code></pre>
<h2 id="contenteditable-bindings"><a class="header" href="#contenteditable-bindings">Contenteditable bindings</a></h2>
<p><code>contenteditable=&quot;true&quot;</code> 어트리뷰트를 보유한 요소들은 <code>textContent</code>와 <code>innerHTML</code>에 대해서도 바인딩을 할 수 있다.</p>
<pre><code class="language-svelte">&lt;div
	contenteditable=&quot;true&quot;
	bind:innerHTML={html}
&gt;&lt;/div&gt;
</code></pre>
<h2 id="each-block-bindings"><a class="header" href="#each-block-bindings">Each block bindings</a></h2>
<p><code>each</code> 문 내에서도 바인딩을 할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let todos = [
		{ done: false, text: 'finish Svelte tutorial' },
		{ done: false, text: 'build an app' },
		{ done: false, text: 'world domination' }
	];

	function add() {
		todos = todos.concat({ done: false, text: '' });
	}

	function clear() {
		todos = todos.filter(t =&gt; !t.done);
	}

	: remaining = todos.filter(t =&gt; !t.done).length;
&lt;/script&gt;

&lt;h1&gt;Todos&lt;/h1&gt;

{#each todos as todo}
	&lt;div class:done={todo.done}&gt;
		&lt;input
			type=checkbox
			bind:checked={todo.done}
		&gt;

		&lt;input
			placeholder=&quot;What needs to be done?&quot;
			bind:value={todo.text}
		&gt;
	&lt;/div&gt;
{/each}

&lt;p&gt;{remaining} remaining&lt;/p&gt;

&lt;button on:click={add}&gt;
	Add new
&lt;/button&gt;

&lt;button on:click={clear}&gt;
	Clear completed
&lt;/button&gt;

&lt;style&gt;
	.done {
		opacity: 0.4;
	}
&lt;/style&gt;
</code></pre>
<p>이 경우 바인딩은 <code>todos</code> Array를 직접 변경하게 된다. 본인이 불변성을 유지하는 형태를 선호한다면, 이 경우엔 바인딩을 사용하지 말고 이벤트 핸들러를 직접 작성하는 편이 좋다.</p>
<h2 id="media-elements"><a class="header" href="#media-elements">Media elements</a></h2>
<p><code>&lt;audio&gt;</code>와 <code>&lt;video&gt;</code> 요소는 바인딩 할 수 있는 수많은 프로퍼티들이 존재한다.</p>
<p>아래는 바인딩 가능한 읽기 전용 프로퍼티다.</p>
<ul>
<li><code>duration</code> (readonly) — 비디오 및 오디오의 전체 시간, 초 단위</li>
<li><code>buffered</code> (readonly) — {start, end} 객체 Array</li>
<li><code>seekable</code> (readonly) — {start, end} 객체 Array</li>
<li><code>played</code> (readonly) — {start, end} 객체 Array</li>
<li><code>seeking</code> (readonly) — boolean</li>
<li><code>ended</code> (readonly) — boolean</li>
</ul>
<p>비디오의 경우는 <code>videoWidth</code> 및 <code>videoHeight</code> 읽기 전용 속성이 추가적으로 존재한다.</p>
<p>아래는 쌍방향으로 바인딩 가능한 프로퍼티들이다.</p>
<ul>
<li><code>currentTime</code> - 비디오 및 오디오의 현재 위치</li>
<li><code>playbackRate</code> - 비디오 및 오디오의 재생 속도, <code>1</code>이 기본.</li>
<li><code>paused</code> - 정지 여부</li>
<li><code>volume</code> - <code>0</code>부터 <code>1</code> 사이의 값</li>
<li><code>muted</code> - 음소거 여부, boolean</li>
</ul>
<h2 id="dimensions"><a class="header" href="#dimensions">Dimensions</a></h2>
<p>모든 블록 요소들은 <code>clientWidth</code>, <code>clientHeight</code>, <code>offsetWidth</code>, 그리고 <code>offsetHeight</code>에 대한 바인딩을 할 수 있다.</p>
<pre><code>&lt;div bind:clientWidth={w} bind:clientHeight={h}&gt;
	&lt;span style=&quot;font-size: {size}px&quot;&gt;{text}&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>이들 바인딩은 읽기 전용이며, 이들 값을 직접 변경하는 것은 아무 의미가 없다.</p>
<blockquote>
<p><strong>주의</strong> :
요소의 크기 등을 측정하기 위해서는 내부적으로 <a href="http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/">이런 테크닉</a>을 사용한다. 이 경우, 오버헤드에 대한 우려 때문에 너무 많은 수에 대해 해당 바인딩을 사용하지 않는 것을 추천한다.</p>
</blockquote>
<h2 id="this"><a class="header" href="#this">This</a></h2>
<p><code>this</code>에 대한 바인딩은 읽기 전용이며, 모든 요소 및 컴포넌트에 사용할 수 있다.</p>
<p>이는 React에서의 Ref와 유사하며, 요소 및 컴포넌트에 대한 참조값을 얻을 수 있다.</p>
<pre><code class="language-svelte">&lt;canvas
	bind:this={canvas}
	width={32}
	height={32}
&gt;&lt;/canvas&gt;
</code></pre>
<p>위 예시에서 <code>canvas</code>는 컴포넌트가 마운트되기 전까지는 <code>undefined</code>임에 유의하자. 때문에, 마운트 시에 해당 컴포넌트 및 요소에 특정 로직을 적용하려면 <code>onMount</code> 등의 라이프사이클 메서드를 사용해야 한다. 이에 대해선 추후 살펴본다.</p>
<h2 id="component-bindings"><a class="header" href="#component-bindings">Component bindings</a></h2>
<p>DOM 요소들의 프로퍼티에 대해 바인딩을 할 수 있는 것처럼, 컴포넌트의 props에 대해서도 바인딩을 할 수 있다.</p>
<pre><code class="language-svelte">&lt;Keypad bind:value={pin} on:submit={handleSubmit}/&gt;
</code></pre>
<p>이 경우, 하위 컴포넌트에서 상태 변화가 일어나면, 바인딩을 적용한 부모 요소에 대해서도 이에 따른 변경이 일어난다.</p>
<blockquote>
<p><strong>주의</strong> : 가능하다면 컴포넌트 바인딩은 사용하지 않는 편이 좋다. 애플리케이션 규모가 커지면서, 데이터 흐름이 너무 많아지는 경우 이에 대한 추적이 어려울 수 있다. 이러한 문제는 single souce of truth가 없는 경우에 더욱 심각해진다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h1>
<h2 id="onmount"><a class="header" href="#onmount">onMount</a></h2>
<p>모든 컴포넌트는 생성되는 시점에서부터 사라질 때까지 생명주기가 존재한다. Svelte 역시 이를 다루기 위한 몇가지 함수들을 제공한다.</p>
<p><code>onMount</code>는 그중 가장 자주 사용하게 될 생명주기 함수로, 최초로 DOM에 렌더링된 이후에 실행된다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { onMount } from 'svelte';

	let photos = [];

	onMount(async () =&gt; {
		const res = await fetch(`https://jsonplaceholder.typicode.com/photos?_limit=20`);
		photos = await res.json();
	});
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>주의</strong> : SSR에 의해, <code>fetch</code> 메서드는 <code>script</code> 태그의 최상위 보다 <code>onMount</code>에 위치하는 것이 좋다. <code>onDestroy</code>를 제외하면, SSR 중에는 생명주기 함수가 실행되지 않으며, 다시말해 DOM에 마운트 된 이후에야 실행되어야 하는 데이터를 페칭하는 경우를 방지할 수 있다.</p>
</blockquote>
<p><code>onMount</code>의 콜백함수에서 함수를 반환할 수 있는데, 이 경우 해당 함수는 컴포넌트가 사라질 때 호출된다. (clean up)</p>
<h2 id="ondestroy"><a class="header" href="#ondestroy">onDestroy</a></h2>
<p>함수에 사라질 때 특정 로직을 처리하고자 할 때 <code>onDestroy</code> 함수를 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { onDestroy } from 'svelte';

	let seconds = 0;
	const interval = setInterval(() =&gt; seconds += 1, 1000);

	onDestroy(() =&gt; clearInterval(interval));
&lt;/script&gt;
</code></pre>
<p>이러한 생명주기 함수들을 React의 커스텀 Hook 처럼 사용할 수도 있다.</p>
<pre><code class="language-svelte">import { onDestroy } from 'svelte';

export function onInterval(callback, milliseconds) {
	const interval = setInterval(callback, milliseconds);

	onDestroy(() =&gt; {
		clearInterval(interval);
	});
}
</code></pre>
<h2 id="beforeupdate--afterupdate"><a class="header" href="#beforeupdate--afterupdate">beforeUpdate &amp; afterUpdate</a></h2>
<p><code>beforeUpdate</code> 함수는 컴포넌트의 상태에 따라 DOM이 업데이트 되기 전마다 실행되며, 반대로 <code>afterUpdate</code>는 DOM이 업데이트 된 이후에 실행된다.</p>
<p>단순히 상태 중심적인 방식으로는 처리하기 어려운 로직을 처리하기 위한 경우에 종종 유용하다. (ex. 스크롤 위치 변경 등)</p>
<pre><code class="language-svelte">let div;
let autoscroll;

beforeUpdate(() =&gt; {
	autoscroll = div &amp;&amp; (div.offsetHeight + div.scrollTop) &gt; (div.scrollHeight - 20);
});

afterUpdate(() =&gt; {
	if (autoscroll) div.scrollTo(0, div.scrollHeight);
});
</code></pre>
<h2 id="tick"><a class="header" href="#tick">tick</a></h2>
<p><code>tick</code> 함수는 다른 생명주기 함수들과 다르게, 최초에 함수가 초기화되는 시점이 아닌, 어디서는 호출할 수 있다. 해당 함수는 보류 중인 상태 변경 사항이 DOM에 적용된 이후 즉시 resolved 되는 promise를 반환한다.</p>
<p>Svelte는 컴포넌트의 상태가 업데이트될 때, DOM을 바로 업데이트하지 않고, 적용할 다른 변경 사항이 없는지를 판단하기 위해 다음 마이크로태스트까지 대기한다. 이렇게 함으로써 불필요한 동작을 피하고, 브라우저가 더 효율적으로 작업을 일괄 처리할 수 있도록 도와준다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { tick } from 'svelte';

	let text = `Select some text and hit the tab key to toggle uppercase`;

	async function handleKeydown(event) {
		if (event.key !== 'Tab') return;

		event.preventDefault();

		const { selectionStart, selectionEnd, value } = this;
		const selection = value.slice(selectionStart, selectionEnd);

		const replacement = /[a-z]/.test(selection)
			? selection.toUpperCase()
			: selection.toLowerCase();

		text = (
			value.slice(0, selectionStart) +
			replacement +
			value.slice(selectionEnd)
		);

		await tick();
		this.selectionStart = selectionStart;
		this.selectionEnd = selectionEnd;
	}
&lt;/script&gt;

&lt;style&gt;
	textarea {
		width: 100%;
		height: 200px;
	}
&lt;/style&gt;

&lt;textarea value={text} on:keydown={handleKeydown}&gt;&lt;/textarea&gt;
</code></pre>
<p>위와 같이 사용하는 경우, <code>await tick();</code>의 이전까지의 내용들이 모두 적용되고, DOM이 업데이트 된 이후, 그 다음의 로직들이 처리된다. 즉, DOM이 업데이트되고 나서야 <code>await tick()</code> 이후의 코드가 실행된다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="stores"><a class="header" href="#stores">Stores</a></h1>
<h2 id="writable-stores"><a class="header" href="#writable-stores">Writable stores</a></h2>
<p>Svelte에서는 <em>store</em>를 통해 상태 로직을 컴포넌트와 분리할 수 있다. store는 상태값이 변경되었을 때 관련 컴포넌트들에게 알려주는 <code>subscribe</code> 메서드를 가진 단순한 객체다.</p>
<p>store 중에는 <strong>writable store</strong>가 있으며, 이는 <code>set</code>과 <code>update</code>메서드를 갖는다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { count } from './stores.js';
	import Incrementer from './Incrementer.svelte';
	import Decrementer from './Decrementer.svelte';
	import Resetter from './Resetter.svelte';

	let count_value;

	const unsubscribe = count.subscribe(value =&gt; {
		count_value = value;
	});
&lt;/script&gt;
</code></pre>
<p><code>update</code>는 인수를 콜백함수로 받으며, <code>set</code>는 직접적인 값을 받는다.</p>
<pre><code class="language-svelte">function increment() {
	count.update(n =&gt; n + 1);
}
</code></pre>
<pre><code class="language-svelte">function reset() {
	count.set(0);
}
</code></pre>
<h2 id="auto-subscriptions"><a class="header" href="#auto-subscriptions">Auto-subscriptions</a></h2>
<p>만약, 컴포넌트가 초기화와 제거를 여러번 반복하게 되는 경우, <code>unsubscribe</code> 함수를 실행하지 않게되면 메모리 누수의 위험이 있다.</p>
<p>따라서, 이를 방지하기 위해선 <code>onDestroy</code> 생명주기 메서드에서 이를 호출해주어야 한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { onDestroy } from 'svelte';
	import { count } from './stores.js';
	import Incrementer from './Incrementer.svelte';
	import Decrementer from './Decrementer.svelte';
	import Resetter from './Resetter.svelte';

	let count_value;

	const unsubscribe = count.subscribe(value =&gt; {
		count_value = value;
	});

	onDestroy(unsubscribe);
&lt;/script&gt;

&lt;h1&gt;The count is {count_value}&lt;/h1&gt;
</code></pre>
<p>헌데, 여러 컴포넌트에 대해 동일한 작업을 해주어야 하는 상황이라면 이런 방법이 다소 번거롭게 느껴질 수 있다.(boilerplatey) Svelte는 ``만 덧붙이면 store 값에 대해 앞선 작업들을 알아서 처리해준다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { count } from './stores.js';
	import Incrementer from './Incrementer.svelte';
	import Decrementer from './Decrementer.svelte';
	import Resetter from './Resetter.svelte';
&lt;/script&gt;

&lt;h1&gt;The count is {count}&lt;/h1&gt;
</code></pre>
<p>이러한 Auto-subscription은 store의 변수들이 컴포넌트 최상위 스코프에서 선언 및 import 되었을 때만 제대로 동작한다.</p>
<p><code>&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;로변수명을시작하는것은&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ore&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;값을참조하겠다는것으로간주되며&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;그렇지않은경우에대해&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05764em;&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;는&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code>로 임의의 변수를 선언하는 것을 방지한다.</p>
<h2 id="readable-stores"><a class="header" href="#readable-stores">Readable stores</a></h2>
<p>모든 경우에 store를 참조하는 컴포넌트들에게 쓰기 권한을 부여할 필요는 없다. 이를테면, 시간, 마우스 위치, 지리적 위치 등을 다루는 경우가 그렇다.</p>
<p>이러한 경우에 readable store를 사용할 수 있다.</p>
<pre><code class="language-svelte">export const time = readable(new Date(), function start(set) {
	const interval = setInterval(() =&gt; {
		set(new Date());
	}, 1000);

	return function stop() {
		clearInterval(interval);
	};
});
</code></pre>
<p><code>readable</code>의 첫번째 인수는 초기값이며, 설정할 필요가 없다면 <code>null</code> 혹은 <code>undefined</code>로 두면 된다.</p>
<p>두번째 인수는 <code>start</code> 콜백함수이며, 이는 <code>set</code> 콜백함수를 파라미터로 받고 <code>stop</code> 함수를 반환하는 함수다. <code>start</code> 함수는 최초의 subscriber에 의해 상태값이 참조되는 경우에 호출되며, <code>stop</code>은 마지막 subscriber가 unscribe를 했을 때에 실행되는 cleanup 함수다.</p>
<h2 id="derived-stores"><a class="header" href="#derived-stores">Derived stores</a></h2>
<p>특정 store의 값에 의존하는 다른 값이 있는 경우, <code>derived</code>를 통해 새로운 store를 만들어 줄 수 있다. 아래는 특정 페이지가 열리고 나서의 시간을 측정한 상태값을 보유한 derived store다.</p>
<pre><code class="language-svelte">export const elapsed = derived(
	time,
	&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69862em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ro&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;((&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;time - start) / 1000)
);
</code></pre>
<p>여러 inputs들로부터 derive store를 갖추고, 값을 반환하는 대신 명시적으로 <code>set</code>를 통해 값을 변경해줄 수도 있다. 이에 대해서는 <a href="https://svelte.dev/docs#derived">여기</a>를 참조하자.</p>
<h2 id="custom-stores"><a class="header" href="#custom-stores">Custom stores</a></h2>
<p>어떤 객체든 <code>subscribe</code> 메서드가 적절하게 실행되기만 하면, 이는 store로 취급된다. 이를 통해 유저가 임의로 커스텀 store를 만들어 로직을 처리할 수 있다.</p>
<p>해당 문서의 앞쪽에서 <code>writable</code>을 통해 store를 다루었던 내용을 커스텀 store를 통해 리팩토링해보자.</p>
<pre><code class="language-svelte">function createCount() {
	const { subscribe, set, update } = writable(0);

	return {
		subscribe,
		increment: () =&gt; update(n =&gt; n + 1),
		decrement: () =&gt; update(n =&gt; n - 1),
		reset: () =&gt; set(0)
	};
}
</code></pre>
<h2 id="store-bindings"><a class="header" href="#store-bindings">Store bindings</a></h2>
<p>writable store를 사용하는 경우, 로컬 컴포넌트의 상태값과 store의 값을 binding 해줄 수 있다.</p>
<p>아래 예시에서는 <code>name</code> store 값을 <code>input</code>의 <code>value</code>값에 바인딩을 해주는 예시다.</p>
<pre><code class="language-svelte">&lt;input bind:value={name}&gt;
</code></pre>
<p>이후, input의 <code>value</code>에 변경이 있다면 <code>name</code> store값 역시 자동으로 업데이트된다.</p>
<p>컴포넌트 내부에서 값을 직접 할당해줄 수도 있다.</p>
<pre><code class="language-svelte">&lt;button on:click=&quot;{() =&gt; name += '!'}&quot;&gt;
	Add exclamation mark!
&lt;/button&gt;
</code></pre>
<p>위에서의 <code>name += '!'</code>은 `name.set(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mord"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">!</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">‘</span><span class="mord hangul_fallback">의호출과동일하다</span><span class="mord">.</span></span></span></span></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="motion"><a class="header" href="#motion">Motion</a></h1>
<h2 id="tweened"><a class="header" href="#tweened">Tweened</a></h2>
<p>Svelte는 상호작용에 따른 매끄러운 UI 애니메이션을 구성하기 위한 툴을 제공한다.</p>
<p><code>tweened</code>를 통해 <code>progress</code> store를 변경해보자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { tweened } from 'svelte/motion';
	import { cubicOut } from 'svelte/easing';

	const progress = tweened(0, {
		duration: 400,
		easing: cubicOut
	});
&lt;/script&gt;
</code></pre>
<p><code>tweened</code>의 첫번째 인수에는 초기값이, 두번째 인수에는 <code>options</code>가 전달된다. 가능한 <code>option</code>에는 다음과 같은 것들이 있다.</p>
<ul>
<li><code>delay</code> - tween이 시작되기 전의 딜레이. <code>ms</code>단위.</li>
<li><code>duration</code> - tween의 동작 시간, <code>ms</code>단위 혹은 <code>(from, to) =&gt; ms</code> 함수</li>
<li><code>easing</code> - <code>p =&gt; t</code> 함수</li>
<li><code>interplate</code> - 커스텀 <code>(from, to) =&gt; t =&gt; value</code> 함수. 기본적으로 Svelte는 number, date, 동일한 모양의 object, array에 대해서만 지원하기 때문에, 컬러스트링 등에 대해 적용하기 위해서는 별도로 커스텀 interpolator를 전달해야한다.</li>
</ul>
<p>해당 옵션들을 <code>progress.set</code> 혹은 <code>progress.update</code>의 두번째 인수로 전달할 수 있으며, 이 경우 기본 옵션에 오버라이딩된다. <code>set</code>와 <code>update</code> 메서드는 tween이 완료될 때 resolved 되는 프라미스를 반환한다.</p>
<h2 id="spring"><a class="header" href="#spring">Spring</a></h2>
<p><code>spring</code> 함수는 <code>tweened</code>보다 좀 더 자주 변경되는 값에 더 최적화된 함수이다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { spring } from 'svelte/motion';

	let coords = spring({ x: 50, y: 50 });
	let size = spring(10);
&lt;/script&gt;
</code></pre>
<p>추가적으로 각각 <code>0</code>과 <code>1</code> 사이의 <code>{stiffness, damping}</code> 옵션을 넘겨줄 수 있다.</p>
<pre><code class="language-svelte">let coords = spring({ x: 50, y: 50 }, {
	stiffness: 0.1,
	damping: 0.25
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="transitions"><a class="header" href="#transitions">Transitions</a></h1>
<h2 id="the-transition-directive"><a class="header" href="#the-transition-directive">The transition directive</a></h2>
<p>Svelte는 <code>transition</code> 선언을 통해 트랜지션을 매우 쉽게 구현할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { fade } from 'svelte/transition';
	let visible = true;
&lt;/script&gt;

&lt;label&gt;
	&lt;input type=&quot;checkbox&quot; bind:checked={visible}&gt;
	visible
&lt;/label&gt;

&lt;p transition:fade&gt;Fades in and out&lt;/p&gt;
</code></pre>
<h2 id="adding-parameters"><a class="header" href="#adding-parameters">Adding parameters</a></h2>
<p>트랜지션 함수들은 추가적으로 매개변수를 가질 수도 있다. 이번엔 <code>fade</code>가 아닌 <code>fly</code>의 예를 보자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { fly } from 'svelte/transition';
	let visible = true;
&lt;/script&gt;

&lt;p transition:fly=&quot;{{ y: 200, duration: 2000 }}&quot;&gt;
	Flies in and out
&lt;/p&gt;
</code></pre>
<p>트랜지션이 <strong>reversible</strong>하다는 점을 눈여겨보자. Svelte에서 제공하는 함수를 통해 구현된 트랜지션은 진행되는 도중에도 다시 되돌아올 수 있다.</p>
<h2 id="in-and-out"><a class="header" href="#in-and-out">In and out</a></h2>
<p>요소가 나타날 때와, 없어질 때 각각의 Transition을 다르게 구현하고자 하는 경우, <code>transition</code> 명령 대신, 요소에 <code>in</code>과 <code>out</code> 명령을 따로 지정할 수 있다.</p>
<pre><code class="language-svelte">import { fade, fly } from 'svelte/transition';

&lt;p in:fly=&quot;{{ y: 200, duration: 2000 }}&quot; out:fade&gt;
	Flies in, fades out
&lt;/p&gt;
</code></pre>
<h2 id="custom-css-transitions"><a class="header" href="#custom-css-transitions">Custom CSS transitions</a></h2>
<p><code>svelte/transition</code> 모듈에는 자체적으로 유용한 빌트인 트랜지션들이 많이 있으나, 직접 트랜지션을 구성하는 것도 쉽다.</p>
<p>아래는 <code>fade</code> 함수의 소스코드다.</p>
<pre><code class="language-js">function fade(node, { delay = 0, duration = 400 }) {
  const o = +getComputedStyle(node).opacity;

  return {
    delay,
    duration,
    css: (t) =&gt; `opacity: {t * o}`,
  };
}
</code></pre>
<p>이 함수는 두 개의 매개변수를 받는다. 하나는 트랜지션이 적용될 노트이고, 다른 하나는 아래의 옵션들이다.</p>
<ul>
<li><code>delay</code> - 트랜지션이 시작되기 전의 딜레이, ms 단위</li>
<li><code>duration</code> - 트랜지션의 전체 길이, ms 단위</li>
<li><code>easing</code> - <code>p =&gt; t</code> easing 함수</li>
<li><code>css</code> - <code>(t, u) =&gt; css</code>함수, 여기서 <code>u === 1 - t</code> 이다.</li>
<li><code>tick</code> - 노드에 효과를 적용하는 <code>(t, u) =&gt; {...}</code> 함수</li>
</ul>
<p><code>t</code>는 인트로의 시작 또는 아웃트로의 끝에서 0이고, 인트로의 끝 또는 아웃트로의 시작에서 1이다.</p>
<p>가능하다면 대부분은 <code>tick</code> 프로퍼티가 아닌 <code>css</code> 프로퍼티를 반환해야 하는데, CSS 애니메이션은 가능하다면 브라우저의 버벅거림을 방지하기 위해 메인 스레드에서 실행되지 않기 때문이다. Svelte는 트랜지션을 시뮬레이션하고, CSS 애니메이션을 구성한 뒤 이를 실행한다.</p>
<p>이를테면, <code>fade</code> 트랜지션은 아래와 같은 CSS 애니메이션을 생성한다.</p>
<pre><code class="language-css">0% {
  opacity: 0;
}
10% {
  opacity: 0.1;
}
20% {
  opacity: 0.2;
}
/* ... */
100% {
  opacity: 1;
}
</code></pre>
<p>좀 더 창의적이고 쓸데없는 애니메이션을 하나 만들어보자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { fade } from 'svelte/transition';
	import { elasticOut } from 'svelte/easing';

	let visible = true;

	function spin(node, { duration }) {
		return {
			duration,
			css: t =&gt; {
				const eased = elasticOut(t);

				return `
					transform: scale({eased}) rotate(&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;se&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1080&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{~~(t * 360)},
						&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{Math.min(50, 500 - 500 * t)}%
					);`
			}
		};
	}
&lt;/script&gt;
</code></pre>
<h2 id="custom-js-transitions"><a class="header" href="#custom-js-transitions">Custom JS transitions</a></h2>
<p>일반적으로는 가능하다면 CSS를 이용한 트랜지션을 사용하는 것이 좋지만, 일부 경우에는 JS 없이 구현하기 어려운 효과가 있을 수 있다. 대표적인 것이 타자기 효과다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let visible = false;

	function typewriter(node, { speed = 50 }) {
		const valid = (
			node.childNodes.length === 1 &amp;&amp;
			node.childNodes[0].nodeType === Node.TEXT_NODE
		);

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length * speed;

		return {
			duration,
			tick: t =&gt; {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
&lt;/script&gt;

&lt;label&gt;
	&lt;input type=&quot;checkbox&quot; bind:checked={visible}&gt;
	visible
&lt;/label&gt;

{#if visible}
	&lt;p in:typewriter&gt;
		The quick brown fox jumps over the lazy dog
	&lt;/p&gt;
{/if}

</code></pre>
<h2 id="transition-events"><a class="header" href="#transition-events">Transition events</a></h2>
<p>트랜지션의 시작과 끝이 언제인지를 아는 것이 유용할 때가 있다. Svelte는 다른 DOM 이벤트들과 마찬가지로 해당 시점에 이벤트를 디스패치해준다.</p>
<pre><code class="language-svelte">&lt;p
	transition:fly=&quot;{{ y: 200, duration: 2000 }}&quot;
	on:introstart=&quot;{() =&gt; status = 'intro started'}&quot;
	on:outrostart=&quot;{() =&gt; status = 'outro started'}&quot;
	on:introend=&quot;{() =&gt; status = 'intro ended'}&quot;
	on:outroend=&quot;{() =&gt; status = 'outro ended'}&quot;
&gt;
	Flies in and out
&lt;/p&gt;
</code></pre>
<h2 id="local-transitions"><a class="header" href="#local-transitions">Local transitions</a></h2>
<p>일반적으로 트랜지션은 컨테이너 블록이 추가되거나 없어지는 모든 경우에 실행된다.</p>
<p>만약, 모든 경우가 아니라, 요소 본인에 대한 직접적인 추가/삭제에 대해서만 트랜지션 효과를 주고자 한다면, local transition을 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;div transition:slide|local&gt;
	{item}
&lt;/div&gt;
</code></pre>
<h2 id="deferred-transitions"><a class="header" href="#deferred-transitions">Deferred transitions</a></h2>
<p>Svelte의 트랜지션 엔진이 갖는 강력한 특징은 트랜지션을 지연시킬 수 있다는 점이다. 따라서, 여러 개의 요소 간에도 이를 조정할 수 있다.</p>
<p><code>crossfade</code> 함수는 <code>send</code>와 <code>receive</code>라는 두 쌍의 트랜지션을 만들어낸다. 어떤 요소가 <code>send</code>될 때, 해당 요소는 여기에 상응하는 <code>received</code> 요소를 찾고나서, 찾아낸 요소의 위치로 이동하며 트랜지션 효과를 실행한다.</p>
<pre><code class="language-svelte">  &lt;script&gt;
	import { quintOut } from 'svelte/easing';
	import { crossfade } from 'svelte/transition';

	const [send, receive] = crossfade({
		duration: d =&gt; Math.sqrt(d * 200),

		fallback(node, params) {
			const style = getComputedStyle(node);
			const transform = style.transform === 'none' ? '' : style.transform;

			return {
				duration: 600,
				easing: quintOut,
				css: t =&gt; `
					transform: &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{t});
					opacity: {t}
				`
			};
		}
	});

  // ...
  &lt;script&gt;
</code></pre>
<p>이후 아래와 주고 받게 될 각각의 요소에서 사용한다.</p>
<pre><code class="language-svelte">&lt;label
	in:receive=&quot;{{key: todo.id}}&quot;
	out:send=&quot;{{key: todo.id}}&quot;
&gt;

&lt;label
	class=&quot;done&quot;
	in:receive=&quot;{{key: todo.id}}&quot;
	out:send=&quot;{{key: todo.id}}&quot;
&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<h2 id="the-animate-directive"><a class="header" href="#the-animate-directive">The animate directive</a></h2>
<p>트랜지션이 적용되지 않는 컴포넌트들에 대해서도 애니메이션을 적용해야하는 경우가 있다. 이를테면, 리스트의 아이템 하나가 삭제됨에 따라 다른 아이템들을 서서히 이동하는 것을 구현해야 하는 경우다.</p>
<p>이를 위해서는 <code>flip</code> 함수를 사용한다. 이는 '<a href="https://aerotwist.com/blog/flip-your-animations/">First, Last, Invert, Play</a>'의 준말이다.</p>
<pre><code class="language-svelte">import { flip } from 'svelte/animate';
</code></pre>
<p>이후, 트랜지션 외에 애니메이션이 적용되어야 하는 컴포넌트 및 요소에 animation을 추가해준다.</p>
<pre><code class="language-svelte">&lt;label
	in:receive=&quot;{{key: todo.id}}&quot;
	out:send=&quot;{{key: todo.id}}&quot;
	animate:flip=&quot;{{duration: 200}}&quot;
&gt;
</code></pre>
<p>위에서의 <code>duration</code>은 <code>d =&gt; ms</code> 형태의 함수일수도 있다. 여기서의 <code>d</code>는 요소가 움직여야 할 픽셀의 갯수에 해당한다.</p>
<p>다시 한번, 모든 트랜지션과 애니메이션은 JS보다는 CSS 상에서 구현되어야 한다는 점을 기억하자. 이는 메인 스레드의 진행을 막는 것을 방지하기 위해서다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<h2 id="the-use-directive"><a class="header" href="#the-use-directive">The use directive</a></h2>
<p>Action은 기본적으로 요소 수준의 생명주기 함수다. 다음과 같은 내용들을 구현할 때 유용하다.</p>
<ul>
<li>서드파티 라이브러리를 사용할 때</li>
<li>이미지에 대한 레이지 로딩</li>
<li>툴팁</li>
<li>커스텀 이벤트 핸들러 추가</li>
</ul>
<p>여러 컴포넌트에 다양하게 사용될 로직들을 미리 모듈화 시켜놓고, <code>use</code>를 통해 사용하는 방식이라고 이해하면 편하다.</p>
<pre><code class="language-svelte">export function pannable(node) {
	// setup work goes here...

	return {
		destroy() {
			// ...cleanup goes here
		}
	};
}
</code></pre>
<pre><code class="language-svelte">import { pannable } from './pannable.js';

&lt;div class=&quot;box&quot;
	use:pannable
	on:panstart={handlePanStart}
	on:panmove={handlePanMove}
	on:panend={handlePanEnd}
	style=&quot;transform:
		translate({coords.x}px,{coords.y}px)
		rotate({coords.x * 0.2}deg)&quot;
&gt;&lt;/div&gt;
</code></pre>
<h2 id="adding-parameters-1"><a class="header" href="#adding-parameters-1">Adding parameters</a></h2>
<p>트랜지션 및 애니메이션처럼, 액션 역시 인자를 전달받아서 로직 구성에 활용할 수 있다. 해당 매개변수는 <code>node</code> 다음의 두번째 매개변수로 전달받는다.</p>
<p>만약, 전달받는 매개변수가 변경될 수 있는 경우라면, <code>destroy</code> 외에도 <code>update</code>함수를 추가적으로 반환해주어야 한다.</p>
<pre><code class="language-svelte">export function longpress(node, duration) {
	// ...

	const handleMousedown = () =&gt; {
		timer = setTimeout(() =&gt; {
			node.dispatchEvent(
				new CustomEvent('longpress')
			);
		}, duration);
	};

	// ...

  return {
    update(newDuration) {
      duration = newDuration;
    },
    destroy() {
      // ...
    }
  };
}
</code></pre>
<p>이 후, 아래와 같이 인수를 전달한다.</p>
<pre><code class="language-svelte">&lt;button use:longpress={duration}&gt;
</code></pre>
<p>만약 여러개의 인자를 전달해야 하는 상황이라면, object를 전달하면 된다.</p>
<pre><code class="language-svelte">&lt;button use:longpress={{duration, spiciness}}&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<h2 id="the-class-directive"><a class="header" href="#the-class-directive">The class directive</a></h2>
<p>다른 어트리뷰트와 마찬가지로, JS 어트리뷰트를 통해 class를 지정할 수 있다.</p>
<pre><code class="language-svelte">&lt;button
	class=&quot;{current === 'foo' ? 'selected' : ''}&quot;
	on:click=&quot;{() =&gt; current = 'foo'}&quot;
&gt;foo&lt;/button&gt;
</code></pre>
<p>위와 같은 것은 UI 개발 상에서 일반적인 패턴으로, Svelte에서는 이를 단순화하기 위한 특별한 명령어를 갖고 있다. 아래 코드는 위와 동일하다.</p>
<pre><code class="language-svelte">&lt;button
	class:selected=&quot;{current === 'foo'}&quot;
	on:click=&quot;{() =&gt; current = 'foo'}&quot;
&gt;foo&lt;/button&gt;
</code></pre>
<h2 id="shorthand-class-directive"><a class="header" href="#shorthand-class-directive">Shorthand class directive</a></h2>
<p>종종, 클래스 이름은 그것이 의존하는 변수명과 동일한 경우가 많다.</p>
<pre><code class="language-svelte">&lt;div class:big={big}&gt;
	&lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<p>이 경우, 아래와 같이 짧게 작성할 수 있다.</p>
<pre><code class="language-svelte">&lt;div class:big&gt;
	&lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="component-composition"><a class="header" href="#component-composition">Component composition</a></h1>
<h2 id="slot"><a class="header" href="#slot">Slot</a></h2>
<p>일반적으로 요소가 자식 요소들을 가질 수 있는 것처럼, 컴포넌트 역시 똑같이 적용될 수 있다.</p>
<p>이는 <code>&lt;slot&gt;</code> 요소를 통해 구현할 수 있는데, React에서의 <code>{children}</code>과 매우 유사하다.</p>
<pre><code class="language-svelte">&lt;div class=&quot;box&quot;&gt;
	&lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<h2 id="slot-fallbacks"><a class="header" href="#slot-fallbacks">Slot fallbacks</a></h2>
<p>컴포넌트는 slot이 비어있을 경우에 제공할 fallback을 지정할 수 있다.</p>
<pre><code class="language-svelte">&lt;div class=&quot;box&quot;&gt;
	&lt;slot&gt;
		&lt;em&gt;no content was provided&lt;/em&gt;
	&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<h2 id="named-slots-1"><a class="header" href="#named-slots-1">Named slots</a></h2>
<p>앞선 예시들은 모두 default slot을 사용했으나, 좀 더 구체적으로 어떤 slot에 위치해야 하는지에 대해 지정해주어야 하는 경우가 있을 수 있다.</p>
<p>이러한 경우에 named slot을 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;article class=&quot;contact-card&quot;&gt;
	&lt;h2&gt;
		&lt;slot name=&quot;name&quot;&gt;
			&lt;span class=&quot;missing&quot;&gt;Unknown name&lt;/span&gt;
		&lt;/slot&gt;
	&lt;/h2&gt;

	&lt;div class=&quot;address&quot;&gt;
		&lt;slot name=&quot;address&quot;&gt;
			&lt;span class=&quot;missing&quot;&gt;Unknown address&lt;/span&gt;
		&lt;/slot&gt;
	&lt;/div&gt;

	&lt;div class=&quot;email&quot;&gt;
		&lt;slot name=&quot;email&quot;&gt;
			&lt;span class=&quot;missing&quot;&gt;Unknown email&lt;/span&gt;
		&lt;/slot&gt;
	&lt;/div&gt;
&lt;/article&gt;
</code></pre>
<p>이후, 각각의 slot에 요소를 추가하기 위해서는 <code>slot</code> 어트리뷰트를 추가적으로 작성해야 한다.</p>
<pre><code class="language-svelte">&lt;ContactCard&gt;
	&lt;span slot=&quot;name&quot;&gt;
		P. Sherman
	&lt;/span&gt;

	&lt;span slot=&quot;address&quot;&gt;
		42 Wallaby Way&lt;br&gt;
		Sydney
	&lt;/span&gt;
&lt;/ContactCard&gt;
</code></pre>
<h2 id="checking-for-slot-content"><a class="header" href="#checking-for-slot-content">Checking for slot content</a></h2>
<p>`<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord hangul_fallback">를통해</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">컴포넌트측에서전달받은</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">들에어떤것들이있는지파악할수있다</span><span class="mord">.</span><span class="mord hangul_fallback">이는아래와같은형태다</span><span class="mord">.‘‘‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">lt</span><span class="mord mathnormal">e</span></span></span></span></span>slots = {
default: false,
comments: true
}</p>
<pre><code>
따라서, 컴포넌트에서는 이를 통해 다음과 같이 조건부로 UI를 구성할 수 있다.

```svelte
&lt;article class:has-discussion={slots.comments}&gt;
</code></pre>
<pre><code class="language-svelte">{#if slots.comments}
	&lt;div class=&quot;discussion&quot;&gt;
		&lt;h3&gt;Comments&lt;/h3&gt;
		&lt;slot name=&quot;comments&quot;&gt;&lt;/slot&gt;
	&lt;/div&gt;
{/if}
</code></pre>
<h2 id="slot-props"><a class="header" href="#slot-props">Slot props</a></h2>
<p>일부 상황에서는, 하위 컴포넌트에서 부모 컴포넌트로 데이터를 전달하여, 이에 따라 slot으로 전달할 내용을 변경해주어야 하는 경우가 생긴다.</p>
<p>이러한 상황에서 slot props를 활용할 수 있다. 가령, 아래의 <code>Hoverable</code> 컴포넌트는, slot에 <code>hovering</code> 값을 전달한다.</p>
<pre><code class="language-svelte">&lt;div on:mouseenter={enter} on:mouseleave={leave}&gt;
	&lt;slot hovering={hovering}&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p>이후, <code>hovering</code>을 <code>&lt;Hoverable&gt;</code> 컴포넌트의 내용에 전달하기 위해, <code>let</code> 명령어를 사용한다.</p>
<pre><code class="language-svelte">&lt;Hoverable let:hovering={hovering}&gt;
	&lt;div class:active={hovering}&gt;
		{#if hovering}
			&lt;p&gt;I am being hovered upon.&lt;/p&gt;
		{:else}
			&lt;p&gt;Hover over me!&lt;/p&gt;
		{/if}
	&lt;/div&gt;
&lt;/Hoverable&gt;
</code></pre>
<p>별도로 변수명을 다시 지어도 된다. 아래의 경우에는 <code>hovering</code>을 <code>active</code>라는 이름으로 부모 컴포넌트 측에서 다시 이름지었다.</p>
<pre><code class="language-svelte">&lt;Hoverable let:hovering={active}&gt;
	&lt;div class:active&gt;
		{#if active}
			&lt;p&gt;I am being hovered upon.&lt;/p&gt;
		{:else}
			&lt;p&gt;Hover over me!&lt;/p&gt;
		{/if}
	&lt;/div&gt;
&lt;/Hoverable&gt;
</code></pre>
<p>Named slot에서도 props를 가질 수 있는데, 이 경우 컴포넌트 자체보다는 <code>slot=&quot;...&quot;</code> 어트리뷰트를 보유한 요소에서 <code>let</code> 명령어를 사용하자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="context-api"><a class="header" href="#context-api">Context API</a></h1>
<h2 id="setcontext-and-getcontext"><a class="header" href="#setcontext-and-getcontext">setContext and getContext</a></h2>
<p>context API는 데이터를 props로 전달하거나, store를 통해 디스패칭하지 않고도 컴포넌트 간에 소통할 수 있는 매커니즘이다.</p>
<p>이는 React에서의 context와도 흡사하게 이해해도 좋다.</p>
<p>한 컴포넌트에서 <code>setContext(key, context)</code>를 호출하면, 컴포넌트 본인을 포함한 하위 컴포넌트 모두에서 <code>const context = getContext(key)</code>로 해당 값을 가져올 수 있다.</p>
<pre><code class="language-svelte">import { onMount, setContext } from 'svelte';
import { mapbox, key } from './mapbox.js';

setContext(key, {
	getMap: () =&gt; map
});
</code></pre>
<p>context는 어떤 타입이든지 가능하며, 생명주기 함수와 마찬가지로 <code>setContext</code>와 <code>getContext</code>는 반드시 컴포넌트 초기화 시점에 호출되어야 한다. 컴포넌트가 마운트되기 전까지 위에서 반환하는 <code>map</code>은 <code>undefined</code>가 되므로, <code>getMap</code> 함수를 통해 우회적으로 가져오는 방법을 사용한다.</p>
<p>이제, 하위 컴포넌트에서는 아래와 같이 <code>map</code>을 가져올 수 있다.</p>
<pre><code class="language-svelte">import { getContext } from 'svelte';
import { mapbox, key } from './mapbox.js';

const { getMap } = getContext(key);
const map = getMap();
</code></pre>
<h3 id="context-keys"><a class="header" href="#context-keys">Context keys</a></h3>
<p>사실, 위에서의 <code>key</code>는 아래와 같다.</p>
<pre><code class="language-js">const key = {};
</code></pre>
<p><code>key</code>로는 어떤 것이든 사용 가능하며, 그냥 <code>setContext('mapbox', ...)</code>와 같이 string을 전달해도 된다.</p>
<p>단, <code>key</code>로 string을 사용할 경우, 여러 컴포넌트 라이브러리들 간에 서로 충돌되는 <code>key</code>를 사용할지도 모른다는 문제가 발생한다. 이를 방지하기 위해 위와 같이 객체 리터럴을 사용하면, 해당 key가 고유함을 보장받을 수 있다.</p>
<h3 id="context-vs-stores"><a class="header" href="#context-vs-stores">Context vs. Stores</a></h3>
<p>Context는 store와 비슷해 보일 수 있다. 둘 사이의 차이점은, store가 애플리케이션의 전역에서 접근할 수 있는 반면, context는 해당 컴포넌트와 그 하위 컴포넌트들에서만 접근할 수 있다는 것이다.</p>
<p>상황에 따라 둘을 적절히 사용할 수도 있다. context는 반응적이지(reactive) 않으므로, 실시간으로 값이 변화하는 값들에 대해서는 아래와 같은 형태로 store를 사용하는 것이 더 적합하다.</p>
<pre><code class="language-svelte">const { these, are, stores } = getContext(...);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="special-elements"><a class="header" href="#special-elements">Special elements</a></h1>
<h2 id="svelteself"><a class="header" href="#svelteself"><a href="svelte:self">svelte:self</a></a></h2>
<p>Svelte는 여러 빌트인 요소들을 제공한다. 먼저, <code>&lt;svelte:self&gt;</code>는 컴포넌트를 재귀적으로 활용할 수 있게 해준다. 기본적으로 모듈은 스스로를 import 하는 것이 불가능하기 때문에, <code>&lt;svelte:self&gt;</code>가 필요하다.</p>
<p>이는 폴더 안에 다른 폴더가 포함될 수 있는 폴더 트리 뷰와 같은 것들을 구성할 때 유용하다.</p>
<pre><code class="language-svelte">{#if file.type === 'folder'}
	&lt;svelte:self {...file}/&gt;
{:else}
	&lt;File {...file}/&gt;
{/if}
</code></pre>
<h2 id="sveltecomponent"><a class="header" href="#sveltecomponent"><a href="svelte:component">svelte:component</a></a></h2>
<p><code>&lt;svelte:component&gt;</code>는 동적으로 특정 컴포넌트가 해당 요소의 위치가 올 수 있을 경우에 활용할 수 있다.</p>
<p>이를테면, 아래처럼 조건부로 컴포넌트를 렌더링하고자 할 때, <code>&lt;svelte:component&gt;</code>를 통해 하나의 동적 컴포넌트로 처리해줄 수 있다.</p>
<pre><code class="language-svelte">{#if selected.color === 'red'}
	&lt;RedThing/&gt;
{:else if selected.color === 'green'}
	&lt;GreenThing/&gt;
{:else if selected.color === 'blue'}
	&lt;BlueThing/&gt;
{/if}
</code></pre>
<p>위의 코드는 아래의 한줄로 대체될 수 있다.</p>
<pre><code class="language-svelte">&lt;svelte:component this={selected.component}/&gt;
</code></pre>
<h2 id="sveltewindow"><a class="header" href="#sveltewindow"><a href="svelte:window">svelte:window</a></a></h2>
<p>바닐라 JS 상에서 어떤 DOM 요소에든 이벤트 리스너를 추가할 수 있듯, Svelte에서 <code>window</code> 오브젝트에 이벤트 리스너를 추가하고자 한다면 <code>&lt;svelte:window&gt;</code>를 이용하면 된다.</p>
<pre><code class="language-svelte">&lt;svelte:window on:keydown={handleKeydown}/&gt;
</code></pre>
<h2 id="sveltewindow-bindings"><a class="header" href="#sveltewindow-bindings"><a href="svelte:window">svelte:window</a> bindings</a></h2>
<p><code>window</code>의 특정 프로퍼티에 바인딩을 해줄 수도 있다.</p>
<pre><code class="language-svelte">&lt;svelte:window bind:scrollY={y}/&gt;
</code></pre>
<p>아래는 바인딩 가능한 프로퍼티의 리스트다.</p>
<ul>
<li><code>innerWidth</code></li>
<li><code>innerHeight</code></li>
<li><code>outerWidth</code></li>
<li><code>outerHeight</code></li>
<li><code>scrollX</code></li>
<li><code>scrollY</code></li>
<li><code>online</code> - <code>window.navigator.onLine</code>과 동일</li>
</ul>
<p><code>scrollX</code>와 <code>scrollY</code>을 제외한 모두는 읽기 전용 프로퍼티다.</p>
<h2 id="sveltebody"><a class="header" href="#sveltebody"><a href="svelte:body">svelte:body</a></a></h2>
<p><code>&lt;svelte:window&gt;</code>와 비슷하게, <code>&lt;svelte:body&gt;</code> 요소 역시 <code>document.body</code>에 직접적으로 이벤트 리스너를 추가해야 하는 경우에 사용할 수 있다.</p>
<p><code>window</code>에서는 발생하지 않는 <code>mouseenter</code> 혹은 <code>mouseleave</code> 이벤트를 사용해야 하는 경우에 유용하다.</p>
<pre><code class="language-svelte">&lt;svelte:body
	on:mouseenter={handleMouseenter}
	on:mouseleave={handleMouseleave}
/&gt;
</code></pre>
<h2 id="sveltehead"><a class="header" href="#sveltehead"><a href="svelte:head">svelte:head</a></a></h2>
<p><code>&lt;svelte:head&gt;</code> 요소는 문서의 <code>&lt;head&gt;</code> 내에 요소를 추가해야할 때 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;svelte:head&gt;
	&lt;link rel=&quot;stylesheet&quot; href=&quot;tutorial/dark-theme.css&quot;&gt;
&lt;/svelte:head&gt;
</code></pre>
<p>SSR 모드의 경우, <code>&lt;svelte:head&gt;</code>의 내용은 HTML의 나머지와 별도로 반환된다.</p>
<h2 id="svelteoptions"><a class="header" href="#svelteoptions"><a href="svelte:options">svelte:options</a></a></h2>
<p><code>&lt;svelte:options&gt;</code>는 컴파일링 옵션을 설정할 수 있게 해준다.</p>
<p>예를 들어, 해당 컴포넌트에서 설정할 수 있는 <code>immutable</code> 옵션이 존재하는데, 이는 해당 컴포넌트가 immutable 데이터를 기반으로 동작함을 의미한다.</p>
<p>이를테면, 아래와 같이 <code>Todo</code> 컴포넌트가 존재한다고 하자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { afterUpdate } from 'svelte';
	import flash from './flash.js';

	export let todo;

	let div;

	afterUpdate(() =&gt; {
    // 아래의 flash는 애니메이션 효과.
		flash(div);
	});
&lt;/script&gt;

&lt;!-- the text will flash red whenever
     the `todo` object changes --&gt;
&lt;div bind:this={div} on:click&gt;
	{todo.done ? '👍': ''} {todo.text}
&lt;/div&gt;

&lt;style&gt;
	div {
		cursor: pointer;
		line-height: 1.5;
	}
&lt;/style&gt;
</code></pre>
<p>헌데, 아래처럼 여러 개의 <code>Todo</code>를 갖는 리스트를 구현하려고 하는 상황을 생각해보자.</p>
<p><code>toggle</code>이 실행될 때, <code>map</code> 메서드에 의해서 새로운 <code>todos</code>가 반환되며, 이에 따라 하위의 일부 <code>Todo</code>에 대해서는 결론적으로는 변경된 데이터가 없어 굳이 새로 리렌더링할 필요가 없음에도 모든 <code>Todo</code> 컴포넌트가 리렌더링 과정을 거치게 된다.</p>
<pre><code class="language-js">let todos = [
  { id: 1, done: true, text: 'wash the car' },
  { id: 2, done: false, text: 'take the dog for a walk' },
  { id: 3, done: false, text: 'mow the lawn' },
];

function toggle(toggled) {
  todos = todos.map((todo) =&gt; {
    if (todo === toggled) {
      // return a new object
      return {
        id: todo.id,
        text: todo.text,
        done: !todo.done,
      };
    }

    // return the same object
    return todo;
  });
}
</code></pre>
<p>이러한 상황을 방지하기 위해서, immutable 옵션을 통해 props 값의 참조가 유지된다면 리렌더링을 수행하지 않도록 한다.</p>
<pre><code class="language-svelte">// &lt;svelte:options immutable/&gt;을 써도 된다.

&lt;svelte:options immutable={true}/&gt;
</code></pre>
<p>아래는 <code>&lt;svelte:options&gt;</code>에서 설정할 수 있는 옵션들이다.</p>
<ul>
<li><code>immutable={true}</code> - mutable 데이터를 사용하지 않겠다는 뜻으로, 컴포넌트는 값의 변경 여부를 확인하기 위해 단순 참조 비교(simple referential quality check)를 거친다.</li>
<li><code>immutable={false}</code> - 기본값. 값이 변경되었는지의 여부에 대해 더 엄격하게 체크한다.</li>
<li><code>accessors={true}</code> - 컴포넌트의 props에 대한 getter와 setter를 추가한다.</li>
<li><code>accessors={false}</code> - 기본값.</li>
<li><code>namespace=&quot;...&quot;</code> - 컴포넌트가 사용될 네임스페이스. 일반적으로 <code>svg</code>에서 사용된다.</li>
<li><code>tag=&quot;...&quot;</code> - 컴포넌트를 커스텀 요소로 컴파일링할 때 사용할 이름.</li>
</ul>
<h2 id="sveltefragment"><a class="header" href="#sveltefragment"><a href="svelte:fragment">svelte:fragment</a></a></h2>
<p><code>&lt;svelte:fragment&gt;</code> 요소는 named slot에 요소를 전달하고자 할 때, 굳이 별도의 컨테이너(ex. <code>div</code>)를 통해 요소를 묶어주지 않아도 곧바로 전달할 수 있게끔 해준다. React에서의 Fragment와 동일하다.(<code>&lt;&gt;&lt;/&gt;</code>)</p>
<pre><code class="language-svelte">&lt;svelte:fragment slot=&quot;footer&quot;&gt;
	&lt;p&gt;All rights reserved.&lt;/p&gt;
	&lt;p&gt;Copyright (c) 2019 Svelte Industries&lt;/p&gt;
&lt;/svelte:fragment&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="module-context"><a class="header" href="#module-context">Module context</a></h1>
<h2 id="sharing-code"><a class="header" href="#sharing-code">Sharing code</a></h2>
<p>지금껏 사용한 것 처럼, <code>&lt;script&gt;</code> 블록은 컴포넌트 초기화 시 각각의 컴포넌트 내에서 실행되는 로직들을 담고 있다. 그리고 대부분의 경우에는 이것으로 충분하다.</p>
<p>헌데, 아주 가끔 컴포넌트 외부에서 로직을 처리하여, 여러 컴포넌트에 해당 코드를 &quot;공유&quot;해야하는 경우가 생긴다. 이를테면, 음악 플레이어 컴포넌트를 만든 이후, 한 플레이어가 재생 중일 때 다른 플레이어를 중지시키는 로직을 구현하고자 하는 경우가 그렇다.</p>
<p>이 경우, <code>&lt;script context=&quot;module&quot;&gt;</code> 블록을 통해 처리할 수 있다. 해당 블록 내에서 실행되는 코드는 컴포넌트의 초기화 시점이 아닌, 최초로 evaluate되는 시점에 딱 한번만 실행된다.</p>
<pre><code class="language-svelte">&lt;script context=&quot;module&quot;&gt;
	let current;
&lt;/script&gt;
</code></pre>
<p>이제, 별도로 부모 컴포넌트에서 상태를 관리하지 않더라도, 동일한 컴포넌트의 인스턴스들끼리 소통하여 로직을 처리할 수 있다.</p>
<pre><code class="language-svelte">function stopOthers() {
	if (current &amp;&amp; current !== audio) current.pause();
	current = audio;
}
</code></pre>
<h2 id="exports"><a class="header" href="#exports">Exports</a></h2>
<p><code>context=&quot;module&quot;</code> 블록 내에서 <code>export</code>되는 변수들은 실제 모듈 자체에서 export한 것처럼 다루어진다.</p>
<p>다시 말해, 아래와 같이 <code>stopAll</code> 함수를 <code>export</code>한 경우,</p>
<pre><code class="language-svelte">// AudioPlayer.svelte
&lt;script context=&quot;module&quot;&gt;
	const elements = new Set();

	export function stopAll() {
		elements.forEach(element =&gt; {
			element.pause();
		});
	}
&lt;/script&gt;
</code></pre>
<p>이는 일반적인 JS 모듈처럼 <code>import</code>해서 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import AudioPlayer, { stopAll } from './AudioPlayer.svelte';
&lt;/script&gt;

&lt;button on:click={stopAll}&gt;
	stop all audio
&lt;/button&gt;

// ...
</code></pre>
<p>Svelte에서는 컴포넌트가 default export로 다루어지기 때문에, <code>default export</code>를 사용할 수 없음에 주의하자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="the-debug-tag"><a class="header" href="#the-debug-tag">The @debug tag</a></h2>
<p>때때로, 애플리케이션을 이용하는 중에 데이터 흐름을 체크하는 과정이 필요하다.</p>
<p>일반적으로 이는 <code>console.log(...)</code>을 통해 처리되곤 하는데, 만약 실행을 멈추고 해당 값을 확인하고자 한다면, <code>{@debug value1, value2, ...}</code> 태그를 사용할 수 있다.</p>
<pre><code class="language-svelte">{@debug user}

&lt;h1&gt;Hello {user.firstname}!&lt;/h1&gt;
</code></pre>
<p>이제 <code>user</code>의 값이 변경될 떄마다 debugger가 동작할 것이다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introspection"><a class="header" href="#introspection">Introspection</a></h1>
<p><a href="https://graphql-kr.github.io/learn/introspection/">여기</a>의 내용을 Github Graphql API로 따라가보자.</p>
<p>타입 시스템을 사용하기 때문에, 우리는 현재 유효한 타입이 무엇인지 알 수 있으나, 그렇지 않은 경우 Query의 루트에서 사용할 수 있는 <code>__schema</code> 필드를 쿼리하여 GraphQL에 요청할 수 있다.</p>
<pre><code class="language-graphql"># query
{
  __schema {
    types {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__schema&quot;: {
      &quot;types&quot;: [
        {
          &quot;name&quot;: &quot;AcceptEnterpriseAdministratorInvitationInput&quot;
        },
        {
          &quot;name&quot;: &quot;AcceptEnterpriseAdministratorInvitationPayload&quot;
        },
        {
          &quot;name&quot;: &quot;AcceptTopicSuggestionInput&quot;
        },
        // ...
        {
          &quot;name&quot;: &quot;__Schema&quot;
        },
        {
          &quot;name&quot;: &quot;__Type&quot;
        },
        {
          &quot;name&quot;: &quot;__TypeKind&quot;
        }
      ]
    }
  }
}
</code></pre>
<p>직접 해보면 알겠지만, 엄청 많이 뜬다. 이를 몇개로 그룹화해볼 수 있다.</p>
<ul>
<li><code>Query</code>, <code>User</code> 등 : 타입 시스템을 통해 정의한 것</li>
<li><code>String</code>, <code>Boolean</code> 등 : 타입 시스템이 제공하는 내장 스칼라</li>
<li><code>__Schema</code>, <code>__Type</code> 등 : 이들 앞에는 <code>__</code>가 붙어있는데, 이는 이것이 Introspection 시스템의 일부임을 나타낸다.</li>
</ul>
<pre><code class="language-graphql"># query
query {
  __schema {
    queryType {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__schema&quot;: {
      &quot;queryType&quot;: {
        &quot;name&quot;: &quot;Query&quot;
      }
    }
  }
}
</code></pre>
<p>최상단의 <code>Query</code> 타입에서 위와 같이 요청하면, 다음과 같이 <code>queryType</code>을 통해 우리가 <code>__schema</code>를 요청한 지점이 <code>Query</code> 타입에 해당함을 확인할 수 있다.</p>
<p>보통은 특정 타입 내에서 검사하는 작업이 유용한 경우가 많으며, 아래에서 <code>User</code> 타입에 대해 살펴보자.</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;User&quot;) {
    name
    description
    kind
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__type&quot;: {
      &quot;name&quot;: &quot;User&quot;,
      &quot;description&quot;: &quot;A user is an individual's account on GitHub that owns repositories and can make new content.&quot;,
      &quot;kind&quot;: &quot;OBJECT&quot;
    }
  }
}
</code></pre>
<p>위와 같은 식으로 특정 타입(위에서는 <code>User</code>)에 대한 상세한 정보를 얻을 수 있다. 여기에 더 나아가 해당 타입이 보유한 필드들에 어떤 것들이 있는지 찾아보자.</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;User&quot;) {
    name
    description
    kind
    fields {
      name
      type {
        name
        kind
        ofType {
          name
          kind
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;__type&quot;: {
      &quot;name&quot;: &quot;User&quot;,
      &quot;description&quot;: &quot;A user is an individual's account on GitHub that owns repositories and can make new content.&quot;,
      &quot;kind&quot;: &quot;OBJECT&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;anyPinnableItems&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;,
            &quot;ofType&quot;: {
              &quot;name&quot;: &quot;Boolean&quot;,
              &quot;kind&quot;: &quot;SCALAR&quot;
            }
          }
        },
        {
          &quot;name&quot;: &quot;avatarUrl&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;,
            &quot;ofType&quot;: {
              &quot;name&quot;: &quot;URI&quot;,
              &quot;kind&quot;: &quot;SCALAR&quot;
            }
          }
        },
        {
          &quot;name&quot;: &quot;bio&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: &quot;String&quot;,
            &quot;kind&quot;: &quot;SCALAR&quot;,
            &quot;ofType&quot;: null
          }
        },
        // ...
        {
          &quot;name&quot;: &quot;watching&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;,
            &quot;ofType&quot;: {
              &quot;name&quot;: &quot;RepositoryConnection&quot;,
              &quot;kind&quot;: &quot;OBJECT&quot;
            }
          }
        },
        {
          &quot;name&quot;: &quot;websiteUrl&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: &quot;URI&quot;,
            &quot;kind&quot;: &quot;SCALAR&quot;,
            &quot;ofType&quot;: null
          }
        }
      ]
    }
  }
}
</code></pre>
<p>(어지럽다..)</p>
<p>유의할만한 내용으로는 위에서 볼수 있는 <code>anyPinnableItems</code> 와 같은 필드의 경우에는 <code>NON_NULL wrapper</code> 타입에 해당하기 때문에, 타입에 대한 이름(<code>name</code>)이 존재하지 않는다.</p>
<p>이 경우, 해당 필드에서 <code>ofType</code>을 쿼리해 추가로 정보를 얻어보면, 해당 타입이 <code>Boolean!</code>에 해당함을 확인할 수 있다. (아래 일부)</p>
<pre><code class="language-json">// fields에 반환되는 내용 중 일부
{
  &quot;name&quot;: &quot;anyPinnableItems&quot;,
  &quot;type&quot;: {
    &quot;name&quot;: null,
    &quot;kind&quot;: &quot;NON_NULL&quot;,
    &quot;ofType&quot;: {
      &quot;name&quot;: &quot;Boolean&quot;,
      &quot;kind&quot;: &quot;SCALAR&quot;
    }
  }
},
</code></pre>
<p>이는 <code>LIST wrapper</code> 타입의 경우도 마찬가지이며, 아래와 같이 깊숙한 정보를 요구할 수도 있다.</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;Repository&quot;) {
    name
    description
    kind
    fields {
      name
      type {
        name
        kind
        ofType {
          name
          kind
          ofType {
            name
            kind
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// fields에 반환되는 내용 일부
{
  &quot;name&quot;: &quot;viewerPossibleCommitEmails&quot;,
  &quot;type&quot;: {
    &quot;name&quot;: null,
    &quot;kind&quot;: &quot;LIST&quot;,
    &quot;ofType&quot;: {
      &quot;name&quot;: null,
      &quot;kind&quot;: &quot;NON_NULL&quot;,
      &quot;ofType&quot;: {
        &quot;name&quot;: &quot;String&quot;,
        &quot;kind&quot;: &quot;SCALAR&quot;
      }
    }
  }
}
</code></pre>
<p>위의 <code>viewerPossibleCommitEmails</code>는 <code>[String!]</code>에 해당함을 확인할 수 있다.</p>
<p>앞서 봤듯이, Introspection 기능을 통해 타입 시스템의 문서에 접근할 수 있고, 문서 탐색기 및 풍부한 IDE 환경을 만들 수 있다.</p>
<p>이는 Introspection 시스템의 극히 일부에 해당하며, <a href="https://github.com/graphql/graphql-js/blob/main/src/type/introspection.js">여기</a>에 GraphQL의 Introspection 시스템을 구현하는 코드가 있으니 추후에 따로 확인해보자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>이 <a href="https://graphql-kr.github.io/learn/execution/">문서</a>의 내용을 실습하며 따라가보려고 한다. (TypeScript를 사용)</p>
<p>GraphQL 쿼리의 각 필드는 특정한 타입의 값을 반환하는 함수로 생각할 수 있으며, 이는 사실 실제 GraphQL의 작동방식이기도 하다.</p>
<p>타입의 각 필드는 GraphQL 서버 측의 <code>resolver</code> 함수에 대응되며, 해당 필드가 <code>string</code>이나 <code>number</code> 같은 스칼라 값을 반환하게 되면 실행이 완료된다.</p>
<p>반면, 필드가 객체를 반환하는 경우, 쿼리는 해당 객체에 적용되는 다른 필드들을 포함하게 되며, 이는 스칼라 값에 도달할 때까지 반복된다.</p>
<p>즉, GraphQL 쿼리의 끝은 항상 스칼라 값이어야 한다.</p>
<h2 id="root-fields--resolvers"><a class="header" href="#root-fields--resolvers">Root fields &amp; resolvers</a></h2>
<p>모든 GraphQL 서버의 최상위 레벨은 GraphQL API에서 사용 가능한 모든 진입점을 나타내는 타입이며, 이는 <code>Root</code> 타입 혹은 <code>Query</code> 타입으로 불린다.</p>
<pre><code class="language-js">// resolver
const resolvers = {
  Query: {
    game: (obj: any, { id }: GameArgs, context: Context) =&gt; {
      return context.db.games.find(({ id: gameId }) =&gt; id === gameId);
    },
    // ...
  },
  // ...
};
</code></pre>
<p>각 필드의 <code>resolver</code> 함수는 네 개의 매개변수를 받는데, 다음과 같다.</p>
<ul>
<li><code>obj</code> : <strong>부모 객체</strong>, 위에서는 이것이 <code>Query</code> Type에 해당하므로 거의 쓰일 일이 없다.</li>
<li><code>args</code> : GraphQL 쿼리의 필드에 제공된 인수. 이를테면 <code>game(id: '1') {...}</code> 과 같은 경우에는 args가 <code>{ id: '1' }</code>이 된다.</li>
<li><code>context</code> : 모든 <code>resolver</code> 함수들에 동일하게 전달되며, 데이터베이스 접근이나 로그인 세션 등에 활용될 수 있다.</li>
<li><code>info</code> : 현재의 쿼리, 스키마 정보와 관련된 필드별 정보를 보유하며, 자세한 내용은 <a href="https://graphql.org/graphql-js/type/#graphqlobjecttype">여기</a>를 참조하자.</li>
</ul>
<h2 id="async-resolvers"><a class="header" href="#async-resolvers">Async Resolvers</a></h2>
<pre><code class="language-js">// 임의로 작성됨
const resolver = async (obj, args, context) {
  const result = await context.db.gameInfo(args.id);
  return result.data;
};
</code></pre>
<p>위와 같이 임의로 작성된 비동기 resolver의 경우에도 정상적으로 동작한다.</p>
<p>하지만, 여기서는 실제 DB에 접근하지 않고 임의의 객체로 만든 Mocking DB를 활용할 것이므로, 편의상 일반적인 함수를 통해 resolver를 구현하겠다.</p>
<h2 id="trivial-resolvers"><a class="header" href="#trivial-resolvers">Trivial resolvers</a></h2>
<p>앞서 <code>Game</code> 객체에 대해 접근하는 resolver를 작성했으므로, 이제 이 <code>Game</code> 객체 내 각 필드를 구체화해보자.</p>
<pre><code class="language-js">const resolvers = {
  Query: {
    game: (obj: any, { id }: GameArgs, context: Context) =&gt; {
      return context.db.games.find(({ id: gameId }) =&gt; id === gameId);
    },
  },
  Game: {
    // id의 resolver 첫번째 파라미터는 이제 Game 객체가 된다.
    id: (game: Game) =&gt; game.id,
    // ...
  },
};
</code></pre>
<p>아래와 같은 구성으로 타입을 지정했다고 하자.</p>
<pre><code class="language-graphql">const typeDefs = gql`
  enum Score {
    good
    normal
    bad
  }

  type Query {
    game(id: ID!): Game
    developer(id: ID!): Developer
  }

  type Game {
    id: ID!
    title: String!
    developer: Developer!
    score: Score!
  }

  type Developer {
    id: ID!
    name: String!
    games: [Game]!
  }
`;
</code></pre>
<p>이에 대해 객체 타입에 대한 resolver 작성을 한꺼번에 해보면 이런 식이다.</p>
<pre><code class="language-js">const resolvers = {
  Query: {
    game: (_: any, { id }: GameArgs, context: Context) =&gt; {
      return context.db.games.find(({ id: gameId }) =&gt; id === gameId);
    },
    developer: (_: any, { id }: DeveloperArgs, context: Context) =&gt; {
      return context.db.developers.find(
        ({ id: developerId }) =&gt; id === developerId,
      );
    },
  },
  Game: {
    id: (game: Game) =&gt; game.id,
    title: (game: Game) =&gt; game.title,
    developer: ({ developer: id }: Game, _: any, context: Context) =&gt; {
      return context.db.developers.find(
        ({ id: developerId }) =&gt; id === developerId,
      );
    },
    score: (game: Game) =&gt; {
      return game.score;
    },
  },
  Developer: {
    id: (developer: Developer) =&gt; developer.id,
    name: (developer: Developer) =&gt; developer.name,
    games: ({ games }: Developer, _: any, context: Context) =&gt; {
      return games.map((gameId) =&gt;
        context.db.games.find(({ id }) =&gt; id === gameId),
      );
    },
  },
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://graphql-kr.github.io/learn/queries/">여기</a> 문서에 따라, GraphQL의 쿼리를 직접 실습해보려고 한다.</p>
<p>여기서는 실습을 위해 Github의 <a href="https://docs.github.com/en/graphql/overview/explorer">GraphQL API</a>를 활용했다.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>GraphQL의 핵심은 쿼리와 결과가 거의 동일한 형태를 보인다는 것이다. 덕분에 항상 클라이언트가 기대한 결과값을 얻을 수 있다.</p>
<pre><code class="language-graphql"># query
{
  viewer {
    email
    interactionAbility {
      origin
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;viewer&quot;: {
      &quot;email&quot;: &quot;&quot;,
      &quot;interactionAbility&quot;: {
        &quot;origin&quot;: &quot;USER&quot;
      }
    }
  }
}
</code></pre>
<p>아래 예제에서 <code>licenses</code>는 배열을 반환하며, 배열 안 각각의 Item에 대해 <code>name</code>만을 가져온다.</p>
<p>쿼리문 자체는 모두 동일해보이지만, GraphQL 스키마를 기반으로 예상되는 결과를 알 수 있다.</p>
<pre><code class="language-graphql"># query
{
  licenses {
    name
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;licenses&quot;: [
      {
        &quot;name&quot;: &quot;GNU Affero General Public License v3.0&quot;
      },
      {
        &quot;name&quot;: &quot;Apache License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;BSD 2-Clause \&quot;Simplified\&quot; License&quot;
      },
      ...
    ]
  }
}
</code></pre>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p>필드에 인자를 전달할 수도 있다.</p>
<pre><code class="language-graphql"># query
{
  user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    }
  }
}
</code></pre>
<h2 id="aliases"><a class="header" href="#aliases">Aliases</a></h2>
<p>만약, 여러 결과 객체 필드가 동일한 이름을 갖는 경우(위에서는 <code>user</code>), 충돌이 일어난다. 아래는 닉네임을 통해 여러 유저의 정보를 가져오는 예시인데, 아래대로라면 에러가 발생한다.</p>
<pre><code class="language-graphql"># query
{
  user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
  user(login: &quot;adam-p&quot;) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// result
// 에러 발생!
{
  &quot;errors&quot;: [
    {
      &quot;path&quot;: [],
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;fieldConflict&quot;,
        &quot;fieldName&quot;: &quot;user&quot;,
        &quot;conflicts&quot;: &quot;{login:\&quot;\\\&quot;Shubidumdu\\\&quot;\&quot;} or {login:\&quot;\\\&quot;adam-p\\\&quot;\&quot;}&quot;
      },
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 2,
          &quot;column&quot;: 2
        },
        {
          &quot;line&quot;: 6,
          &quot;column&quot;: 3
        }
      ],
      &quot;message&quot;: &quot;Field 'user' has an argument conflict: {login:\&quot;\\\&quot;Shubidumdu\\\&quot;\&quot;} or {login:\&quot;\\\&quot;adam-p\\\&quot;\&quot;}?&quot;
    }
  ]
}
</code></pre>
<p>이러한 상황에서 Alias를 사용할 수 있다. 각각의 <code>user</code> 결과에 대해 이름을 지정해주자.</p>
<pre><code class="language-graphql"># query
{
  me: user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
  not_me: user(login: &quot;adam-p&quot;) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;me&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    },
    &quot;not_me&quot;: {
      &quot;name&quot;: &quot;Adam Pritchard&quot;,
      &quot;location&quot;: &quot;Toronto, Canada&quot;
    }
  }
}
</code></pre>
<h2 id="fragments"><a class="header" href="#fragments">Fragments</a></h2>
<p>상대적으로 복잡한 페이지의 경우, Fragment라는 <strong>재사용 가능한 단위</strong>가 사용될 수 있다. 이를 사용하면 미리 필드셋을 구성한 다음 쿼리에 포함시킬 수 있다.</p>
<p>앞서 여러 유저들의 정보를 가져오는 쿼리를 Fragment를 통해 다시 만들어보면 아래와 같아진다.</p>
<pre><code class="language-graphql"># query
{
  me: user(login: &quot;Shubidumdu&quot;) {
    ...userInfo
  }
  not_me: user(login: &quot;adam-p&quot;) {
    ...userInfo
  }
}

fragment userInfo on User {
  name
  location
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;me&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    },
    &quot;not_me&quot;: {
      &quot;name&quot;: &quot;Adam Pritchard&quot;,
      &quot;location&quot;: &quot;Toronto, Canada&quot;
    }
  }
}
</code></pre>
<p>결과는 동일하지만, 쿼리 시에 일일이 객체 필드를 작성해줄 필요가 없게 되었다.</p>
<h3 id="fragment-안에서-매개변수variables-사용하기"><a class="header" href="#fragment-안에서-매개변수variables-사용하기">Fragment 안에서 매개변수(variables) 사용하기</a></h3>
<p>쿼리 및 뮤테이션에다 선언한 변수는 Fragment를 통해서도 접근할 수 있다.</p>
<p>아래는 기존의 <code>userInfo</code>에서 <code>avatarSize</code> 변수를 통해 임의의 사이즈를 가진 avatar 이미지를 추가로 쿼리한 것이다.</p>
<pre><code class="language-graphql"># query
query UserInfos(avatarSize: Int = 100) {
  me: user(login: &quot;Shubidumdu&quot;) {
    ...userInfo
  }
  not_me: user(login: &quot;adam-p&quot;) {
    ...userInfo
  }
}

fragment userInfo on User {
  name
  location
  avatarUrl(size: avatarSize)
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;me&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;,
      &quot;avatarUrl&quot;: &quot;https://avatars.githubusercontent.com/u/54790378?s=100&amp;u=9fa9c08aa2c952a873633a1baf3ea342a4c45855&amp;v=4&quot;
    },
    &quot;not_me&quot;: {
      &quot;name&quot;: &quot;Adam Pritchard&quot;,
      &quot;location&quot;: &quot;Toronto, Canada&quot;,
      &quot;avatarUrl&quot;: &quot;https://avatars.githubusercontent.com/u/425687?s=100&amp;v=4&quot;
    }
  }
}
</code></pre>
<h2 id="operation-name-작업명"><a class="header" href="#operation-name-작업명">Operation name (작업명)</a></h2>
<p>지금껏 <code>query</code> 키워드와 이름을 모두 생략한 채 <code>{ ... }</code>와 같은 형태로 쿼리를 요청했다.</p>
<p>하지만 실제로 애플리케이션에 GraphQL을 적용하고자 할 때는 코드를 최대한 덜 헷갈리게 만드는 편이 좋다.</p>
<p>바로 위의 쿼리에서는 <code>UserInfos</code>와 같은 식으로 이름을 지정했다.</p>
<p>작업 타입은 <code>query</code>, <code>mutation</code>, <code>subscription</code>이 될 수 있으며, 해당 작업이 어떤 형태의 작업인지를 나타낸다.</p>
<p>작업명은 명시적인 작업의 <strong>이름</strong>인데, 디버깅 및 로깅에 있어 매우 유용하다. 임의의 쿼리 결과를 찾아내는 것보다, 직접 쿼리명을 찾아내는 것이 훨씬 쉽기 때문이다.</p>
<h2 id="variables-변수"><a class="header" href="#variables-변수">Variables (변수)</a></h2>
<p>지금껏 앞의 모든 예시에서 인자들은 쿼리 문자열에 함께 작성되었다. 허나, 대부분 필드에 대한 인자는 동적이다.</p>
<p>클라이언트 측에서는 쿼리 문자열을 런타임 시점에 동적으로 조작하고, 이를 GraphQL의 특정 포맷으로 Serialize해야 한다.</p>
<p>그렇기 때문에 동적 인자들을 쿼리 문자열에 직접 전달하는 것은 좋은 방법이 아니다. 그래서 GraphQL은 동적 값을 쿼리에서 없애고 이를 별도로 전달하는 방법을 제공하는데 이를 Variables(변수)라고 한다.</p>
<pre><code class="language-graphql">{
  user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
}
</code></pre>
<p>위의 쿼리를 Variables를 활용한 형태로 바꾸려면 다음과 같은 작업들이 필요하다.</p>
<ol>
<li>쿼리 내의 정적인 값을 <code>variableName</code> 형태로 변경한다.</li>
<li><code>variableName</code>를 쿼리에서 받아오는 변수의 타입으로 선언한다.</li>
<li>별도의 전송규약(일반적으로 JSON) 변수에 <code>variableName: value</code>를 전달한다.</li>
</ol>
<p>변수를 이용해 위의 쿼리를 재작성하면 아래와 같은 형태가 된다.</p>
<pre><code class="language-graphql"># query
query MyInfo(nickname: String!) {
  user(login: nickname) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// variables
{ &quot;nickname&quot;: &quot;Shubidumdu&quot; }
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    }
  }
}
</code></pre>
<p>이제, 클라이언트 측에서는 완전히 새로운 쿼리를 작성하지 않고 손쉽게 다른 변수를 전달할 수 있다.</p>
<p>한편, 이런 방식은 쿼리의 어떤 Argument가 동적인 형태를 띠는지 나타내는 좋은 방법이기도 하다.</p>
<h3 id="변수-정의"><a class="header" href="#변수-정의">변수 정의</a></h3>
<p>변수 정의는 위 예시 쿼리에서 <code>(nickname: String!)</code>에 해당하는 부분이다. 정적타입 언어의 함수에 대한 인자 정의와 동일하다.</p>
<p><strong>모든 변수는 scalars, enum, 또는 input object type 이어야 한다.</strong> 복잡한 객체를 필드에 전달하려면 서버에서 일치하는 입력 타입을 알아야 하며, 이에 대해서는 문서를 통해 더 알아보자.</p>
<p>변수 정의는 required 혹은 optional일 수 있다. 위에서는 <code>String!</code>으로 <code>!</code>가 붙었으므로 required scalar type에 해당한다. 반대로, <code>!</code>가 붙지 않았다면 이는 optional한 값이 된다.</p>
<h3 id="변수-기본값"><a class="header" href="#변수-기본값">변수 기본값</a></h3>
<p>타입 선언 다음에 기본값을 할당할 수도 있다.
이 경우에는 별도로 Variable을 전달하지 않더라도 올바르게 동작한다.</p>
<pre><code class="language-graphql"># query
query MyInfo(nickname: String = &quot;Shubidumdu&quot;) {
  user(login: nickname) {
    name
    location
  }
}
</code></pre>
<p><strong>여기에, <code>nickname: String!</code>과 같이 required 변수를 요구하는 경우에는 기본값을 가질 수 없다는 점을 유의하자.</strong></p>
<h2 id="directives-지시어"><a class="header" href="#directives-지시어">Directives (지시어)</a></h2>
<p>Directives는 GraphQL의 기능으로, 필드나 프래그먼트 안에 삽입되어, 쿼리 실행에 영향을 줄 수 있다.</p>
<ul>
<li><code>@include(if: Boolean)</code>: 인자가 <code>true</code>인 경우에만 이 필드를 결과에 포함한다.</li>
<li><code>@skip(if: Boolean)</code>: 인자가 <code>true</code>인 경우에만 이 필드를 건너뛴다.</li>
</ul>
<p>이를 이용해 앞서 작성한 유저 정보 쿼리에서 <code>withAvatar</code> 변수가 <code>true</code>인 경우에만 이미지를 함께 가져오게끔 해보자.</p>
<pre><code class="language-graphql"># query
query MyInfo(&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ni&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;knam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;St&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;withAvatar: Boolean = false) {
  user(login: nickname) {
    name
    location
    avatarUrl @include(if: withAvatar)
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;nickname&quot;: &quot;Shubidumdu&quot;,
  &quot;withAvatar&quot;: true
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;,
      &quot;avatarUrl&quot;: &quot;https://avatars.githubusercontent.com/u/54790378?u=9fa9c08aa2c952a873633a1baf3ea342a4c45855&amp;v=4&quot;
    }
  }
}
</code></pre>
<p>물론, 필드가 객체를 참조하는 경우에도 활용할 수 있다.</p>
<pre><code class="language-graphql"># query
query MyInfo(
  &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ni&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;knam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8777699999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;St&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05764em;&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;bi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;withItemShowcase: Boolean = false
) {
  user(login: nickname) {
    name
    location
    company
    itemShowcase @include(if: withItemShowcase) {
      items {
        totalCount
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;withItemShowcase&quot;: true
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;,
      &quot;company&quot;: &quot;The Mong, Inc.&quot;,
      &quot;itemShowcase&quot;: {
        &quot;items&quot;: {
          &quot;totalCount&quot;: 6
        }
      }
    }
  }
}
</code></pre>
<h2 id="mutation"><a class="header" href="#mutation">Mutation</a></h2>
<p>지금까지는 전부 데이터 가져오기(<code>fetch</code>)에만 초점을 뒀다.</p>
<p>REST의 경우, 사실 상 모든 요청이 사이드 이펙트를 일으킬 수 있지만, 데이터 수정에 있어서는 <code>GET</code>을 사용하지 않는다는 규칙이 정해져 있다.</p>
<p>이는 GraphQL 역시 마찬가지다. 기술적으로는 어떤 형태의 쿼리든 데이터에 수정을 가할 수 있으나, 사이드 이펙트를 유발하는 작업의 경우에는 Mutation을 통해 전송되어야 한다는 규칙이 있다.</p>
<p>아래는 내 <code>shubi-docs</code> repo에 star를 추가하는 예시 Mutation이다.</p>
<pre><code class="language-graphql"># mutation
mutation MyMutation(repoId: ID!) {
  __typename
  addStar(input: { starrableId: repoId, clientMutationId: &quot;Star added!&quot; }) {
    clientMutationId
  }
}
</code></pre>
<pre><code class="language-json">// variables
{ &quot;repoId&quot;: &quot;MDEwOlJlcG9zaXRvcnkzMDYzNjgwMDY&quot; }
</code></pre>
<pre><code class="language-json">// result
// 실제로 repo에 star가 추가된다.
{
  &quot;data&quot;: {
    &quot;__typename&quot;: &quot;Mutation&quot;,
    &quot;addStar&quot;: {
      &quot;clientMutationId&quot;: &quot;Star added!&quot;
    }
  }
}
</code></pre>
<h3 id="다중-필드-mutation"><a class="header" href="#다중-필드-mutation">다중 필드 Mutation</a></h3>
<p>Mutation은 쿼리와 마찬가지로 여러 필드를 포함할 수 있는데, 둘 사이에 중요한 차이점이 있다.</p>
<p><strong>쿼리 필드는 병렬로 실행되지만 뮤테이션 필드는 하나씩 차례대로 실행된다</strong>는 점이다.</p>
<p>덕분에, 아래와 같이 여러 개의 뮤테이션을 요청하면, 순서가 보장되기 때문에 결국 추가한 star는 다시 사라진다.</p>
<pre><code class="language-graphql">mutation MyMutation(repoId: ID!) {
  __typename
  addStar(input: { starrableId: repoId, clientMutationId: &quot;Star added!&quot; }) {
    clientMutationId
  }
  removeStar(
    input: { starrableId: repoId, clientMutationId: &quot;Star removed!&quot; }
  ) {
    clientMutationId
  }
}
</code></pre>
<pre><code class="language-json">// variables
{ &quot;repoId&quot;: &quot;MDEwOlJlcG9zaXRvcnkzMDYzNjgwMDY&quot; }
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__typename&quot;: &quot;Mutation&quot;,
    &quot;addStar&quot;: {
      &quot;clientMutationId&quot;: &quot;Star added!&quot;
    },
    &quot;removeStar&quot;: {
      &quot;clientMutationId&quot;: &quot;Star removed!&quot;
    }
  }
}
</code></pre>
<h2 id="inline-fragments"><a class="header" href="#inline-fragments">Inline Fragments</a></h2>
<p>다른 여러 타입과 마찬가지로 GraphQL 스키마에는 인터페이스와 유니온 타입을 정의하는 기능이 포함되어 있다.</p>
<p>만약, 인터페이스나 유니언 타입을 반환하는 필드를 쿼리하는 경우, Inline Fragement를 사용할 수 있는데, 다음과 같은 형태다.</p>
<pre><code class="language-graphql"># query
{
  node(id: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;) {
    id
    ... on User {
      name
    }
    ... on Organization {
      email
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;node&quot;: {
      &quot;id&quot;: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;,
      &quot;name&quot;: &quot;Won Gyo Seo&quot;
    }
  }
}
</code></pre>
<p>위의 인자로 입력한 <code>id</code>를 통해 반환되는 값은 Node이자 User 타입이다.</p>
<p>User를 반환받는 경우, <code>id</code>와 <code>name</code> 필드를 가져오도록 Inline Fragment (<code>... on User</code>)를 활용했기 때문에, <code>... on Organization {...}</code>은 완전히 무시된다.</p>
<h3 id="meta-fields"><a class="header" href="#meta-fields">Meta fields</a></h3>
<p>만약, GraphQL 상에서 리턴될 타입을 모르는 상황인 경우, 클라이언트에서 해당 데이터를 처리할 방법을 결정하기 위해 타입이 요구되는 경우가 있다.</p>
<p>GraphQL은 쿼리의 어느 지점에서건 메타 필드인 <code>__typename</code>을 요청해 그 시점에서의 객체 타입의 이름을 가져올 수 있다.</p>
<pre><code class="language-graphql"># query
{
  node(id: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;) {
    __typename
    id
    ... on User {
      name
    }
    ... on Organization {
      email
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;node&quot;: {
      &quot;__typename&quot;: &quot;User&quot;,
      &quot;id&quot;: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;,
      &quot;name&quot;: &quot;Won Gyo Seo&quot;
    }
  }
}
</code></pre>
<p>위 쿼리에서 <code>__typename</code>을 추가해 클라이언트 측에서 타입을 구분할 수 있게끔 해주었다.</p>
<p>GraphQL은 이 외에도 몇 가지 메타필드를 제공하며, 이들은 <strong>introspection</strong>의 일부다. 이에 대해서는 다른 문서를 통해 설명하겠다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://graphql-kr.github.io/learn/schema/">여기</a> 문서에 따라, GraphQL 스키마 및 타입에 관해 직접 실습해보려고 한다.</p>
<p>실습을 위해 Typescript 기반으로 Apollo를 이용한 임의의 GraphQL 서버를 생성했다.</p>
<h1 id="schema--type"><a class="header" href="#schema--type">Schema &amp; Type</a></h1>
<p>다음과 같은 쿼리를 받았다고 생각해보자.</p>
<pre><code class="language-graphql"># query
{
  game {
    title
    genre
    tags
  }
}
</code></pre>
<pre><code class="language-json">// result
// 임의로 작성됨
{
  &quot;data&quot;: {
    &quot;title&quot;: &quot;Super Mario Bros&quot;,
    &quot;genre&quot;: &quot;adventure&quot;,
    &quot;developer&quot;: &quot;Nintendo&quot;,
    &quot;publisher&quot;: &quot;Nintendo&quot;,
    &quot;tags&quot;: [&quot;2d&quot;, &quot;famicom&quot;]
  }
}
</code></pre>
<p>기본적으로 GraphQL 쿼리의 형태가 결과와 거의 일치하기 때문에, 서버에 대해 모르는 상태에서도 쿼리가 어떤 형태의 값을 반활할지에 대해 어느 정도 예측할 수 있다.</p>
<p>하지만, 어떤 필드를 선택할 수 있는지, 어떤 종류의 객체를 반환할 수 있는지, 하위 객체에서 사용할 수 있는 필드가 무엇인지 등에 대한 정보를 얻기 위해 스키마가 필요하다.</p>
<p>모든 GraphQL 서비스는 해당 서비스에서 쿼리 가능한 데이터들을 완벽하게 설명하는 타입들을 정의하고, 쿼리가 들어오면 해당 스키마에 대한 유효성이 검사된 후에 실행된다.</p>
<h2 id="type-language"><a class="header" href="#type-language">Type language</a></h2>
<p>GraphQL은 어떤 언어로든 작성될 수 있으며, 해당 문서에서는 TypeScript에 기반하여 내용을 따라갈 예정이다.</p>
<h2 id="object-types-and-fields"><a class="header" href="#object-types-and-fields">Object types and fields</a></h2>
<p>GraphQL 스키마의 가장 기본적인 구성 요소는 객체 타입으로, 이는 서비스에서 가져올 수 있는 객체 종류와 그 객체의 필드를 나타낸다.</p>
<pre><code class="language-graphql">type Game {
  title: String!
  developer: Developer!
  tags: [Tag]!
}

type Developer {
  name: String!
  games: [Game]!
}
</code></pre>
<ul>
<li><code>Game</code>, <code>Developer</code> 등은 <strong>GraphQL Object 타입</strong>이다. 다시 말해, 필드가 존재하는 타입이란 의미이며, 스키마에서 대부분의 타입은 여기에 해당한다.</li>
<li><code>title</code>, <code>name</code> 등은 <code>Character</code> 타입 내에 존재하는 <strong>Field</strong>이다. 즉, 쿼리에서 <code>title</code>는 <code>Game</code> 타입 내에서, <code>name</code>은 <code>Developer</code> 타입 내에서 어디서든 사용할 수 있는 필드이다.</li>
<li><code>String</code>은 내장된 스칼라(scalar) 타입 중 하나다. 이는 단일 스칼라 객체로 해석된다.</li>
<li><code>String!</code>은 필드가 non-nullable함을 의미한다. 즉, 해당 필드를 쿼리하는 경우 항상 GraphQL 서비스는 해당 값을 반환한다는 것을 의미한다.</li>
<li><code>[Game]!</code>은 <code>Game</code> 객체의 배열을 나타내는데, 이 또한 non-nullable하여 무조건 배열을 반환함을 의미한다. (배열 자체는 길이가 0이어도 상관이 없다.)</li>
</ul>
<h2 id="arguments인자"><a class="header" href="#arguments인자">Arguments(인자)</a></h2>
<p>GraphQL 객체 타입의 모든 필드는 0개 이상의 인수를 가질 수 있다.</p>
<pre><code class="language-graphql">type Game {
  title(language: Language = KOREAN): String!
  developer: Developer!
  tags: [Tag]!
}
</code></pre>
<p>모든 인자에는 이름이 있다. 위의 예시에서는 <code>title</code> 필드가 <code>language</code>라는 매개변수를 갖는다.</p>
<p>인자는 required일수도, optional할수도 있다. 인자가 optional인 경우 기본값을 정의할 수 있으며, 이에 대해서는 쿼리에 관한 문서에서도 설명한 바가 있다.</p>
<h2 id="query-type--mutation-type"><a class="header" href="#query-type--mutation-type">Query Type &amp; Mutation Type</a></h2>
<p>스키마 대부분의 타입은 일반 객체 타입이지만, 두 가지 특수한 타입이 존재한다.</p>
<pre><code>schema {
  query: Query
  mutation: Mutation
}
</code></pre>
<p>모든 GraphQL 서비스는 <code>query</code> 타입을 가지며, <code>mutation</code> 타입은 가질 수도, 가지지 않을 수도 있다. 전반적인 취급은 동일하지만, 모든 GraphQL 쿼리의 진입점(<strong>Entry Point</strong>)를 정의하는 것이므로 이는 특별하다.</p>
<h2 id="scalar-type"><a class="header" href="#scalar-type">Scalar Type</a></h2>
<p>GraphQL 객체 타입은 이름과 필드를 가지지만, 결국 그 끝에는 구체적인 데이터로 해석되어야 하는데, 이것이 스칼라 타입이 필요한 이유다.</p>
<p>쿼리를 요청할 때, 필드에 하위 필드가 존재하지 않는 경우 그것이 스칼라 타입임을 알 수 있다. 기본적으로 존재하는 스칼라 타입에는 다음과 같은 것들이 있다.</p>
<ul>
<li><code>Int</code> : 부호가 있는(Signed) 32비트 정수</li>
<li><code>Float</code> : 부호가 있는 부동소수점(double-precision floating-point) 값</li>
<li><code>String</code> : UTF-8 문자열</li>
<li><code>Boolean</code> : <code>true</code> 또는 <code>false</code></li>
<li><code>ID</code> : ID 스칼라 타입은 객체를 다시 요청하거나 캐시 키로써 종종 사용되는 고유 식별자다. String과 같은 형태로 Serialized 되지만, <code>ID</code>로 정의하는 것은 사람들이 읽기 위한 용도가 아님을 의미한다.</li>
</ul>
<p>별도로 커스텀 스칼라 타입을 지정할 수도 있는데, 이는 어떤 언어와 라이브러리를 활용하느냐에 따라 조금씩 다른 형태가 될 것이다. 아래는 JS와 apollo를 활용한 기준.</p>
<pre><code class="language-js">const { ApolloServer, gql } = require('apollo-server');
const { GraphQLScalarType, Kind } = require('graphql');

const typeDefs = gql`
  scalar Date

  type Event {
    id: ID!
    date: Date!
  }

  type Query {
    events: [Event!]
  }
`;

const dateScalar = new GraphQLScalarType({
  name: 'Date',
  description: 'Date custom scalar type',
  serialize(value) {
    return value.getTime(); // Convert outgoing Date to integer for JSON
  },
  parseValue(value) {
    return new Date(value); // Convert incoming integer to Date
  },
  parseLiteral(ast) {
    if (ast.kind === Kind.INT) {
      return new Date(parseInt(ast.value, 10)); // Convert hard-coded AST string to integer and then to Date
    }
    return null; // Invalid hard-coded value (not an integer)
  },
});

const resolvers = {
  Date: dateScalar,
  // ...other resolver definitions...
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
});
</code></pre>
<h2 id="enum-type"><a class="header" href="#enum-type">Enum Type</a></h2>
<p>Enum 타입은 특정 값들로 제한되는 특별한 종류의 스칼라다.</p>
<pre><code class="language-graphql">enum Genre {
  action
  puzzle
  adventure
}
</code></pre>
<p>위의 예시에서 <code>Genre</code> 타입을 사용하면, 이는 정확히 <code>action</code>, <code>puzzle</code>, <code>adventure</code> 중에 하나일 것임을 보장한다.</p>
<h2 id="lists--non-null"><a class="header" href="#lists--non-null">Lists &amp; Non-Null</a></h2>
<p>object, scalar, enum 타입은 GraphQL에서 정의할 수 있는 타입의 전부다.</p>
<p>하지만, 스키마의 다른 부분이나 쿼리 변수 선언에서 타입을 사용해 해당 값의 유효성 검사를 할 수 있는 타입 수정자를 적용할 수 있다.</p>
<pre><code class="language-graphql">type Game {
  title: String!
  tags: [String]!
}
</code></pre>
<p><code>String</code>타입의 뒤에 느낌표 <code>!</code>를 추가해 Non-Null임을 나타냈다. 이제 서버는 해당 필드에 대해 항상 <code>null</code>이 아닐 것이라 기대하며, 만약 <code>null</code>이 반환되면 오류를 발생시킨다.</p>
<p>Non-null 타입 수정자는 매개 변수를 정의할 때도 사용할 수 있는데, 이를 쿼리 시에 충족시키지 않는 경우 유효성 검사 오류를 반환하게끔 한다.</p>
<pre><code class="language-graphql"># query
query GameInfo(id: ID!) {
  game(id: id) {
    title
    tags
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  // 아무것도 넘기지 않는다.
}
</code></pre>
<pre><code class="language-json">// result
// variables에 아무것도 넘기지 않아 에러가 발생.
{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Variable \&quot;id\&quot; of required type \&quot;ID!\&quot; was not provided.&quot;,
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 1,
          &quot;column&quot;: 17
        }
      ]
    }
  ]
}
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>여러가지 타입 시스템과 마찬가지로 GraphQL 역시 인터페이스를 지원한다.</p>
<p>예를 들면, 다음과 같은 식으로 작성할 수 있다.</p>
<pre><code class="language-graphql">interface Game {
  id: ID!
  title: String!
  tags: [Tag]!
}

type ActionGame implements Game {
  id: ID!
  title: String!
  tags: [Tag]!
  genre: ActionGenre!
}

enum ActionGenre {
  Fighting
  Platformer
  ARPG
}
</code></pre>
<p>이런 식으로 <code>Game</code>을 implement하는 모든 타입이 해당 인자와 리턴 타입을 가진 정확한 필드를 가져야함을 명시해줄 수 있다.</p>
<p>만약, 앞선 쿼리의 형태에서 특정 타입에만 존재하는 필드를 가져오고자 하는 경우, 단순히 아래와 같은 형태는 에러가 발생한다.</p>
<pre><code class="language-graphql">query GameInfo(id: ID!) {
  game(id: id) {
    title
    genre # ActionGame 타입에만 존재
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;id1234&quot;
}
</code></pre>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Cannot query field \&quot;genre\&quot; on type \&quot;Game\&quot;. Did you mean to use an inline fragment on \&quot;ActionGame\&quot;?&quot;,
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 4,
          &quot;column&quot;: 5
        }
      ]
    }
  ]
}
</code></pre>
<p>이러한 경우에 아래와 같은 형태로 인라인 프래그먼트를 사용하여 특정 객체 타입일 경우의 필드를 요청할 수 있다.</p>
<pre><code class="language-graphql">query GameInfo(id: ID!) {
  game(id: id) {
    title
    ... on ActionGame {
      genre
    }
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;id&quot;: &quot;id1234&quot;
}
</code></pre>
<pre><code class="language-json">// result
// 임의로 작성됨
{
  &quot;data&quot;: {
    &quot;title&quot;: &quot;Super Mario Bros&quot;,
    &quot;genre&quot;: &quot;Platformer&quot;
  }
}
</code></pre>
<h2 id="union-type"><a class="header" href="#union-type">Union Type</a></h2>
<p>유니온 타입은 인터페이스와 유사하지만, 타입 간의 공통 필드를 정의하지 않는다는 차이점이 있다.</p>
<pre><code class="language-graphql">union SearchResult = ActionGame | PuzzleGame
</code></pre>
<p>이런 경우, SearchResult의 결과가 어떤 타입이더라도 쿼리할 수 있도록 조건부 프래그먼트를 사용해야 한다.</p>
<pre><code class="language-graphql">search(text: &quot;ma&quot;) {
  ... on ActionGame {
    # ActionGame 타입에서 존재하는 필드
  }
  ... on PuzzleGame {
    # PuzzleGame 타입에서 존재하는 필드
  }
}
</code></pre>
<h2 id="input-type"><a class="header" href="#input-type">Input Type</a></h2>
<p>지금껏 매개변수에 전달하는 인자가 간단한 스칼라 값인 경우에 대해서만 나타냈는데, 좀 더 복잡한 객체도 쉽게 전달할 수 있다. 이는 뮤테이션 타입에서 특히 유용하다.</p>
<p>이 때 활용하는 타입이 <strong>Input Type</strong>이며, 일반 객체 타입과 완전히 동일하지만, <code>type</code> 대신에 <code>input</code>을 사용한다는 차이점이 있다.</p>
<pre><code class="language-graphql">input ReviewInput {
  stars: Int!
  comment: String
}
</code></pre>
<pre><code class="language-graphql"># mutation
mutation CreateReviewForGame(gameId: ID!, review: ReviewInput!) {
  createReview(gameId: gameId, review: review) {
    stars
    commentary
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;gameId&quot;: &quot;mario1234&quot;,
  &quot;review&quot;: {
    &quot;stars&quot;: 5,
    &quot;comment&quot;: &quot;The begin of legend. :)&quot;
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;createReview&quot;: {
      &quot;stars&quot;: 5,
      &quot;commentary&quot;: &quot;The begin of legend. :)&quot;
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://graphql-kr.github.io/learn/pagination/">여기</a>의 내용을 Github GraphQL API로 따라가보자.</p>
<h1 id="pagination"><a class="header" href="#pagination">Pagination</a></h1>
<h2 id="plurals"><a class="header" href="#plurals">Plurals</a></h2>
<p>여러 개의 객체를 가져오기 위한 가장 간단한 방법은 Plurals(복수형) 타입을 반환하는 필드를 사용하는 것이다.</p>
<pre><code class="language-graphql">licenses {
  name
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;licenses&quot;: [
      {
        &quot;name&quot;: &quot;GNU Affero General Public License v3.0&quot;
      },
      {
        &quot;name&quot;: &quot;Apache License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;BSD 2-Clause \&quot;Simplified\&quot; License&quot;
      },
      {
        &quot;name&quot;: &quot;BSD 3-Clause \&quot;New\&quot; or \&quot;Revised\&quot; License&quot;
      },
      {
        &quot;name&quot;: &quot;Boost Software License 1.0&quot;
      },
      {
        &quot;name&quot;: &quot;Creative Commons Zero v1.0 Universal&quot;
      },
      {
        &quot;name&quot;: &quot;Eclipse Public License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;GNU General Public License v2.0&quot;
      },
      {
        &quot;name&quot;: &quot;GNU General Public License v3.0&quot;
      },
      {
        &quot;name&quot;: &quot;GNU Lesser General Public License v2.1&quot;
      },
      {
        &quot;name&quot;: &quot;MIT License&quot;
      },
      {
        &quot;name&quot;: &quot;Mozilla Public License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;The Unlicense&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="slicing"><a class="header" href="#slicing">Slicing</a></h2>
<p>헌데, 여기에 클라이언트가 가장 앞의 둘, 혹은 가장 뒤의 둘과 같은 식으로 Slicing을 원한다면, 아래와 같은 형태가 이루어질 수 있다.</p>
<pre><code class="language-graphql">{
  search(query: &quot;react&quot;, type: REPOSITORY, first: 2) {
    nodes {
      ... on Repository {
        name
        owner {
          ... on User {
            name
          }
          ... on Organization {
            name
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;search&quot;: {
      &quot;nodes&quot;: [
        {
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;name&quot;: &quot;Facebook&quot;
          }
        },
        {
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;name&quot;: &quot;TypeScript Cheatsheets&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<h2 id="pagination-and-edges"><a class="header" href="#pagination-and-edges">Pagination and Edges</a></h2>
<p>페이지네이션을 할 수 있는 방법은 여러 가지가 있다.</p>
<ul>
<li>
<p><code>field(first: 2, offset: 2)</code> : 리스트로 다음 두 개를 요청</p>
</li>
<li>
<p><code>field(first: 2, after: &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.77777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;앞서가져온마지막&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;의&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;값을통해그다음두개를요청&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;fieldCursor)</code> : 마지막 항목으로부터 커서를 가져와 사용</p>
</li>
</ul>
<p>이 중 가장 기능이 강력한 것은 마지막의 **커서 기반 페이지네이션(cursor-based pagination)**이며, 커서를 사용하면 향후 페이지네이션 모델이 변경될 경우에 추가적인 유연성이 제공된다.</p>
<p>다만, 또 여기서 문제가 발생하는데, 객체에서 어떻게 커서를 가져오느냐 하는 것이다.</p>
<p>기본적으로, 커서는 연결(<code>connection</code>)을 위한 필드이므로 이것이 객체 속성에 포함되는 것은 부적절해보인다.</p>
<p>때문에 <code>edge</code>라고 하는 별도의 필드를 가지며, 이는 객체와 관련된 정보가 아닌 엣지와 관련된 자체 정보가 있는 경우에 유용하다.</p>
<pre><code class="language-graphql"># query
{
  search(query: &quot;react&quot;, type: REPOSITORY, first: 3) {
    edges {
      cursor
    }
    nodes {
      ... on Repository {
        id
        name
        owner {
          id
          ... on User {
            name
          }
          ... on Organization {
            name
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;search&quot;: {
      &quot;edges&quot;: [
        {
          &quot;cursor&quot;: &quot;Y3Vyc29yOjE=&quot;
        },
        {
          &quot;cursor&quot;: &quot;Y3Vyc29yOjI=&quot;
        },
        {
          &quot;cursor&quot;: &quot;Y3Vyc29yOjM=&quot;
        }
      ],
      &quot;nodes&quot;: [
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMDI3MDI1MA==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;,
            &quot;name&quot;: &quot;Facebook&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMzU3ODYwOTM=&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjUwMTg4MjY0&quot;,
            &quot;name&quot;: &quot;TypeScript Cheatsheets&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnk3NTM5NjU3NQ==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDQ6VXNlcjMyNDk2NTM=&quot;,
            &quot;name&quot;: &quot;肚皮&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<h2 id="end-of-list-counts-and-connections"><a class="header" href="#end-of-list-counts-and-connections">End-of-list, counts, and Connections</a></h2>
<p>그렇다면 이런 식으로 pagination을 반복하다가 언제 <code>connection</code>이 끝났는지를 알 수 있을까?? 또한, 총 몇 개의 item이 존재하는지 어떻게 알 수 있을까??</p>
<p>이를 위해 필드는 <code>connection</code> 객체를 반환할 수 있다.</p>
<p><code>connection</code> 객체에는 엣지에 대한 필드 뿐만 아니라 다른 정보(ex. item 갯수, 다음 페이지 존재 여부)등을 담고 있다.</p>
<p>이를 활용한다면, 다음과 같은 형태로 이용할 수 있다.</p>
<pre><code class="language-graphql">{
  search(query: &quot;react&quot;, type: REPOSITORY, first: 3) {
    nodes {
      ... on Repository {
        id
        name
        owner {
          id
          ... on User {
            name
          }
          ... on Organization {
            name
          }
        }
      }
    }
    repositoryCount
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;search&quot;: {
      &quot;nodes&quot;: [
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMDI3MDI1MA==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;,
            &quot;name&quot;: &quot;Facebook&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMzU3ODYwOTM=&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjUwMTg4MjY0&quot;,
            &quot;name&quot;: &quot;TypeScript Cheatsheets&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnk3NTM5NjU3NQ==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDQ6VXNlcjMyNDk2NTM=&quot;,
            &quot;name&quot;: &quot;肚皮&quot;
          }
        }
      ],
      &quot;repositoryCount&quot;: 1979845,
      &quot;pageInfo&quot;: {
        &quot;startCursor&quot;: &quot;Y3Vyc29yOjE=&quot;,
        &quot;endCursor&quot;: &quot;Y3Vyc29yOjM=&quot;,
        &quot;hasPreviousPage&quot;: false,
        &quot;hasNextPage&quot;: true
      }
    }
  }
}
</code></pre>
<p><code>pageInfo</code>내의 <code>startCursor</code>, <code>endCursor</code>를 통해 페이지네이션에 필요한 커서를 얻을 수 있으며, 더 이상 <code>edge</code>를 쿼리할 필요가 없어졌다.</p>
<h2 id="complete-connection-model"><a class="header" href="#complete-connection-model">Complete Connection Model</a></h2>
<p>이는 별도로 <code>~Connection</code>과 같은 필드를 추가하는 방식이다.</p>
<p>단순히 복수 타입을 갖도록 하는 형태보다 훨씬 더 복잡하지만, 이러한 디자인을 채택함으로써 클라이언트를 위한 다양한 기능을 사용할 수 있게 된다.</p>
<ul>
<li>리스트의 페이지네이션 기능</li>
<li><code>totalCount</code> 또는 <code>pageInfo</code>와 같은 연결 자체에 대한 정보를 요청하는 기능</li>
<li><code>cursor</code> 등 엣지 자체에 대한 정보를 요청하는 기능</li>
<li>백엔드 측에서 페이지네이션 방식 변경이 가능 (사용자가 불투명(<code>opaque</code>) 커서만을 사용하기 때문에)</li>
</ul>
<p>아래는 예시.</p>
<pre><code class="language-graphql">{
  hero {
    name
    friends {
      name
    }
    friendsConnection(first: 3) {
      totalCount
      edges {
        cursor
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;hero&quot;: {
      &quot;name&quot;: &quot;R2-D2&quot;,
      &quot;friends&quot;: [
        {
          &quot;name&quot;: &quot;Luke Skywalker&quot;
        },
        {
          &quot;name&quot;: &quot;Han Solo&quot;
        },
        {
          &quot;name&quot;: &quot;Leia Organa&quot;
        }
      ],
      &quot;friendsConnection&quot;: {
        &quot;totalCount&quot;: 3,
        &quot;edges&quot;: [
          {
            &quot;cursor&quot;: &quot;Y3Vyc29yMQ==&quot;
          },
          {
            &quot;cursor&quot;: &quot;Y3Vyc29yMg==&quot;
          },
          {
            &quot;cursor&quot;: &quot;Y3Vyc29yMw==&quot;
          }
        ],
        &quot;pageInfo&quot;: {
          &quot;endCursor&quot;: &quot;Y3Vyc29yMw==&quot;,
          &quot;hasNextPage&quot;: false
        }
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="serving-over-http"><a class="header" href="#serving-over-http">Serving Over HTTP</a></h1>
<p><a href="https://graphql-kr.github.io/learn/serving-over-http/">여기</a>의 내용을 따라가보자.</p>
<h2 id="uris-routes"><a class="header" href="#uris-routes">URIs, Routes</a></h2>
<p>HTTP는 일반적으로 리소스를 핵심 개념으로 여기는 REST와 관련이 있다.</p>
<p>이와 반대로, GraphQL의 개념 모델은 엔티티 그래프로, 이는 URL로 식별되지 않는다.</p>
<p>GraphQL 서버는 단일 엔드포인트(일반적으로 <code>/graphql</code>)에서 작동하며, 주어진 서비스에 대한 모든 요청은 해당 엔드포인트에서 수행된다.</p>
<h2 id="http-methods-headers-and-body"><a class="header" href="#http-methods-headers-and-body">HTTP Methods, Headers, and Body</a></h2>
<p>GraphQL HTTP 서버는 HTTP GET / POST 메서드를 처리해야 한다.</p>
<h3 id="get-요청"><a class="header" href="#get-요청">GET 요청</a></h3>
<p>만약 다음과 같은 GraphQL 쿼리를 실행하려고 한다면,</p>
<pre><code class="language-graphql">{
  me {
    name
  }
}
</code></pre>
<p>다음과 같이 HTTP GET을 통해 전송할 수 있다.</p>
<pre><code>/graphql?query={me{name}}
</code></pre>
<p>여기에 더해 다음과 같은 추가 쿼리 파라미터를 가질 수 있다.</p>
<ul>
<li><code>variables</code> : 쿼리 변수들을 넘기는 객체를 JSON Stringified 처리한 문자열</li>
<li><code>operationName</code> : 쿼리에 여러 개의 명명된 작업이 포함된 경우에, 어떤 쿼리를 실행하는지 제어</li>
</ul>
<p>즉, <code>variables</code>과 함께 좀 더 복잡한 쿼리를 전달해보자면, 가령 아래와 같은 쿼리가 있다고 할 때,</p>
<pre><code class="language-graphql">query gameInfo(id: ID!) {
  game(id: id) {
    title
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;id&quot;: &quot;1&quot;
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;game&quot;: {
      &quot;title&quot;: &quot;Super Mario Bros&quot;
    }
  }
}
</code></pre>
<p>이를 (굳이) HTTP GET 메서드로 요청해보겠다고 하면 아래와 같아진다. 만약 나머지 특수문자들도 인코딩한다면 훨씬 지저분해질 것이다.</p>
<pre><code>/graphql?variables={&quot;id&quot;:&quot;1&quot;}&amp;query=query%20gameInfo(id:ID!){game(id:id){title}}
</code></pre>
<p><code>operationName</code>의 경우, 앞서 말했듯 여러 개의 쿼리 작업을 보유한 경우, 실행하길 원하는 작업명을 의미한다.</p>
<p>이를테면 아래와 같이 사용한다. 다음과 같은 쿼리가 있다고 하자.</p>
<pre><code class="language-graphql">query query1 {
  game(id: &quot;1&quot;) {
    title
  }
}

query query2 {
  game(id: &quot;2&quot;) {
    title
  }
}
</code></pre>
<p>여기서, (굳이 또) HTTP GET 메서드로 <code>query2</code>에 해당하는 작업을 요구하려는 경우에는 다음과 같이 할 수 있다.</p>
<pre><code>/graphql?operationName=query2&amp;query=query%20query1{game(id:&quot;1&quot;){title}}%20query%20query2{game(id:&quot;2&quot;){title}}
</code></pre>
<h3 id="post-요청"><a class="header" href="#post-요청">POST 요청</a></h3>
<p>표준 GraphQL POST 요청은 <code>application/json</code> content-type을 사용해야하며, 아래 형식의 JSON 인코딩 처리된 Body를 포함해야한다.</p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;...&quot;,
  &quot;operationName&quot;: &quot;...&quot;,
  &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }
}
</code></pre>
<p><code>operationName</code>과 <code>variables</code>는 앞선 GET 메서드의 경우와 똑같은 역할을 한다.</p>
<p>위 내용 외에도 추가로 다음 두 가지 경우에 대해 지원하는 것이 좋다.</p>
<ul>
<li>위의 GET 요청과 같은 방식으로 쿼리스트링 파라미터가 존재하는 경우, HTTP GET의 경우와 동일한 형식으로 처리</li>
<li><code>application/graphql</code> Content-Type header가 있는 경우, HTTP POST body의 내용을 GraphQL 쿼리스트링으로 처리 (Body에 넘겨진 텍스트 자체를 쿼리문으로 여겨야 한다는 듯)</li>
</ul>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>쿼리와 변수가 전송된 방식과는 관계없이, 응답은 Body에 JSON 형태로 반환되어야 한다.
쿼리는 데이터 뿐만 아니라 오류 또한 유발할 수 있기 때문에, 다음과 같은 형태로 반환되어야 한다.</p>
<pre><code>{
  &quot;data&quot;: { ... },
  &quot;errors&quot;: [ ... ]
}
</code></pre>
<p>오류가 없는 경우에는 <code>errors</code> 필드가 없어야 한다.
반면 데이터가 반환되지 않는 경우에는 실행 도중에 에러가 발생한 경우에 대해서만 <code>data</code> 필드가 포함된다.</p>
<h3 id="graphiql"><a class="header" href="#graphiql">GraphiQL</a></h3>
<p>GraphiQL이나 GraphQL Playground는 테스트 및 개발 중에 유용하게 쓰일 수 있지만, 기본적으로 프로덕션 환경에서는 사용하지 않도록 되어야 한다.</p>
<p><code>express-graphql</code>의 경우는 다음과 같이 이를 구현할 수 있다.</p>
<pre><code class="language-js">app.use(
  '/graphql',
  graphqlHTTP({
    schema: MySessionAwareGraphQLSchema,
    graphiql: process.env.NODE_ENV === 'development',
  }),
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h2>
<pre><code class="language-bash">docker run -d -p 80:80 docker/getting-started
</code></pre>
<ul>
<li><code>-d</code> : 컨테이너를 <code>detached</code> 모드로 실행한다. (백그라운드에서)</li>
<li><code>-p 80:80</code> : 호스트의 <code>80</code> 포트를 컨테이너의 <code>80</code> 포트로 연결시킨다.</li>
<li><code>docker/getting-started</code> : 사용할 이미지</li>
</ul>
<p>위의 단일 문자 플래그들은 합쳐서 사용할 수 있다. 이를테면 아래와 같이 작성할 수 있다.</p>
<pre><code class="language-bash">docker run -dp 80:80 docker/getting-started
</code></pre>
<h2 id="대쉬보드"><a class="header" href="#대쉬보드">대쉬보드</a></h2>
<p>컨테이너를 실행하고나면 이를 대쉬보드 상에서 확인할 수 있다.</p>
<img src="https://docs.docker.com/get-started/images/tutorial-in-dashboard.png" />
<h2 id="컨테이너란"><a class="header" href="#컨테이너란">컨테이너란?</a></h2>
<p>컨테이너란 호스트 머신의 다른 프로세스로부터 격리된 또 하나의 프로세스다. 이러한 분리는 Linux에서 오랫동안 사용되어 온 기능인 <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces와 cgroups</a>를 활용한다. 그리고 Docker는 이런 기능들은 접근 가능하고 사용하기 쉽게 만들고자 한 것이다.</p>
<h2 id="컨테이너-이미지란"><a class="header" href="#컨테이너-이미지란">컨테이너 이미지란?</a></h2>
<p>컨테이너가 실행될 때, 해당 컨테이너는 격리된 파일시스템을 사용한다. 이 격리된 파일시스템이 바로 <strong>컨테이너 이미지</strong>로부터 제공된다. 각 이미지들은 컨테이너의 파일시스템을 내포하고 있으며, 애플리케이션의 실행에 필요한 모든 것들을 담고 있어야 한다. (dependencies / configurations / scripts / binaries / etc.) 또한 환경변수, 기초 실행 명령 / 그 외의 메타 데이터 등 컨테이너에 대한 다른 설정들 또한 갖고있다.</p>
<p>이미지에 대해서는 Layering, Best practices 등 추후 더 깊게 다루어보도록 하겠다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="애플리케이션-구성"><a class="header" href="#애플리케이션-구성">애플리케이션 구성</a></h2>
<img src="https://docs.docker.com/get-started/images/ide-screenshot.png" />
<p>위와 같은 애플리케이션이 있다고 하자.</p>
<h2 id="컨테이너-이미지-빌드"><a class="header" href="#컨테이너-이미지-빌드">컨테이너 이미지 빌드</a></h2>
<p>애플리케이션을 빌드하기 위해서는 <code>Dockerfile</code>을 사용해야 한다. <code>Dockerfile</code>은 컨테이너 이미지를 생성하기 위해 사용되는 간단한 텍스트 스크립트다.</p>
<ol>
<li>먼저 <code>Dockerfile</code>을 <code>package.json</code>이 위치한 폴더와 같은 곳에 생성한다.</li>
</ol>
<pre><code class="language-dockerfile"> # syntax=docker/dockerfile:1
 FROM node:12-alpine
 RUN apk add --no-cache python g++ make
 WORKDIR /app
 COPY . .
 RUN yarn install --production
 CMD [&quot;node&quot;, &quot;src/index.js&quot;]
</code></pre>
<p><code>Dockerfile</code>에는 별도로 <code>.txt</code>와 같은 확장자가 붙어있지 않음을 유의하자.</p>
<ol start="2">
<li><code>Dockerfile</code>이 위치한 디렉토리로 이동하여 <code>docker build</code> 명령을 통해 컨테이너 이미지를 빌드한다.</li>
</ol>
<pre><code class="language-bash">docker build -t getting-started .
</code></pre>
<p>빌드 과정에서, 수많은 <strong>layer</strong>들이 다운로드되는 것을 확인할 수 있는데, 이는 <code>Dockerfile</code>의 처음에 <code>node:12-alpine</code> 이미지에서부터 시작된다고 빌더에게 명령했기 때문이다. 현재의 호스트 머신에는 이 이미지가 존재하지 않고, 따라서 해당 이미지를 다운로드하는 과정이 필요한 것이다.</p>
<p>해당 이미지가 다운로드되면, 애플리케이션을 복사하고 <code>yarn</code>으로 애플리케이션의 dependencies를 설치한다. <code>CMD</code> 명령에는 이미지로부터 컨테이너를 가동할 때 실행할 기본 명령어를 지정한다.</p>
<p>마지막으로, <code>-t</code> 플래그는 이미지에 대한 태그를 의미한다. 생성한 이미지에 대한 읽기 쉬운 이름이라고 이해하면 된다. <code>getting-started</code> 라는 이름으로 이미지를 이름지었기 때문에, 컨테이너를 실행할 때마다 해당 이름을 참조할 수 있다.</p>
<p><code>docker build</code>의 마지막에 있는 <code>.</code>은 Docker에게 <strong>현재 디렉토리</strong>에서 <code>Dockerfile</code>을 찾아야한다고 명령하는 것이다.</p>
<h2 id="앱-컨테이너-실행"><a class="header" href="#앱-컨테이너-실행">앱 컨테이너 실행</a></h2>
<p>자, 이제 이미지를 만들었으니, 이를 실행해보자. <code>docker run</code> 명령을 사용하면 된다.</p>
<ol>
<li>앞서 만든 이미지를 <code>docker run</code> 명령을 통해 컨테이너로 실행한다.</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 getting-started
</code></pre>
<p>앞선 챕터에서 <code>-d</code>와 <code>-p</code> 플래그에 대해 설명했던 것이 기억나는가? <code>-dp</code> 플래그를 통해, 호스트의 3000 포트를 컨테이너의 3000 포트와 매핑하고, 컨테이너를 &quot;detached&quot; 모드(백그라운드에서) 실행했다. 만약 별도로 포트를 지정해주지 않는다면, 애플리케이션에 접근할 수 없다.</p>
<ol start="2">
<li>잠시 후, <code>http://localhost:3000</code>에 접근하면, 애플리케이션을 확인할 수 있다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="애플리케이션-업데이트"><a class="header" href="#애플리케이션-업데이트">애플리케이션 업데이트</a></h2>
<pre><code class="language-bash">docker build -t getting-started .
docker run -dp 3000:3000 getting-started
</code></pre>
<p>애플리케이션에 어떤 변경사항이 생겼을 때, 이를 적용하고 이전 챕터에서 했던 것과 동일하게 빌드 / 실행하게되면 아래와 같은 에러가 발생한다.</p>
<pre><code class="language-bash">docker: Error response from daemon: driver failed programming external connectivity on endpoint laughing_burnell
(bb242b2ca4d67eba76e79474fb36bb5125708ebdabd7f45c8eaf16caaabde9dd): Bind for 0.0.0.0:3000 failed: port is already allocated.
</code></pre>
<p>해당 문제는 컨테이너가 호스트의 3000 포트를 사용하고 있고, 호스트 머신에서는 하나의 프로세스만이 특정 포트를 수신할 수 있기 때문이다. 따라서, 이를 해결하려면 실행 중인 이전의 컨테이너를 제거해야 한다.</p>
<h2 id="컨테이너-교체"><a class="header" href="#컨테이너-교체">컨테이너 교체</a></h2>
<p>컨테이너를 제거하려면, 먼저 컨테이너를 멈추어야 한다. 두 가지 방법이 있는데, 어느 쪽을 사용해도 상관없다.</p>
<h3 id="1-cli로-컨테이너-제거"><a class="header" href="#1-cli로-컨테이너-제거">1. CLI로 컨테이너 제거</a></h3>
<ol>
<li><code>docker ps</code> 명령으로 컨테이너의 ID를 가져온다.</li>
</ol>
<pre><code class="language-bash">docker ps
</code></pre>
<ol start="2">
<li><code>docker stop</code> 명령으로 컨테이너를 멈춘다.</li>
</ol>
<pre><code class="language-bash"># &lt;the-container-id&gt;를 앞선 과정에서 얻은 ID로 교체
docker stop &lt;the-container-id&gt;
</code></pre>
<ol start="3">
<li>컨테이너가 멈추고 난 후, <code>docker rm</code> 명령으로 제거한다.</li>
</ol>
<pre><code class="language-bash">docker rm &lt;the-container-id&gt;
</code></pre>
<p>만약 &quot;force&quot; 플래그를 추가한다면 <code>docker rm</code> 명령 하나만으로 컨테이너를 정지하고 삭제할 수 있다.</p>
<pre><code class="language-bash">docker rm -f &lt;the-container-id&gt;
</code></pre>
<h3 id="2-docker-대쉬보드를-통해-컨테이너-삭제"><a class="header" href="#2-docker-대쉬보드를-통해-컨테이너-삭제">2. Docker 대쉬보드를 통해 컨테이너 삭제</a></h3>
<img src="https://docs.docker.com/get-started/images/dashboard-removing-container.png" />
<p>Docker 대쉬보드를 이용한다면 몇 번의 클릭을 통해 앞선 과정을 해결할 수 있다.</p>
<h2 id="컨테이너-재실행"><a class="header" href="#컨테이너-재실행">컨테이너 재실행</a></h2>
<p>이제, 다시 업데이트된 컨테이너를 실행해보자.</p>
<pre><code class="language-bash">docker run -dp 3000:3000 getting-started
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="저장소repository-생성"><a class="header" href="#저장소repository-생성">저장소(Repository) 생성</a></h2>
<p>이미지를 푸쉬하기 위해서는 먼저 DockerHub에 저장소를 생성해야 한다.</p>
<ol>
<li>Docker Hub에 가입하고, 로그인</li>
<li><strong>Create Repository</strong> 버튼을 클릭</li>
<li>저장소 이름을 설정하고, Visibility를 <code>Public</code>으로 지정
<blockquote>
<p>기본적으로 Private 저장소는 개인 당 1개만 주어진다. 추가로 이용하거나 팀 별로 이용하고자 하는 경우엔 <a href="https://www.docker.com/pricing?utm_source=docker&amp;utm_medium=webreferral&amp;utm_campaign=docs_driven_upgrade">Pricing</a>을 참조하자.</p>
</blockquote>
</li>
<li><strong>Create</strong> 버튼을 클릭</li>
</ol>
<p>해당 과정을 마쳤으면, 아래와 같이 <strong>Docker commands</strong>가 나타난다. 이는 현재 저장소에 푸쉬하기 위한 예시 명령이다.</p>
<img src="https://docs.docker.com/get-started/images/push-command.png" />
<h2 id="이미지-푸쉬"><a class="header" href="#이미지-푸쉬">이미지 푸쉬</a></h2>
<ol>
<li>다음과 같이 푸쉬 명령을 작성한다. <code>docker</code>가 아니라, 본인의 네임 스페이스로 작성해주어야 함을 주의하자.</li>
</ol>
<pre><code class="language-bash">  docker push docker/getting-started
 The push refers to repository [docker.io/docker/getting-started]
 An image does not exist locally with the tag: docker/getting-started
</code></pre>
<p>뭐가 문제일까? 푸쉬 명령이 <code>docker/getting-started</code>라는 이름의 이미지를 찾아봤지만, 알 수 없었다. <code>docker image ls</code>를 실행해보면 알겠지만, 아무 것도 존재하지 않는다.</p>
<ol start="2">
<li>
<p>먼저, <code>docker login -u &lt;USER-NAME&gt;</code> 명령으로 Docker Hub에 로그인한다.</p>
</li>
<li>
<p><code>docker tag</code> 명령으로 <code>getting-started</code> 이미지에 새로운 이름을 부여한다.</p>
</li>
</ol>
<pre><code class="language-bash">docker tag getting-started &lt;USER-NAME&gt;/getting-started
</code></pre>
<ol start="4">
<li>이제, 앞선 과정을 다시 해보자. 현재 따로 태그네임을 추가하지 않았으므로 <code>:tagname</code> 부분은 없어도 된다. 별도로 태그를 지정하지 않는 경우, Docker는 <code>latest</code>라는 이름의 태그를 사용한다.</li>
</ol>
<pre><code class="language-bash">docker push YOUR-USER-NAME/getting-started
</code></pre>
<h2 id="새-인스턴스에-이미지-실행"><a class="header" href="#새-인스턴스에-이미지-실행">새 인스턴스에 이미지 실행</a></h2>
<p>이제, 우리가 빌드한 컨테이너 이미지를 전혀 다른 새로운 환경에서 사용해보자. 여기서는 <strong>Play with Docker</strong>를 사용한다.</p>
<ol>
<li>
<p>브라우저로 <a href="https://labs.play-with-docker.com/">Play with Docker</a>에 접속한다.</p>
</li>
<li>
<p><strong>Login</strong>을 클릭하고, <strong>docker</strong>를 선택한다.</p>
</li>
<li>
<p>본인의 Docker Hub 계정으로 접속한다.</p>
</li>
<li>
<p>로그인 한 후, <strong>ADD NEW INSTANCE</strong> 옵션을 클릭한다. 이 후, 브라우저 상에서 터미널을 확인할 수 있다.</p>
</li>
</ol>
<img src="https://docs.docker.com/get-started/images/pwd-add-new-instance.png" />
<ol start="5">
<li>해당 터미널에서 우리가 푸쉬했던 애플리케이션을 실행하자.</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 YOUR-USER-NAME/getting-started
</code></pre>
<ol start="6">
<li>위쪽에 <code>3000</code> 포트를 클릭하면, 실행한 애플리케이션을 확인할 수 있다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="컨테이너-파일시스템"><a class="header" href="#컨테이너-파일시스템">컨테이너 파일시스템</a></h2>
<p>컨테이너가 실행될 때, 파일시스템을 구축하기 위해 이미지로부터 여러 개의 레이어를 사용한다. 각각의 컨테이너는 파일을 생성/업데이트/제거하기 위한 &quot;Scratch space&quot;를 갖는다. 한 컨테이너 내의 어떤 변화는 다른 컨테이너에 영향을 주지 않으며, 심지어 그것이 같은 이미지로부터 만들어진 컨테이너라도 마찬가지다.</p>
<h2 id="실전"><a class="header" href="#실전">실전</a></h2>
<p>직접 두 개의 컨테이너를 실행시키고 각각 하나의 파일을 만들게끔 해보자. 이로부터 하나의 컨테이너에서 생긴 파일은 다른 컨테이너에서 활용할 수 없음을 확인할 수 있을 것이다.</p>
<ol>
<li><code>ubuntu</code> 컨테이너를 실행하고 1에서 10000 사이의 난수를 갖는 <code>/data.txt</code>라는 이름의 파일을 만든다.</li>
</ol>
<pre><code class="language-bash">docker run -d ubuntu bash -c &quot;shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null&quot;
</code></pre>
<p>위에서는 <code>&amp;&amp;</code>를 통해 두 가지 명령을 실행했는데, 첫번째는 무작위 번호를 추출하여 <code>/data.txt</code>라는 파일로 작성한 것이고, 두번째는 컨테이너를 실행 상태로 유지하기 위해 파일을 확인하는 것이다.</p>
<ol start="2">
<li>컨테이너에 <code>exec</code>을 해줌으로써 결과를 확인할 수 있다. 그렇게 하기 위해서, 대쉬보드를 열고 실행 중인 <code>ubuntu</code> 이미지가 실행 중인 컨테이너를 클릭하자.</li>
</ol>
<img src="https://docs.docker.com/get-started/images/dashboard-open-cli-ubuntu.png"/>
<p>그러면 현재 실행 중인 <code>ubuntu</code> 컨테이너 내에서 동작하고 있는 터미널을 확인할 수 있다. 작성한 <code>/data.txt</code> 파일을 확인하기 위해 아래의 명령을 실행하고, 터미널을 다시 종료하자.</p>
<pre><code class="language-bash">cat /data.txt
</code></pre>
<p>만약, 대쉬보드보다 CLI 방식을 더 선호한다면, 아래와 같이 <code>docker exec</code> 명령을 실행하여 똑같이 진행할 수 있다. 이 경우 컨테이너의 ID를 알고 있어야 한다.(<code>docker ps</code>를 사용하자.)</p>
<pre><code class="language-bash">docker exec &lt;container-id&gt; cat /data.txt
</code></pre>
<p>그러면 <code>/data.txt</code>에 작성된 난수를 확인할 수 있을 것이다!</p>
<ol start="3">
<li>이제, 똑같은 이미지를 통해 다른 <code>ubuntu</code> 컨테이너를 실행시켜보자. 동일한 파일이 존재하지 않음을 알 수 있다.</li>
</ol>
<pre><code class="language-bash">docker run -it ubuntu ls /
</code></pre>
<p>보시다시피 <code>data.txt</code>가 존재하지 않는다. 말했다시피 해당 파일은 첫번째 컨테이너에 대한 &quot;scratch space&quot;에 작성되었기 때문이다.</p>
<h2 id="컨테이너-볼륨"><a class="header" href="#컨테이너-볼륨">컨테이너 볼륨</a></h2>
<p>앞선 실험에서, 동일한 이미지에서 실행한 각각의 컨테이너는 매번 새롭게 실행되는 것임을 확인했다. 각각의 컨테이너 내에서 일어나는 일련의 CRUD 작업들은 해당 컨테이너 내에서만 영향을 준다. 단, **볼륨(Volume)**을 사용한다면, 이를 바꿀 수 있다.</p>
<p><a href="https://docs.docker.com/storage/volumes/">볼륨</a>은 컨테이너의 특정 파일 시스템 경로를 호스트 머신에 연결시켜줄 수 있게 해준다. 컨테이너의 디렉토리가 마운트되면, 디렉토리 내의 변경사항들은 호스트 머신에도 적용된다. 덕분에, 컨테이너가 여러번 재실행되더라도, 동일한 디렉토리를 마운트하게 되면 매번 동일한 파일을 유지할 수 있다.</p>
<p>볼륨에는 두 가지 종류가 있는데, 하나는 <strong>Named volumes</strong>이다.</p>
<h2 id="데이터-유지하기"><a class="header" href="#데이터-유지하기">데이터 유지하기</a></h2>
<p>앞선 챕터에서, 기본적으로 우리의 TODO 앱은 <a href="https://www.sqlite.org/index.html">SQLite</a>를 통해 <code>/etc/todos/todo.db</code>에 데이터를 저장한다. SQLite는 하나의 파일에 데이터를 저장하는 간단한 형태의 관계형 DB다. 이는 대규모의 애플리케이션에 적합하진 않지만, 작은 데모에서는 잘 동작한다. DB 엔진을 변경하는 방법에 대해서는 추후에 따로 다루어보자.</p>
<p>DB가 하나의 파일이기 때문에, 해당 파일을 유지하기만 하면 다음 컨테이너의 실행에서도 DB에 저장된 내용을 유지할 수 있다. 볼륨을 만들고, 디렉토리에 첨부(일반적으로, <strong>mouting</strong>이라고 함)하면, 데이터가 저장, 유지된다. 현재 컨테이너는 <code>todo.db</code> 파일을 작성하기 때문에, 볼륨을 통해 해당 파일이 호스트에 지속될 것이다.</p>
<p>앞서 말했듯, 먼저 <strong>named volume</strong>을 사용해보겠다. named volume은 간단한 데이터 버킷이다. Docker가 디스크의 물리적인 로케이션을 유지하고, 우리는 해당 볼륨의 이름을 기억하기만 하면 된다. 해당 볼륨을 사용할 때마다, Docker가 적절한 데이터가 제공됨을 보장해줄 것이다.</p>
<ol>
<li><code>docker volume create</code> 명령으로 볼륨을 만든다.</li>
</ol>
<pre><code class="language-bash">docker volume create todo-db
</code></pre>
<ol start="2">
<li>
<p>작동 중인 TODO 앱 컨테이너를 멈추고, 삭제한다. (대쉬보드, 혹은 <code>docker rm -f &lt;id&gt;</code>)</p>
</li>
<li>
<p>새로 컨테이너를 실행하되, <code>-v</code> 플래그를 통해 마운트할 볼륨을 지정해준다. 여기선 named volume을 사용하고, 이를 <code>/etc/todos</code>에 마운트 해주었다. 이를 통해 해당 경로에 있는 모든 파일들이 캡처된다.</p>
</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
</code></pre>
<ol start="4">
<li>애플리케이션을 실행하여 적절히 데이터가 생성 / 변경 / 유지되는지 확인한다.</li>
</ol>
<img src="https://docs.docker.com/get-started/images/items-added.png"/>
<ol start="5">
<li>2 ~ 4번을 다시 수행하면서, 컨테이너를 재실행시키더라도 데이터가 여전히 유지되는지 확인한다.</li>
</ol>
<blockquote>
<p><strong>참고</strong> : Docker에서는 기본적으로 named volume과 bind mounts(추후 설명)를 볼륨으로 제공하지만, NFS, SFTP, NetApp 등 수많은 볼륨 드라이버 플러그인들이 존재한다. 이는 Swarm, Kubernetes 등의 클러스터 환경을 통해 여러 호스트에서 컨테이너를 실행한다면 특히 중요하다.</p>
</blockquote>
<h2 id="볼륨-파헤치기"><a class="header" href="#볼륨-파헤치기">볼륨 파헤치기</a></h2>
<p>종종, &quot;<em>Named volume을 사용할 때, Docker는 실제로 어디에 데이터를 저장하는 걸까?</em>&quot;하는 물음이 들 수 있다. 이를 확인하고 싶다면, <code>docker volume inspect</code> 명령을 사용해보자.</p>
<pre><code class="language-bash">docker volume inspect todo-db
[
    {
        &quot;CreatedAt&quot;: &quot;2019-09-26T02:18:36Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;,
        &quot;Name&quot;: &quot;todo-db&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<p><code>Mountpoint</code>가 바로 데이터가 저장되는 디스크의 실제 위치다. 대부분의 머신에서는 해당 디렉토리에 접근하기 위해 루트 엑세스 권한이 요구된다.</p>
<blockquote>
<p><strong>Docker Desktop의 경우</strong> : Docker Desktop을 실행하는 동안, Docker 명령은 실제로는 호스트 머신 내의 작은 VM 내에서 실행된다. 이 경우 <code>Mountpoint</code> 디렉토리 내의 실제 파일들을 확인하려고 한다면, 먼저 VM 내부로 들어가야 한다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>이전 챕터에서, DB 내의 데이터를 보존하기 위한 <strong>named volume</strong>에 대해서 이야기했다. Named volume은 어디에 데이터를 저장하는지에 대해서는 신경쓰지 않기 때문에, 단순히 데이터를 저장하기 위한 용도로는 충분하다.</p>
<p><strong>Bind mounts</strong>를 사용한다면, 우리가 직접 호스트의 정확한 &quot;mountpoint&quot;를 조작할 수 있다. Bind Mounts는 데이터를 보존하기 위해 사용할 수도 있지만, 컨테이너에 추가적인 데이터를 제공해야 하는 경우에 쓰이는 경우가 많다. 애플리케이션 개발 단계에서 Bind Mounts를 사용하면 소스 코드를 컨테이너에 마운트하여 코드 변경 사항을 확인하고, 즉각적인 변경 사항을 확인할 수 있다.</p>
<p><a href="https://npmjs.com/package/nodemon">nodemon</a>은 NodeJS 애플리케이션에서 변경 사항을 파악하고, 재실행 시켜주는 툴이다. NodeJS 외의 언어 및 프레임워크에서는 다른 적합한 툴들이 존재할 것이다.</p>
<h2 id="볼륨-타입-비교"><a class="header" href="#볼륨-타입-비교">볼륨 타입 비교</a></h2>
<p>Bind mounts 와 Named volumes는 Docker 엔진에서 제공되는 두가지 타입의 볼륨이다. 다른 경우에 제공되는 추가적인 볼륨 드라이버를 사용할 수도 있다.</p>
<table><thead><tr><th></th><th>Named Volumes</th><th>Bind Mounts</th></tr></thead><tbody>
<tr><td>호스트 위치</td><td>Docker가 정함</td><td>직접 정함</td></tr>
<tr><td>마운트 예시 (<code>-v</code> 플래그)</td><td><code>my-volume:/usr/local/data</code></td><td><code>/path/to/data:/usr/local/data</code></td></tr>
<tr><td>새 볼륨을 컨테이너 컨텐츠로 채움</td><td>예</td><td>아니오</td></tr>
<tr><td>볼륨 드라이버 지원</td><td>예</td><td>아니오</td></tr>
</tbody></table>
<h2 id="dev-모드-컨테이너-실행"><a class="header" href="#dev-모드-컨테이너-실행">Dev 모드 컨테이너 실행</a></h2>
<p>컨테이너가 개발 워크플로우를 지원하도록 하기 위해서, 아래의 사항을 수행해야 한다.</p>
<ul>
<li>컨테이너에 소스 코드를 마운트시킨다.</li>
<li>모든 종속성을 설치한다. (<code>dev</code> 종속성 포함)</li>
<li><code>nodemon</code>을 실행하여 파일시스템 변경을 감시한다.</li>
</ul>
<ol>
<li>이전에 실행했던 <code>getting-started</code> 컨테이너를 종료, 제거한다.</li>
<li>아래 명령을 입력한다. 아래쪽에서 해당 명령에 대해 상세히 설명하겠다.</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 \
    -w /app -v &quot;(pwd):/app&quot; \
    node:12-alpine \
    sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<p>PowerShell을 사용한다면 아래 명령을 사용해야 한다.</p>
<pre><code class="language-shell">docker run -dp 3000:3000 `
    -w /app -v &quot;(pwd):/app&quot; `
    node:12-alpine `
    sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ul>
<li><code>-dp 3000:3000</code> - 포트 매핑 및 백그라운드 모드 (이전에 언급한 것과 같다.)</li>
<li><code>-w /app</code> - 작업 디렉토리, 혹은 명령이 실행될 디렉토리를 지정</li>
<li><code>-v &quot;(pwd):/app&quot;</code> - 호스트의 현재 디렉토리(<code>pwd</code>)를 컨테이너의 <code>/app</code> 디렉토리와 <strong>bind mount</strong>시킴</li>
<li><code>node:12-alpine</code> - 사용할 이미지. Dockerfile 내의 Base 이미지를 사용.</li>
<li><code>sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</code> - 명령어. <code>sh</code>를 통해서 셸을 실행하고(alpine은 <code>bash</code>를 갖고있지 않다.) <code>yarn install</code>을 실행하여 모든 종속성을 설치한 뒤 <code>yarn run dev</code>로 개발 모드로 실행한다.</li>
</ul>
<ol start="3">
<li><code>docker logs -f &lt;container-id&gt;</code>를 통해 로그를 확인할 수 있다.</li>
</ol>
<pre><code class="language-bash"> docker logs -f &lt;container-id&gt;
  nodemon src/index.js
 [nodemon] 1.19.2
 [nodemon] to restart at any time, enter `rs`
 [nodemon] watching dir(s): *.*
 [nodemon] starting `node src/index.js`
 Using sqlite database at /etc/todos/todo.db
 Listening on port 3000
</code></pre>
<ol start="4">
<li>이제, 애플리케이션에 변경을 적용해보자. <code>src/static/js/app.js</code> 파일에서 텍스트를 간단하게 변경해보겠다.</li>
</ol>
<pre><code> -                         {submitting ? 'Adding...' : 'Add Item'}
 +                         {submitting ? 'Adding...' : 'Add'}
</code></pre>
<ol start="5">
<li>브라우저가 변경을 감지하고 페이지를 새로고침하는 것을 확인할 수 있다.</li>
</ol>
<img src="https://docs.docker.com/get-started/images/updated-add-button.png" />
<ol start="6">
<li>모든 작업이 끝났다면, 컨테이너를 정지시키고 <code>docker build -t getting-started .</code> 명령을 통해 새로운 이미지를 빌드한다.</li>
</ol>
<p>bind mounts의 이용은 로컬 개발 환경에서 매우 일반적으로 사용된다. 호스트 머신에서 별도로 빌드 툴과 환경을 설치하지 않아도 된다는 장점이 있다. 덕분에 단순히 <code>docker run</code> 커맨드를 실행함으로써 개발 환경이 구축되고, 곧바로 개발에 돌입할 수 있다.</p>
<p>추후에 <strong>Docker Compose</strong>에 대해 이야기할텐데, 이를 사용하면 앞서 사용했던 명령들을 훨씬 간단하게 처리할 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>이전 챕터까지는 모두 단일 컨테이너 애플리케이션을 다루었다. 자, 이제 MySQL과 같이 별도의 애플리케이션 스택을 추가하려고 한다. 종종 다음과 같은 물음이 생긴다. - &quot;어디서 MySQL을 구동해야 할까? 똑같은 컨테이너 내에서 설치되어야 하나, 아니면 따로 실행되어야 하나?&quot; 일반적으로, <strong>각각의 컨테이너는 한 가지 일만을 수행하고, 그것이 잘 이루어져야 한다.</strong> 이유는 다음과 같다.</p>
<ul>
<li>DB 외에 API 및 프론트엔드를 확장해야 할 가능성이 높다.</li>
<li>별도의 컨테이너를 통한 버저닝이 수월하다.</li>
<li>로컬에서 데이터베이스에 대한 컨테이너를 사용할 수도 있는 한편, 프로덕션 상에 운영 중인 데이터베이스에 대해 관리되는 서비스를 사용하고 싶을수도 있다.</li>
<li>여러 프로세스를 실행하려면 별도의 프로세스 매니저가 요구된다. (컨테이너는 하나의 프로세스만을 실행한다.) 따라서 컨테이너의 시작 / 종료에 복잡성을 가중시킨다.</li>
</ul>
<p>그 외에도 여러 이유가 있으며, 결국 우리는 아래와 같은 형태로 애플리케이션을 업데이트하려고 한다.</p>
<img src="https://docs.docker.com/get-started/images/multi-app-architecture.png"/>
<h2 id="컨테이너-네트워킹"><a class="header" href="#컨테이너-네트워킹">컨테이너 네트워킹</a></h2>
<p>기본적으로, 컨테이너는 격리된 환경에서 실행되며, 동일한 머신 내의 다른 프로세스나 컨테이너에 대해서는 아무것도 알지 못한다는 점을 기억하라. 그렇다면, 어떻게 컨테이너 상호 간의 소통을 주도할 수 있을까? 정답은 <strong>Networking</strong>이다. <strong>두 컨테이너가 같은 네트워크 상에 있다면, 컨테이너 간에 상호작용을 할 수 있다. 그렇지 않다면, 불가능하다.</strong></p>
<h2 id="mysql-실행"><a class="header" href="#mysql-실행">MySQL 실행</a></h2>
<p>컨테이너를 네트워크에 포함시키기 위한 두가지 방법이 있다. <strong>1) 실행 시점에 할당시키거나</strong>, <strong>2) 기존 컨테이너에 연결한다.</strong> 먼저, 네트워크를 생성하고 MySQL 컨테이너를 해당 네트워크에 첨부해보자.</p>
<ol>
<li>네트워크를 생성한다.</li>
</ol>
<pre><code class="language-bash">docker network create todo-app
</code></pre>
<ol start="2">
<li>MySQL 컨테이너를 실행하고 네트워크에 첨부한다. 데이터베이스를 초기화하기 위해서 환경 변수를 지정해주어야 한다.</li>
</ol>
<pre><code class="language-bash"> docker run -d \
     --network todo-app --network-alias mysql \
     -v todo-mysql-data:/var/lib/mysql \
     -e MYSQL_ROOT_PASSWORD=secret \
     -e MYSQL_DATABASE=todos \
     mysql:5.7
</code></pre>
<p>PowerShell을 이용한다면 아래 명령을 사용하자.</p>
<pre><code class="language-shell"> docker run -d `
     --network todo-app --network-alias mysql `
     -v todo-mysql-data:/var/lib/mysql `
     -e MYSQL_ROOT_PASSWORD=secret `
     -e MYSQL_DATABASE=todos `
     mysql:5.7
</code></pre>
<p>위에서 <code>--network-alias</code> 플래그를 지정한 것을 볼 수 있는데, 이에 대해서는 아래쪽에서 다루도록 하자.</p>
<blockquote>
<p><strong>유의</strong> : 위에서 <code>todo-mysql-data</code>로 볼륨명을 지정하고, <code>/var/lib/mysql</code>에 마운트한 것을 확인할 수 있는데, 이는 MySQL이 데이터를 저장하는 디렉토리이다. 헌데, 이 후 <code>docker volume create</code> 명령을 수행하지는 않는다. Docker가 Named volume의 사용을 인지하고 자동으로 볼륨을 생성해주기 때문이다.</p>
</blockquote>
<ol start="3">
<li>이후 데이터베이스를 실행하고, 연결한 후에 제대로 연결되었는지를 확인해보자.</li>
</ol>
<pre><code class="language-bash">docker exec -it &lt;mysql-container-id&gt; mysql -u root -p
</code></pre>
<p>패스워드 프롬프트가 뜨면, 패스워드를 입력한다. 이후 MySQL 셸에서 데이터베이스를 리스트하고 <code>todos</code> 데이터베이스를 확인하자.</p>
<pre><code class="language-bash">mysql&gt; SHOW DATABASES;
</code></pre>
<p>이제 아래와 같은 결과가 보일 것이다.</p>
<pre><code class="language-bash"> +--------------------+
 | Database           |
 +--------------------+
 | information_schema |
 | mysql              |
 | performance_schema |
 | sys                |
 | todos              |
 +--------------------+
 5 rows in set (0.00 sec)
</code></pre>
<p>여기까지가 <code>todos</code> 데이터베이스를 만드는 과정이었다.</p>
<h2 id="mysql에-연결"><a class="header" href="#mysql에-연결">MySQL에 연결</a></h2>
<p>이제 MySQL에 DB를 구성했고, 이제 사용하기만 하면 된다. 문제는 이를 어떻게 사용하느냐인데, 동일한 네트워크에서 다른 컨테이너들을 어떻게 찾아낼 수 있을까?</p>
<p>이를 확인하기 위해서 <a href="https://github.com/nicolaka/netshoot">nicolaka/netshoot</a> 컨테이너를 사용한다. 해당 컨테이너는 네트워킹 이슈에 대한 트러블 슈팅 혹은 디버깅에 유용한 수많은 툴을 제공한다.</p>
<ol>
<li>nicolaka/netshoot 이미지를 사용하여 새로운 컨테이너를 실행한다. 기존에 생성한 것과 동일한 네트워크에 연결하는 것임을 확인하자.</li>
</ol>
<pre><code class="language-bash">docker run -it --network todo-app nicolaka/netshoot
</code></pre>
<ol start="2">
<li>컨테이너 내에서 <code>dig</code> 명령을 사용하는데, 이는 유용한 DNS 툴이다. 아래 명령으로 <code>mysql</code>이라는 호스트네임에 대한 IP 주소를 찾을 수 있다.</li>
</ol>
<pre><code class="language-bash">dig mysql
</code></pre>
<p>그리고 그 결과는 아래처럼 나타난다.</p>
<pre><code class="language-bash"> ; &lt;&lt;&gt;&gt; DiG 9.14.1 &lt;&lt;&gt;&gt; mysql
 ;; global options: +cmd
 ;; Got answer:
 ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32162
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;mysql.				IN	A

 ;; ANSWER SECTION:
 mysql.			600	IN	A	172.23.0.2

 ;; Query time: 0 msec
 ;; SERVER: 127.0.0.11#53(127.0.0.11)
 ;; WHEN: Tue Oct 01 23:47:24 UTC 2019
 ;; MSG SIZE  rcvd: 44
</code></pre>
<p><code>ANSWER SECTION</code> 부분에서 <code>mysql</code>의 <code>A</code> 레코드가 <code>172.23.0.2</code>로 지정되어 있음을 확인할 수 있다. (환경에 따라 IP 주소는 달라질 수 있다.) <code>mysql</code>은 일반적으로 타당한 호스트네임이 아니지만, Docker는 network alias를 보유한 컨테이너의 IP 주소를 사용함으로써 이를 처리했다. (앞서 <code>--network-alias</code> 플래그를 사용했던 것을 기억하자.)</p>
<p>그 결과, 이제 애플리케이션은 <code>mysql</code>이라는 이름의 호스트에 연결하기만 하면, 데이터베이스와 상호작용할 수 있게 된다.</p>
<h2 id="mysql과-함께-애플리케이션-구동"><a class="header" href="#mysql과-함께-애플리케이션-구동">MySQL과 함께 애플리케이션 구동</a></h2>
<p>이제 TODO 앱은 MySQL과 연결하기 위해 몇가지 환경 변수 설정이 필요하다.</p>
<ul>
<li><code>MYSQL_HOST</code></li>
<li><code>MYSQL_USER</code></li>
<li><code>MYSQL_PASSWORD</code></li>
<li><code>MYSQL_DDB</code></li>
</ul>
<blockquote>
<p><strong>환경 변수에 대해</strong> : 개발 단계에서 환경 변수를 사용하는 것은 괜찮지만, 애플리케이션이 프로덕션 단계에서 실행되는 경우 환경 변수는 <strong>대부분의 경우 사용하지 말아야 한다.</strong> 그 이유에 대해서는 Docker의 보안 리드 Diogo Monica의 <a href="https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/">블로그 포스트</a>를 참조하자.</p>
<p>보다 안전한 방법은, 컨테이너 오케스트레이션 프레임워크에서 제공하는 Secret Support 기능을 사용하는 것이다. 대부분의 경우 이러한 Secret들은 실행 중인 컨테이너에 파일로 마운트된다. 많은 애플리케이션들이 이를 위해 <code>_FILE</code> 접미사가 붙은 변수들을 지원하는 것을 확인할 수 있다.</p>
<p>예를 들어, 우리가 사용하는 예시 애플리케이션에서는 <code>MYSQL_PASSWORD_FILE</code> 변수를 설정하여 DB를 연결하기 위한 환경변수가 담긴 파일을 참조하도록 할 수 있다. Docker 자체는 별도로 환경 변수를 지원하지 않는다. 애플리케이션 자체적으로 사용할 환경 변수에 대한 파일을 찾아서 사용하도록 구현해야 한다.</p>
</blockquote>
<p>당장에는 환경 변수를 통해서 애플리케이션을 DB에 연결해보자.</p>
<ol>
<li>각각의 환경 변수들을 작성해주고, 컨테이너를 네트워크에 연결해준다.</li>
</ol>
<pre><code class="language-bash"> docker run -dp 3000:3000 \
   -w /app -v &quot;(pwd):/app&quot; \
   --network todo-app \
   -e MYSQL_HOST=mysql \
   -e MYSQL_USER=root \
   -e MYSQL_PASSWORD=secret \
   -e MYSQL_DB=todos \
   node:12-alpine \
   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<p>PowerShell을 사용한다면 아래와 같이 작성한다.</p>
<pre><code class="language-sh"> docker run -dp 3000:3000 `
   -w /app -v &quot;(pwd):/app&quot; `
   --network todo-app `
   -e MYSQL_HOST=mysql `
   -e MYSQL_USER=root `
   -e MYSQL_PASSWORD=secret `
   -e MYSQL_DB=todos `
   node:12-alpine `
   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ol start="2">
<li>컨테이너 로그를 살펴보면(<code>docker logs &lt;container-id&gt;</code>), 다음과 같이 DB 연결에 성공했음을 나타내는 메시지를 확인할 수 있다.</li>
</ol>
<pre><code class="language-bash"> # Previous log messages omitted
 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05724em;&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1.19.2&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ores&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02691em;&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hin&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.46528em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;esrc&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05724em;&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.07153em;&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ec&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ba&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nin&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;3000‘‘‘3.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;브라우저에서애플리케이션을실행하고&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;TO&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;앱을테스트해본다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.4.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;아래명령을통해&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;데이터베이스에연결하고&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;데이터가적절하게저장되었는지를확인하자&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.‘‘‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ba&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;oc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ere&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ec&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69862em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.74285em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ain&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.73354em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘‘‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;셸상에서아래와같이작성하고&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;결과를확인한다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.‘‘‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ba&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hm&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;se&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ec&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ro&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.31166399999999994em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathnormal mtight&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;pl&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;906&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;ff&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;08&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;44&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;49&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;0853&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;85∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ama&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.04398em;&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hin&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣0∣∣2912&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;79&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;8486&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.77777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;460793&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;575&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05017em;&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02691em;&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;eso&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣0∣&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘‘‘&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;현재&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;Doc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;대쉬보드를확인해본다면&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;두개의앱컨테이너가작동하고있음을확인할수있다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;하지만&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;두컨테이너가하나의애플리케이션을위해그룹화되어있음을확인할수는없다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;이를개선할방법에에대해서는이후챕터에서알아보겠다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.85396em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ttp&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ocs&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;oc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ima&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;es&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hb&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.77777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.74285em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ain&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;/&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://docs.docker.com/compose/">Docker Compose</a>는 멀티 컨테이너 애플리케이션을 정의하고 공유하는 것을 돕고자 개발된 툴이다. Compose를 사용하면, YAML 파일을 생성하여 서비스를 정의한 후, 단일 명령을 통해 애플리케이션을 구축하거나 분해할 수 있다.</p>
<p>Compose를 사용할 경우의 큰 이점은 바로 애플리케이션 스택을 하나의 파일로 정의할 수 있다는 점이다. 해당 파일은 프로젝트 저장소의 루트에 저장되며, 다른 이들이 이를 보고 프로젝트에 쉽게 기여할 수 있게 해준다. 그런 경우가 아니더라도, 단순히 repo를 클론하여 애플리케이션을 실행하기만 하면 된다는 점에서 편리하다. 이는 Github/GitLab 등에서 이루어지는 것과 유사하다.</p>
<h2 id="docker-compose-설치"><a class="header" href="#docker-compose-설치">Docker Compose 설치</a></h2>
<p>Windows나 Mac에서 Docker Desktop/Toolbox를 설치했다면, 이미 Docker Compose가 포함되어 있다. &quot;Play-with-Docker&quot; 인스턴스 역시 Docker Compose가 설치되어 있으며, Linux 머신을 사용하는 상황이라면, 별도로 <a href="https://docs.docker.com/compose/install/">설치</a>해주어야 한다.</p>
<p>설치 이후, 아래 명령을 통해 버전 정보를 확인해보자.</p>
<pre><code>docker-compose version
</code></pre>
<h2 id="compose-파일-생성"><a class="header" href="#compose-파일-생성">Compose 파일 생성</a></h2>
<ol>
<li>
<p>프로젝트 루트에서, <code>docker-compose.yml</code> 이라는 이름의 파일을 생성한다.</p>
</li>
<li>
<p>해당 파일에서, 우선 schema 버전을 정의하는 것부터 시작하자. 대부분의 경우에는 최신 지원 버전을 사용하는 것이 좋다. 현재 schema 버전에서 가능한 Compose file의 <a href="https://docs.docker.com/compose/compose-file/">레퍼런스</a>에 대해 확인하자.</p>
</li>
</ol>
<pre><code class="language-yaml">version: '3.7'
</code></pre>
<ol start="3">
<li>이후, 애플리케이션에 사용할 각각의 서비스(컨테이너)를 정의해준다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
</code></pre>
<h2 id="앱-서비스-정의"><a class="header" href="#앱-서비스-정의">앱 서비스 정의</a></h2>
<p>이전 챕터에서 우리는 앱 컨테이너를 정의하기 위해 아래와 같은 명령을 실행했다.</p>
<pre><code class="language-bash">docker run -dp 3000:3000 \
  -w /app -v &quot;(pwd):/app&quot; \
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:12-alpine \
  sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<p>PowerShell의 경우</p>
<pre><code class="language-sh">docker run -dp 3000:3000 `
  -w /app -v &quot;(pwd):/app&quot; `
  --network todo-app `
  -e MYSQL_HOST=mysql `
  -e MYSQL_USER=root `
  -e MYSQL_PASSWORD=secret `
  -e MYSQL_DB=todos `
  node:12-alpine `
  sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ol>
<li>먼저, 컨테이너에 사용할 서비스 엔트리와 이미지를 정의한다. 서비스에는 어떤 이름이든 쓰여도 된다(여기에서는 <code>app</code>). 여기서의 이름은 자동으로 network alias가 되며, 이후 다른 서비스에서 해당 서비스를 활용할 때 유용하다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
</code></pre>
<ol start="2">
<li>일반적으로 <code>command</code> 항목을 <code>image</code> 가까이에 정의하긴 하지만, 별도로 순서에 대한 요구 사항은 없다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ol start="3">
<li>서비스의 <code>ports</code>를 정의해준다. (<code>-p 3000:3000</code>) 이 부분에서는 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-1">짧게</a> 작성할 수도 있고, 좀 더 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#long-syntax-1">길게</a> 구체적으로 작성할 수도 있다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
</code></pre>
<ol start="4">
<li>이제 <code>working_dir</code>과 <code>volumes</code> 항목을 통해 작업 디렉토리(<code>-w /app</code>)와 볼륨 매핑(<code>-v &quot;(pwd):/app&quot;</code>)를 정의한다. 볼륨 역시 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-3">짧게</a> 혹은 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#long-syntax-3">길게</a> 작성될 수 있다.</li>
</ol>
<p>Docker Compose를 통해 볼륨을 정의하는 경우, 현재 디렉토리에서의 상대 경로를 사용할 수 있다는 장점이 있다.</p>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
</code></pre>
<ol start="5">
<li>마지막으로, 사용하는 환경 변수를 <code>environment</code> 항목에서 지정해준다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos
</code></pre>
<h2 id="mysql-서비스-정의"><a class="header" href="#mysql-서비스-정의">MySQL 서비스 정의</a></h2>
<p>자, 이제 MySQL 서비스에 대해 정의해보자. 앞서 아래와 같은 명령을 통해 MySQL 컨테이너를 실행했다.</p>
<pre><code class="language-bash">docker run -d \
  --network todo-app --network-alias mysql \
  -v todo-mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  -e MYSQL_DATABASE=todos \
  mysql:5.7
</code></pre>
<p>PowerShell을 사용한다면</p>
<pre><code class="language-sh">docker run -d `
  --network todo-app --network-alias mysql `
  -v todo-mysql-data:/var/lib/mysql `
  -e MYSQL_ROOT_PASSWORD=secret `
  -e MYSQL_DATABASE=todos `
  mysql:5.7
</code></pre>
<ol>
<li>먼저 새로운 서비스를 정의하고 <code>mysql</code>로 이름짓는다. 이를 통해 자동으로 network alias를 갖게 된다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    # The app service definition
  mysql:
    image: mysql:5.7
</code></pre>
<ol start="2">
<li>다음으로, 볼륨 매핑을 정의한다. 기존에는 <code>docker run</code>을 통해 컨테이너를 실행하게 되면, named volume이 알아서 생성되었지만, Compose를 사용하는 경우에는 그렇지 않다. 최상단의 <code>volumes:</code> 항목에서 직접 볼륨을 정의하고, <code>services:</code> 의 각 항목 내에서 mountpoint를 지정해주어야 한다. 단순히 볼륨 네임만을 정의한다면 기본 옵션값들이 사용된다. 추가 옵션들에 대해서는 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#volume-configuration-reference">여기</a>를 참조하자.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    # The app service definition
  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql

volumes:
  todo-mysql-data:
</code></pre>
<ol start="3">
<li>마지막으로, 환경 변수들을 정의해준다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    # The app service definition
  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
</code></pre>
<p>최종적으로, 작성한 <code>docker-compose.yml</code>파일은 아래와 같은 형태가 된다.</p>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
</code></pre>
<h2 id="애플리케이션-스택-실행"><a class="header" href="#애플리케이션-스택-실행">애플리케이션 스택 실행</a></h2>
<p><code>docker-compose.yml</code> 파일을 갖고 있다면, 이제 애플리케이션들을 실행할 수 있다.</p>
<ol>
<li>
<p>기존에 실행 중인 app 혹은 db가 없는지 확인한다. (<code>docker ps</code>와 <code>docker rm -f &lt;ids&gt;</code> 사용)</p>
</li>
<li>
<p><code>docker-compose up</code>을 통해 애플리케이션 스택을 실행한다. <code>-d</code> 플래그를 통해 모든 스택들을 백그라운드 모드에서 실행한다.</p>
</li>
</ol>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<p>명령 이후 아래와 같은 진행사항들이 출력된다.</p>
<pre><code class="language-bash">Creating network &quot;app_default&quot; with the default driver
Creating volume &quot;app_todo-mysql-data&quot; with default driver
Creating app_app_1   ... done
Creating app_mysql_1 ... done
</code></pre>
<p>네트워크와 볼륨들이 생성되는 것을 확인할 수 있다. 기본적으로, Docker Compose는 애플리케이션 스택 상에 정의된 네트워크를 생성한다. (별도로 compose 파일 내에서 네트워크를 정의하지 않은 이유다.)</p>
<ol start="3">
<li><code>docker-compose logs -f</code> 명령을 통해 로그를 확인할 수 있다. 각각의 서비스에서의 로그가 단일 스트림으로 인터리빙된것을 볼 수 있다. 이는 타이밍 관련 이슈들을 탐지하고자 하는 경우에 굉장히 유용하다. <code>-f</code> 플래그는 로그를 &quot;팔로우&quot;할 것을 의미하며, 실시간으로 재생되는 로그들을 제공받는다.</li>
</ol>
<pre><code>mysql_1  | 2019-10-03T03:07:16.083639Z 0 [Note] mysqld: ready for connections.
mysql_1  | Version: '5.7.27'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server (GPL)
app_1    | Connected to mysql db at host mysql
app_1    | Listening on port 3000
</code></pre>
<p>서비스 네임이 각 줄의 <code>|</code> 좌측에 출력되며, 만약 특정 서비스에 대한 로그만을 확인하고자 한다면, 로그 명령 끝에 원하는 서비스네임을 추가해주면 된다.</p>
<pre><code>docker-compose logs -f app
</code></pre>
<blockquote>
<p><strong>DB 실행 이후 App이 실행되도록 하기</strong> : Docker는 다른 컴포넌트가 완전히 구동되고 준비될 때까지 기다리도록 하는 내장 지원 기능이 별도로 없다. Node 기반의 프로젝트에서는 이를 위해 <a href="https://github.com/dwmkerr/wait-port">wait-port</a> 라이브러리를 사용할 수 있다. 다른 프레임워크 및 언어에 대해서도 유사한 것들이 존재한다.</p>
</blockquote>
<ol start="4">
<li>이제 애플리케이션을 직접 열어 확인해보자.</li>
</ol>
<h2 id="대쉬보드에서-애플리케이션-스택-확인"><a class="header" href="#대쉬보드에서-애플리케이션-스택-확인">대쉬보드에서 애플리케이션 스택 확인</a></h2>
<p>Docker 대쉬보드를 살펴보면 <code>app</code>이라는 이름으로 그룹이 생성되었음을 확인할 수 있다. 이는 Docker Compose에서 작성된 프로젝트 네임으로, 기본값으로 <code>docker-compose.yml</code>이 위치한 디렉토리의 이름이 사용된다.</p>
<img src="https://docs.docker.com/get-started/images/dashboard-app-project-collapsed.png" />
<p>애플리케이션 스택을 살펴보면, 앞서 compose 파일을 통해 정의한 두 컨테이너를 확인할 수 있다. 이들은 <code>&lt;project-name&gt;_&lt;service-name&gt;_&lt;replica-number&gt;</code>의 패턴을 따른다.</p>
<img src="https://docs.docker.com/get-started/images/dashboard-app-project-expanded.png" />
<h2 id="종료-및-제거"><a class="header" href="#종료-및-제거">종료 및 제거</a></h2>
<p><code>docker-compose down</code>을 명령하거나 대쉬보드 상에서 휴지통 아이콘을 클릭하면 앱 스택을 종료할 수 있다. 관련된 모든 컨테이너들이 중지되고, 네트워크는 삭제된다.</p>
<blockquote>
<p><strong>주의</strong> : 기본적으로 compose 파일에서 정의된 named volume들은 <code>docker-compose down</code> 명령으로 제거되지 않는다. 볼륨들도 제거하고자 하는 경우, <code>--volumes</code> 플래그를 추가해주어야 한다.</p>
<p>Docker 대쉬보드에서도 마찬가지로 애플리케이션 스택을 제거할 때 볼륨은 제거하지 않는다.</p>
</blockquote>
<p>앱 스택을 제거 한 이후, 다른 프로젝트를 작업할 때도 단순히 <code>docker-compose up</code>를 실행하기만 하면 된다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="보안-스캐닝"><a class="header" href="#보안-스캐닝">보안 스캐닝</a></h2>
<p>이미지를 빌드하고 나서, <code>docker scan</code> 명령으로 보안 취약점을 탐색하는 것이 좋다. Docker는 <a href="http://snyk.io/">Snyk</a>과 파트너쉽을 보유하여 취약점 탐색 서비스를 제공한다.</p>
<p>예를 들어, <code>getting-started</code> 이미지에 대한 스캐닝을 진행해보자.</p>
<pre><code class="language-bash">docker scan getting-started
</code></pre>
<p>스캔은 지속적으로 업데이트되는 취약점 데이터베이스를 활용하기 때문에, 아래와 같이 표시되는 출력은 상황에 따라 달라질 수 있다.</p>
<pre><code>✗ Low severity vulnerability found in freetype/freetype
  Description: CVE-2020-15999
  Info: https://snyk.io/vuln/SNYK-ALPINE310-FREETYPE-1019641
  Introduced through: freetype/freetype@2.10.0-r0, gd/libgd@2.2.5-r2
  From: freetype/freetype@2.10.0-r0
  From: gd/libgd@2.2.5-r2 &gt; freetype/freetype@2.10.0-r0
  Fixed in: 2.10.0-r1

✗ Medium severity vulnerability found in libxml2/libxml2
  Description: Out-of-bounds Read
  Info: https://snyk.io/vuln/SNYK-ALPINE310-LIBXML2-674791
  Introduced through: libxml2/libxml2@2.9.9-r3, libxslt/libxslt@1.1.33-r3, nginx-module-xslt/nginx-module-xslt@1.17.9-r1
  From: libxml2/libxml2@2.9.9-r3
  From: libxslt/libxslt@1.1.33-r3 &gt; libxml2/libxml2@2.9.9-r3
  From: nginx-module-xslt/nginx-module-xslt@1.17.9-r1 &gt; libxml2/libxml2@2.9.9-r3
  Fixed in: 2.9.9-r4
</code></pre>
<p>출력에는 취약점의 타입을 나열하고, 이와 관련된 URL을 보여주며, 취약점을 고치기 위한 최근 라이브러리 버전 등을 제공해준다.</p>
<p><a href="https://docs.docker.com/engine/scan/">Docker scan 문서</a>에서 더 많은 옵션들에 대한 사항을 살펴볼 수 있다.</p>
<p>CLI 외에도, Docker Hub 설정을 통해 새롭게 푸쉬된 이미지들에 대해서 스캐닝을 진행할 수도 있다.</p>
<img src="https://docs.docker.com/get-started/images/hvs.png" />
<h2 id="이미지-레이어링"><a class="header" href="#이미지-레이어링">이미지 레이어링</a></h2>
<p>한 이미지가 어떻게 구성되어 있는지 확인하려면 어떻게 해야할까? <code>docker image history</code> 명령을 사용하면, 하나의 이미지를 구성하기 위해 생성된 여러 레이어들에 대한 명령어들을 확인할 수 있다.</p>
<ol>
<li><code>docker image history</code> 명령을 사용하면 이전 챕터에서 만들었던 <code>getting-started</code> 이미지에 대한 레이어들을 확인할 수 있다.</li>
</ol>
<pre><code>docker image history getting-started
</code></pre>
<p>결과는 아래와 같은 형태일 것이다.</p>
<pre><code> IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
 a78a40cbf866        18 seconds ago      /bin/sh -c #(nop)  CMD [&quot;node&quot; &quot;src/index.j…    0B
 f1d1808565d6        19 seconds ago      /bin/sh -c yarn install --production            85.4MB
 a2c054d14948        36 seconds ago      /bin/sh -c #(nop) COPY dir:5dc710ad87c789593…   198kB
 9577ae713121        37 seconds ago      /bin/sh -c #(nop) WORKDIR /app                  0B
 b95baba1cfdb        13 days ago         /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;docker-entry…   0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B
 &lt;missing&gt;           13 days ago         /bin/sh -c apk add --no-cache --virtual .bui…   5.35MB
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.21.1      0B
 &lt;missing&gt;           13 days ago         /bin/sh -c addgroup -g 1000 node     &amp;&amp; addu…   74.3MB
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV NODE_VERSION=12.14.1     0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop) ADD file:e69d441d729412d24…   5.59MB
</code></pre>
<p>각각의 한줄은 이미지 내 하나의 레이어들을 나타낸다. 최근의 레이어일수록 상단에 위치한다. 이를 통해, 각각의 레이어 사이즈를 찾아볼 수 있고, 큰 이미지들을 진단하는데에 도움이 된다.</p>
<ol start="2">
<li>위에서, 여러 줄들이 결과 출력에서 잘린 것을 볼 수 있는데, <code>--no-trunc</code> 플래그를 추가해서 전체 출력을 표시할 수 있다.</li>
</ol>
<pre><code class="language-bash">docker image history --no-trunc getting-started
</code></pre>
<h2 id="레이어-캐싱"><a class="header" href="#레이어-캐싱">레이어 캐싱</a></h2>
<p>레이어가 동작하는 방식을 살펴봤으니, 이제 컨테이너 이미지를 빌드하는데에 걸리는 시간을 줄이기 위한 방법에 대해 살펴보자.</p>
<p><strong><em>일단 하나의 레이어가 변경된다면, 해당 레이어의 다운스트림 레이어들도 모두 재생성되어야 한다.</em></strong></p>
<p>기존에 작성했던 Dockerfile을 다시 살펴보자.</p>
<pre><code># syntax=docker/dockerfile:1
FROM node:12-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD [&quot;node&quot;, &quot;src/index.js&quot;]
</code></pre>
<p>이미지 히스토리에서 살펴본 것처럼, Dockerfile 내의 각각의 명령어들이 이미지 내 레이어가 되는 것을 볼 수 있다. 아마, 이미지에 어떤 변화가 발생하면 모든 yarn 종속성들이 전부 새로 설치되는 것을 확인할 수 있을 것이다. 빌드할 때마다 매번 동일한 종속성들을 설치하는게 적절해보이진 않는다. 이를 보완하려면 어떻게 해야할까?</p>
<p>이를 보완하기 위해서는, Dockerfile이 종속성 캐싱을 지원하도록 수정해야한다. Node 기반의 애플리케이션의 경우, 종속성들은 <code>package.json</code> 파일에 정의된다. 만약 우리가 처음 한번만 <code>package.json</code> 파일을 복사하고, 종속성을 설치한 후, 그 다음에 다른 것들을 복사하는 형태로 진행한다면 어떨까? 그렇다면 <code>package.json</code>에 변경이 있을 때에만 yarn 종속성이 재설치되도록 할 수 있을 것이다.</p>
<ol>
<li>Dockerfile에 가장 먼저 <code>package.json</code>을 복사하도록 수정한다. 이후 종속성을 설치하고, 그 다음에 나머지 모두를 복사한다.</li>
</ol>
<pre><code class="language-dockerfile"> # syntax=docker/dockerfile:1
 FROM node:12-alpine
 WORKDIR /app
 COPY package.json yarn.lock ./
 RUN yarn install --production
 COPY . .
 CMD [&quot;node&quot;, &quot;src/index.js&quot;]
</code></pre>
<ol start="2">
<li>동일한 폴더에 <code>.dockerignore</code> 라는 이름의 파일을 생성하고 아래의 내용을 작성한다.</li>
</ol>
<pre><code>node_modules
</code></pre>
<p><code>.dockerignore</code> 파일은 이미지와 관련된 파일만을 선택적으로 복사하기 위한 쉬운 방법이다. <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">여기</a>에서 더 많은 정보를 찾아볼 수 있다. 위 경우에서는, <code>node_modules</code> 폴더가 이미지에 추가될 필요가 없으므로 제외시켰다. 어차피 <code>RUN</code> 명령 단계를 통해 종속성이 설치되기 때문이다. <a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/">여기 문서</a>를 통해 NodeJS 애플리케이션을 도커라이징하는데 있어서 추천되는 디테일 사항에 대해 살펴볼 수 있다.</p>
<ol start="3">
<li><code>docker build</code>를 통해 새로운 이미지를 빌드한다.</li>
</ol>
<pre><code>docker build -t getting-started .
</code></pre>
<p>그러면 아래와 같은 결과가 나타날 것이다.</p>
<pre><code>Sending build context to Docker daemon  219.1kB
Step 1/6 : FROM node:12-alpine
---&gt; b0dc3a5e5e9e
Step 2/6 : WORKDIR /app
---&gt; Using cache
---&gt; 9577ae713121
Step 3/6 : COPY package.json yarn.lock ./
---&gt; bd5306f49fc8
Step 4/6 : RUN yarn install --production
---&gt; Running in d53a06c9e4c2
yarn install v1.17.3
[1/4] Resolving packages...
[2/4] Fetching packages...
info fsevents@1.2.9: The platform &quot;linux&quot; is incompatible with this module.
info &quot;fsevents@1.2.9&quot; is an optional dependency and failed compatibility check. Excluding it from installation.
[3/4] Linking dependencies...
[4/4] Building fresh packages...
Done in 10.89s.
Removing intermediate container d53a06c9e4c2
---&gt; 4e68fbc2d704
Step 5/6 : COPY . .
---&gt; a239a11f68d8
Step 6/6 : CMD [&quot;node&quot;, &quot;src/index.js&quot;]
---&gt; Running in 49999f68df8f
Removing intermediate container 49999f68df8f
---&gt; e709c03bc597
Successfully built e709c03bc597
Successfully tagged getting-started:latest
</code></pre>
<p>Dockerfile을 수정했으므로 모든 레이어들이 다시 빌드됨을 확인할 수 있다.</p>
<ol start="4">
<li>
<p>이제, <code>src/static/index.html</code> 상에서 약간의 변경을 해보자.</p>
</li>
<li>
<p>다시 <code>docker build -t getting-started .</code>를 통해 도커 이미지를 빌드한다. 이번에는 결과가 조금 다르게 출력될 것이다.</p>
</li>
</ol>
<pre><code> Sending build context to Docker daemon  219.1kB
 Step 1/6 : FROM node:12-alpine
 ---&gt; b0dc3a5e5e9e
 Step 2/6 : WORKDIR /app
 ---&gt; Using cache
 ---&gt; 9577ae713121
 Step 3/6 : COPY package.json yarn.lock ./
 ---&gt; Using cache
 ---&gt; bd5306f49fc8
 Step 4/6 : RUN yarn install --production
 ---&gt; Using cache
 ---&gt; 4e68fbc2d704
 Step 5/6 : COPY . .
 ---&gt; cccde25a3d9a
 Step 6/6 : CMD [&quot;node&quot;, &quot;src/index.js&quot;]
 ---&gt; Running in 2be75662c150
 Removing intermediate container 2be75662c150
 ---&gt; 458e5c6f080c
 Successfully built 458e5c6f080c
 Successfully tagged getting-started:latest
</code></pre>
<p>빌드 타임이 훨씬 짧아졌음을 확인할 수 있을 것이다. 그리고 위의 1 ~ 4 단계들이 전부 <code>Using cache</code>로 처리된 것을 볼 수 있다.</p>
<h2 id="멀티스테이지-빌드"><a class="header" href="#멀티스테이지-빌드">멀티스테이지 빌드</a></h2>
<p>현재 튜토리얼에서 너무 깊은 내용을 다루진 않겠지만, 멀티스테이지 빌드는 한 이미지를 생성하기 위해 여러 스테이지를 사용하도록 도와주는 유용한 툴이다. 이는 다음과 같은 이점을 제공한다.</p>
<ul>
<li>런타임 종속성과 빌드타임 종속성을 분리한다.</li>
<li>애플리케이션 구동에 오직 필요한 내용만 빌드하여 전반적인 이미지 사이즈를 줄인다.</li>
</ul>
<h3 id="react-예시"><a class="header" href="#react-예시">React 예시</a></h3>
<p>React 애플리케이션을 빌드할 때, JS 코드, SASS, 그 외 정적 파일들을 컴파일하기 위한 Node 환경이 필요하다. (특히 JSX) 만약 SSR을 적용하는 것이 아니라면, 프로덕션 빌드 상에는 굳이 Node 환경이 필요하지 않다. 때문에 아래 예시에서는 정적인 nginx 컨테이너에 정적 리소스들만을 복사해준다.</p>
<pre><code class="language-dockerfile"># syntax=docker/dockerfile:1
FROM node:12 AS build
WORKDIR /app
COPY package* yarn.lock ./
RUN yarn install
COPY public ./public
COPY src ./src
RUN yarn run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
</code></pre>
<p>위에서는 <code>node:12</code> 이미지를 사용해 빌드를 수행한 후, nginx 컨테이너에 그 결과를 복사해넣게끔 해주었다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ssh--secure-shell--secure-socket-shell"><a class="header" href="#ssh--secure-shell--secure-socket-shell">SSH : Secure Shell / Secure Socket Shell</a></h1>
<ul>
<li>참고문서 : <a href="https://medium.com/@Magical_Mudit/understanding-ssh-workflow-66a0e8d4bf65">Understanding SSH workflow</a></li>
</ul>
<h2 id="ssh란-"><a class="header" href="#ssh란-">SSH란 ?</a></h2>
<p>SSH는 관리자들이 원격 컴퓨터에 안전한 방법으로 접근할 수 있게끔 해주는 네트워크 프로토콜이다. SSH는 클라이언트와 서버 간에 보안된 연결을 형성하며, 서로 간에 증명하며 명령어를 전달할 수 있다.</p>
<h2 id="ssh는-어떻게-동작하는가"><a class="header" href="#ssh는-어떻게-동작하는가">SSH는 어떻게 동작하는가?</a></h2>
<p><img src="https://www.hostinger.com/tutorials/wp-content/uploads/sites/2/2017/07/symmetric-encryption-ssh-tutorial.jpg" alt="ssh_architecture" /></p>
<p>SSH 프로토콜은 정보의 전송을 안전하게 하기 위해 대칭 / 비대칭 암호화와 해싱을 사용한다. 클라이언트와 서버 간의 SSH 연결은 다음의 세 단계를 거친다.</p>
<ol>
<li>클라이언트에 의한 서버의 증명</li>
<li>모든 통신을 암호화하기 위한 세션 키 생성</li>
<li>클라이언트의 인증</li>
</ol>
<p>위의 세 단계에 대해서는 아래에서 살펴보자.</p>
<h3 id="1-서버의-증명"><a class="header" href="#1-서버의-증명">1. 서버의 증명</a></h3>
<p>클라이언트가 처음 서버와 SSH 연결을 실행한다. 서버는 기본적으로는 SSH 연결에 대해서 22번 포트(바뀔 수 있다)를 수신한다. 이 시점에서, 서버의 신원이 확인되는데, 두 가지 경우가 있다.</p>
<p><img src="https://miro.medium.com/max/1134/1*gnKOi4J8qq21gBdj99EXsg.png" alt="known_hosts" /></p>
<ol>
<li>만약 클라이언트가 서버에 처음으로 접속하는 것이라면, 클라이언트는 서버의 공개 키(퍼블릭 키 : Public key)를 검증함으로써 직접 인증해야 한다. 서버의 퍼블릭 키는 <strong><code>ssh-keyscan</code></strong> 커맨드를 통해서 확인하거나, 구글 등을 통해 살펴볼 수 있다. 일단 키가 증명되면, 클라이언트 측의 <code>~/.ssh</code> 디렉토리에 <code>known_hosts</code> 파일에 해당 서버를 추가한다. 이 <code>known_hosts</code>파일은 클라이언트에 의해 검증된 서버들에 대한 정보들을 담고 있다.</li>
<li>만약 클라이언트가 처음으로 서버에 접속하는 게 아니라면, 앞서 생성한 <code>known_hosts</code>파일에 기록된 정보들로 서버의 신원을 확인하며, 이를 인증에 사용한다.</li>
</ol>
<h3 id="2-세션-키-생성"><a class="header" href="#2-세션-키-생성">2. 세션 키 생성</a></h3>
<p>일단 서버가 인증되고 나면, 클라이언트와 서버 양측에서 <strong>Diffie-Hellman</strong> 알고리즘이라는 버전을 사용하여 세션 키를 협상한다. 해당 알고리즘은 세션 키 생성 시에 양측이 동등하게 기여할 수 있는 방식으로 설계된다. 생성된 세션키는 공유 대칭 키(Shared symmetirc key)이며, 다시 말해 동일한 키가 암호화와 복호화에 같이 사용된다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="tdd--test-driven-development"><a class="header" href="#tdd--test-driven-development">TDD : Test Driven Development</a></h1>
<h4 id="참고문서"><a class="header" href="#참고문서">참고문서</a></h4>
<ul>
<li><a href="https://medium.com/javascript-scene/tdd-changed-my-life-5af0ce099f80">TDD Changed My Life</a></li>
<li><a href="https://medium.com/javascript-scene/5-common-misconceptions-about-tdd-unit-tests-863d5beb3ce9">5 Common Misconceptions About TDD &amp; Unit Tests
</a></li>
</ul>
<h2 id="tdd-"><a class="header" href="#tdd-">TDD ?</a></h2>
<p><img src="https://cdn.shortpixel.ai/client/q_glossy,ret_img,w_1024/https://marsner.com/wp-content/uploads/test-driven-development-TDD.png" alt="tdd_process" />
프로세스 자체는 굉장히 심플하다.</p>
<ol>
<li>
<p>직접 코딩하기 전에, <strong>실패하는</strong> 테스트 코드를 작성해둔다. 이는 '정답'이 나오는 테스트들을 '양산하는' 것을 방지하기 위해서다.</p>
</li>
<li>
<p>코드를 작성하고, 테스트 코드를 통과하는지 확인한다.</p>
</li>
<li>
<p>필요하다면 리팩토링한다. 든든한 테스트코드를 작성했다면, '어디가 망가졌는지'를 파악할 수 있으므로, 리팩토링에 자신감을 갖자.</p>
</li>
</ol>
<h2 id="비효율적"><a class="header" href="#비효율적">비효율적?</a></h2>
<p><img src="https://miro.medium.com/max/875/1*9ZbCv6O3Sr7x6d3lt3uNRA.png" alt="two_states_of_programmer" /></p>
<p>나도 최근에 테스트 코드를 직접 작성해보면서, 이상과의 괴리감을 좀 느꼈다. 생각만큼 그 '테스트 코드'를 작성하는 것이 쉽지 않았다.</p>
<p>표면 상으로도, 이 또한 코드를 작성하는 것이기 때문에, 추가적인 코드를 위한, 추가적인 시간 소요가 필요하다. 코드를 테스트하기 위한 테스트 코드를 테스트 하기 위한 테스트... 같은 느낌으로 코드를 만들고 있는 내 모습을 볼 수 있었다.</p>
<p><strong>틀린 말은 아니다.</strong> 처음 테스트 코드를 작성할 때, 몇가지 노고를 겪는다.</p>
<ul>
<li>테스트 코드를 작성하는 법 자체</li>
<li>어떤 테스트를 추가해야 하는지</li>
</ul>
<p>결국, <strong>TDD도 러닝커브가 있다</strong>. 위 그림처럼 이상적인 프로세스로 보이는 것도, 실제로 해보려면 익숙해지기 위한 시간이 제법 되는 것이다. 한 작성자는 대략 15%-35% 정도 시간이 더 늘어난다고 말했다.</p>
<p>다만, 이것에 익숙해지기 시작하면, 마법같은 일이 일어나는데, 유닛테스트에 익숙해지면서 이전과는 비교가 안될 속도로 코드를 작성하는 것이다.</p>
<h2 id="수동-테스트"><a class="header" href="#수동-테스트">수동 테스트</a></h2>
<p>TDD라는 개념이고 뭐고, 테스트 코드란게 있는지 조차 몰랐을 적의 내 모습을 떠올려보자.</p>
<p>HTML/CSS, JS를 작성하면서, 제대로 됐는지 확인을 해야한다. 당시에 내가 할 수 있는 유일한 '테스트'는 새로고침을 하고, 직접 버튼을 눌러보고, <code>console.log</code>로 직접 상태를 확인하는 것이었다.</p>
<blockquote>
<p>코드 바꾸고, 저장하고, 새로고침하고, 클릭하고, 기다렸다가, 어 안되네, <code>console.log</code>달고, 바꾸고, 저장하고, 아 이것도 안되네.... 콤보</p>
</blockquote>
<p>내가 건들고 있는 부분이 비록 한 두 페이지에 불과하고, 변경과 컴파일에 얼마 걸리지 않는다면, 이는 전혀 문제될 게 없다. 근데, 앞으로 우리가 건드리게 될 것들이 그렇게 쉬운 문제들일까?? 버튼 한두개 만들고, 아이콘 한두개 띄우고...??</p>
<p>결국, 이런 테스트의 대상이 많아지면 많아질수록, 저런 식의 테스트는 비효율 그 자체가 되어버리고, 심지어는 리팩토링을 하거나 기능을 추가하는 과정에서 기존에 됐던 것이 안되거나 하는 일이 일어나도 전혀 인지하지 못하는 일이 생긴다.</p>
<h2 id="테스트코드의-마법"><a class="header" href="#테스트코드의-마법">테스트코드의 마법</a></h2>
<pre><code class="language-js">describe('clipReducer/setClipStopTime', async (assert) =&gt; {
  const stopTime = 5;
  const clipState = {
    startTime: 2,
    stopTime: Infinity,
  };
  assert({
    given: 'clip stop time',
    should: 'set clip stop time in state',
    actual: clipReducer(clipState, setClipStopTime(stopTime)),
    expected: { ...clipState, stopTime },
  });
});
</code></pre>
<p>이 코드를 보면 무슨 생각이 드는가? <strong>테스트 한번 하겠다고 너무 코드를 길게 써야하는 것 아닌가??</strong> 싶을 수도 있겠다. 근데 그게 바로 요점이다. 이 테스트 코드는 일종의 <strong>명세서</strong>같은 개념이다. 이렇게 문서화되어있는 대로 코드를 동작시키겠다는 일종의 증명이고, 그것이 있는 한, <strong>내가 제대로 테스트했는지</strong>에 대한 염려 자체를 할 필요가 없어진다.</p>
<p>결국 테스트 코드를 쓰는데 얼마나 오래걸렸는지가 중요한 것이 아니다. <strong>뭔가 잘못되었을때, 그것을 디버깅하기 위해 얼마나 걸리는지</strong>가 중요한 것이지. 위 코드가 제대로 동작하지 않으면, 그 테스트 자체가 훌륭한 버그 리포트가 된다. 테스트 코드를 살펴보는 것만으로 어디가 문제인지를 알 수 있게 된다.</p>
<h2 id="tdd는-더-나은-코드-작성법을-알려준다"><a class="header" href="#tdd는-더-나은-코드-작성법을-알려준다">TDD는 더 나은 코드 작성법을 알려준다</a></h2>
<p>유닛테스트를 작성할 때 중요한 것은, 테스트하고자 하는 부분 이외의 것들과는 완전히 독립적이어야한다는 점이다. 예를 들어, 상태 관리에 대해 테스트를 하고자 한다면 별도로 스크린을 띄우거나 데이터베이스에 어떤 동작을 하지 않고 테스트를 할 수 있어야 한다. UI를 테스트한다면 브라우저에 페이지를 로딩하거나 네트워크를 건들지 않고도 테스트할 수 있어야 한다.</p>
<p>TDD는 가능한한 UI 컴포넌트들을 작게 유지함으로써 훨씬 간편해진다는 점을 알려준다. UI와 비즈니스 로직, 사이드이펙트들을 구분지어 생각하자. 이는 React 등의 라이브러리를 사용할 때도, 디스플레이를 담당하는 컴포넌트와 컨테이너 컴포넌트들을 구분지어 사용하기 쉽게 만들어준다.</p>
<p>모든 소프트웨어 개발은 **구성(Composition)**이다. 커다란 문제들을 작고 해결이 쉬운 많은 문제들로 분해하고, 그 문제들에 대한 해결책들을 만들어 애플리케이션을 만들어간다.</p>
<p>유닛테스트에서의 <strong>모킹</strong>은 이렇게 구성된 애플리케이션의 구성이 실제로 그렇게 범접 못할 정도로 긴밀하게 뭉쳐져있지 않다는 것을 알려주며, 어떻게 하면 그 '분리점'을 발견해낼 수 있는지를 알려준다.</p>
<h2 id="tdd에-대한-5가지-오해"><a class="header" href="#tdd에-대한-5가지-오해">TDD에 대한 5가지 오해</a></h2>
<ol>
<li>
<p>TDD는 시간 낭비다. 경영팀에서 절대 허용해줄 리가 없다.</p>
</li>
<li>
<p>디자인을 알기 전에는 테스트를 작성할 수 없다 &amp; 코드를 실행시켜보기 전까진 그 디자인을 알 수 없다.</p>
</li>
<li>
<p>코드를 실행하기 전에 모든 테스트를 작성해야만 한다.</p>
</li>
<li>
<p>Red, Green 이후 <strong>항상</strong> 리팩토링한다.</p>
</li>
<li>
<p>모든 것에 유닛테스트가 필요하다.</p>
</li>
</ol>
<h2 id="모든-유닛테스트가-갖춰야-하는-5가지-질문"><a class="header" href="#모든-유닛테스트가-갖춰야-하는-5가지-질문">모든 유닛테스트가 갖춰야 하는 5가지 질문</a></h2>
<ol>
<li>무엇을 테스트하는 중인가?(모듈 / 함수 / 클래스 / 뭐든)</li>
<li>그것이 무엇을 해야 하는가? (설명: description)</li>
<li>실제로 나온 결과가 무엇인가?</li>
<li>예상했던 결과는 무엇인가?</li>
<li>어떻게 '실패'를 만들어 낼 수 있는가?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h1>
<p>함수형 프로그래밍(Functional Programming)은 예전부터 들어왔지만, 그 자체로 되게 애매한 지식으로 내게 자리잡고 있었다.</p>
<p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">여기</a>의 문서를 살펴보면서 함수형 프로그래밍에 대한 개념을 잡고 가려고 한다.</p>
<hr />
<p>FP는 다음과 같은 방식을 통해 소프트웨어를 만들어나가는 과정이다.</p>
<ul>
<li>순수 함수의 합성(compose) 기반</li>
<li>공유 상태 / mutable 데이터 / 사이드 이펙트를 모두 회피</li>
<li>명령형 보다는 선언형</li>
<li>웹의 측면에서 보자면 순수함수들을 통한 상태 관리를 지향</li>
</ul>
<p>이는 일반적으로 앱의 상태가 공유되고, 객체 메서드와 동일시되는 OOP와는 대조적인 성향을 띤다.</p>
<p>함수형 코드는 OOP 및 명령형 코드보다 명확하고, 예측가능하고, 테스트하기 쉽다.</p>
<p>사실, JS를 통해 프로그래밍을 해왔다면, 함수형 프로그래밍의 컨셉과 기능들을 본인도 모르는 사이에 적용해왔을 가능성이 높다.</p>
<h2 id="왜-어렵게-들릴까"><a class="header" href="#왜-어렵게-들릴까">왜 어렵게 들릴까?</a></h2>
<p><strong>함수형 프로그래밍</strong>은 뭔가 거창하게 들린다. 생소한 단어들이 여기저기 있기 때문이다.</p>
<ul>
<li>순수 함수 (Pure func.)</li>
<li>합성 함수 (Function Composition)</li>
<li>공유 상태 방지</li>
<li>Mutationg 상태 방지</li>
<li>사이드 이펙트 방지</li>
</ul>
<h2 id="순수-함수"><a class="header" href="#순수-함수">순수 함수</a></h2>
<p>동일한 입력이 있으면, 결과도 항상 동일하다</p>
<p>사이드 이펙트가 없다</p>
<h2 id="합성-함수"><a class="header" href="#합성-함수">합성 함수</a></h2>
<p>둘 이상의 함수들을 합쳐 새로운 작업을 수행하는 함수다.</p>
<h2 id="공유-상태"><a class="header" href="#공유-상태">공유 상태</a></h2>
<p>공유 상태는 공유 영역에 존재하는 변수, 객체, 메모리 공간들을 의미한다.</p>
<p>공유 상태가 갖는 문제점은, 단순히 함수의 실행 순서가 달라졌음에도 그 결과가 달라질 수 있다는 점에서 온다.</p>
<pre><code class="language-js">// With shared state, the order in which function calls are made
// changes the result of the function calls.
const x = {
  val: 2,
};

const x1 = () =&gt; (x.val += 1);

const x2 = () =&gt; (x.val *= 2);

x1();
x2();

console.log(x.val); // 6

// This example is exactly equivalent to the above, except...
const y = {
  val: 2,
};

const y1 = () =&gt; (y.val += 1);

const y2 = () =&gt; (y.val *= 2);

// ...the order of the function calls is reversed...
y2();
y1();

// ... which changes the resulting value:
console.log(y.val); // 5
</code></pre>
<p>이를 회피하기 위해, 앞서 나온 개념들인 순수함수, 합성함수들을 활용함과 더불어 공유 상태를 회피한다.</p>
<pre><code class="language-js">const x = {
  val: 2,
};

const x1 = (x) =&gt; Object.assign({}, x, { val: x.val + 1 });

const x2 = (x) =&gt; Object.assign({}, x, { val: x.val * 2 });

console.log(x1(x2(x)).val); // 5

const y = {
  val: 2,
};

// Since there are no dependencies on outside variables,
// we don't need different functions to operate on different
// variables.

// this space intentionally left blank

// Because the functions don't mutate, you can call these
// functions as many times as you want, in any order,
// without changing the result of other function calls.
x2(y);
x1(y);

console.log(x1(x2(y)).val); // 5
</code></pre>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p><strong>불변성</strong>은 일단 생성되고 난 후에는 수정될 수 없는 성질을 의미한다.</p>
<p>단순히 <code>const</code>로 변수를 선언하는 것과 헷갈리지 말아야 한다.</p>
<h2 id="side-effects"><a class="header" href="#side-effects">Side Effects</a></h2>
<p>사이드 이펙트는 함수의 실행 이후 반환되는 값이 아닌 다른 부분에서 상태 변화가 생기는 경우다.</p>
<p>사이드 이펙트를 유발하는 동작들은 소프트웨어에서 별도로 관리되어야 하며, 프로그래밍 로직에 직접적으로 관련되어선 안된다.</p>
<p>앞선 과정이 이루어지면, 소프트웨어의 확장, 리팩토링, 디버깅, 테스트 및 유지보수가 훨씬 수월해진다.</p>
<p>때문에 많은 프론트엔드 프레임워크들이 느슨하게 결합된 모듈을 통해 상태를 관리하고, 컴포넌트를 렌더링하게끔 유도한다.</p>
<h2 id="고차-함수를-통한-재사용성"><a class="header" href="#고차-함수를-통한-재사용성">고차 함수를 통한 재사용성</a></h2>
<p>함수형 프로그래밍에서는 어떤 종류의 데이터든 동일하게 취급된다.</p>
<p><code>map()</code> 메서드는 매개변수로 함수를 사용하기 때문에, 어떤 종류의 값이든 매핑을 할 수 있다.</p>
<p>JS는 1등급 함수를 갖는다. 이는 함수를 데이터로 다룰 수 있게 하며, 매개변수로 지정할 수도 있고, 인수로 전달될 수도 있고, 함수 자체가 반환될 수도 있다.</p>
<p>결국, 고차 함수란 함수를 매개변수로 받거나, 함수를 반환하는 함수로 여겨질 수 있다. 이들을 종종 다음과 같은 역할을 할 수 있다.</p>
<ul>
<li>콜백, 프로미스 등을 통해 이벤트 핸들링이나 비동기 로직을 처리한다.</li>
<li>다양한 데이터 타입에 폭넓게 적용할 수 있는 유틸 함수를 만든다</li>
<li>Partial Application 및 Currying</li>
<li>함수의 리스트를 받아 이들 함수들의 합성함수를 반환</li>
</ul>
<h2 id="선언형-vs-명령형"><a class="header" href="#선언형-vs-명령형">선언형 vs 명령형</a></h2>
<p>함수형 프로그래밍은 선언형이며, 이는 프로그램 로직이 내부적인 흐름을 설명하지 않고 표현되는 하나의 패러다임이다.</p>
<p>명령형 프로그래밍은 원하는 결과를 얻기 위한 순차적인 방법을 코드에 작성하며, <strong>어떻게 처리하는가</strong>를 주로 코드에 작성한다.</p>
<p>선언형 프로그래밍은 어떻게 이를 얻는지보다는 <strong>무엇을 하는가</strong>를 명시하는 코드를 주로 작성한다. 짧은 예시를 보자.</p>
<p>아래는 명령형 프로그래밍으로, 함수 실행을 통해 각 배열에 2를 곱한 결과를 얻고자 한다.</p>
<pre><code class="language-js">const doubleMap = (numbers) =&gt; {
  const doubled = [];
  for (let i = 0; i &lt; numbers.length; i++) {
    doubled.push(numbers[i] * 2);
  }
  return doubled;
};

console.log(doubleMap([2, 3, 4])); // [4, 6, 8]
</code></pre>
<p>아래는 선언형 프로그래밍으로, 앞의 코드와 동일한 역할을 하지만, <code>map</code> 메서드를 통해 각각의 값에 2를 곱하는 과정을 추상화하여 훨씬 데이터의 흐름을 명확하게 나타낸다.</p>
<p>결국, 명령형 프로그래밍은 Statement를 위주로 작성되는 코드에 해당한다. Statement는 일정한 액션을 수행하는 코드 조각들이며, <code>for</code>, <code>if</code>, <code>switch</code>, <code>throw</code>, 등이 이에 해당한다고 볼 수 있다.</p>
<p>반면, 선언형 프로그래밍은 Expression에 더 많이 의존한다. Expression은 어떤 값을 나타내는 코드 조각들이다. 일반적으로 결과 값을 생성하기 위해 함수 호출, 값 또는 연산자들의 조합들이다.</p>
<h2 id="결론-1"><a class="header" href="#결론-1">결론</a></h2>
<p>함수형 프로그래밍은 다음을 선호하는 패러다임이다.</p>
<ul>
<li>공유 상태 &amp; 사이드 이펙트 대신에 순수함수</li>
<li>불변(Immutable) 데이터를 활용</li>
<li>명령형 흐름보다는 합성 함수</li>
<li>고차 함수를 통해 여러 종류의 데이터 타입에 폭넓게 재사용될 수 있는 유틸함수</li>
<li>명령형보다 선언형 (어떻게 하는지보다 무엇을 하는지에 초점)</li>
<li>Statement보다 Expression</li>
<li>다형성(Polymorphism)보다는 컨테이너와 고차함수</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="reactive-programming"><a class="header" href="#reactive-programming">Reactive Programming</a></h1>
<p>해당 문서는 <a href="https://medium.com/@kevalpatel2106/what-is-reactive-programming-da37c1611382">여기</a>의 내용을 번역 및 참조한 것입니다.</p>
<h2 id="왜-우리는-비동기적인-작업을-필요로-할까요"><a class="header" href="#왜-우리는-비동기적인-작업을-필요로-할까요">왜 우리는 비동기적인 작업을 필요로 할까요?</a></h2>
<p>간단한 대답은 바로 <strong>이용자 경험을 향상시키기 위해서</strong>입니다. 우리들은 애플리케이션을 더 반응성이 뛰어나게 만들고 싶어합니다. 다시 말해 메인 쓰레드를 멈추도록 하지 않고 더 부드러운 이용자 경험을 제공하고 싶어하죠.</p>
<p>메인 쓰레드를 자유롭게 유지하기 위해서는, 비용 소모가 많은 작업들에 대해서는 백그라운드를 통해 처리하도록 할 필요가 있습니다. 또, 무겁고 연산이 복잡한 작업들에 대해서는 서버를 통해 처리해야할 필요가 있죠. 이런 경우에도 네트워크 작업을 위해서 비동기적인 처리가 요구됩니다.</p>
<h2 id="그래서-반응형-프로그래밍은-뭘까요"><a class="header" href="#그래서-반응형-프로그래밍은-뭘까요">그래서 반응형 프로그래밍은 뭘까요?</a></h2>
<p>반응형 프로그래밍은 데이터의 흐름과 변경의 전파를 중심으로 하는 프로그래밍 패러다임입니다. 이는 정적 또는 동적인 데이터 흐름을 쉽게 표현할 수 있고, 그에 따라 그 아래 놓인 실행 모델이 데이터 흐름을 통해 변경 사항을 자동으로 전파한다는 것을 의미합니다.</p>
<p>쉽게 말해서, 반응형 프로그래밍에서는 한 컴포넌트에 의해 데이터 흐름이 실행되고, 실행 모델이 해당 데이터 변화를 받게끔 등록한 다른 컴포넌트로 변경사항을 전파하도록 합니다.</p>
<p>아래에서는 Rx에서 사용되는 3가지 포인트에 대해 이야기해봅시다.</p>
<blockquote>
<p><strong>RX = OBSERVABLE + OBSERVER + SCHEDULERS</strong></p>
</blockquote>
<ul>
<li>
<p><strong>Observable</strong> : Observable은 대단할게 없는 데이터 스트림입니다. 이는 데이터를 한 쓰레드에서 다른 쓰레드로 넘겨질 수 있도록 데이터를 감쌉니다. 이들은 기본적으로 구성에 따라 주기적으로 또는 수명 주기에 한번 데이터를 내보냅니다. 당장에는, 해당 Observable을 일종의 &quot;공급자&quot;라고 생각하시면 됩니다. 이들은 데이터를 다른 컴포넌트에 처리하고 공급합니다.</p>
</li>
<li>
<p><strong>Observers</strong> : Observer는 Observable에서 내보낸 데이터 스트림을 소비합니다. Observer는 observer를 <code>subscribeOn()</code>을 통해 구독하며, Observable가 내보낸 데이터를 전달받습니다. Observable이 데이터 스트림을 내보낼 때마다, 등록된 모든 Observer가 <code>onNext()</code>콜백을 통해 데이터를 넘겨받습니다. 이 시점에서 JSON 응답을 파싱하거나, UI를 업데이트 하는 등의 다양한 작업을 수행할 수 있습니다. 반면 에러가 발생하는 경우에는 <code>onError()</code> 콜백을 통해 처리할 수 있습니다.</p>
</li>
<li>
<p><strong>Schedulers</strong> : 기본적으로 반응형 프로그래밍은 비동기적인 프로그래밍을 위한 것이고, 우리는 쓰레드 관리가 필요합니다. Rx 상에서 Scheduler란 Observable과 Observer에게 어떤 쓰레드를 실행해야 하는지에 대해 알려주는 역할을 합니다. <code>observeOn()</code> 메서드를 통해 어떤 쓰레드가 observe를 수행해야 하는지에 대해 처리해줄 수 있습니다.</p>
</li>
</ul>
<h2 id="애플리케이션에서-rx를-사용하는-간단한-3단계"><a class="header" href="#애플리케이션에서-rx를-사용하는-간단한-3단계">애플리케이션에서 Rx를 사용하는 간단한 3단계</a></h2>
<img src="https://miro.medium.com/max/1400/1*-N6sUYNrO615PQCeKtP0Kw.png" />
<ol>
<li>데이터 스트림을 내보낼 Observable을 생성</li>
<li>해당 데이터를 소비할 Observer를 생성</li>
<li>동시성 관리</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="machine-learning"><a class="header" href="#machine-learning">Machine Learning</a></h1>
<p>해당 문서는 <a href="https://developers.google.com/machine-learning/">여기</a>의 내용을 따라가기 위한 과정입니다.</p>
<p>이는 번역 작업에 중점을 둔 것이 아니라, 어디까지나 제 개인적인 학습을 위한 것으로, 중간중간에 생략 및 의역된 내용들이 다수 포함될 확률이 높습니다. 이에 참고바랍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="problem-framing"><a class="header" href="#problem-framing">Problem Framing</a></h1>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Process.svg?hl=ko" />
<p>해당 섹션의 목표는 다음과 같습니다.</p>
<ul>
<li>일반적인 ML 용어의 정의</li>
<li>ML을 사용하는 상품과 각각에서 쓰이는 ML 문제 해결의 일반적인 방식</li>
<li>ML로 특정 문제를 해결할 수 있는지를 구분</li>
<li>다른 프로그래밍 방식과 ML의 비교 및 대조</li>
<li>ML 문제들에 대한 가설 검증과 과학적 방법</li>
<li>ML 문제 해결에 대한 이야기</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="common-ml-problems"><a class="header" href="#common-ml-problems">Common ML Problems</a></h1>
<p>일반적인 관점에서, 머신 러닝이란 <strong>모델</strong>이라 불리는 하나의 소프트웨어를 훈련시키는 과정입니다. 모델은 데이터 셋을 사용해 유용한 예측을 수행합니다.</p>
<p>종종, 사람들은 머신러닝을 <em>지도학습</em>과 <em>비지도학습</em>이라는 두가지 패러다임으로 구분합니다. 하지만, 실제로 머신러닝은 이 두가지 학습 방식이 복합적으로 어우러진다고 보는 편이 더 정확합니다. 여기서는 간단함을 위해, 좀 더 양쪽에 극단적인 케이스를 다루고자 합니다.</p>
<h2 id="지도-학습"><a class="header" href="#지도-학습">지도 학습</a></h2>
<p>지도 학습은 <strong>label</strong>처리된 트레이닝 데이터들을 제공받는 머신러닝의 유형입니다.</p>
<p>예를 들어, 아래와 같은 식물들의 데이터를 통해, 각 식물이 어떤 종에 속하는지를 맞추는 것과 같죠.</p>
<table>
<thead>
<tr>
<th>Leaf Width</th>
<th>Leaf Length</th>
<th>Species</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.7</td>
<td>4.9</td>
<td>small-leaf</td>
</tr>
<tr>
<td>3.2</td>
<td>5.5</td>
<td>big-leaf</td>
</tr>
<tr>
<td>2.9</td>
<td>5.1</td>
<td>small-leaf</td>
</tr>
<tr>
<td>3.4</td>
<td>6.8</td>
<td>big-leaf</td>
</tr>
</tbody>
</table>
<p>여기서 잎의 너비와 길이는 <strong>Features</strong>입니다. 그리고 우리가 맞추어야 하는 종(Species)는 곧 <strong>Label</strong>이 되죠. 아마 실제로는 훨씬 더 많은 Feature들이 존재할테지만, 여전히 Label은 한개일겁니다. 그리고, 이 Label이란 개념은 반드시 &quot;정답&quot;과 같은 느낌으로, 명확해야 합니다.</p>
<p>위에서는 단순히 4개의 예시만 다루었지만, 실제로는 훨씬 더 많은 데이터가 존재할 겁니다. 만약 데이터셋이 다음과 같은 그래프를 그려낸다고 생각해봅시다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph1.svg?hl=ko">
<p>지도학습에서는, 각 데이터셋의 케이스에 대한 Feature와 Label들을 알고리즘에 전달하는 <strong>Training</strong>이라 불리는 과정을 거칩니다. 이러한 과정 속에서, 알고리즘은 점차적으로 Feature들과 Label 간의 상관관계를 파악하게 되며, 이러한 상관관계가 곧 <strong>모델</strong>이 됩니다. 머신러닝에서 대부분 이러한 모델은 굉장히 복잡한 형태지만, 당장에는 다음과 같이 선 하나로 표현될 수 있는 모델이 있다고 하겠습니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph2.svg?hl=ko">
<p>이제 모델은 난생 처음보는 케이스들에 대해서 나름의 예측을 할 수 있게 됩니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph3.svg?hl=ko">
<h2 id="비지도-학습"><a class="header" href="#비지도-학습">비지도 학습</a></h2>
<p>비지도 학습에서의 목표는 데이터 내에 존재하는 <strong>의미있는 패턴</strong>을 발견하는 것입니다. 이를 위해서 기계는 별도의 Label이 존재하지 않는 데이터로부터 배워야합니다. 다시 말해, 모델은 각 데이터 조각들을 어떻게 분류해나가고, 어떻게 처리되어야 하는지에 대한 별도의 힌트를 전달받지 못합니다.</p>
<p>아래 그래프에는 별도의 Label이 없습니다. 그렇기 때문에 모두 초록색 동그라미로 표기됩니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph4.svg?hl=ko" />
<p>이처럼 Label이 없는 데이터셋에 아래와 같이 선을 긋는 것은 무의미합니다. 여전히 줄의 양쪽에는 동일한 초록 동그라미들이 있을 뿐입니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph5.svg?hl=ko" />
<p>한번 다르게 접근해봅시다. 여기 두 <strong>Cluster</strong>(군집)이 있습니다. 이 군집들은 무엇을 나타낼까요? 아마 대답하기는 어려울겁니다. 때때로 모델은 우리가 배우지 않기를 바라는 데이터에 대한 패턴을 찾아내기도 합니다. 스테레오타입(Stereotypes)과 편향(Bias)같은 것들이죠.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph6.svg?hl=ko" />
<p>그럼에도 부룩하고, 새로운 데이터가 나타났을 때, 그것이 현재 알고 있는 군집에 적합한 데이터라면 우리는 쉽게 이를 분류할 수 있습니다. 그런데, 만약 우리가 난생 처음 보는 군집에 해당하는 데이터라면 어떨까요?</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph7.svg?hl=ko" />
<blockquote>
<p>참고 : 사실, 클러스터링(군집화)는 비지도 학습의 유일한 형태가 아닙니다. 비지도 학습에는 여러 유형이 있고, 군집화는 그 중 가장 일반적인 방식일 뿐입니다.</p>
</blockquote>
<h3 id="강화-학습"><a class="header" href="#강화-학습">강화 학습</a></h3>
<p>머신 러닝의 추가적인 갈래로 강화 학습(Reinforcement Learning)이 있습니다. 이는 머신러닝의 다른 유형들과 구분됩니다. 기본적으로 이는 Label을 가진 데이터를 수집하지 않습니다. 만약 기계에게 정말 간단한 비디오게임을 플레이하게 만들고, 절대 지지 않게끔 가르치려고 한다고 해봅시다. 이는 기계에게 게임을 하되, 게임오버에 도달하지 말라고 말하는 것과 같습니다. 기계는 학습 중에 <strong>reward</strong> 함수라 불리는 것을 통하여 각 태스크에 대한 보상을 전달받습니다. 강화 학습을 거치면서, 이들은 실제로 사람을 뛰어넘는 수준으로 빠르게 학습할 수도 있습니다.</p>
<p>기본적으로 강화 학습은 수많은 데이터를 요구하지 않습니다. 그러나 좋은 reward 함수를 디자인하는 것은 어려우며, 그렇기 때문에 지도 학습보다 덜 안정적이고, 예측이 어렵습니다. 추가적으로, 기계가 게임과 같은 것들을 플레이 해나가며 상호작용을 통해 데이터를 생산해나갈 방법 자체도 고려해야합니다. 만약, 우리가 실 생활에서나, 혹은 VR 세계에서 강화학습을 적용해나가고자 한다면, 대단히 어려운 과정이 될 것입니다. 강화 학습도 머신러닝 분야에서 굉장히 활발하게 연구되고 있으나, 여기에서는 별도로 자세히 알아보지는 않도록 하겠습니다.</p>
<h2 id="머신러닝-문제의-유형"><a class="header" href="#머신러닝-문제의-유형">머신러닝 문제의 유형</a></h2>
<p>머신러닝 문제는 <em>예측이 어떤 식으로 이루어지느냐</em>에 따라 여러가지로 구분됩니다. 아래는 일반적인 지도/비지도 학습의 예시들을 다루고 있습니다.</p>
<table class="blue">
  <tbody><tr><th>Type of ML Problem</th><th>Description</th><th>Example</th></tr>
  <tr>
    <td>Classification</td>
    <td>Pick one of N labels</td>
    <td>Cat, dog, horse, or bear</td>
  </tr>
    <tr>
    <td>Regression</td>
      <td>Predict numerical values</td>
      <td>Click-through rate</td>
  </tr>
    <tr>
    <td>Clustering</td>
      <td>Group similar examples</td>
      <td>Most relevant documents (unsupervised)</td>
  </tr>
   <tr>
    <td>Association rule learning</td>
      <td>Infer likely association patterns in data</td>
      <td>If you buy hamburger buns, you're likely to buy hamburgers
        (unsupervised)</td>
  </tr>
    <tr>
    <td>Structured output</td>
      <td>Create complex output</td>
      <td>Natural language parse trees, image recognition bounding boxes</td>
  </tr>
      <tr>
    <td>Ranking</td>
      <td>Identify position on a scale or status</td>
      <td>Search result ranking</td>
  </tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="the-ml-mindset"><a class="header" href="#the-ml-mindset">The ML Mindset</a></h1>
<blockquote>
<p><em>머신러닝은 당신이 문제에 대해 생각하는 방법을 바꿉니다. 문제의 초점이 수학에서 자연과학으로 옮겨가면서 논리가 아닌, 실험과 통계에 기반하게 됩니다.</em> - Perter Norvig</p>
</blockquote>
<p>전통적인 방식의 소프트웨어 엔지니어링은 요구사항으로부터 실행가능한 디자인까지 추론해낼 수 있습니다. 그러나 머신러닝에서는, 실행가능한 모델을 찾기 위해서 실험이 필수적입니다.</p>
<p>많은 머신러닝 시스템은 인간과 다르게 신호를 해석함으로서 지식과 지능을 인코딩하는 모델을 만듭니다. Neural Network(인공신경망, 이하 NN)는 임베딩을 통해 단어를 해석할 수도 있을 겁니다. 예를들어, &quot;tree&quot;는 <code>[0.37, 0.24, 0.2]</code>, &quot;car&quot;는 <code>[0.1, 0.78, 0.9]</code>와 같은 식으로 해석될 것입니다. NN은 이러한 결과를 번역이나 감정 분석등에 사용할 수 있겠지만, 이는 사람이 봤을 때에는 도무지 이해할 수 없는 형태일 것입니다. 이러한 부분들이 기계 입장에서의 지능을 인간 입장에서 상당히 이해하고 평가하기 어렵게 만듭니다. 아예 불가능하지는 않겠지만요.</p>
<p>모델은 왜곡된 교육 데이터부터 시작해, 예상치 못한 해석에 이르기까지, 여러가지 디버깅하기 어려운 실수들을 범합니다. 게다가, 이를 실제 제품에 적용하려면, 상호작용이 훨씬 복잡해질테고, 이런 이유로 가능한 모든 상황을 예측하고 테스트하는 것이 어려울 수 있습니다. 이러한 문제들을 해결하기 위해 제품을 담당하는 팀이 머신러닝 시스템의 기능과 개선 방법을 이해하는 데에 많은 시간을 투자하는 것이 필요합니다.</p>
<h2 id="experimental-design-primer"><a class="header" href="#experimental-design-primer">Experimental Design Primer</a></h2>
<h3 id="어느-정도의-불확실성에-대해서는-익숙해지세요"><a class="header" href="#어느-정도의-불확실성에-대해서는-익숙해지세요">어느 정도의 불확실성에 대해서는 익숙해지세요.</a></h3>
<p>단순히 문제를 다르게 생각하는 것을 넘어, ML의 구현은 기존의 프로그래밍 방식과는 다릅니다. 전통적인 방식에서의 프로그래밍은 매개변수를 설정하고 모든 것이 어떻게 동작하는지에 대해 개발자가 이해할 수 있습니다. 허나 ML에서는, 일반적으로 훨씬 더 적은 양의 코드를 작성하지만, 코딩 이외의 작업이 매우 복잡할 수 있습니다.</p>
<p>사용가능한 모델만 만들고 끝내고 싶다고요? 이런 생각은 처음부터 글러먹었습니다.</p>
<h3 id="과학적-방법론"><a class="header" href="#과학적-방법론">과학적 방법론</a></h3>
<p>ML로 전환하는 문제를 해결하기 위해서, ML 프로세스는 테스트에 테스트를 거듭하여 실행 가능한 모델에 수렴해나가기 위한 실험 과정으로 이해하면 도움이 됩니다. 마치 실험과도 같이, 그 과정은 흥미롭고 도전적이고, 궁극적으로 가치있을겁니다.</p>
<table label="Steps of the Scientific Method with examples.">
  <tbody><tr><th>Step</th><th>Example</th></tr>
  <tr><td>1. 연구 목표 설정</td><td>주어진 날짜에 교통 체증이 얼마나 발생할지를 예측하고 싶다.</td></tr>
  <tr><td>2. 가설 세우기</td><td>아마 일기 예보가 좋은 정보가 될 것 같은데?</td></tr>
  <tr><td>3. 데이터 수집</td><td>각 날짜의 교통과 날씨 정보를 수집한다.</td></tr>
  <tr><td>4. 가설을 테스트한다.</td><td>수집한 데이터로 모델을 훈련시킨다.</td></tr>
  <tr><td>5. 결과를 분석한다.</td><td>지금보다 더 좋은 모델이 나올 수 있을까?</td></tr>
  <tr><td>6. 결론을 도출한다.</td><td>X, Y, Z 때문에, 이 모델을 사용해야(하지 말아야) 한다.</td></tr>
  <tr><td>7. 새로운 가설을 세우고 다시 반복한다.</td><td>1년을 기준으로 본 시간이 의미가 있을 수도 있어!</td></tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="identifying-good-problems-for-ml"><a class="header" href="#identifying-good-problems-for-ml">Identifying Good Problems for ML</a></h1>
<p>해당 섹션에서는 좋은 ML 문제들의 특징에 대해서 살펴봅니다.</p>
<h2 id="명확한-유스-케이스-use-case"><a class="header" href="#명확한-유스-케이스-use-case">명확한 유스 케이스 (Use Case)</a></h2>
<blockquote>
<p><em>해답이 아니라, 문제부터 시작하세요. ML 하나로 모든 문제들을 뚝딱 해결할거라 생각하지 마세요.</em></p>
</blockquote>
<p>전통적인 프로그래밍 방식으로 해결하기 어렵다고 생각하는 문제를 들여다봅시다. 예를 들어, <a href="https://ai.googleblog.com/2017/05/efficient-smart-reply-now-for-gmail.html">Smart Reply</a>같은 것이죠.</p>
<p>이러한 시스템들은 기존의 프로그래밍으로는 명확한 접근 방식을 생각해낼 수 없습니다. 반면에 ML을 통해서 여러 데이터들 간의 패턴을 파악하고 적용하면서 이런 문제들을 해결해낼 수 있죠. ML은 도구함 속 한가지 도구로 생각하는 것이 맞습니다. 오직 적절한 상황에서만 사용하는 그런 도구일 뿐이죠.</p>
<p>ML이 필요한지에 대해 파악하기 위해서는 다음과 같은 질문들에 대해 스스로 생각해볼 필요가 있습니다.</p>
<ol>
<li>현재 내가 무엇인가 만들던 도중 마주친 문제가 무엇인가?</li>
<li>그것이 ML로 해결하기에 적합한 문제인가?</li>
</ol>
<h2 id="데이터에-집중하기-이전에-문제부터-파악하라"><a class="header" href="#데이터에-집중하기-이전에-문제부터-파악하라">데이터에 집중하기 이전에 문제부터 파악하라</a></h2>
<blockquote>
<p><em>본인이 세운 가정이 틀릴 상황에 대해 준비하세요.</em></p>
</blockquote>
<p>어떤 문제를 명확하게 이해했다면, 최상의 모델을 만들기 위해 몇가지 잠재적인 솔루션을 세워볼 수 있을겁니다. 제대로 동작하는 모델을 만들기 전에는 몇가지 솔루션들을 시도해봐야 할 것입니다.</p>
<p>탐색적 데이터 분석(EDA)은 데이터를 이해하는 데는 도움이 될 수 있지만, 이전에 보지 못했던 데이터에 대해서도 동일한 패턴이 일반적으로 발생한다는 것을 직접 확인하기 전에는 이에 대해 확신할 수 없습니다. 이러한 부분을 정확하게 체크하지 않으면, 스테레오타입(고정관념)과 바이어스(편향)에 빠질 수 있다는 점을 주의하세요.</p>
<h2 id="본인-팀의-로그에-의존하세요"><a class="header" href="#본인-팀의-로그에-의존하세요">본인 팀의 로그에 의존하세요.</a></h2>
<blockquote>
<p><em>ML은 수많은 데이터들을 필요로 합니다.</em></p>
</blockquote>
<p>애초에 ML 작업을 위해 특별한 형태로 수집된 데이터가 가장 유용합니다. 하지만, 실제 상황에서는 이러한 형태로 이루어지기 어려울 수 있으며, 그런 경우 가깝게 위치한 모든 데이터에 의존해야 합니다. 비용과 제품 로그 등에 대해 알고 있다면, 이를 통해 더 적합할 모델을 구축할 수 있습니다.</p>
<p><em>얼마나 많이요?</em> 그것은 해결하고자 하는 문제에 따라 다릅니다. 그러나 일반적으로 모델은 더 많은 데이터를 활용할 수록 더 좋은 예측을 할 수 있습니다. 기본적인 선형 모델의 경우 적어도 수천 개의 예시를, 신경망의 경우에는 수십 만개의 예시를 갖는 것이 일반적으로 좋습니다. 이 정도의 데이터를 모을 수 없는 상황이라면, ML이 아닌 솔루션을 우선적으로 고려할 필요가 있습니다.</p>
<h2 id="예측력"><a class="header" href="#예측력">예측력</a></h2>
<blockquote>
<p><em>Feature들은 예측력을 포함하고 있습니다.</em></p>
</blockquote>
<p>경마에서 어떤 말이 좋은 성적을 보일지 예측하는 모델을 만들고 싶다고 합시다. 여기서 우리는 말의 눈 색깔을 Feature로 사용하기로 결정했다고 합시다. 우리의 가설은, &quot;눈 색깔을 통해 말이 눈병에 걸리기 쉬운지를 예측하고, 이것이 말의 신체능력에 영향이 줄 것&quot;이라는 것이죠. 이러한 가설은 틀릴지도 모르고, 추후 증거에 기초하여 가설을 기각할 수도 있습니다. 즉, 눈 색깔이 모델의 향상에 도움을 주는 Feature가 되지 않을지도 모른다는거죠.</p>
<p>그렇다고 해서 ML이 자신과 관련된 Feature가 무엇인지 찾는 어려운 작업을 수행하게 만들어서는 안됩니다. 모델에게 관련된 데이터를 모두 던져주고, 어떤 것이 유용한지 확인하려고 한다면, 우리가 만든 모델을 지나치게 복잡하고, 비싸고, 중요하지 않은 Feature들로 가득차게 될 가능성이 높습니다. 작은 데이터 셋 내에서 Feature는 샘플 데이터 내에서 우연한 상관관계를 띄게 될 가능성이 큽니다. 가설을 세우지 않고 무작정 많은 Feature를 적용하려고 하면, 그것이 모델과 관련된 신호라고 착각하게 될 가능성이 높습니다. 이러한 사실은 모형을 사용해 예측을 시도하고, 그것이 일반화되지 않았다는 것을 깨닫기 전까지는 알 수 없습니다.</p>
<h2 id="예측predictions-vs-결정decisions"><a class="header" href="#예측predictions-vs-결정decisions">예측(Predictions) vs. 결정(Decisions)</a></h2>
<blockquote>
<p><em>예측이 아닌, 결정에 초점을 맞추세요.</em></p>
</blockquote>
<p>여기서 말하는 <strong>결정</strong>이란, 모델의 출력 결과에 따라 제품이 수행하게 될 작업을 말합니다. ML은 우리에게 문제에 대한 통찰력을 제안하기 보다는, 이에 기반한 결정을 내리는 것에 더 초점이 맞추어져 있습니다. 만약, 우리가 가진 수많은 데이터에 대해 어떤 <strong>흥미로운</strong> 분석 결과에 대해 알고 싶다면 ML보다는 통계학이 더 올바른 접근 방법입니다.</p>
<p>예측이 유용한 액션을 취할 수 있도록 하는지 확신하세요. 예를 들어, 특정 동영상을 클릭할 가능성을 예측하는 모델을 통해 시스템이 클릭할 가능성이 가장 높은 동영상을 미리 가져오도록 할 수 있습니다.</p>
<p>가끔 예측과 결정은 밀집하게 연관된 경우도 있지만, 그와 다르게 관계가 명확하지 않은 경우도 많습니다. 아래의 예측/결정 간의 차이에 다룬 테이블을 확인해봅시다.</p>
<table class="cyan">
  <tbody><tr><th>Prediction</th><th>Decision</th></tr>
  <tr><td>이용자가 다음에 어떤 동영상을 보고자 할까?</td><td>추천 목록에 해당 동영상들을 띄워주자.</td></tr>
  <tr><td>누군가 검색 결과에 대해 클릭할 확률</td><td>`P(click) > 0.12` 이라면, 해당 웹페이지를 미리 가져오자.</td></tr>
  <tr><td>이용자가 시청할 비디오 광고의 비율</td><td>적은 비율이라면, 광고를 보여주지 않도록 하자.</td></tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="hard-ml-problems"><a class="header" href="#hard-ml-problems">Hard ML Problems</a></h1>
<p>해당 섹션에서는 ML에서 특히 다루기 어려운 문제들에 대해 이야기합니다.</p>
<h2 id="clustering-클러스터링--군집화"><a class="header" href="#clustering-클러스터링--군집화">Clustering (클러스터링 = 군집화)</a></h2>
<p>비지도 학습에서 각 클러스터는 무엇을 의미할까요? 예를 들어, 우리가 만든 모델이 아래의 사진에서 <em>파란 클러스터</em>내에 특정 유저가 포함된다고 이야기한다면, 결국 우리는 파란 클러스터 자체가 무엇을 의미하는지를 알아야할 필요가 있습니다.</p>
<p><img src="https://developers.google.com/machine-learning/problem-framing/images/LabeledClusters.svg?hl=ko" alt="Image of scatterplot with 4 clusters
circled" class="screenshot attempt-right"></p>
<p>종종 클러스터에 따라 액션을 취해야 할 수 있습니다. 예를 들어, Google Photo에서는 동일한 사람들이 모인 사진들을 동일한 사진 그룹에 모아놓습니다. 그 밖의 경우, 클러스터에 기반하여 어떤 액션을 수행하는 것은 도전적인 일이 될 겁니다. 클러스터에 의미를 부여하려고 할 수는 있지만, 생각보다 쉽지는 않습니다. 왜냐하면 모델이 직관적인 기준에 따라 그룹화되어 있지 않을 수도 있기 때문입니다.</p>
<p>이에 대한 한가지 대안은 클러스터링을 하기 이전에 미리 일부 표본들에 대해 label(레이블)을 수행한 다음 해당 레이블들을 전체 클러스터에 전파하는 것입니다. 예를 들어, 레이블이 X인 모든 항목이 하나의 클러스터에 모여있다면, 해당 레이블 X를 다른 예시들에도 전파시켜볼 수 있습니다.</p>
<h2 id="anomaly-detection"><a class="header" href="#anomaly-detection">Anomaly Detection</a></h2>
<p><img src="https://developers.google.com/machine-learning/problem-framing/images/Anomaly.png?hl=ko" alt="Image of a scatterplot with 2 parallel lines indicating a threshold that has
points outside of it which are to be considered anomalies."></p>
<p>종종, 사람들은 이상징후를 식별하기 위해서 ML을 사용하려고 합니다. 관건은 &quot;어떤 것이 이상치인지&quot; 어떻게 결정하느냐 입니다. 한 가지 선택지는 휴리스틱을 정의하고 이를 이상치의 레이블링에 사용하는 것입니다. 그러나, 이 휴리스틱을 정의하였을 때, 이를 학습 단계에서 사용하게 될 경우 애초에 ML은 해당 휴리스틱을 능가할 수 없는 상황에 처하기 때문에, 생산 단계에서 해당 휴리스틱을 사용하는 것이 좋습니다.</p>
<blockquote>
<p>참고 : 떄때로 고정밀 저호출 휴리스틱(High-precision Low-recall heuristic)을 정의한 다음, 준지도적인(semi-superviesed) 방식을 사용해 모델이 시드 예측 집합(seed set of predictions)에서 성장하게끔 훈련시켜 레이블이 없는 더 큰 데이터 집합을 분류할 수 있게끔 할 수도 있습니다. (아직은 뭔 소린지 모르겠다.)</p>
</blockquote>
<p>만약, 휴리스틱이 충분히 복잡하다면 ML을 통해 이를 대체하는 것을 고려해볼 수도 있습니다. 그러나 일반적으로 휴리스틱을 다시 정의하는 것만큼 모델은 쉽게 수정하기 어렵기 때문에 주의할 필요가 있습니다.</p>
<h2 id="causation"><a class="header" href="#causation">Causation</a></h2>
<p>ML은 둘 이상의 상호 관계 및 연관성에 대해 식별할 수 있습니다. 반면, <em>인과 관게</em>를 판단하는 것은 훨씬 어려운 일입니다. 다시 말해, **무슨 일들이 일어났는가?**에 대해서는 알기 쉽지만, **왜 그것이 일어났는가?**에 대해서는 훨씬 판악하기 어렵습니다.</p>
<blockquote>
<p>예를 들어, 소비자들이 어떤 책들을 구매한 것은, 바로 지난 주에 해당 책에 대한 긍정적인 리뷰가 있었기 때문일까? 아니면 그 리뷰는 전혀 상관 없는 것이었을까?</p>
</blockquote>
<p>오직 관측 데이터를 통해서는 인과 관계에 대해 파악할 수 없습니다. 위 사례처럼, 지난 일들에 대한 기록만 보고서는 지난 주의 리뷰가 구매를 유발했는지의 여부를 판단할 수 없습니다. 이를 파악하려면, 리뷰를 보지 못한 이용자와, 리뷰를 본 이용자 간을 비교하는 실험이 추가적으로 필요합니다. 결국, 일반적으로 어떤 일들의 인과 관계를 확인하려면 추가적인 실험이 필요하고, 이는 순수 관측 데이터를 통해서는 불가능한 일입니다.</p>
<h2 id="no-existing-data"><a class="header" href="#no-existing-data">No Existing Data</a></h2>
<p>앞서 언급한 것처럼, 모델을 훈련시킬 데이터가 없다면, ML은 여러분에게 아무런 도움을 줄 수가 없습니다. 데이터가 없다면, 단순한 휴리스틱 기반의 규칙 기반 시스템을 사용하세요. 많은 신규 서비스들은 휴리스틱 기반의 시스템으로 시작하여, 이용자들이 해당 서비스와 상호작용하기 시작하면서부터 새로운 훈련 데이터들을 얻습니다. 일단 훈련 데이터들이 갖추어지기 시작한다면, 그 속에서 패턴을 찾으려고 노력하세요. 패턴이 존재하지 않거나, 자질구레한 패턴만이 존재한다면, ML은 아마 별다른 쓸모가 없을 겁니다. 결국, <strong>수많은 패턴이 존재하고, 그 속에서 정확한 예측을 하는 것이 중요한 상황</strong> 속에서야 ML은 비로소 올바른 접근이 될 겁니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="deciding-on-ml"><a class="header" href="#deciding-on-ml">Deciding on ML</a></h1>
<p>데이터를 본격적으로 다루기 전에, 준비되었는지 확인해보는 과정을 거치도록 하자.
아래에서는 머신 러닝 문제들을 구성하기 전에 생각해야 할 몇가지 사항에 대해 간략하게 설명한다.</p>
<h2 id="명확하고-간단하게-시작하라"><a class="header" href="#명확하고-간단하게-시작하라">명확하고 간단하게 시작하라.</a></h2>
<p>말 그대로, ML 모델이 어떤 일을 했으면 좋겠는가?</p>
<table class="green">
  <tbody><tr><th>예시</th></tr>
  <tr>
    <td>ML 모델으로 방금 업로드된 동영상이 추후에 얼마나 인기를 끌지 예측하고 싶다.</td>
  </tr>
</tbody></table>
<p>현 시점에서, 이에 대해 답하는 것은 다소 정성적인 목표가 될 수 있으나, 간접적인 목표가 아니라, 실제 목표를 지니고 있는지 확인하라.</p>
<h2 id="어떤-결과가-이상적인가"><a class="header" href="#어떤-결과가-이상적인가">어떤 결과가 이상적인가?</a></h2>
<p>시스템에 ML 모델을 추가하는 것은 이상적인 결과를 생산해야 한다. 이는 단순히 모델과 그 품질을 평가하는 것과는 다른 의미를 갖는다.</p>
<table class="green">
  <tbody><tr><th>예시</th><th></th></tr>
  <tr>
    <td>트랜스코딩</td>
    <td>
      <div>이상적인 목표는 덜 인기있는 영상에 대해 트랜스코딩을 거쳐 이들이 잡아먹는 리소스를 줄이는 것이다.</div>
    </td>
  </tr>
    <tr>
    <td>영상 추천</td>
    <td>이상적인 목표는 사람들이 유용하고, 흥미로워하고, 가치가 있다고 판단하는 영상을 제안하는 것이다.</td>
  </tr>
</tbody></table>
<blockquote>
<p><strong>주의</strong>: 똑같은 모델로도 다른 이상적인 결과를 목표로 할 수 있다. 이것이 이상적인 결과를 명확하게 두어야 하는 이유다.</p>
</blockquote>
<p>이미 최적화를 하고 있는 서비스의 매트릭스에 갇혀있지 마라. 제품 및 서비스의 더 큰 목표에 집중해야 한다.</p>
<h2 id="성공실패-매트릭스지표"><a class="header" href="#성공실패-매트릭스지표">성공/실패 매트릭스(지표)</a></h2>
<h3 id="정량화하라"><a class="header" href="#정량화하라">정량화하라</a></h3>
<p>시스템이 성공적인지 아닌지 어떻게 판단할 수 있을까?</p>
<p>성공 및 실패 매트릭스는 정밀도, 재현율 또는 AUC와 같은 평가 매트릭스와 독립적으로 표현되어야 합니다.
대신, 예상 결과를 구체화시켜야 합니다.
시작하기 전에 미리 성공 매트릭스를 설정하세요.
이는 매몰 비용으로 우리가 평범한 모델로부터 시작하게끔 하는 것을 막기 위해서 입니다.</p>
<table class="green">
  <tbody><tr><th>예시</th><th></th></tr>
  <tr>
    <td>트랜스코딩</td>
    <td>성공 매트릭스는 CPU 리소스 사용률이다. 성공은 트랜스코딩을 위한 CPU 비용을 35% 줄이는 것을 의미한다. 반면 실패는 비용 절감이 모델 학습 및 제공을 위한 CPU 비용보다 적은 경우다.</td></tr>
    <tr>
    <td>영상 추천</td>
    <td>성공 매트릭스는 모델을 통해 적절하게 예측한 영상의 개수가 된다. 성공은 업로드된 이후 28일 이내에 시청 시간을 기반으로 가장 인기있는 동영상의 95%를 예측하는 것을 의미한다. 반면 실패는 적절하게 예측된 인기 동영상의 수가 현재의 휴리스틱을 통한 예측보다 성능이 나쁜 경우다.</td>
  </tr>
</tbody></table>
<h3 id="측정-가능한-매트릭스인가"><a class="header" href="#측정-가능한-매트릭스인가">측정 가능한 매트릭스인가?</a></h3>
<p>측정가능한 지표는 실제로 적용하였을 때의 평가에 있어 충분한 정보를 제공한다.
예를 들어, 과수원의 건강 상태를 모니터링하는 시스템은 병든 나무들의 비율을 줄이고자 한다.
한편, &quot;어떤 나무가 병든 나무인가?&quot;에 대한 측정이 불가능하다면, 그다지 유용한 지표는 아니다.</p>
<p>아래와 같은 질문들을 스스로 해보자.</p>
<ul>
<li>어떻게 지표를 측정하는가?</li>
<li>언제 지표를 측정할 수 있는가?</li>
<li>새로운 ML 시스템이 성공적인지 아닌지를 판단하는 데에 얼마나 많은 시간이 걸릴 것인가?</li>
</ul>
<p>이상적으로는, 빨리 실패하고자 할 것이다. 
데이터의 신호(Signal)가 너무 적거나, 예측할 수 없는 데이터가 있는지를 확인하여 가설이 틀릴 수 있는지에 대해 판단하라.
빠른 실패는 프로세스의 초기에 가설을 수정하고 시간 손실을 방지할 수 있다.</p>
<table class="green">
  <tbody><tr><th>예시</th></tr>
  <tr>
    <td>
      이용자의 위치에 따라 어떤 영상이 시청되었지에 대해 판단하고 싶다.
      이는 가능한 것처럼 보이지만, 막상 시도해보면, 신호가 너무 약하거나, 너무 많은 노이즈가 껴있어 제대로 이루어지기 어렵다.
      얼마나 오래 해당 가설을 고수할 것인가?
    </td>
  </tr>
</tbody></table>
<p>보다 장기적인 관점에서 엔지니어링 및 유지 비용을 고려하라.</p>
<h3 id="다른-실패-시나리오"><a class="header" href="#다른-실패-시나리오">다른 실패 시나리오</a></h3>
<p>성공 지표와 관련이 없는 실패에 대해서도 확인하라.
예를 들어, 영상 추천 시스템이 항상 &quot;어그로 영상&quot;들을 추천한다면 양질의 서비스를 제공해야한다는 관점에서 성공적이라고 할 수 없을 것이다.</p>
<h2 id="ml-모델이-어떤-형태의-결과를-만들어냈으면-하는가"><a class="header" href="#ml-모델이-어떤-형태의-결과를-만들어냈으면-하는가">ML 모델이 어떤 형태의 결과를 만들어냈으면 하는가?</a></h2>
<p>아래 테이블을 기반으로, 어떤 형태의 결과를 출력하는 것이 가장 적절할지에 대해 생각해보라.</p>
<table class="blue">
  <tbody><tr><th>Type of ML Problem</th><th>Description</th><th>Example</th></tr>
  <tr>
    <td>Classification (분류)</td>
    <td>N개의 라벨 중 하나를 선택</td>
    <td>cat, dog, horse, or bear</td>
  </tr>
    <tr>
    <td>Regression (회귀)</td>
      <td>수치에 대한 예측</td>
      <td>클릭율</td>
  </tr>
    <tr>
    <td>Clustering (군집화)</td>
      <td>유사한 예시들을 그룹화시키기</td>
      <td>가장 관련이 있는 문서 (비지도)</td>
  </tr>
   <tr>
    <td>Association rule learning (연관 규칙 학습)</td>
      <td>데이터에서 가능한 연관 패턴 추론</td>
      <td>만약 햄버거 빵을 샀으면, 햄버거도 샀을 것이다. (비지도)</td>
  </tr>
    <tr>
    <td>Structured output (구조적인 결과)</td>
      <td>복잡한 출력 생성</td>
      <td>자연어 파싱 트리, 이미지 인식 경계 박스</td>
  </tr>
</tbody></table>
<blockquote>
<p><strong>주의</strong> : 특정 ML 문제는 어떤 타입에서는 실패하지만, 어떤 타입에서는 성공적일 수 있습니다.</p>
</blockquote>
<h3 id="좋은-출력의-특징"><a class="header" href="#좋은-출력의-특징">좋은 출력의 특징</a></h3>
<h4 id="모델이-만들어낸-출력은-명확한-정의가-가능한-정량적-결과여야-합니다"><a class="header" href="#모델이-만들어낸-출력은-명확한-정의가-가능한-정량적-결과여야-합니다"><strong>모델이 만들어낸 출력은 명확한 정의가 가능한 정량적 결과여야 합니다.</strong></a></h4>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>
      이용자가 영상을 재밌게 보았는가? vs. 이용자가 영상을 공유하였는가?
    </td>
  </tr>
</tbody></table>
<p>이용자에게 직접 물어보지 않는 한, 이용자가 정말로 해당 영상을 즐겼는지에 대해 알 방도가 없다.
만약 이를 판단하려면, 별도의 **<a href="https://developers.google.com/machine-learning/glossary?hl=ko#proxy_labels">프록시 레이블</a>**이 필요할 것이다.
프록시 레이블은 실제를 대신할 대체 레이블을 의미하는데, 이용자의 공유 여부는 좋은 프록시 레이블이 된다.
물론, 공유는 이용자가 영상을 재밌게 보았는지에 대한 완벽한 측정치가 될 수 없다.
그러나, 공유는 정량적이고, 추적 가능하고, 수많은 예측 시그널을 제공한다는 점에서 더 적절하다.</p>
<h4 id="출력은-앞서-정한-이상적인-결과와-관련이-있어야-한다"><a class="header" href="#출력은-앞서-정한-이상적인-결과와-관련이-있어야-한다"><strong>출력은 앞서 정한 이상적인 결과와 관련이 있어야 한다.</strong></a></h4>
<p>모델은 출력을 올바른 방향으로 최적화해 나갈 것이다. 그러므로, 출력은 우리가 신경쓰고자 하는 실질적인 이상적인 목표와 관련이 있어야 한다.
프록시 레이블이 종종 필수적인데, 항상 이상적인 결과를 직접 측정할 수 없기 때문이다.
그러나, 레이블과 실제 결과 간의 연관성이 강할수록, 제대로 된 것을 최적화시켜 나가고 있다는 자신을 갖기도 용이하다.</p>
<table class="green">
  <tbody><tr><th>Output</th><th>Ideal Outcome</th></tr>
  <tr><td>이용자가 기사를 공유할지 아닌지에 대한 예측</td><td>이용자들이 좋아하는 기사를 보여줌</td></tr>
  <tr><td>비디오가 인기있을 것인지 아닌지에 대한 예측</td><td>이용자가 유용하고 가치있다고 판단하는 영상을 제공</td></tr>
  <tr><td>이용자들이 앱 스토어에서 어떤 앱을 설치할지 아닌지에 대한 예측</td>
    <td>이용자들이 좋아할만한 앱을 찾아줌</td></tr>
  <tr class="alt"><td colspan="3"><b>둘 사이에 강한 연관성이 있는지 확인해야 한다!</b></td></tr>
</tbody></table>
<h4 id="연습-데이터로-사용할-예시-데이터들을-얻을-수-있는가"><a class="header" href="#연습-데이터로-사용할-예시-데이터들을-얻을-수-있는가"><strong>연습 데이터로 사용할 예시 데이터들을 얻을 수 있는가?</strong></a></h4>
<p>어떻게, 어디서 데이터들을 가져올 것인가?</p>
<p>지도 학습은 레이블 처리된 데이터에 의존한다. 
만약 연습에 사용할 데이터를 얻는 것이 어려운 상황이라면, 앞선 단계를 다시 밟으면서 문제와 목표를 재정의하는 것이 필요할 것이다.
앞서 시청 시간을 퍼센트 단위로 변환한 것처럼, 출력 예시는 엔지니어링 되어야 할 수도 있다.</p>
<h2 id="출력-활용"><a class="header" href="#출력-활용">출력 활용</a></h2>
<p>모델은 다음의 두 부분에서 예측을 수행할 수 있다.</p>
<ul>
<li>실제 사례, 이용자 활동에 따른 반응 (online)</li>
<li>배치 또는 캐시로써 사용</li>
</ul>
<p>서비스에서 어떻게 예측을 활용할 것인가? 명심하라, ML은 단순히 예측을 하는 것이 아니라, 그것에 기반해 결정을 수행해야 한다.
어떻게 모델의 예측 결과를 의사 결정으로 바꿀 수 있을까?</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>모델은 새 영상이 업로드될 때 영상의 인기도를 예측할 것이다. 그 결과에 기반하여 영상에 대한 트랜스코딩 알고리즘을 결정할 것이다.</td>
  </tr>
</tbody></table>
<p>아래 예시처럼, 이용자의 클릭율을 예측하여 이를 통해 이용자에게 알림을 전달할 수도 있다.</p>
<pre><code>click_probability = call_model(user)
if click_probability &gt; 0.05:
    send_notification(user)
</code></pre>
<p>다음으로, 아키텍처의 어디에 이러한 의사 결정 코드들이 위치할 지에 대해 판단하라.
아래의 질문들이 중요한 도움이 될 것이다.</p>
<ul>
<li>모델을 호출할 때 어떤 데이터들이 필요한가?</li>
<li>대기시간(latency) 요구사항이 있는가? UX를 위해 빠르게 실행해야 하는가, 아니면 이용자가 기다리지 않아도 되는 경우인가?</li>
</ul>
<p>위의 질문들은 모델의 실제 feature를 구성하는 데에도 영향을 준다. 
모델을 호출할 때 사용할 수 있는 데이터들에 대해서만 feature를 결정하고 훈련시킬 수 있기 떄문이다.
요구 대기시간 역시 feature 구성에 영향을 줄 수 있는데, 이를테면 카메라 앱에서 현재 날씨 데이터를 feature로 사용하고자 하는 경우, 해당 데이터를 다른 api 등을 통해 가져오는 데 비용이 너무 크게 소모되기 때문이다.</p>
<p>마지막으로, 너무 오래된 데이터를 사용하지 않도록 해야한다.
훈련 데이터가 며칠이 지난 경우가 있을 수 있다.
실시간 트래픽에서 동작하는 경우, 최신 데이터에 대해 당장에 접근할 수 없는 경우가 발생할 수도 있다.</p>
<h2 id="좋지-않은-목표"><a class="header" href="#좋지-않은-목표">좋지 않은 목표</a></h2>
<p>적절하게 설정되기만 한다면, ML 시스템은 목표를 추구하기에 정말 유용하다.
반대로, 적절하지 않은 목표에 기반을 둔다면, ML 시스템은 의도치 않은 결과를 생산해낼 것이다.
그러므로, 어떤 문제를 해결하기 위하여 해당 시스템의 목표에 대해서 주의깊게 고려할 필요가 있다.</p>
<p>유튜브에서 어떤 이용자가 다음에 볼 영상을 예측하는 모델의 경우를 생각해보자.
아래는 모두 <strong>적절하지 않은 목표</strong>에 대한 예시이다.</p>
<h3 id="클릭율을-최대한-높이기"><a class="header" href="#클릭율을-최대한-높이기">클릭율을 최대한 높이기</a></h3>
<ul>
<li>이용자가 어떤 것을 클릭할 순 있어도 그렇게 오래 머물러있지 않는 경우가 발생할 수 있다.</li>
<li>이는 낚시 기사 내지는 어그로성 게시물들에 최적화될 것이며, 그렇기 때문에 다른 목표가 필요하다.</li>
</ul>
<h3 id="시청-시간-최대한-늘리기"><a class="header" href="#시청-시간-최대한-늘리기">시청 시간 최대한 늘리기</a></h3>
<ul>
<li>이용자가 오래동안 시청을 하더라도, 금방 세션에서 벗어날 수 있다.</li>
<li>예를 들어, 마인크래프트의 0.1% 시청자만이 3시간 동안 영상을 보고, 8%는 5분 동안 영상을 본다. 그 외의 나머지는 시청을 완전히 중단한다. 시스템은 시청 시간을 최대화할 것이므로, 다음 시청 목록은 긴 마인크래프트 비디오로만 구성될 것이다.</li>
<li>단순히 영상을 오래 보는 것 보다, 여러 짧은 동영상들을 많이 보게끔 하는 것이 더 중요하며, 전반적인 세션을 길게 유지하는 것 역시 중요하다.</li>
</ul>
<h3 id="세션-시청-시간을-최대한-늘리기"><a class="header" href="#세션-시청-시간을-최대한-늘리기">세션 시청 시간을 최대한 늘리기</a></h3>
<ul>
<li>앞선 예시처럼, 여전히 긴 영상을 선호하게 되는데, 이는 여전히 문제가 된다.</li>
<li>이 경우, 특정 관심사에 대해서만 편향되기 매우 쉽다.</li>
<li>예를 들어, 한 이용자가 르브론 제임스의 덩크 영상을 봤따면, 시스템은 해당 이용자에게 르브론 제임스의 모든 덩크 영상을 보여줄 것이다.</li>
<li>영상 추천 시스템은 이를 정말 잘 수행하겠지만, 이용자 경험은 그다지 좋지 않을 것이다.</li>
<li>이 경우 많은 이들이 유튜브를 단순히 특정 영상만 가득한 곳으로 판단할 것이며, 다양성이 사라지게 된다.</li>
</ul>
<h3 id="다양성-증가--세션-시청-시간을-최대한-늘리기"><a class="header" href="#다양성-증가--세션-시청-시간을-최대한-늘리기">다양성 증가 &amp; 세션 시청 시간을 최대한 늘리기</a></h3>
<ul>
<li>해당 목표에서는 어떤 문제가 발생할까? </li>
<li>여기서는 굿하트의 법칙을 떠올리자. &quot;측정이 곧 목표가 된다면, 올바른 측정은 불가능하다.&quot;</li>
</ul>
<h2 id="휴리스틱"><a class="header" href="#휴리스틱">휴리스틱</a></h2>
<p>어떻게 하면 ML 없이도 문제를 해결할 수 있을까?</p>
<p>어떤 서비스를 당장 내일 제공해야 한다고 가정하자. 그렇다면 ML 보다는 당장에 비즈니스 로직을 하드코딩할 시간 정도밖에 없을 것이다.
이 때는 아래 예시처럼 ML 없이 휴리스틱을 시도하고자 할 수 있다.</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>과거에 인기 있었던 영상들을 올린 사람이 새로 업로드하는 영상들 역시 인기있을 것이라고 가정한다.</td>
  </tr>
</tbody></table>
<p>이러한 예시는 세상에서 제일 완벽한 휴리스틱은 아니겠지만, 토대를 마련하기에는 충분할 것이다.
굳이 팬시한 ML 모델에 집착할 필요 없습니다. 굳이 휴리스틱을 이기지 못하는 ML 모델을 서비스로 제공할 필요가 없습니다.
휴리스틱을 만드는 연습은 ML 모델에서 좋은 신호를 판단하는 데에 도움이 됩니다.</p>
<p>ML이 아닌 해답은 대부분 ML을 통한 해답보다 유지보수가 더 쉽습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="formulate-your-problem-as-an-ml-problem"><a class="header" href="#formulate-your-problem-as-an-ml-problem">Formulate Your Problem as an ML Problem</a></h1>
<p>해당 섹션에서는 ML 문제를 구성하기 위한 적절한 접근에 대한 가이드를 제공합니다.</p>
<ol>
<li>문제를 분명히 하라.</li>
<li>간단하게 시작하라.</li>
<li>데이터 소스를 정의하라.</li>
<li>모델에 사용할 데이터를 디자인하라.</li>
<li>어디서 데이터가 올지 결정하라.</li>
<li>쉽게 얻을 수 있는 입력을 결정하라.</li>
<li>학습 능력</li>
<li>잠재적인 편향(bias)에 대해 생각하라.</li>
</ol>
<h2 id="문제를-분명히-하라"><a class="header" href="#문제를-분명히-하라">문제를 분명히 하라.</a></h2>
<p>분류와 회귀에도 여러 세부유형들이 존재합니다.
아래 플로우차트를 따라 정확히 어떤 유형의 문제인지를 정의하세요.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/FlowChart1.svg?hl=ko" >
<img src="https://developers.google.com/machine-learning/problem-framing/images/FlowChart2.svg?hl=ko" >
<p>우리 문제는 다음과 같이 잘 구성됩니다.</p>
<ul>
<li>Binary classification</li>
<li>Unidimensional regression</li>
<li>Multi-class single-label classification</li>
<li>Multi-class multi-label classification</li>
<li>Multidimensional regression</li>
<li>Clustering (unsupervised)</li>
<li>Other (translation, parsing, bounding box id, etc.)</li>
</ul>
<p>문제를 정확히 한 이후에, 모델이 예측할 내용이 정확히 무엇인지 설명하세요.</p>
<p>이러한 각 요소들을 합쳐서 정리해보면, 문제에 대한 간결한 설명이 됩니다.</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>어떤 영상에 대해 다음 3개의 클래스 중 어떤 것에 해당할지 예측하는 단일 레이블 분류 문제를 정의해볼 수 있다.—<code translate="no" dir="ltr">{very popular,<wbr> somewhat popular,<wbr> not popular}</code>— 업로드 후 28일이 된 시점에 대한 예측이다.
    </td>
  </tr>
</tbody></table>
<h2 id="간단하게-시작하라"><a class="header" href="#간단하게-시작하라">간단하게 시작하라.</a></h2>
<p>먼저, 모델링 작업을 간단하게 만들어봅시다. 주어진 문제에 대해 이진 분류 또는 단일 회귀 문제(아니면 둘다)로 정의해보세요. 두 문제들은 도움이 되는 많은 도구와 전문가들의 지원이 있는, 제일 간단한 접근 방식입니다.</p>
<p>그 다음, 작업을 위해서 최대한 간단한 모델을 사용하세요. 간단한 모델은 실행하기도, 이해하기도 쉽습니다. 일단 전체 ML 파이프라인을 갖추고 나면, 간단한 모델에서부터 더 쉽게 발전시켜 나갈 수 있습니다.</p>
<table class="green">
  <tbody><tr><th>Examples</th></tr>
  <tr>
    <td>업로드된 영상이 유명해질 것 같은지 아닌지를 예측한다. (Binary Classification)</td>
  </tr>
    <tr>
    <td>업로드된 영상의 인기도를 28일 이내에 받을 조회수를 기준으로 에측한다. (Regression).</td>
  </tr>
</tbody></table>
<p>실제로 그것을 서비스에 곧장 이용하지 않더라도, 간단한 모델로부터 출발하는 것은 좋은 베이스라인이 됩니다. 사실, 간단한 모델은 오히려 생각보다 더 잘 동작할 겁니다. 단순한 모델은 모델이 제대로 정의되었는지 판단하기 훨씬 쉽습니다. 반면, 복잡한 모델은 훈련시키기도, 이해하기도 훨씬 더 어렵고 느립니다. 그러니 성능을 충분히 향상시킬 정도로 트레이드오프를 갖추지 않는 이상은 이를 단순하게 유지하는 편이 더 좋습니다.</p>
<blockquote>
<p><strong>주의</strong>: 대부분의 ML은 데이터 쪽에 있습니다. 복잡한 모델에 대한 전체 파이프라인을 실행하는 것은 모델 자체를 반복하는 것보다 어렵습니다.</p>
</blockquote>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Barchart.svg?hl=ko">
<p>ML 도입 시에 가장 이득이 큰 시점은 데이터를 처음으로 활용하여 모델을 구축해냈을 때입니다. 추가적인 조정은 여전히 성능의 향상을 일으키지만, 일반적으로 가장 큰 이득을 얻는 시점은 시작점에 있으므로 프로세스를 더 쉽게 만들기 위해 잘 테스트된 방법을 고르는 것이 좋습니다.</p>
<h2 id="데이터-소스를-정의하라"><a class="header" href="#데이터-소스를-정의하라">데이터 소스를 정의하라.</a></h2>
<p>우리의 데이터 레이블에 대해 다음의 질문에 답해봅시다.</p>
<ul>
<li>레이블링된 데이터를 얼마나 많이 갖고 있나?</li>
<li>레이블의 출처가 어디인가?</li>
<li>해당 레이블은 내리고자 하는 결정과 긴밀하게 연관되어 있는가?</li>
</ul>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>우리의 데이터 셋은 인기도 데이터 및 영상 설명과 함께 과거에 업로드 된 영상에 대한 100,000 개의 예제로 구성되어 있다.</td>
  </tr>
</tbody></table>
<h2 id="모델에-사용할-데이터를-디자인하라"><a class="header" href="#모델에-사용할-데이터를-디자인하라">모델에 사용할 데이터를 디자인하라.</a></h2>
<p>ML 시스템이 의사 결정을 내리기 위해 사용할 데이터를 정의해야 합니다. (input =&gt; output)</p>
<table class="green" label="Example of table with data from a video sharing site.">
  <tbody><tr><th>Title</th><th>Channel</th><th>Upload Time</th><th>Uploader's Recent
    Videos</th><th>Output (label)</th></tr>
  <tr><td>My silly cat</td><td>Alice</td><td>2018-03-21 08:00</td><td>Another cat
    video, yet another cat</td><td>Very popular</td></tr>
  <tr><td>A snake video</td><td>Bob</td><td>2018-04-03 12:00</td><td>None
    </td><td>Not popular</td></tr>
</tbody></table>
<p>각각의 행(row)은 하나의 예측이 수행될 하나의 데이터가 됩니다. 예측이 이루어지는 순간에 사용할 수 있는 정보만을 포함합니다. 각 input은 스칼라 또는 정수/실수/바이트/문자열 등으로 구성된 1차원 리스트가 될 수 있습니다.</p>
<p>만약, input이 1차원 리스트가 아닌 경우, 해당 데이터를 가장 잘 나타낼 방법에 대해 고려해야 합니다. 예를 들자면 :</p>
<ul>
<li>한 input이 사실 상 서로 다른 둘 이상의 항목을 나타내는 경우, 이를 별도의 input으로 분할할 수 있습니다.</li>
<li>한 input이 중첩된 <a href="https://developers.google.com/protocol-buffers?hl=ko">프로토콜 버퍼</a>를 나타내는 경우, 이들의 각 field를 쪼갤 수 있습니다.</li>
<li>예외 : 오디오, 이미지, 영상 데이터.. (blob of bytes)</li>
</ul>
<table class="blue">
  <tbody><tr><th>Tips for audio/image/video data</th><th>Examples</th></tr>
  <tr>
    <td>There may not be explicit inputs.</td>
    <td>The only inputs may be the bytes for the audio/image/video.</td>
  </tr>
    <tr>
    <td>There may be metadata accompanying the image.</td>
    <td>Compression format, object bounding boxes, source</td>
  </tr>
  <tr>
    <td>Your outputs may be simplified for an initial implementation.</td>
    <td>Rather than doing bounding-box object detection, you may create a simple
      binary classifier that learns whether one type of object is present in the
      image or not.</td>
  </tr>
</tbody></table>
<h2 id="어디서-데이터가-올지-결정하라"><a class="header" href="#어디서-데이터가-올지-결정하라">어디서 데이터가 올지 결정하라.</a></h2>
<p>하나의 행(row)를 구성하기 위해 각 열(column)에 들어갈 값을 만들어줄 데이터 파이프라인을 개발하는 데 얼마나 많은 작업이 필요할지 평가해보세요. 예제 출력을 얻기 어려운 경우, 출력을 다시 고려하여 모델에 다른 출력을 사용할 수 있는지의 여부를 조사해볼 수 있습니다.</p>
<p>모든 입력이 예측 시에 정확히 작성한 형태로 사용할 수 있는지 확인하세요. 예측 시점에 특정한 feature 값을 얻는 것이 어렵다고 판단된다면 해당 특성을 생략해야 합니다.</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>We applied the labels <code translate="no" dir="ltr">{very popular,<wbr> somewhat popular,<wbr>
      not popular}</code> to each video that fell within a determined range of
      views and "thumbs ups" and determined keyword descriptions for each video.
      Hand-generating descriptions is not sustainable, so we are considering
      adding a keyword description to the upload form.</td>
  </tr>
</tbody></table>
<h2 id="쉽게-얻을-수-있는-입력을-결정하라"><a class="header" href="#쉽게-얻을-수-있는-입력을-결정하라">쉽게 얻을 수 있는 입력을 결정하라.</a></h2>
<p>얻기 쉽고, 합리적인 초기 결과를 얻을 수 있을 거라고 판단되는 1-3개의 입력을 선택하세요.</p>
<p>이전에 언급했던 휴리스틱을 구현하는 데 어떤 입력이 유용할까요?</p>
<p>input들을 준비하기 위해 데이터 파이프라인을 개발하는데 드는 엔지니어링 비용과, 모델에 각 input들을 가짐에 따라 예상되는 이득을 고려하세요. 간단한 파이프라인으로 단일 시스템에서 손쉽게 얻을 수 있는 입력에 중점을 두세요. 가능한 최소의 인프라로 시작하세요.</p>
<h2 id="학습-능력"><a class="header" href="#학습-능력">학습 능력</a></h2>
<p>우리 ML 모델이 과연 학습할 수 있을까요? 학습에 어려움을 줄 수 있을 것 같은 문제들을 나열해보세요. 예를 들어:</p>
<ul>
<li>데이터 셋에 충분한 양의 레이블이 포함되어 있지 않을 수 있습니다.</li>
<li>훈련 데이터에 충분한 예제가 없을 수 있습니다.</li>
<li>레이블에 노이즈가 너무 많이 끼어있을 수 있습니다.</li>
<li>시스템이 훈련 데이터들을 기억하는 바람에, 새로운 케이스에 일반화시키는 것에 어려움을 겪을 수 있습니다.</li>
</ul>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>The measure "popular" is subjective based on the audience and
        inconsistent across video genres.
        Tastes change over time, so today's "popular" video might
        be tomorrow's "not popular" video.</td>
  </tr>
</tbody></table>
<h2 id="잠재적인-편향에-대해-생각하세요"><a class="header" href="#잠재적인-편향에-대해-생각하세요">잠재적인 편향에 대해 생각하세요.</a></h2>
<p>많은 데이터 셋들은 어떤 방식으로는 <a href="https://developers.google.com/machine-learning/glossary?hl=ko#bias_ethics">편향(bias)</a>를 갖습니다. 이러한 편향은 훈련 및 예측에 부정적인 영향을 끼칠 수 있습니다. 예를 들어:</p>
<ul>
<li>편향된 데이터 소스가 여러 문맥 간에 적절하게 해석되지 않을 수 있습니다.</li>
<li>훈련 데이터 셋이 모델의 최종 이용자를 대표하지 못할 수 있으며, 이에 따라 부정적인 이용자 경험을 유발할 수 있습니다.</li>
</ul>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>Since the measure "popular" is subjective, it is possible that the model
      will serve popular videos that reinforce unfair or biased societal views.
    </td>
  </tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="crash-course"><a class="header" href="#crash-course">Crash Course</a></h1>
<p>ML 크래쉬 코스</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="framing"><a class="header" href="#framing">Framing</a></h1>
<p>지도 학습(Supervised Learning)이란 무엇일까요? 결론적으로는, 아래를 의미합니다.</p>
<ul>
<li>이전에 보지 못한 데이터에 대해 유용한 예측을 생성하는 방법을 배우는 ML 시스템</li>
</ul>
<h2 id="labels-레이블"><a class="header" href="#labels-레이블">Labels (레이블)</a></h2>
<p><strong>레이블</strong>은 <strong>우리가 예측하려는 것</strong>입니다. 단순 선형 회귀에서 <code>y</code> 변수에 해당하는 것이죠. 레이블에는 다음과 같은 것들이 될 수 있습니다.</p>
<ul>
<li>쌀의 추후 가격 예측</li>
<li>사진에 찍힌 동물의 종류</li>
<li>오디오 클립의 의미</li>
</ul>
<h2 id="features-피쳐"><a class="header" href="#features-피쳐">Features (피쳐)</a></h2>
<p><strong>Feature</strong>는 입력 변수입니다. 단순 선형 회귀에서 <code>x</code> 변수에 해당하는 것입니다.
가장 단순한 형태의 ML 프로젝트는 단 하나의 피쳐만 사용함으로써 이루어집니다.
반면, 엄청 섬세한 형태의 ML 프로젝트는 수십만개의 피쳐가 존재할수도 있죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>스팸 메일 분류기를 예시로 들자면, 피쳐는 아래와 같은 것들이 될 수 있습니다.</p>
<ul>
<li>이메일 텍스트에 들어간 단어들</li>
<li>발신자 주소</li>
<li>이메일이 보내진 시각</li>
<li>&quot;one weird trick&quot; 이라는 문구가 포함되었는지의 여부</li>
</ul>
<h2 id="examples-예시"><a class="header" href="#examples-예시">Examples (예시)</a></h2>
<p><strong>Example</strong>은 데이터의 구체적인 한 예시입니다. <b>x</b>로 표현되기도 합니다. (굵은 글씨로 되었다는 점을 유의하세요.) 이러한 Example은 또 두개로 분류될 수 있습니다.</p>
<ul>
<li>Labeled examples</li>
<li>Unlabeled examples</li>
</ul>
<p>레이블 처리된 예시의 경우 Feature들과 Label을 모두 갖습니다. </p>
<pre><code>labeled examples: {features, label}: (x, y)
</code></pre>
<p>이러한 레이블 처리된 예시들은 모델을 <b>Train(훈련)</b> 시키기 위해 사용됩니다. 우리의 스팸 분류기 예시에서, &quot;스팸인지 아닌지&quot;에 대해 명시되어있는 레이블 처리된 예시들이 곧 레이블 처리된 예시들이 됩니다.</p>
<p>예를 들어, 아래 5줄의 예시로 구성된 테이블은 켈리포니아의 집값 정보를 담고있는 데이터셋입니다.</p>
<table>
  <tbody><tr>
    <th>housingMedianAge<br>(feature)</th>
    <th>totalRooms<br>(feature)</th>
    <th>totalBedrooms<br>(feature)</th>
    <th>medianHouseValue<br>(label)</th>
  </tr>
<tr>
    <td>15</td>
    <td>5612</td>
    <td>1283</td>
    <td>66900</td>
  </tr>
  <tr>
    <td>19</td>
    <td>7650</td>
    <td>1901</td>
    <td>80100</td>
  </tr>
  <tr>
    <td>17</td>
    <td>720</td>
    <td>174</td>
    <td>85700</td>
  </tr>
  <tr>
    <td>14</td>
    <td>1501</td>
    <td>337</td>
    <td>73400</td>
  </tr>
  <tr>
    <td>20</td>
    <td>1454</td>
    <td>326</td>
    <td>65500</td>
  </tr>
</tbody></table>
<p>반면 레이블이 없는 예시의 경우 Feature는 갖고 있지만 Label은 없습니다.</p>
<pre><code>unlabeled examples: {features, ?}: (x, ?)
</code></pre>
<p>아래는 위와 동일한 집값 데이터이지만, Label에 해당하는 <code>medianHouseValue</code>가 존재하지 않습니다.</p>
<table>
  <tbody><tr>
      <th>housingMedianAge<br>(feature)</th>
      <th>totalRooms<br>(feature)</th>
      <th>totalBedrooms<br>(feature)</th>
    </tr>
    <tr>
      <td>42</td>
      <td>1686</td>
      <td>361</td>
    </tr> 
    <tr>
      <td>34</td>
      <td>1226</td>
      <td>180</td>
    </tr>
    <tr>
      <td>33</td>
      <td>1077</td>
      <td>271</td>
    </tr>
  </tbody>
</table>
<p>일단 우리가 레이블 처리된 모델을 훈련시키고 나면, 레이블이 없는 예시들에 대해서도 예측을 수행할 수 있습니다. 스팸 분류기에서 레이블이 없는 데이터는 사람들이 아직 레이블을 처리하지 않은 새로운 이메일이 되겠죠.</p>
<h2 id="models"><a class="header" href="#models">Models</a></h2>
<p><strong>모델</strong>은 Feature와 Label 간의 관계를 의미합니다. 예를 들어, 스팸 분류기 모델은 일부 Feature들은 스팸과 강하게 연관이 있다고 판단할 것입니다. 모델이 사용되는 두 단계에 대해서 살펴봅시다.</p>
<ul>
<li><b>Training(훈련)</b>은 모델을 만들고, <strong>가르치는 것</strong>을 의미합니다. 다시 말해, 모델에게 레이블처리된 예시를 보여주고, 점차 모델에게 Feature와 Label 간의 관계를 가르치는 것입니다.</li>
<li><b>Inference(추론)</b>는 훈련이 완료된 모델을 레이블이 되어있지 않은 예시에 적용함을 의미합니다. 다시 말해, 유용한 예측(<code>y'</code>)을 수행할 수 있는 모델을 사용하는 것이죠. 앞선 경우를 예로 들자면, 레이블이 없는 예시에 대해 집값에 해당하는 Label인 <code>medianHouseValue</code>를 예측하는 것을 의미합니다.</li>
</ul>
<h2 id="regression-vs-classification"><a class="header" href="#regression-vs-classification">Regression vs. Classification</a></h2>
<p>Regression(회귀)는 모델이 연속성을 띄는 값을 예측하는 것을 의미합니다. 예를 들어, 회귀 모델의 경우 아래와 같은 문제들에 대한 답을 예측합니다.</p>
<ul>
<li>켈리포니아의 집값은 얼마일까?</li>
<li>이 광고를 이용자가 클릭할 가능성은 얼마나 될까?</li>
</ul>
<p>Classification(분류)는 모델이 분리된 값에 대한 예측을 하는 것을 의미합니다. 예를 들어, 분류 모델은 아래와 같은 문제들에 대한 답을 예측합니다.</p>
<ul>
<li>수신한 이메일이 스팸일까 아닐까?</li>
<li>사진의 동물은 개일까 고양이일까?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="descending-into-ml"><a class="header" href="#descending-into-ml">Descending into ML</a></h1>
<h2 id="linear-regression"><a class="header" href="#linear-regression">Linear Regression</a></h2>
<p>귀뚜라미가 추운 날보다 더운 날에 더 자주 운다는 것은 익히 알려진 사실입니다. 지난 몇년간, 전문가들과 과학자들은 온도와 귀뚜라미의 울음 주기에 대한 데이터를 수집해왔습니다. 해당 데이터를 통해 둘 간의 상관 관계를 파악해봅시다.</p>
<p>먼저, 플롯을 통해 데이터에 대해 시각적으로 살펴봅시다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/CricketPoints.svg?hl=ko" />
<h4 id="그림-1-분당-울음횟수-vs-섭씨-온도"><a class="header" href="#그림-1-분당-울음횟수-vs-섭씨-온도">그림 1. 분당 울음횟수 vs. 섭씨 온도</a></h4>
<p>예상한 대로, 온도가 올라갈 수록 귀뚜라미의 울음 주기도 많아집니다. 이것이 둘 사이의 상관관계 일까요? 맞습니다. 여기에 하나의 선을 그어 보면 그 관계를 더 뚜렷하게 알 수 있습니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/CricketLine.svg?hl=ko" />
<h4 id="그림-2-선형-관계"><a class="header" href="#그림-2-선형-관계">그림 2. 선형 관계</a></h4>
<p>네, 맞습니다. 선이 모든 점들을 꿰뚫지는 않고 있죠. 하지만 위에 그은 선은 두 변수 간의 상관관계를 뚜렷하게 보여줍니다. 이걸 방정식으로 나타내본다면, 아래와 같은 형태겠죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>는 섭씨 온도입니다. -&gt; 예측하고자 하는 값이죠.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>는 선의 기울기입니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>는 귀뚜라미의 분당 울음 횟수입니다. -&gt; 입력 Feature로 주어지는 값이죠.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>는 y-절편(intercept)입니다.</li>
</ul>
<p>이걸 머신러닝 컨벤션에 따라 작성한다면 약간 다르게 아래와 같은 방정식이 됩니다.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>은 예측된 레이블입니다. (예상되는 결과)</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>는 bias(편향)입니다. 종종 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>로 불리기도 합니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>는 Feature1의 weight(가중치)입니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>은 Feature(피쳐)입니다. (알려진 입력)</li>
</ul>
<p>새로운 분당 귀뚜라미 울음 횟수값인 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대한 온도 예측 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>을 알기 위해서는 단순히 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 값을 위 모델에 집어넣기만 하면 됩니다.</p>
<p>반면, 우리가 지금껏 살펴본 모델은 하나의 Feature만을 갖는 매우 단순한 모델입니다. 실제로 더 복잡한 모델은 더 많은 Feature들에 의존합니다. (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, ...) 예를 들어, Feature가 3개로 늘어난다면 아래와 같은 모델이 만들어지게 되는거죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="training-and-loss"><a class="header" href="#training-and-loss">Training and Loss</a></h2>
<p>모델을 <strong>훈련</strong>시키는 것은 레이블 처리된 예시들로부터 적절한 가중치(Weight)와 편향(Bias)를 배우게 하는 것을 의미합니다. 지도 학습에서, 머신러닝 알고리즘은 수많은 예시들을 살펴보고 loss(손실)을 줄여나가면서 모델을 완성하게 됩니다. 이러한 과정을 Empirical Risk Minimization(경험적 위험 최소화)라고 합니다.</p>
<p>loss는 좋지 않은 예측을 한 경우에 대한 페널티와 같은 개념입니다. 즉, <strong>loss</strong>는 하나의 예시에 대한 모델의 예측이 <b>얼마나 별로였나?</b>를 나타내는 값이죠. 만약 모델의 예측이 완벽했다면, loss는 0이 됩니다. 모델을 훈련시키는 것의 목적은 모든 예시에서 평균적으로 loss를 갖도록 하는 여러 가중치들과 편향을 찾아나가는 것입니다. 예를 들어, 아래의 그림3은 좌측에 loss가 큰 모델과 우측의 loss가 적은 모델을 각각 그래프로 나타내고 있습니다.</p>
<ul>
<li>화살표선은 loss를 나타냅니다.</li>
<li>파란색 선은 prediction을 의미합니다.</li>
</ul>
<img src="https://developers.google.com/machine-learning/crash-course/images/LossSideBySide.png?hl=ko" >
<h4 id="그림3-loss가-큰-왼쪽-모델-loss가-작은-오른쪽-모델"><a class="header" href="#그림3-loss가-큰-왼쪽-모델-loss가-작은-오른쪽-모델">그림3. loss가 큰 왼쪽 모델; loss가 작은 오른쪽 모델.</a></h4>
<p>왼쪽의 각 화살표선들이 오른쪽의 각 화살표선보다 훨씬 길다는 것을 유의하세요. 이런 경우, 우측 모델이 명백히 <strong>더 나은 모델</strong>이 됩니다.</p>
<p>이쯤 되면 수학적으로 어떻게 loss를 계산하는지에 대한 <b>Loss Function(손실 함수)</b>가 궁금할 겁니다.</p>
<h3 id="squared-loss-가장-인기있는-손실-함수"><a class="header" href="#squared-loss-가장-인기있는-손실-함수">Squared Loss: 가장 인기있는 손실 함수</a></h3>
<p>우리가 살펴볼 손실 함수는 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> loss 라고도 알려진 Squared Loss입니다. 이건 식으로 나타내자면 아래와 같습니다. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>는 실제 Label의 값을, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>은 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>에 대한 예측값 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>을 의미합니다.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>평균제곱오차(Mean Square Error: MSE)는 전체 데이터셋의 각각에 대한 Squared Loss의 평균입니다. MSE를 계산하려면, 각각의 예시에 대한 Squared Loss를 전부 더하고, 예시의 갯수만큼 나누어주면 되죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">MSE</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.8374449999999998em;vertical-align:-1.516005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 는 아래를 의미합니다.
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>는 모델의 예측에 사용될 Feature들의 집합입니다. (ex. 분당 귀뚜라미 울음 횟수, 나이, 성별..)</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>는 예시의 Label입니다. (ex. 온도)</li>
</ul>
</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>는 여러 개의 Feature <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>와 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>), 편향(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>)의 조합으로 이루어진 함수입니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>는 레이블 처리 된 많은 예시들을 담고 있는 데이터셋입니다. 이는 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>의 쌍으로도 나타낼 수 있습니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>은 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>에 속하는 데이터 예시들의 갯수입니다.</li>
</ul>
<p>MSE는 머신러닝에서 일반적으로 사용되기는 하지만, 모든 상황에서 유일하게 사용되는 최상의 손실 함수는 아닙니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="reducing-loss"><a class="header" href="#reducing-loss">Reducing Loss</a></h1>
<h2 id="an-iterative-approach"><a class="header" href="#an-iterative-approach">An Iterative Approach</a></h2>
<p>이전 챕터에서는 loss에 대한 개념을 살펴봤습니다. 그렇다면 이번에는 어떻게 ML 모델이 loss를 반복적으로 줄여나갈 수 있는지에 대해 배워봅시다.</p>
<p>반복 학습(Iterative learning)은 흔히 하는 업앤다운 게임과 유사합니다. 여기서 정답이 되는 숫자를 찾는게 곧 최고의 모델이 되는거죠. 우리가 임의로 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)값을 추측하면 모델 시스템이 이에 따른 loss값이 얼마인지 알려줄겁니다. 그러면 이제 또다른 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)값을 추측하고, 또 이에 따른 loss값을 전달받죠. 이런식으로 진행해나가면서 가장 최적의 가중치를 찾는 것이 곧 최선의 모델을 찾는 방법입니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentDiagram.svg?hl=ko">
<h4 id="그림-1-모델-학습에-대한-반복적-접근iterative-approach-방식"><a class="header" href="#그림-1-모델-학습에-대한-반복적-접근iterative-approach-방식">그림 1. 모델 학습에 대한 반복적 접근(Iterative approach) 방식</a></h4>
<p>우리는 이번 ML코스 내내 이러한 접근 방식을 사용할 겁니다. 반복 전략은 대규모 데이터셋에 적합하도록 확장되기 때문에 머신러닝에서 널리 사용됩니다.</p>
<p>모델은 하나 이상의 Feature를 입력으로 받아, 하나의 예측(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>)을 결과로 반환합니다. 간단히 말해, 하나의 Feature를 받아 하나의 Prediction을 만들어내는 모델은 아래와 같은 형태죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>위의 식에서 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에는 무엇이 들어가야 할까요? 선형 회귀 문제에 있어서 사실 이는 그다지 중요하지 않은 것으로 나타났습니다. 임의의 값을 선택해도 되지만, 아래와 같은 값을 사용해보겠습니다.</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ul>
<p>처음으로 Feature에 대한 가중치 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>을 10이라고 해봅시다. 그러면 아래와 같은 예측이 나옵니다.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>위 다이어그램에서 &quot;loss를 계산한다&quot;는 것은 곧 해당 모델이 사용할 손실함수를 통한 계산값입니다. 우리가 만약 Squared loss 함수(제곱 손실함수)를 사용하기로 정했다면, 아래와 같은 두가지 입력을 손실함수가 요구할겁니다.</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>: Feature x에 대한 모델의 예측</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> : Feature x에 대한 실제 label</li>
</ul>
<p>마지막으로 위 다이어그램에서 &quot;파라미터 갱신값을 계산한다&quot;는 부분을 살펴봅시다. 이 부분에서 ML 시스템이 손실 함수의 값을 검사하고, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대한 새로운 값을 생성해냅니다. 지금은 이 신비한 상자가 새로운 값을 고안한 다음 ML 시스템이 모든 레이블에 대한 모든 Feature들을 재평가하여 손실 함수에 대한 새로운 값을 산출해내고, 새로운 매개변수 값을 산출해낸다는 것만 이해하세요. 그리고 학습은 알고리즘이 가능한 최소의 loss값을 갖게끔 하는 모델에 대한 파라미터를 발견해낼 때까지 계속됩니다. 일반적으로, 이는 전체 loss가 변경되지 않거나, 극적으로 느리게 변경될 때까지 반복됩니다. 여기에 도달한 경우, 우리는 모델이 <b>수렴했다(converged)</b>고 말합니다.</p>
<blockquote>
<p><strong>요약!</strong> : 머신러닝 모델은 임의의 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>)와 편향(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">bia</span><span class="mord mathnormal">s</span></span></span></span>)으로부터 시작하여 최대한 낮은 loss를 갖게될 때까지 반복적으로 가중치와 편향을 조정해나가며 학습합니다.</p>
</blockquote>
<h2 id="gradient-descent"><a class="header" href="#gradient-descent">Gradient Descent</a></h2>
<p>위쪽에서 ML 시스템이 loss를 줄이기 위해 가중치와 편향을 조정해나간다는 것은 이해했지만, 구체적으로 그것이 어떻게 이루어지는지에 대해서 아직 우리는 다루지 않았습니다.</p>
<p>가능한 모든 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>값에 대한 손실을 계산할 시간과 컴퓨팅 자원이 충분하다고 가정합시다. 우리가 다루는 회귀 문제의 경우 loss와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대해 그림을 그려보면 이는 항상 볼록합니다. 다시 말해, 이는 항상 그릇과 같은 모양이 되죠.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/convex.svg?hl=ko">
<h4 id="그림-2-회귀-문제에-대한-loss-vs-가중치-플롯"><a class="header" href="#그림-2-회귀-문제에-대한-loss-vs-가중치-플롯">그림 2. 회귀 문제에 대한 loss vs. 가중치 플롯</a></h4>
<p>이러한 경우에는 항상 유일한 최솟값을 갖게됩닌다. 즉, 어디 한 군데는 정확히 기울기가 0인 지점이 존재하죠. 그리고 그 최솟값이 되는 지점이 손실 함수가 수렴하는 부분이 됩니다.</p>
<p>전체 데이터셋에 대해 생각할 수 있는 모든 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 값에 대해 손실함수를 계산하는 것은 수렴하는 지점을 찾는 비효율적인 방법입니다. 그것보다는, 머신러닝에서 매우 널리 사용되는 <b>경사하강법(Gradient Descent)</b>이라는 매커니즘을 배워봅시다.</p>
<p>경사하강법은 처음에 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대한 시작점에서부터 출발합니다. 시작점은 사실 중요하지 않습니다. 그렇기 때문에 많은 알고리즘은 이를 0 또는 랜덤한 숫자로부터 시작합니다. 아래 플롯에서는 0보다 약간 더 큰 값으로부터 출발해보겠습니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentStartingPoint.svg?hl=ko">
<h4 id="그림-3-경사하강법에-대한-시작점"><a class="header" href="#그림-3-경사하강법에-대한-시작점">그림 3. 경사하강법에 대한 시작점</a></h4>
<p>경사하강법 알고리즘은 시작점에 대한 loss 곡선의 경사를 계산합니다. 그림 3에서, loss의 경사는 곧 곡선의 기울기를 의미하고, 이 기울기가 값을 얼마나 조정해야하는지에 대한 정보가 됩니다. 만약 가중치가 여러 개가 된다면, 기울기는 가중치에 대한 도함수의 벡터가 됩니다.</p>
<p>경사가 하나의 벡터를 이룬다는 점을 기억하세요. 이는 곧 다음의 특징을 갖습니다.</p>
<ul>
<li>방향(direction)</li>
<li>크기(magnitude)</li>
</ul>
<p>경사는 항상 손실 함수 상에서 가장 가파른 증가 방향을 가리킵니다. 경사하강 알고리즘은 loss를 최대한 빨리 줄이기 위해 <strong>음의 기울기 방향</strong>으로 단계를 진행해나갑니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentNegativeGradient.svg?hl=ko" >
<h4 id="그림-4-경사-하강은-음의-기울기에-의존합니다"><a class="header" href="#그림-4-경사-하강은-음의-기울기에-의존합니다">그림 4. 경사 하강은 음의 기울기에 의존합니다.</a></h4>
<p>손실 함수 곡선을 따라 다음 지점을 결정하기 위해, 경사 하강 알고리즘은 아래 그림과 같이 시작점에서 기울기 크기의 일부만큼 더합니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentGradientStep.svg?hl=ko" >
<h4 id="그림-5-기울기-step은-손실-곡선의-다음-지점으로-이동합니다"><a class="header" href="#그림-5-기울기-step은-손실-곡선의-다음-지점으로-이동합니다">그림 5. 기울기 step은 손실 곡선의 다음 지점으로 이동합니다.</a></h4>
<p>경사 하강법은 이러한 과정을 반복해 나가면서 최소값에 점점 더 가까워지는 과정입니다.</p>
<blockquote>
<p><strong>노트</strong>: 경사하강법을 수행할 때는, 위의 과정을 일반화하여 모든 모델의 파라미터를 <em>동시에</em> 조정합니다. 예를 들어, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>과 편향 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>의 최적값을 찾기 위해 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>과 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 모두에 대한 기울기를 계산하죠. 그 다음 각각의 기울기에 따라 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>의 값을 수정합니다. 그 다음 최소 손실에 도달할 때까지 이 단계를 반복해나갑니다.</p>
</blockquote>
<h2 id="learning-rate"><a class="header" href="#learning-rate">Learning Rate</a></h2>
<p>앞서 살핀대로, 경사 벡터는 방향과 크기를 모두 갖습니다. 경사 하강 알고리즘은 기울기에 <b>학습률(Learning rate)</b>라는 스칼라를 곱해서 다음 지점을 결정합니다. 예를 들어, 경사의 크기가 2.5고, 학습률이 0.01이라면, 경사 하강 알고리즘은 이전 지점에서 0.025만큼 떨어진 다음 지점으로 진행합니다.</p>
<p><b>하이퍼 파라미터(Hyperparameter)</b>는 프로그래머가 직접 머신러닝 알고리즘 상에서 조정하는 값입니다. 대부분의 머신러닝 프로그래머는 이 학습률을 조정하는데에 대부분의 시간을 할애합니다. </p>
<p>만약 너무 작은 학습률을 선택하게 되면 시간이 너무 오래 걸리죠.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/LearningRateTooSmall.svg?hl=ko">
<h4 id="그림-6-학습률이-너무-작은-경우"><a class="header" href="#그림-6-학습률이-너무-작은-경우">그림 6. 학습률이 너무 작은 경우</a></h4>
<p>반대로, 학습률을 너무 크게 정했을 경우, 다음 지점은 저만치 멀리 가버리기 때문에 수렴하기가 어렵습니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/LearningRateTooLarge.svg?hl=ko">
<h4 id="그림-7-학습률이-너무-큰-경우"><a class="header" href="#그림-7-학습률이-너무-큰-경우">그림 7. 학습률이 너무 큰 경우</a></h4>
<p>모든 회귀 문제에는 <b>골디락스(Goldilocks)</b> 학습률이 존재합니다. 골디락스 값은 손실 함수가 얼마나 평평한지와 관련됩니다. 만약 손실 함수의 기울기가 작다는 것을 알고 있다면, 더 큰 학습률을 안전하게 시도하여 더 빠른 시간 내에 최소값에 도달할 수 있게 됩니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/LearningRateJustRight.svg?hl=ko">
<h4 id="그림-8-학습률이-적절한-경우"><a class="header" href="#그림-8-학습률이-적절한-경우">그림 8. 학습률이 적절한 경우</a></h4>
<blockquote>
<p>학습률에 대해 : 1차원에서 이상적인 학습률은 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(x에서 f(x)의 2차 도함수의 역)입니다. 2차원 이상에 대한 이상적인 학습률은 Hessian(2차 편도함수의 행렬)의 역입니다. 일반적인 볼록 함수에 대해서는 훨씬 더 복잡합니다.</p>
</blockquote>
<h2 id="stochastic-gradient-descent-확률적-경사하강법"><a class="header" href="#stochastic-gradient-descent-확률적-경사하강법">Stochastic Gradient Descent (확률적 경사하강법)</a></h2>
<p>경사하강법에서, <b>배치(Batch)</b>란 한 번의 반복에서 경사를 계산하기 위해 사용하는 예시(example)들의 갯수입니다. 지금껏 우리는 이 배치가 전체 데이터셋이 되는 것 처럼 이야기했지만, 구글의 경우 이 &quot;전체 데이터셋&quot;은 말도 안되게 큰 수치입니다. 게다가 구글 데이터는 Feature의 개수도 엄청나게 많죠. 결국, 한 배치가 너무 과대할 수 있습니다. 배치가 너무 크다면 한번의 반복이라고 해도 매우 오랜 시간이 걸릴 수 있습니다.</p>
<p>예시들 사이에서 랜덤하게 샘플링된 대규모 데이터셋에는 중복 데이터가 포함될 수 있습니다. 실제로 배치 크기가 그다면 중복 가능성이 커집니다. 일부 중복성은 노이즈가 심한 경사를 좀 더 부드럽게 만드는데 유용하지만, 너무 과대한 배치에서는 그다지 유용하지 않습니다.</p>
<p>훨씬 적은 계산을 통해 평균적으로 올바른 경사를 얻을 수 있다면 어떨까요? 데이터셋에서 무작위로 예시를 고르는 것은 훨씬 작은 데이터셋으로부터 큰 평균을 예측할 수 있도록 합니다. <b>확률적 경사하강법(SGD)</b>는 이 아이디어를 극단적으로 활용합니다. 한 반복 당 하나의 예시만 사용하는 것이죠.(배치 크기가 1) 충분한 반복이 주어진다면야 SGD는 올바르게 작동하지만, 매우 노이즈가 많다는 문제가 있습니다. &quot;확률적&quot;이라는 말은 각 배치를 구성하는 하나의 예시가 무작위로 선택됨을 나타내죠.</p>
<p><b>미니배치 확률적 경사 하강법(mini-batch SGD)<b>는 전체 데이터셋에 대한 반복과 SGD 간의 절충안입니다. 미니 배치는 일반적으로 10개에서 1000개 사이의 예시를 가지며, 이는 무작위로 선택됩니다. 미니 배치 SGD는 SGD의 노이즈 양을 줄이지만, 여전히 전체 배치에 대한 반복보다는 효율적으로 동작합니다.</p>
<p>설명을 쉽게 하기 위해서, 우리는 단일 Feature에 대한 경사 하강법만을 언급했습니다. 경사 하강법은 여러 Feature들을 갖는 경우에도 제대로 동작하니 안심하셔도 됩니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>

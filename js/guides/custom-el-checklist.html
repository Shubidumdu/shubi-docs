<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Element 체크리스트 - Shubi Docs</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../js/index.html"><strong aria-hidden="true">1.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/exec-ctx.html"><strong aria-hidden="true">1.1.</strong> 실행 컨텍스트</a></li><li class="chapter-item "><a href="../../js/class.html"><strong aria-hidden="true">1.2.</strong> 클래스</a></li><li class="chapter-item "><a href="../../js/arrow-func.html"><strong aria-hidden="true">1.3.</strong> 화살표 함수</a></li><li class="chapter-item "><a href="../../js/binding-function.html"><strong aria-hidden="true">1.4.</strong> 함수 바인딩</a></li><li class="chapter-item "><a href="../../js/call-apply.html"><strong aria-hidden="true">1.5.</strong> call, apply</a></li><li class="chapter-item "><a href="../../js/closure.html"><strong aria-hidden="true">1.6.</strong> 클로저</a></li><li class="chapter-item "><a href="../../js/func-exp-and-dec.html"><strong aria-hidden="true">1.7.</strong> 함수 표현식 vs 함수 선언문</a></li><li class="chapter-item "><a href="../../js/event-loop.html"><strong aria-hidden="true">1.8.</strong> 이벤트 루프</a></li><li class="chapter-item "><a href="../../js/new.html"><strong aria-hidden="true">1.9.</strong> new와 생성자 함수</a></li><li class="chapter-item "><a href="../../js/properties.html"><strong aria-hidden="true">1.10.</strong> 프로퍼티</a></li><li class="chapter-item "><a href="../../js/prototype.html"><strong aria-hidden="true">1.11.</strong> 프로토타입</a></li><li class="chapter-item "><a href="../../js/this.html"><strong aria-hidden="true">1.12.</strong> this</a></li><li class="chapter-item "><a href="../../js/var.html"><strong aria-hidden="true">1.13.</strong> var를 쓰지 않는 이유</a></li><li class="chapter-item "><a href="../../js/babel.html"><strong aria-hidden="true">1.14.</strong> Babel</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.15.</strong> Web APIs</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/web-api/intersection.html"><strong aria-hidden="true">1.15.1.</strong> Intersection Observer</a></li><li class="chapter-item "><a href="../../js/web-api/mutation.html"><strong aria-hidden="true">1.15.2.</strong> Mutation Observer</a></li><li class="chapter-item "><a href="../../js/web-api/template.html"><strong aria-hidden="true">1.15.3.</strong> Template Element</a></li><li class="chapter-item "><a href="../../js/web-api/shadow-dom/intro.html"><strong aria-hidden="true">1.15.4.</strong> Shadow DOM</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/web-api/shadow-dom/slot.html"><strong aria-hidden="true">1.15.4.1.</strong> Slot</a></li><li class="chapter-item "><a href="../../js/web-api/shadow-dom/styling.html"><strong aria-hidden="true">1.15.4.2.</strong> Styling</a></li><li class="chapter-item "><a href="../../js/web-api/shadow-dom/events.html"><strong aria-hidden="true">1.15.4.3.</strong> Events</a></li></ol></li><li class="chapter-item "><a href="../../js/web-api/canvas/intro.html"><strong aria-hidden="true">1.15.5.</strong> Canvas API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/web-api/canvas/shapes.html"><strong aria-hidden="true">1.15.5.1.</strong> 도형 그리기</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.16.</strong> Guides</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/guides/render-opt.html"><strong aria-hidden="true">1.16.1.</strong> 렌더링 최적화</a></li><li class="chapter-item expanded "><a href="../../js/guides/custom-el-checklist.html" class="active"><strong aria-hidden="true">1.16.2.</strong> Custom Element 체크리스트</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../ts/index.html"><strong aria-hidden="true">2.</strong> TypeScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/intro/index.html"><strong aria-hidden="true">2.1.</strong> 타입스크립트 알아보기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/intro/ts_js.html"><strong aria-hidden="true">2.1.1.</strong> TS와 JS의 관계</a></li><li class="chapter-item "><a href="../../ts/intro/setting.html"><strong aria-hidden="true">2.1.2.</strong> TS 설정 이해하기</a></li><li class="chapter-item "><a href="../../ts/intro/transpile.html"><strong aria-hidden="true">2.1.3.</strong> 코드 생성과 타입이 관계없음을 이해하기</a></li><li class="chapter-item "><a href="../../ts/intro/typing.html"><strong aria-hidden="true">2.1.4.</strong> 구조적 타이핑에 익숙해지기</a></li><li class="chapter-item "><a href="../../ts/intro/no_any.html"><strong aria-hidden="true">2.1.5.</strong> any 타입 지양하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/types/index.html"><strong aria-hidden="true">2.2.</strong> 타입스크립트의 타입 시스템</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/types/use_editor.html"><strong aria-hidden="true">2.2.1.</strong> 편집기를 사용하여 타입 시스템 탐색하기</a></li><li class="chapter-item "><a href="../../ts/types/set.html"><strong aria-hidden="true">2.2.2.</strong> 타입이 값들의 집합이라고 생각하기</a></li><li class="chapter-item "><a href="../../ts/types/symbol.html"><strong aria-hidden="true">2.2.3.</strong> 타입 공간과 값 공간의 심벌 구분하기</a></li><li class="chapter-item "><a href="../../ts/types/type-def.html"><strong aria-hidden="true">2.2.4.</strong> 타입 단언보다는 타입 선언을 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/wrapper.html"><strong aria-hidden="true">2.2.5.</strong> 객체 래퍼 타입 피하기</a></li><li class="chapter-item "><a href="../../ts/types/excess-type-check.html"><strong aria-hidden="true">2.2.6.</strong> 잉여 속성 체크의 한계 인지하기</a></li><li class="chapter-item "><a href="../../ts/types/function-expression.html"><strong aria-hidden="true">2.2.7.</strong> 함수 표현식에 타입 적용하기</a></li><li class="chapter-item "><a href="../../ts/types/type-and-interface.html"><strong aria-hidden="true">2.2.8.</strong> 타입과 인터페이스의 차이점 알기</a></li><li class="chapter-item "><a href="../../ts/types/generics.html"><strong aria-hidden="true">2.2.9.</strong> 타입 연산과 제너릭 사용으로 반복 줄이기</a></li><li class="chapter-item "><a href="../../ts/types/index-signature.html"><strong aria-hidden="true">2.2.10.</strong> 동적 데이터에 인덱스 시그니처 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/no-index-signature.html"><strong aria-hidden="true">2.2.11.</strong> number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/readonly.html"><strong aria-hidden="true">2.2.12.</strong> 변경 관련된 오류 방지를 위해 readonly 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/mapped-type.html"><strong aria-hidden="true">2.2.13.</strong> 매핑된 타입을 사용하여 값을 동기화하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/type-inference/index.html"><strong aria-hidden="true">2.3.</strong> 타입 추론</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/type-inference/use-inferable-types.html"><strong aria-hidden="true">2.3.1.</strong> 추론 가능한 타입을 사용해 장황한 코드 방지하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/use-const.html"><strong aria-hidden="true">2.3.2.</strong> 다른 타입에는 다른 변수 사용하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/type-widening.html"><strong aria-hidden="true">2.3.3.</strong> 타입 넓히기</a></li><li class="chapter-item "><a href="../../ts/type-inference/type-narrowing.html"><strong aria-hidden="true">2.3.4.</strong> 타입 좁히기</a></li><li class="chapter-item "><a href="../../ts/type-inference/create-object-at-once.html"><strong aria-hidden="true">2.3.5.</strong> 한꺼번에 객체 생성하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/avoid-aliasing.html"><strong aria-hidden="true">2.3.6.</strong> 일관성있는 별칭 사용하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/use-async.html"><strong aria-hidden="true">2.3.7.</strong> 비동기 코드에는 콜백 대신 async 함수 사용하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/context-inference.html"><strong aria-hidden="true">2.3.8.</strong> 타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/well-typed-lib.html"><strong aria-hidden="true">2.3.9.</strong> 함수형 기법과 라이브러리로 타입 흐름 유지하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/design/index.html"><strong aria-hidden="true">2.4.</strong> 타입 설계</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/design/valid-states.html"><strong aria-hidden="true">2.4.1.</strong> 유효한 상태만 표현하는 타입을 지향하기</a></li><li class="chapter-item "><a href="../../ts/design/loose-accept-strict-produce.html"><strong aria-hidden="true">2.4.2.</strong> 사용할 때는 너그럽게, 생성할 때는 엄격하게</a></li><li class="chapter-item "><a href="../../ts/design/jsdoc-repeat.html"><strong aria-hidden="true">2.4.3.</strong> 문서에 타입 정보를 쓰지 않기</a></li><li class="chapter-item "><a href="../../ts/design/null-values-to-perimeter.html"><strong aria-hidden="true">2.4.4.</strong> 타입 주변에 null값 배치하기</a></li><li class="chapter-item "><a href="../../ts/design/union-of-interfaces.html"><strong aria-hidden="true">2.4.5.</strong> 유니온의 인터페이스보다는 인터페이스의 유니온 사용하기</a></li><li class="chapter-item "><a href="../../ts/design/avoid-strings.html"><strong aria-hidden="true">2.4.6.</strong> string 타입보다 더 구체적인 타입 사용하기</a></li><li class="chapter-item "><a href="../../ts/design/incomplete-over-innacurate.html"><strong aria-hidden="true">2.4.7.</strong> 부정확한 타입보다는 미완성 타입을 사용하기</a></li><li class="chapter-item "><a href="../../ts/design/consider-codegen.html"><strong aria-hidden="true">2.4.8.</strong> 데이터가 아닌, API와 명세를 보고 타입 만들기</a></li><li class="chapter-item "><a href="../../ts/design/language-of-domain.html"><strong aria-hidden="true">2.4.9.</strong> 해당 분야의 용어로 타입 이름 짓기</a></li><li class="chapter-item "><a href="../../ts/design/brands.html"><strong aria-hidden="true">2.4.10.</strong> 공식 명칭에는 상표를 붙이기</a></li></ol></li><li class="chapter-item "><a href="../../ts/any/index.html"><strong aria-hidden="true">2.5.</strong> any 다루기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/any/narrowest-any.html"><strong aria-hidden="true">2.5.1.</strong> any 타입은 가능한 한 좁은 범위에서만 사용하기</a></li><li class="chapter-item "><a href="../../ts/any/specific-any.html"><strong aria-hidden="true">2.5.2.</strong> any를 구체적으로 변형해서 사용하기</a></li><li class="chapter-item "><a href="../../ts/any/hide-unsafe-casts.html"><strong aria-hidden="true">2.5.3.</strong> 함수 안으로 타입 단언문 감추기</a></li><li class="chapter-item "><a href="../../ts/any/evolving-any.html"><strong aria-hidden="true">2.5.4.</strong> any의 진화를 이해하기</a></li><li class="chapter-item "><a href="../../ts/any/never-unknown.html"><strong aria-hidden="true">2.5.5.</strong> 모르는 타입의 값에는 any 대신 unknown을 사용하기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.</strong> React</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../react/why.html"><strong aria-hidden="true">3.1.</strong> 왜 React인가?</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> Redux</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../redux/pure.html"><strong aria-hidden="true">4.1.</strong> 왜 Reducer는 순수해야 하는가?</a></li></ol></li><li class="chapter-item "><a href="../../svelte/intro.html"><strong aria-hidden="true">5.</strong> Svelte</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../svelte/reactivity.html"><strong aria-hidden="true">5.1.</strong> Reactivity</a></li><li class="chapter-item "><a href="../../svelte/props.html"><strong aria-hidden="true">5.2.</strong> Props</a></li><li class="chapter-item "><a href="../../svelte/logic.html"><strong aria-hidden="true">5.3.</strong> Logic</a></li><li class="chapter-item "><a href="../../svelte/events.html"><strong aria-hidden="true">5.4.</strong> Events</a></li><li class="chapter-item "><a href="../../svelte/bindings.html"><strong aria-hidden="true">5.5.</strong> Bindings</a></li><li class="chapter-item "><a href="../../svelte/lifecycle.html"><strong aria-hidden="true">5.6.</strong> Life Cycle</a></li><li class="chapter-item "><a href="../../svelte/stores.html"><strong aria-hidden="true">5.7.</strong> Stores</a></li><li class="chapter-item "><a href="../../svelte/motion.html"><strong aria-hidden="true">5.8.</strong> Motion</a></li><li class="chapter-item "><a href="../../svelte/transition.html"><strong aria-hidden="true">5.9.</strong> Transitions</a></li><li class="chapter-item "><a href="../../svelte/animations.html"><strong aria-hidden="true">5.10.</strong> Animations</a></li><li class="chapter-item "><a href="../../svelte/actions.html"><strong aria-hidden="true">5.11.</strong> Actions</a></li><li class="chapter-item "><a href="../../svelte/classes.html"><strong aria-hidden="true">5.12.</strong> Classes</a></li><li class="chapter-item "><a href="../../svelte/composition.html"><strong aria-hidden="true">5.13.</strong> Component Composition</a></li><li class="chapter-item "><a href="../../svelte/context.html"><strong aria-hidden="true">5.14.</strong> Context API</a></li><li class="chapter-item "><a href="../../svelte/specials.html"><strong aria-hidden="true">5.15.</strong> Special Elements</a></li><li class="chapter-item "><a href="../../svelte/module.html"><strong aria-hidden="true">5.16.</strong> Module Context</a></li><li class="chapter-item "><a href="../../svelte/debug.html"><strong aria-hidden="true">5.17.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="../../graphql/intro.html"><strong aria-hidden="true">6.</strong> GraphQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../graphql/execution.html"><strong aria-hidden="true">6.1.</strong> Execution</a></li><li class="chapter-item "><a href="../../graphql/query-mutation.html"><strong aria-hidden="true">6.2.</strong> Query &amp; Mutation</a></li><li class="chapter-item "><a href="../../graphql/schema-type.html"><strong aria-hidden="true">6.3.</strong> Schema &amp; Type</a></li><li class="chapter-item "><a href="../../graphql/pagination.html"><strong aria-hidden="true">6.4.</strong> Pagination</a></li><li class="chapter-item "><a href="../../graphql/http.html"><strong aria-hidden="true">6.5.</strong> HTTP에서의 GraphQL</a></li></ol></li><li class="chapter-item "><a href="../../docker/setup.html"><strong aria-hidden="true">7.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docker/sample.html"><strong aria-hidden="true">7.1.</strong> 샘플 애플리케이션</a></li><li class="chapter-item "><a href="../../docker/update.html"><strong aria-hidden="true">7.2.</strong> 애플리케이션 수정</a></li><li class="chapter-item "><a href="../../docker/share.html"><strong aria-hidden="true">7.3.</strong> 애플리케이션 공유</a></li><li class="chapter-item "><a href="../../docker/persist.html"><strong aria-hidden="true">7.4.</strong> DB 유지</a></li><li class="chapter-item "><a href="../../docker/bind-mounts.html"><strong aria-hidden="true">7.5.</strong> Bind Mounts</a></li><li class="chapter-item "><a href="../../docker/multi.html"><strong aria-hidden="true">7.6.</strong> 멀티 컨테이너 앱</a></li><li class="chapter-item "><a href="../../docker/docker-compose.html"><strong aria-hidden="true">7.7.</strong> Docker Compose</a></li><li class="chapter-item "><a href="../../docker/best-practices.html"><strong aria-hidden="true">7.8.</strong> 실전 이미지 빌딩</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> Etc.</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../etc/ssh.html"><strong aria-hidden="true">8.1.</strong> SSH</a></li><li class="chapter-item "><a href="../../etc/tdd.html"><strong aria-hidden="true">8.2.</strong> TDD</a></li><li class="chapter-item "><a href="../../etc/fp.html"><strong aria-hidden="true">8.3.</strong> 함수형 프로그래밍</a></li><li class="chapter-item "><a href="../../etc/rp.html"><strong aria-hidden="true">8.4.</strong> 반응형 프로그래밍</a></li></ol></li><li class="chapter-item "><a href="../../ml/index.html"><strong aria-hidden="true">9.</strong> Machine Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/problem-framing/index.html"><strong aria-hidden="true">9.1.</strong> Problem Framing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/problem-framing/common-problems.html"><strong aria-hidden="true">9.1.1.</strong> Common ML Problems</a></li><li class="chapter-item "><a href="../../ml/problem-framing/mindset.html"><strong aria-hidden="true">9.1.2.</strong> The ML Mindset</a></li><li class="chapter-item "><a href="../../ml/problem-framing/good.html"><strong aria-hidden="true">9.1.3.</strong> Identifying Good Problems for ML</a></li><li class="chapter-item "><a href="../../ml/problem-framing/hard.html"><strong aria-hidden="true">9.1.4.</strong> Hard ML Problems</a></li><li class="chapter-item "><a href="../../ml/problem-framing/framing.html"><strong aria-hidden="true">9.1.5.</strong> Deciding on ML</a></li><li class="chapter-item "><a href="../../ml/problem-framing/formulate.html"><strong aria-hidden="true">9.1.6.</strong> Formulate Your Problem as an ML Problem</a></li></ol></li><li class="chapter-item "><a href="../../ml/crash-course/index.html"><strong aria-hidden="true">9.2.</strong> Crash Course</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/crash-course/framing.html"><strong aria-hidden="true">9.2.1.</strong> Framing</a></li><li class="chapter-item "><a href="../../ml/crash-course/descending-into-ml.html"><strong aria-hidden="true">9.2.2.</strong> Descending into ML</a></li><li class="chapter-item "><a href="../../ml/crash-course/reducing-loss.html"><strong aria-hidden="true">9.2.3.</strong> Reducing Loss</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shubi Docs</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="custom-element-checklist"><a class="header" href="#custom-element-checklist">Custom Element CheckList</a></h1>
<blockquote>
<p>출처 : <a href="https://developers.google.com/web/fundamentals/web-components/best-practices?authuser=0">Google Developers</a></p>
</blockquote>
<p>커스텀 요소들은 HTML을 확장하여 본인 스스로의 태그를 갖게 해준다. 해당 기능은 어마어마하지만, 저수준의 기능이기도 해서, 어떻게 활용하는 것이 제일 좋은지 불명확한 경우가 많다.</p>
<p>커스텀 요소를 최적으로 활용하기 위해 해당 체크리스트를 확인하자. 제대로 동작하는 커스텀 요소들을 구성하는 내용들을 나눈 것이다.</p>
<h2 id="체크리스트"><a class="header" href="#체크리스트">체크리스트</a></h2>
<h3 id="shadow-dom"><a class="header" href="#shadow-dom"><strong>Shadow DOM</strong></a></h3>
<ul>
<li>
<p>스타일을 캡슐화하기 위해 섀도우 루트를 생성하라</p>
<blockquote>
<p>섀도우 루트에 스타일링을 캡슐화 시키는 것은 어디에서 해당 요소가 사용되든 해당 스타일링이 적용될 것을 보장한다.</p>
</blockquote>
</li>
<li>
<p>섀도우 루트는 <code>constructor</code> 내에서 생성하라</p>
<blockquote>
<p><code>constuctor</code>는 요소 본인에 관한 지식들을 보관하는 곳이다. 따라서 여기에는 다른 요소들을 활용하지 않는 구현 디테일들을 설정하기 적절하다. <br/> 만약, <code>connectedCallback</code>에서 이런 내용들을 수행하면, 요소가 분리/연결되는 경우의 상황을 고려해야 한다.</p>
</blockquote>
</li>
<li>
<p>커스텀 요소가 생성하는 하위 요소들은 섀도우 루트 안에 넣어라</p>
<blockquote>
<p>커스텀 요소에 의해 생성된 자식들은 <code>private</code>해야한다. 만약 섀도우 루트의 보호가 없다면, 해당 자식 요소들은 외부 JS에 의해 간섭받을 수 있다.</p>
</blockquote>
</li>
<li>
<p>light DOM에서의 자식들을 반영하기 위해 <code>&lt;slot&gt;</code>을 사용해라</p>
<blockquote>
<p><code>&lt;slot&gt;</code>을 활용하면 커스텀 요소가 담고 있는 요소들을 이용자들이 지정하기 편하게 만들 수 있다.</p>
</blockquote>
</li>
<li>
<p>기본적으로 <code>inline</code>으로 설정된 스타일링을 원하는 게 아니라면, <code>:host</code>의 <code>display</code> 스타일을 변경하라.</p>
</li>
</ul>
<blockquote>
<p>기본적으로 커스텀요소는 <code>display: inline</code> 설정을 갖는다. 따라서 단순히 <code>width</code>나 <code>height</code>를 설정하는 것은 아무 영향도 없다. 만약, 애초에 <code>inline</code> 디스플레이 설정을 의도하는 게 아니라면, 적절히 변경하라.</p>
</blockquote>
<ul>
<li><code>hidden</code> 속성에 대응하기 위한 <code>:host</code> 디스플레이 스타일을 추가하라
<blockquote>
<p>섀도우 루트에서 <code>:host</code>로 스타일링을 하게되면 이는 HTML 자체적인 <code>hidden</code> 속성을 덮어씌우게 된다. 때문에, <code>:host([hidden]) { display: none }</code>와 같은 식으로, <code>hidden</code>속성을 갖고 있는 경우에 대해 적절한 스타일링 처리가 필요하다.</p>
</blockquote>
</li>
</ul>
<h3 id="속성attributes와-프로퍼티"><a class="header" href="#속성attributes와-프로퍼티"><strong>속성(Attributes)와 프로퍼티</strong></a></h3>
<ul>
<li>글로벌 속성(global attributes)들을 덮어쓰지(override) 말아라
<blockquote>
<p>글로벌 속성들은 모든 HTML 요소들에 존재하는 것이다. 예를 들면 <code>tabindex</code>와 <code>role</code>이 이에 해당한다. 커스텀 요소가 기본적으로 <code>tabindex</code>를 0으로 초기화하게끔 설정하고 싶을 수도 있다. 그러나 항상 해당 커스텀 요소를 사용하는 개발자가 이를 다른 값으로 설정할 수 있음을 유의해라. 때문에 아래와 같은 체크가 필요하다.</p>
</blockquote>
</li>
</ul>
<pre><code class="language-js">connectedCallback() {
  if (!this.hasAttribute('role'))
    this.setAttribute('role', 'checkbox');
  if (!this.hasAttribute('tabindex'))
    this.setAttribute('tabindex', 0);
</code></pre>
<ul>
<li>
<p>항상 원시(primitive) 데이터들을 속성 혹은 프로퍼티 모두로 가져올 수 있게 하라.</p>
<blockquote>
<p>커스텀 요소들은 수정가능해야 한다. 그리고 이러한 수정은 속성 혹은 프로퍼티 어느쪽으로든 적절히 이루어질 수 있어야 한다. 결국, 이상적으로 모든 원시 속성들은 프로퍼티와 연결되어 있어야 한다.</p>
</blockquote>
</li>
<li>
<p>원시 데이터 속성과 프로퍼티들을 항상 동기화(sync)시키도록 해라. 프로퍼티는 속성에 반영되어야하고, 반대도 마찬가지다.</p>
<blockquote>
<p>요소를 활용하는 사람들이 어떤 식으로 해당 요소와 상호작용 할지는 알 수 없다. 때문에 속성과 프로퍼티가 서로를 항상 반영하도록 해야한다. 물론 예외도 존재한다. 비디오 플레이어의 <code>currentTime</code>과 같은 너무 변경 빈도가 잦은 프로퍼티는 매번 속성에 반영하는 것이 부적절하다.</p>
</blockquote>
</li>
<li>
<p>Object, Array와 같은 리치 데이터(rich data)들은 프로퍼티로만 받아와라</p>
<blockquote>
<p>사실,애초에 내장 HTML 요소에서 속성을 통해 이러한 류의 데이터를 받아들이는 예시 자체가 없다. 대신에 이런 데이터들은 메서드 호출이나 프로퍼티를 통해서 전달된다. 만약, 굳이 이들을 속성으로 전달하고자 하는 경우, 명확한 단점들이 몇가지 있다. 1) 거대한 객체를 문자열로 직렬화(Serialize)하는데에 너무 많은 비용이 들고, 2) 또한 이 문자열화(Stringify) 과정에서 객체에 대한 참조가 사라질 수도 있다.</p>
</blockquote>
</li>
<li>
<p>요소를 업그레이드하기 이전에, 이미 설정되었을지도 모르는 프로퍼티를 체크해봐라</p>
<blockquote>
<p>커스텀 요소를 활용하는 개발자들이 해당 요소를 불러오기 이전에 먼저 프로퍼티를 설정할지도 모른다. 이런 상황은 종종 로딩 컴포넌트를 핸들링하거나, 해당 컴포넌트를 페이지에 찍어내거나, 해당 프로퍼티를 모델에 바인딩하는 프레임워크를 사용하거나 할 때 종종 발생한다.</p>
</blockquote>
</li>
<li>
<p>클래스를 자동으로 적용시키지 마라</p>
<blockquote>
<p>요소들은 본인의 상태를 속성을 통해서 나타내야 한다. <code>class</code> 속성을 해당 요소를 사용하는 개발자들에 의한 것으로 간주되어야 하며, 이를 임의로 자동으로 설정하는 경우 개발자들의 <code>class</code> 관리를 망쳐버릴 수 있다.</p>
</blockquote>
</li>
</ul>
<h3 id="events"><a class="header" href="#events"><strong>Events</strong></a></h3>
<ul>
<li>내부 컴포넌트 활동에 따라 적절히 이벤트를 디스패치하라
<blockquote>
<p>오직 컴포넌트 본인만 알 수 있는 활동이 있을 수 있다. 이를테면 타이머나 애니메이션 완료, 혹은 로딩이 완료되는 시점과 같은 것들이다. 이러한 변화에 따라, 호스트에게 해당 컴포넌트의 상태가 변경되었음을 알려주게끔 이벤트를 전달하는 것이 좋다.</p>
</blockquote>
</li>
<li>프로퍼티 설정에 대해서는 별도로 이벤트를 디스패치할 필요없다.
<blockquote>
<p>호스트가 프로퍼티를 설정한 내용에 대해 이벤트를 전달하는 것은 불필요하다. 호스트가 직접 설정한 내용이기 때문에 현재 상태를 직접 인지할 수 있기 때문이다. 또한, 호스트가 프로퍼티를 설정한 것에 대한 반응으로 이벤트를 전달하는 경우, 데이터 바인딩과 함께 무한 루프를 유발할 수 있다.</p>
</blockquote>
</li>
</ul>
<h2 id="explainers"><a class="header" href="#explainers"><strong>Explainers</strong></a></h2>
<h3 id="프로퍼티를-lazy하게-만들어라"><a class="header" href="#프로퍼티를-lazy하게-만들어라">프로퍼티를 Lazy하게 만들어라</a></h3>
<p>개발자가 커스텀 요소를 불러오기 전에 먼저 프로퍼티를 설정하고자 할 수도 있다. 이는 로딩 컴포넌트를 다루는 프레임워크 등에서 특히 이루어진다.</p>
<p>아래 예시에서는, Angular가 <code>isChecked</code> 프로퍼티를 체크박스의 <code>checked</code> 프로퍼티에 바인딩하려고 한다. 만약 해당 커스텀 요소가 <strong>lazy-load</strong>된다면 Angular는 요소가 업그레이드되기 이전에 먼저 <code>checked</code>프로퍼티를 설정할 수 있을 것이다.</p>
<pre><code class="language-html">&lt;howto-checkbox [checked]=&quot;defaults.isChecked&quot;&gt;&lt;/howto-checkbox&gt;
</code></pre>
<p>커스텀 요소는 본인의 인스턴스에 어떤 요소가 이미 설정되어 있는지에 대해 확인함으로써 이러한 경우를 다룰 수 있다. 아래에서 <code>_upgradeProperty()</code> 메서드가 그러한 역할을 한다.</p>
<pre><code class="language-js">connectedCallback() {
  ...
  this._upgradeProperty('checked');
}

_upgradeProperty(prop) {
  if (this.hasOwnProperty(prop)) {
    let value = this[prop];
    delete this[prop];
    this[prop] = value;
  }
}
</code></pre>
<p><code>_upgradeProperty()</code>는 업그레이드되지 않은 인스턴스로부터 값을 가져온 후, 프로퍼티를 삭제하여 커스텀 요소가 자체적인 프로퍼티 <code>setter</code>를 사용하지 않도록 만든다. 이를 통해, 커스텀 요소가 최종적으로 로드되었을 때, 곧바로 수정된 상태를 반영할 수 있도록 만든다.</p>
<h3 id="재방문-이슈reentrancy-issues를-피해라"><a class="header" href="#재방문-이슈reentrancy-issues를-피해라">재방문 이슈(reentrancy issues)를 피해라</a></h3>
<p><code>attributeChangeCallback()</code>을 사용하여 상태를 기본 프로퍼티에 반영되도록 하자.</p>
<pre><code class="language-js">// When the [checked] attribute changes, set the checked property to match.
attributeChangedCallback(name, oldValue, newValue) {
  if (name === 'checked')
    this.checked = newValue;
}
</code></pre>
<p>헌데, 프로퍼티 설정자가 속성에도 반영되는 경우 무한 루프를 만들어내는 문제가 발생한다.</p>
<pre><code class="language-js">set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    // OOPS! This will cause an infinite loop because it triggers the
    // attributeChangedCallback() which then sets this property again.
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}
</code></pre>
<p>이에 대한 대안으로, 프로퍼티에 대한 setter와 getter를 모두 만들어 getter가 속성에 따라 값을 결정하도록 할 수 있다.</p>
<pre><code class="language-js">set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}

get checked() {
  return this.hasAttribute('checked');
}
</code></pre>
<p>이제, 속성을 삭제하거나 추가하는 작업은 프로퍼티에도 영향을 미칠 것이다.</p>
<p>끝으로, <code>attributeChangedCallback()</code>는 ARIA 상태를 적용하는 것과 같은 사이드 이펙트를 처리하는 데에 사용해라.</p>
<pre><code class="language-JS">attributeChangedCallback(name, oldValue, newValue) {
  const hasValue = newValue !== null;
  switch (name) {
    case 'checked':
      // Note the attributeChangedCallback is only handling the *side effects*
      // of setting the attribute.
      this.setAttribute('aria-checked', hasValue);
      break;
    ...
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../js/guides/render-opt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../ts/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../js/guides/render-opt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../ts/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>

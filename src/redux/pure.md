# 왜 Reducer는 순수해야 하는가?

[여기](https://medium.com/free-code-camp/why-redux-needs-reducers-to-be-pure-functions-d438c58ae468)의 글을 참조했습니다.

Redux는 상태의 변경에 있어서 Reducer를 사용합니다. 그런데 이 Reducer는 아시다시피 기본적으로 **순수함수**입니다. 동일한 Input이 있다면, 항상 동일한 Output을 반환해야 합니다. 이는 다시 말해, 해당 함수가 항상 Immutable하게 동작해야 한다는 뜻이죠.

<img src="https://miro.medium.com/max/700/1*BojNgnfwqAXdqJSsuNf0Sg.png" />

다만, 단순히 생각해볼 때, 얼핏 이는 비효율적으로 보이기도 하죠. 왜 해당 상태를 직접 변경하지 않는 걸까요? 훨씬 더 간편할텐데요.

이는 기본적으로, Redux가 상태의 변경을 감지할 때, "**얕은 비교**"를 하기 때문입니다. 만약에 어떤 변화가 생겼다면, 해당 리듀서로부터 아예 새로운 객체를 반환받을 것이라 생각하는 것이죠.

그래서, Redux는 왜 이런 식으로 구현되어 있을까요?

사실, 답은 간단합니다. 이는 객체의 변화를 깊은 비교를 통해 감지하는 것보다 **훨씬 빠르기 때문입니다.** 만약 JS의 두 객체가 같은 프로퍼티를 가졌는지에 대해 판단하기 위해서는, 깊은 비교를 통해서 각각의 프로퍼티를 일일이 비교해나가야 합니다. 그런데 이 과정은 실제 애플리케이션에서는 굉장히 비용이 많이 드는 과정이죠. 이는 특히 애플리케이션의 규모가 커져 관리해야할 상태가 늘어나게 되면 더더욱 두드러집니다.

그래서 이를 대체하기 위한 방법으로, **개발자는 상태 변화가 생기면 매번 새로운 객체를 만들어 반환해줘야 한다.**라는 하나의 규칙이 Redux에 생겨난 것입니다. 만약 변화가 없다면, 기존의 객체를 반환하면 되는 것이죠. 다시 말해, 새로운 객체는 곧 새로운 상태를 의미합니다.

이러한 규칙이 존재한다면, Redux가 상태의 변화를 감지하는 것이 굉장히 쉬워집니다. 아시다시피 객체의 참조에 대한 비교는 직접 새로운 비교 알고리즘을 구현하지 않더라도 `!==` 만으로 쉽게 처리할 수 있거든요.

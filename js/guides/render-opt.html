<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>렌더링 최적화 - Shubi Docs</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.</strong> Web</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../web/web-performance/index.html"><strong aria-hidden="true">1.1.</strong> 웹 성능 최적화 기법</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../web/web-performance/what-is-web-performance.html"><strong aria-hidden="true">1.1.1.</strong> 웹 성능이란 무엇인가?</a></li><li class="chapter-item "><a href="../../web/web-performance/web-optimization.html"><strong aria-hidden="true">1.1.2.</strong> 웹 최적화</a></li><li class="chapter-item "><a href="../../web/web-performance/basic-optimization.html"><strong aria-hidden="true">1.1.3.</strong> 웹 사이트 성능을 개선하는 기본적인 방법</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../js/index.html"><strong aria-hidden="true">2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/exec-ctx.html"><strong aria-hidden="true">2.1.</strong> 실행 컨텍스트</a></li><li class="chapter-item "><a href="../../js/class.html"><strong aria-hidden="true">2.2.</strong> 클래스</a></li><li class="chapter-item "><a href="../../js/arrow-func.html"><strong aria-hidden="true">2.3.</strong> 화살표 함수</a></li><li class="chapter-item "><a href="../../js/binding-function.html"><strong aria-hidden="true">2.4.</strong> 함수 바인딩</a></li><li class="chapter-item "><a href="../../js/call-apply.html"><strong aria-hidden="true">2.5.</strong> call, apply</a></li><li class="chapter-item "><a href="../../js/closure.html"><strong aria-hidden="true">2.6.</strong> 클로저</a></li><li class="chapter-item "><a href="../../js/func-exp-and-dec.html"><strong aria-hidden="true">2.7.</strong> 함수 표현식 vs 함수 선언문</a></li><li class="chapter-item "><a href="../../js/event-loop.html"><strong aria-hidden="true">2.8.</strong> 이벤트 루프</a></li><li class="chapter-item "><a href="../../js/new.html"><strong aria-hidden="true">2.9.</strong> new와 생성자 함수</a></li><li class="chapter-item "><a href="../../js/properties.html"><strong aria-hidden="true">2.10.</strong> 프로퍼티</a></li><li class="chapter-item "><a href="../../js/prototype.html"><strong aria-hidden="true">2.11.</strong> 프로토타입</a></li><li class="chapter-item "><a href="../../js/this.html"><strong aria-hidden="true">2.12.</strong> this</a></li><li class="chapter-item "><a href="../../js/var.html"><strong aria-hidden="true">2.13.</strong> var를 쓰지 않는 이유</a></li><li class="chapter-item "><a href="../../js/babel.html"><strong aria-hidden="true">2.14.</strong> Babel</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.15.</strong> Web APIs</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/web-api/intersection.html"><strong aria-hidden="true">2.15.1.</strong> Intersection Observer</a></li><li class="chapter-item "><a href="../../js/web-api/mutation.html"><strong aria-hidden="true">2.15.2.</strong> Mutation Observer</a></li><li class="chapter-item "><a href="../../js/web-api/template.html"><strong aria-hidden="true">2.15.3.</strong> Template Element</a></li><li class="chapter-item "><a href="../../js/web-api/shadow-dom/intro.html"><strong aria-hidden="true">2.15.4.</strong> Shadow DOM</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/web-api/shadow-dom/slot.html"><strong aria-hidden="true">2.15.4.1.</strong> Slot</a></li><li class="chapter-item "><a href="../../js/web-api/shadow-dom/styling.html"><strong aria-hidden="true">2.15.4.2.</strong> Styling</a></li><li class="chapter-item "><a href="../../js/web-api/shadow-dom/events.html"><strong aria-hidden="true">2.15.4.3.</strong> Events</a></li></ol></li><li class="chapter-item "><a href="../../js/web-api/canvas/intro.html"><strong aria-hidden="true">2.15.5.</strong> Canvas API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../js/web-api/canvas/shapes.html"><strong aria-hidden="true">2.15.5.1.</strong> 도형 그리기</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.16.</strong> Guides</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../js/guides/render-opt.html" class="active"><strong aria-hidden="true">2.16.1.</strong> 렌더링 최적화</a></li><li class="chapter-item "><a href="../../js/guides/custom-el-checklist.html"><strong aria-hidden="true">2.16.2.</strong> Custom Element 체크리스트</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../ts/index.html"><strong aria-hidden="true">3.</strong> TypeScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/intro/index.html"><strong aria-hidden="true">3.1.</strong> 타입스크립트 알아보기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/intro/ts_js.html"><strong aria-hidden="true">3.1.1.</strong> TS와 JS의 관계</a></li><li class="chapter-item "><a href="../../ts/intro/setting.html"><strong aria-hidden="true">3.1.2.</strong> TS 설정 이해하기</a></li><li class="chapter-item "><a href="../../ts/intro/transpile.html"><strong aria-hidden="true">3.1.3.</strong> 코드 생성과 타입이 관계없음을 이해하기</a></li><li class="chapter-item "><a href="../../ts/intro/typing.html"><strong aria-hidden="true">3.1.4.</strong> 구조적 타이핑에 익숙해지기</a></li><li class="chapter-item "><a href="../../ts/intro/no_any.html"><strong aria-hidden="true">3.1.5.</strong> any 타입 지양하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/types/index.html"><strong aria-hidden="true">3.2.</strong> 타입스크립트의 타입 시스템</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/types/use_editor.html"><strong aria-hidden="true">3.2.1.</strong> 편집기를 사용하여 타입 시스템 탐색하기</a></li><li class="chapter-item "><a href="../../ts/types/set.html"><strong aria-hidden="true">3.2.2.</strong> 타입이 값들의 집합이라고 생각하기</a></li><li class="chapter-item "><a href="../../ts/types/symbol.html"><strong aria-hidden="true">3.2.3.</strong> 타입 공간과 값 공간의 심벌 구분하기</a></li><li class="chapter-item "><a href="../../ts/types/type-def.html"><strong aria-hidden="true">3.2.4.</strong> 타입 단언보다는 타입 선언을 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/wrapper.html"><strong aria-hidden="true">3.2.5.</strong> 객체 래퍼 타입 피하기</a></li><li class="chapter-item "><a href="../../ts/types/excess-type-check.html"><strong aria-hidden="true">3.2.6.</strong> 잉여 속성 체크의 한계 인지하기</a></li><li class="chapter-item "><a href="../../ts/types/function-expression.html"><strong aria-hidden="true">3.2.7.</strong> 함수 표현식에 타입 적용하기</a></li><li class="chapter-item "><a href="../../ts/types/type-and-interface.html"><strong aria-hidden="true">3.2.8.</strong> 타입과 인터페이스의 차이점 알기</a></li><li class="chapter-item "><a href="../../ts/types/generics.html"><strong aria-hidden="true">3.2.9.</strong> 타입 연산과 제너릭 사용으로 반복 줄이기</a></li><li class="chapter-item "><a href="../../ts/types/index-signature.html"><strong aria-hidden="true">3.2.10.</strong> 동적 데이터에 인덱스 시그니처 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/no-index-signature.html"><strong aria-hidden="true">3.2.11.</strong> number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/readonly.html"><strong aria-hidden="true">3.2.12.</strong> 변경 관련된 오류 방지를 위해 readonly 사용하기</a></li><li class="chapter-item "><a href="../../ts/types/mapped-type.html"><strong aria-hidden="true">3.2.13.</strong> 매핑된 타입을 사용하여 값을 동기화하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/type-inference/index.html"><strong aria-hidden="true">3.3.</strong> 타입 추론</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/type-inference/use-inferable-types.html"><strong aria-hidden="true">3.3.1.</strong> 추론 가능한 타입을 사용해 장황한 코드 방지하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/use-const.html"><strong aria-hidden="true">3.3.2.</strong> 다른 타입에는 다른 변수 사용하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/type-widening.html"><strong aria-hidden="true">3.3.3.</strong> 타입 넓히기</a></li><li class="chapter-item "><a href="../../ts/type-inference/type-narrowing.html"><strong aria-hidden="true">3.3.4.</strong> 타입 좁히기</a></li><li class="chapter-item "><a href="../../ts/type-inference/create-object-at-once.html"><strong aria-hidden="true">3.3.5.</strong> 한꺼번에 객체 생성하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/avoid-aliasing.html"><strong aria-hidden="true">3.3.6.</strong> 일관성있는 별칭 사용하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/use-async.html"><strong aria-hidden="true">3.3.7.</strong> 비동기 코드에는 콜백 대신 async 함수 사용하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/context-inference.html"><strong aria-hidden="true">3.3.8.</strong> 타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></li><li class="chapter-item "><a href="../../ts/type-inference/well-typed-lib.html"><strong aria-hidden="true">3.3.9.</strong> 함수형 기법과 라이브러리로 타입 흐름 유지하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/design/index.html"><strong aria-hidden="true">3.4.</strong> 타입 설계</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/design/valid-states.html"><strong aria-hidden="true">3.4.1.</strong> 유효한 상태만 표현하는 타입을 지향하기</a></li><li class="chapter-item "><a href="../../ts/design/loose-accept-strict-produce.html"><strong aria-hidden="true">3.4.2.</strong> 사용할 때는 너그럽게, 생성할 때는 엄격하게</a></li><li class="chapter-item "><a href="../../ts/design/jsdoc-repeat.html"><strong aria-hidden="true">3.4.3.</strong> 문서에 타입 정보를 쓰지 않기</a></li><li class="chapter-item "><a href="../../ts/design/null-values-to-perimeter.html"><strong aria-hidden="true">3.4.4.</strong> 타입 주변에 null값 배치하기</a></li><li class="chapter-item "><a href="../../ts/design/union-of-interfaces.html"><strong aria-hidden="true">3.4.5.</strong> 유니온의 인터페이스보다는 인터페이스의 유니온 사용하기</a></li><li class="chapter-item "><a href="../../ts/design/avoid-strings.html"><strong aria-hidden="true">3.4.6.</strong> string 타입보다 더 구체적인 타입 사용하기</a></li><li class="chapter-item "><a href="../../ts/design/incomplete-over-innacurate.html"><strong aria-hidden="true">3.4.7.</strong> 부정확한 타입보다는 미완성 타입을 사용하기</a></li><li class="chapter-item "><a href="../../ts/design/consider-codegen.html"><strong aria-hidden="true">3.4.8.</strong> 데이터가 아닌, API와 명세를 보고 타입 만들기</a></li><li class="chapter-item "><a href="../../ts/design/language-of-domain.html"><strong aria-hidden="true">3.4.9.</strong> 해당 분야의 용어로 타입 이름 짓기</a></li><li class="chapter-item "><a href="../../ts/design/brands.html"><strong aria-hidden="true">3.4.10.</strong> 공식 명칭에는 상표를 붙이기</a></li></ol></li><li class="chapter-item "><a href="../../ts/any/index.html"><strong aria-hidden="true">3.5.</strong> any 다루기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/any/narrowest-any.html"><strong aria-hidden="true">3.5.1.</strong> any 타입은 가능한 한 좁은 범위에서만 사용하기</a></li><li class="chapter-item "><a href="../../ts/any/specific-any.html"><strong aria-hidden="true">3.5.2.</strong> any를 구체적으로 변형해서 사용하기</a></li><li class="chapter-item "><a href="../../ts/any/hide-unsafe-casts.html"><strong aria-hidden="true">3.5.3.</strong> 함수 안으로 타입 단언문 감추기</a></li><li class="chapter-item "><a href="../../ts/any/evolving-any.html"><strong aria-hidden="true">3.5.4.</strong> any의 진화를 이해하기</a></li><li class="chapter-item "><a href="../../ts/any/never-unknown.html"><strong aria-hidden="true">3.5.5.</strong> 모르는 타입의 값에는 any 대신 unknown을 사용하기</a></li><li class="chapter-item "><a href="../../ts/any/type-safe-monkey.html"><strong aria-hidden="true">3.5.6.</strong> 몽키 패치보다는 안전한 타입을 사용하기</a></li><li class="chapter-item "><a href="../../ts/any/type-percentage.html"><strong aria-hidden="true">3.5.7.</strong> 타입 커버리지를 추적하여 타입 안정성 유지하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/declarations/index.html"><strong aria-hidden="true">3.6.</strong> 타입 선언과 @types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/declarations/dev-dependencies.html"><strong aria-hidden="true">3.6.1.</strong> devDependencies에 typescript와 @types 추가하기</a></li><li class="chapter-item "><a href="../../ts/declarations/understand-ts-types.html"><strong aria-hidden="true">3.6.2.</strong> 타입 선언과 관련된 세 가지 버전 이해하기</a></li><li class="chapter-item "><a href="../../ts/declarations/export-your-types.html"><strong aria-hidden="true">3.6.3.</strong> 공개 API에 등장하는 모든 타입을 export하기</a></li><li class="chapter-item "><a href="../../ts/declarations/use-tsdoc.html"><strong aria-hidden="true">3.6.4.</strong> API 주석에 TSDoc 사용하기</a></li><li class="chapter-item "><a href="../../ts/declarations/this-in-callbacks.html"><strong aria-hidden="true">3.6.5.</strong> 콜백에서 this에 대한 타입 제공하기</a></li><li class="chapter-item "><a href="../../ts/declarations/conditional-overload.html"><strong aria-hidden="true">3.6.6.</strong> 오버로딩 타입보다는 조건부 타입을 사용하기</a></li><li class="chapter-item "><a href="../../ts/declarations/mirror-types-for-deps.html"><strong aria-hidden="true">3.6.7.</strong> 의존성 분리를 위해 미러 타입 사용하기</a></li><li class="chapter-item "><a href="../../ts/declarations/test-your-types.html"><strong aria-hidden="true">3.6.8.</strong> 테스팅 타입의 함정에 주의하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/write-run/index.html"><strong aria-hidden="true">3.7.</strong> 코드를 작성하고 실행하기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/write-run/avoid-non-ecma.html"><strong aria-hidden="true">3.7.1.</strong> 타입스크립트 기능보다는 ECMASCript 기능을 사용하기</a></li><li class="chapter-item "><a href="../../ts/write-run/iterate-objects.html"><strong aria-hidden="true">3.7.2.</strong> 객체를 순회하는 노하우</a></li><li class="chapter-item "><a href="../../ts/write-run/understand-the-dom.html"><strong aria-hidden="true">3.7.3.</strong> DOM 계층 구조 이해하기</a></li><li class="chapter-item "><a href="../../ts/write-run/private-rely.html"><strong aria-hidden="true">3.7.4.</strong> 정보를 감추는 목적으로 private 사용하지 않기</a></li><li class="chapter-item "><a href="../../ts/write-run/source-maps-debug.html"><strong aria-hidden="true">3.7.5.</strong> 소스맵을 사용하여 타입스크립트 디버깅하기</a></li></ol></li><li class="chapter-item "><a href="../../ts/migrate/index.html"><strong aria-hidden="true">3.8.</strong> 타입스크립트로 마이그레이션하기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ts/migrate/write-modern-js.html"><strong aria-hidden="true">3.8.1.</strong> 모던 자바스크립트로 작성하기</a></li><li class="chapter-item "><a href="../../ts/migrate/jsdoc-tscheck.html"><strong aria-hidden="true">3.8.2.</strong> 타입스크립트 도입 전에 @ts-check와 JsDoc으로 시험해 보기</a></li><li class="chapter-item "><a href="../../ts/migrate/allow-js.html"><strong aria-hidden="true">3.8.3.</strong> allowJs로 타입스크립트와 자바스크립트 같이 사용하기</a></li><li class="chapter-item "><a href="../../ts/migrate/convert-up-the-graph.html"><strong aria-hidden="true">3.8.4.</strong> 의존성 관계에 따라 모듈 단위로 전환하기</a></li><li class="chapter-item "><a href="../../ts/migrate/start-loose.html"><strong aria-hidden="true">3.8.5.</strong> 마이그레이션의 완성을 위해 noImplicitAny 설정하기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> React</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../react/why.html"><strong aria-hidden="true">4.1.</strong> 왜 React인가?</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> Redux</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../redux/pure.html"><strong aria-hidden="true">5.1.</strong> 왜 Reducer는 순수해야 하는가?</a></li></ol></li><li class="chapter-item "><a href="../../svelte/intro.html"><strong aria-hidden="true">6.</strong> Svelte</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../svelte/reactivity.html"><strong aria-hidden="true">6.1.</strong> Reactivity</a></li><li class="chapter-item "><a href="../../svelte/props.html"><strong aria-hidden="true">6.2.</strong> Props</a></li><li class="chapter-item "><a href="../../svelte/logic.html"><strong aria-hidden="true">6.3.</strong> Logic</a></li><li class="chapter-item "><a href="../../svelte/events.html"><strong aria-hidden="true">6.4.</strong> Events</a></li><li class="chapter-item "><a href="../../svelte/bindings.html"><strong aria-hidden="true">6.5.</strong> Bindings</a></li><li class="chapter-item "><a href="../../svelte/lifecycle.html"><strong aria-hidden="true">6.6.</strong> Life Cycle</a></li><li class="chapter-item "><a href="../../svelte/stores.html"><strong aria-hidden="true">6.7.</strong> Stores</a></li><li class="chapter-item "><a href="../../svelte/motion.html"><strong aria-hidden="true">6.8.</strong> Motion</a></li><li class="chapter-item "><a href="../../svelte/transition.html"><strong aria-hidden="true">6.9.</strong> Transitions</a></li><li class="chapter-item "><a href="../../svelte/animations.html"><strong aria-hidden="true">6.10.</strong> Animations</a></li><li class="chapter-item "><a href="../../svelte/actions.html"><strong aria-hidden="true">6.11.</strong> Actions</a></li><li class="chapter-item "><a href="../../svelte/classes.html"><strong aria-hidden="true">6.12.</strong> Classes</a></li><li class="chapter-item "><a href="../../svelte/composition.html"><strong aria-hidden="true">6.13.</strong> Component Composition</a></li><li class="chapter-item "><a href="../../svelte/context.html"><strong aria-hidden="true">6.14.</strong> Context API</a></li><li class="chapter-item "><a href="../../svelte/specials.html"><strong aria-hidden="true">6.15.</strong> Special Elements</a></li><li class="chapter-item "><a href="../../svelte/module.html"><strong aria-hidden="true">6.16.</strong> Module Context</a></li><li class="chapter-item "><a href="../../svelte/debug.html"><strong aria-hidden="true">6.17.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="../../graphql/intro.html"><strong aria-hidden="true">7.</strong> GraphQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../graphql/execution.html"><strong aria-hidden="true">7.1.</strong> Execution</a></li><li class="chapter-item "><a href="../../graphql/query-mutation.html"><strong aria-hidden="true">7.2.</strong> Query & Mutation</a></li><li class="chapter-item "><a href="../../graphql/schema-type.html"><strong aria-hidden="true">7.3.</strong> Schema & Type</a></li><li class="chapter-item "><a href="../../graphql/pagination.html"><strong aria-hidden="true">7.4.</strong> Pagination</a></li><li class="chapter-item "><a href="../../graphql/http.html"><strong aria-hidden="true">7.5.</strong> HTTP에서의 GraphQL</a></li></ol></li><li class="chapter-item "><a href="../../docker/setup.html"><strong aria-hidden="true">8.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../docker/sample.html"><strong aria-hidden="true">8.1.</strong> 샘플 애플리케이션</a></li><li class="chapter-item "><a href="../../docker/update.html"><strong aria-hidden="true">8.2.</strong> 애플리케이션 수정</a></li><li class="chapter-item "><a href="../../docker/share.html"><strong aria-hidden="true">8.3.</strong> 애플리케이션 공유</a></li><li class="chapter-item "><a href="../../docker/persist.html"><strong aria-hidden="true">8.4.</strong> DB 유지</a></li><li class="chapter-item "><a href="../../docker/bind-mounts.html"><strong aria-hidden="true">8.5.</strong> Bind Mounts</a></li><li class="chapter-item "><a href="../../docker/multi.html"><strong aria-hidden="true">8.6.</strong> 멀티 컨테이너 앱</a></li><li class="chapter-item "><a href="../../docker/docker-compose.html"><strong aria-hidden="true">8.7.</strong> Docker Compose</a></li><li class="chapter-item "><a href="../../docker/best-practices.html"><strong aria-hidden="true">8.8.</strong> 실전 이미지 빌딩</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> Etc.</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../etc/ssh.html"><strong aria-hidden="true">9.1.</strong> SSH</a></li><li class="chapter-item "><a href="../../etc/tdd.html"><strong aria-hidden="true">9.2.</strong> TDD</a></li><li class="chapter-item "><a href="../../etc/fp.html"><strong aria-hidden="true">9.3.</strong> 함수형 프로그래밍</a></li><li class="chapter-item "><a href="../../etc/rp.html"><strong aria-hidden="true">9.4.</strong> 반응형 프로그래밍</a></li></ol></li><li class="chapter-item "><a href="../../ml/index.html"><strong aria-hidden="true">10.</strong> Machine Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/problem-framing/index.html"><strong aria-hidden="true">10.1.</strong> Problem Framing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/problem-framing/common-problems.html"><strong aria-hidden="true">10.1.1.</strong> Common ML Problems</a></li><li class="chapter-item "><a href="../../ml/problem-framing/mindset.html"><strong aria-hidden="true">10.1.2.</strong> The ML Mindset</a></li><li class="chapter-item "><a href="../../ml/problem-framing/good.html"><strong aria-hidden="true">10.1.3.</strong> Identifying Good Problems for ML</a></li><li class="chapter-item "><a href="../../ml/problem-framing/hard.html"><strong aria-hidden="true">10.1.4.</strong> Hard ML Problems</a></li><li class="chapter-item "><a href="../../ml/problem-framing/framing.html"><strong aria-hidden="true">10.1.5.</strong> Deciding on ML</a></li><li class="chapter-item "><a href="../../ml/problem-framing/formulate.html"><strong aria-hidden="true">10.1.6.</strong> Formulate Your Problem as an ML Problem</a></li></ol></li><li class="chapter-item "><a href="../../ml/crash-course/index.html"><strong aria-hidden="true">10.2.</strong> Crash Course</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ml/crash-course/framing.html"><strong aria-hidden="true">10.2.1.</strong> Framing</a></li><li class="chapter-item "><a href="../../ml/crash-course/descending-into-ml.html"><strong aria-hidden="true">10.2.2.</strong> Descending into ML</a></li><li class="chapter-item "><a href="../../ml/crash-course/reducing-loss.html"><strong aria-hidden="true">10.2.3.</strong> Reducing Loss</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">11.</strong> AWS</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../aws/iam.html"><strong aria-hidden="true">11.1.</strong> IAM</a></li><li class="chapter-item "><a href="../../aws/ec2.html"><strong aria-hidden="true">11.2.</strong> EC2</a></li><li class="chapter-item "><a href="../../aws/ami.html"><strong aria-hidden="true">11.3.</strong> AMI</a></li><li class="chapter-item "><a href="../../aws/ebs.html"><strong aria-hidden="true">11.4.</strong> EBS</a></li><li class="chapter-item "><a href="../../aws/efs.html"><strong aria-hidden="true">11.5.</strong> EFS</a></li><li class="chapter-item "><a href="../../aws/ebs-vs-efs.html"><strong aria-hidden="true">11.6.</strong> EBS vs. EFS</a></li><li class="chapter-item "><a href="../../aws/elb.html"><strong aria-hidden="true">11.7.</strong> ELB</a></li><li class="chapter-item "><a href="../../aws/rds.html"><strong aria-hidden="true">11.8.</strong> RDS</a></li><li class="chapter-item "><a href="../../aws/route53.html"><strong aria-hidden="true">11.9.</strong> Route 53</a></li><li class="chapter-item "><a href="../../aws/eb.html"><strong aria-hidden="true">11.10.</strong> Elastic Beanstalk</a></li><li class="chapter-item "><a href="../../aws/s3.html"><strong aria-hidden="true">11.11.</strong> S3</a></li><li class="chapter-item "><a href="../../aws/cf.html"><strong aria-hidden="true">11.12.</strong> CloudFront</a></li><li class="chapter-item "><a href="../../aws/storage-extra.html"><strong aria-hidden="true">11.13.</strong> Storage Extras</a></li><li class="chapter-item "><a href="../../aws/decouple-applications.html"><strong aria-hidden="true">11.14.</strong> Decoupling Applications</a></li><li class="chapter-item "><a href="../../aws/containers.html"><strong aria-hidden="true">11.15.</strong> Containers</a></li><li class="chapter-item "><a href="../../aws/serverless.html"><strong aria-hidden="true">11.16.</strong> Serverless</a></li><li class="chapter-item "><a href="../../aws/databases.html"><strong aria-hidden="true">11.17.</strong> Databases</a></li><li class="chapter-item "><a href="../../aws/data-analytics.html"><strong aria-hidden="true">11.18.</strong> Data & Analytics</a></li><li class="chapter-item "><a href="../../aws/machine-learning.html"><strong aria-hidden="true">11.19.</strong> Machine Learning</a></li><li class="chapter-item "><a href="../../aws/monitoring.html"><strong aria-hidden="true">11.20.</strong> Monitoring & Audit</a></li><li class="chapter-item "><a href="../../aws/iam-advanced.html"><strong aria-hidden="true">11.21.</strong> IAM Advanced</a></li><li class="chapter-item "><a href="../../aws/security.html"><strong aria-hidden="true">11.22.</strong> Security & Encryption</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> Network</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../network/osi-model.html"><strong aria-hidden="true">12.1.</strong> OSI Model</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shubi Docs</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<ul>
<li>해당 md는 <a href="https://developers.google.com/web/fundamentals">여기</a>의 글을 재구성한 것입니다.</li>
</ul>
<h1 id="렌더링-최적화"><a class="header" href="#렌더링-최적화">렌더링 최적화</a></h1>
<h2 id="픽셀-파이프라인"><a class="header" href="#픽셀-파이프라인">픽셀 파이프라인</a></h2>
<img src='https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg' />
<p>위 그림은 작업 시 유의해야하는 5가지 주요 영역이며, 픽셀 - 화면 파이프라인의 핵심 요소이다.</p>
<ul>
<li><strong>JS / CSS</strong> : JS 및 CSS를 통해 이루어지는 시각적 변화의 트리거를 가리킨다.</li>
<li><strong>Style</strong> : <code>.headline</code>과 같은 선택자에 따라 어떤 CSS 규칙을 어떤 요소에 적용할지 계산하는 프로세스이다.</li>
<li><strong>Layout</strong> : 브라우저가 각 요소에 어떤 규칙을 적용할 지 알고난 후, 실제로 어디에, 어느 정도의 공간을 차지하며 위치할지를 계산하는 과정. 한 요소가 다른 요소에 영향을 줄 수 있기 때문에 해당 과정이 필요하다.</li>
<li><strong>Paint</strong> : 실제로 화면의 픽셀을 채우는 과정. 텍스트 / 색 / 경계 및 그림자 등 요소의 모든 시각적 부분을 그려낸다. 일반적으로 레이어라고 하는 여러 개의 표면에서 수행된다.</li>
<li><strong>Composition</strong> : 페이지의 각 부분들이 여러 레이어를 통해 그려졌기 때문에, 페이지가 정확히 렌더링되기 위해 정확한 순서대로 화면에 그려내는 과정.</li>
</ul>
<p>JS / CSS를 통해 시각적인 변경이 이루어졌을 때, 파이프라인이 동작하는 세가지 형태가 존재한다.</p>
<h3 id="1-js--css---style---layout---paint---composition"><a class="header" href="#1-js--css---style---layout---paint---composition"><strong>1. JS / CSS -&gt; Style -&gt; Layout -&gt; Paint -&gt; Composition</strong></a></h3>
<img src='https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg' />
<ul>
<li>너비 / 높이 / 위치 등 요소의 기하학적 형태에 영향을 주는 Layout 속성들을 변경하면 브라우저가 다른 요소들을 확인하고 페이지에 대해 <strong>리플로우(Reflow)</strong> 작업을 수행해야 한다. 이후 영향을 받은 영역이 있다면 다시 페인트해야 하고, 최종적으로 페인트한 요소는 다시 합성이 이루어져야 한다.</li>
</ul>
<h3 id="2-js--css---style---paint---composition"><a class="header" href="#2-js--css---style---paint---composition"><strong>2. JS / CSS -&gt; Style -&gt; Paint -&gt; Composition</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg" />
<ul>
<li>페이지의 레이아웃에 영향을 주지 않는 배경 이미지, 텍스트 색상 또는 그림자 등 Paint Only 속성을 변경하면, 브라우저가 레이아웃 작업을 건너뛰고 페인트 작업부터 수행한다.</li>
</ul>
<h3 id="3-js--css---style---composition"><a class="header" href="#3-js--css---style---composition"><strong>3. JS / CSS -&gt; Style -&gt; Composition</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg" />
<ul>
<li>레이아웃과 페인트 모두 필요없는 속성을 변경하게 되면 브라우저가 바로 합성 단계로 건너뛴다.</li>
</ul>
<p>각 속성을 변경함에 있어 위 중 어떤 과정을 거치게 되는지에 대해 알고 싶다면 <a href="https://csstriggers.com/">CSS Triggers</a>를 참조하자.</p>
<p>아래부터는 파이프라인의 각 부분에 있어서 발생할 수 있는 일반적인 문제와 그 진단 / 해결방법에 대해 살펴보자.</p>
<h2 id="js-실행-최적화"><a class="header" href="#js-실행-최적화">JS 실행 최적화</a></h2>
<p>실행 타이밍이 안좋거나, 실행 시간이 긴 JS는 렌더링 성능에 영향을 미칠 수 있다.</p>
<h3 id="시각적-업데이트에-settimeout-또는-setinterval을-피하고-대신-항상-requestanimationframe을-사용하라"><a class="header" href="#시각적-업데이트에-settimeout-또는-setinterval을-피하고-대신-항상-requestanimationframe을-사용하라"><strong>시각적 업데이트에 setTimeout 또는 setInterval을 피하고 대신 항상 requestAnimationFrame을 사용하라.</strong></a></h3>
<p><code>setTimeout</code>에 의해 특정 시점에 콜백이 실행되는 경우, 종종 프레임이 누락되어 버벅거리는 현상이 발생할 수 있다. <code>requestAnimationFrame</code>을 이용한 방법은 JS가 프레임 시작 시에 실행되도록 보장한다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/optimize-javascript-execution/settimeout.jpg" />
<pre><code class="language-js">/**
 * If run as a requestAnimationFrame callback, this
 * will be run at the start of the frame.
 */
function updateScreen(time) {
  // Make visual updates here.
}

requestAnimationFrame(updateScreen);
</code></pre>
<h3 id="메인-스레드를-벗어나-오래-실행되는-자바스크립트를-web-workers로-이전하라"><a class="header" href="#메인-스레드를-벗어나-오래-실행되는-자바스크립트를-web-workers로-이전하라"><strong>메인 스레드를 벗어나 오래 실행되는 자바스크립트를 Web Workers로 이전하라.</strong></a></h3>
<p>원하는 작업에 DOM 액세스가 필요하지 않은 경우에는 Web Worker의 사용을 고려해볼 수 있다. 정렬 / 검색 또는 순회(traversal)는 대개 이 모델에 적합하며, 로드 및 모델 생성도 마찬가지다.</p>
<pre><code class="language-js">const dataSortWorker = new Worker('sort-worker.js');
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function (evt) {
  const sortedData = evt.data;
  // Update data on screen...
});
</code></pre>
<h3 id="마이크로-작업을-사용하여-여러-프레임을-통해-dom을-변경하라"><a class="header" href="#마이크로-작업을-사용하여-여러-프레임을-통해-dom을-변경하라"><strong>마이크로 작업을 사용하여 여러 프레임을 통해 DOM을 변경하라.</strong></a></h3>
<p>단, 반대로 말해서 DOM 액세스를 요구하는 작업의 경우 이런 방식이 적합하지 않다. 이와 같이 작업이 메인 스레드에 있어야 한다면, 큰 작업을 몇 개의 마이크로 작업으로 세분화하여, 각각의 프레임에서 <code>requestAnimationFrame</code> 핸들러를 통해 실행하는 방식을 고려해볼 수 있다.</p>
<pre><code class="language-js">const var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
  const taskFinishTime;

  do {
    // Assume the next task is pushed onto a stack.
    const nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
    taskFinishTime = window.performance.now();
  } while (taskFinishTime - taskStartTime &lt; 3);

  if (taskList.length &gt; 0) requestAnimationFrame(processTaskList);
}
</code></pre>
<p>이러한 접근 방식을 활용하는 경우, UX/UI를 통해 특정 작업을 계속 수행하고 있음을 이용자에게 나타내는 것이 중요하다. 또한 앱의 메인 스레드를 계속해서 사용 가능한 상태를 유지하여 사용자의 상호작용에 계속 반응할 수 있도록 해야한다.</p>
<h3 id="chrome-devtools의-timeline-및-자바스크립트-프로파일러를-사용하여-자바스크립트의-영향을-평가한다"><a class="header" href="#chrome-devtools의-timeline-및-자바스크립트-프로파일러를-사용하여-자바스크립트의-영향을-평가한다"><strong>Chrome DevTools의 Timeline 및 자바스크립트 프로파일러를 사용하여 자바스크립트의 영향을 평가한다.</strong></a></h3>
<p>프레임별로 JS 코드의 실행 비용을 평가하는 것 역시 중요한데, 이는 특히 트랜지션이나 스크롤처럼 성능이 중요한 애니메이션 작업 시에 더욱 중요하다.</p>
<p>JS 비용 및 성능 프로필을 측정하기 위한 가장 좋은 방법은 DevTools를 사용하는 것이다. (Timeline, Profiler)</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/optimize-javascript-execution/high-js-detail.jpg" />
<h3 id="js-미세-최적화micro-optimization를-피하라"><a class="header" href="#js-미세-최적화micro-optimization를-피하라"><strong>JS 미세 최적화(Micro Optimization)를 피하라.</strong></a></h3>
<p><code>offsetTop</code>이 <code>getBoundingClientRect()</code> 계산보다 빠른 것처럼, 브라우저는 일부 작업을 다른 작업보다 100배 가까이 빨리 처리할 수 있다. 하지만 실제로 함수 호출 시의 프레임 당 시간은 거의 항상 짧기 때문에, JS의 성능적인 측면에 중점을 두는 것은 일반적으로 시간 낭비에 가깝다. 이러한 노고를 통해 절약되는 시간이 거의 밀리초의 일부에 불과하기 때문이다. 단, 게임이나 컴퓨팅 비용이 비싼 앱의 경우엔 예외인데, 일반적으로 많은 계산이 단일 프레임에 적용되고, 이 경우에는 모든 것이 도움이 되기 때문이다. 거꾸로 말하면, 그렇지 않은 경우(게임 등을 개발하는 것이 아닌 경우)에는 적절하지 않으므로 피해야 한다.</p>
<h2 id="style-계산의-스코프--복잡성-최적화"><a class="header" href="#style-계산의-스코프--복잡성-최적화">Style 계산의 스코프 / 복잡성 최적화</a></h2>
<p>요소의 스타일링 규칙을 정하는 단계에서, 더 간단한 규칙을 지닌 더 작은 트리가 큰 트리나 복잡한 규칙보다 더 효율적으로 처리된다.</p>
<p>다음의 각각은 동일한 요소를 대상으로 하기 위해 지정한 선택자지만, 브라우저가 이를 계산하는데에 드는 시간 비용에는 차이가 생긴다.</p>
<pre><code class="language-css">.box:nth-last-child(-n + 1) .title {
  /* styles */
}
</code></pre>
<pre><code class="language-css">.final-box-title {
  /* styles */
}
</code></pre>
<p>BEM과 같은 CSS 아키텍처 역시 이러한 선택기 매칭의 성능 이점에서 구현된다.</p>
<pre><code>.list { }
.list__list-item { }
.list__list-item--last-child {}
</code></pre>
<h2 id="레이아웃-최적화"><a class="header" href="#레이아웃-최적화">레이아웃 최적화</a></h2>
<p>레이아웃은 브라우저가 요소의 기하학적인 정보를 파악하는 장소이며, 각 요소는 사용한 CSS, 요소의 컨텐츠 또는 상위 요소에 따라 명시적 / 암시적인 크기 지정 정보를 갖게된다. 해당 프로세스를 Chrome, Opera, Safari 및 IE에서는 레이아웃이라고 하며, Firefox에서는 리플로우(Reflow)라고 한다.</p>
<h3 id="레이아웃의-범위는-거의-항상-전체-문서로-지정된다"><a class="header" href="#레이아웃의-범위는-거의-항상-전체-문서로-지정된다"><strong>레이아웃의 범위는 거의 항상 전체 문서로 지정된다.</strong></a></h3>
<p>요소가 많은 경우 모든 요소의 위치와 크기를 파악하는데 오랜 시간이 걸린다. 레이아웃을 피할 수 없는 경우, DevTools의 Timeline을 통해 해당 레이아웃에 시간이 얼마나 걸리는지에 대한 파악이 필요하다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/big-layout.jpg" />
<p>위의 예에서는 레이아웃 내부에서 20ms 이상 소요된 것을 확인할 수 있는데, 애니메이션 화면에서 프레임당 16ms가 필요한 경우 이에 비해 훨씬 높은 값이다. 또한 트리 크기(위에서는 1,618 요소) 및 레이아웃에 필요한 노드 수도 확인할 수 있다.</p>
<h3 id="flexbox는-동일한-수의-요소에-대해-레이아웃-시간을-훨씬-덜-소요한다"><a class="header" href="#flexbox는-동일한-수의-요소에-대해-레이아웃-시간을-훨씬-덜-소요한다"><strong>Flexbox는 동일한 수의 요소에 대해 레이아웃 시간을 훨씬 덜 소요한다.</strong></a></h3>
<p>브라우저에 따라 Flexbox를 지원하지 않는 경우도 있겠지만.. 결국 Flexbox의 사용 여부 이전에 레이아웃 트리거 자체를 완전히 피하려고 노력하는 것이 좋다. 아래는 float를 사용하는 레이아웃과 flex를 사용한 레이아웃 간의 처리시간 차이를 나타내는 결과다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-float.jpg" />
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-flex.jpg" />
<h3 id="강제-동기식-레이아웃을-피하라"><a class="header" href="#강제-동기식-레이아웃을-피하라"><strong>강제 동기식 레이아웃을 피하라</strong></a></h3>
<p>화면에 프레임을 추가하는 순서는 다음과 같다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/frame.jpg" />
<p>JS를 실행한 후 -&gt; 스타일 계산을 수행한 후에 -&gt; 레이아웃을 실행한다.</p>
<p>하지만, JS를 사용해 브라우저가 레이아웃을 더 일찍 수행하도록 하는 것도 가능한데, 이를 **강제 동기식 레이아웃(forced synchronous layouts)**이라고 한다.</p>
<p>JS가 실행될 때, <strong>이전</strong> 프레임의 모든 레이아웃 값은 알려져 있고, 이를 쿼리에 사용할 수 있다. 이를테면 프레임 시작 시 요소의 높이를 기록하려면 다음과 같이 작성할 수 있다.</p>
<pre><code class="language-js">// Schedule our function to run at the start of the frame.
requestAnimationFrame(logBoxHeight);

function logBoxHeight() {
  // Gets the height of the box in pixels and logs it out.
  console.log(box.offsetHeight);
}
</code></pre>
<p>헌데, 높이를 요청하기 <strong>전에</strong> 스타일을 먼저 변경한 경우 문제가 발생할 수 있다.</p>
<pre><code class="language-js">function logBoxHeight() {
  box.classList.add('super-big');

  // Gets the height of the box in pixels
  // and logs it out.
  console.log(box.offsetHeight);
}
</code></pre>
<p>이 경우, 정확한 높이를 구하기 위해 브라우저는 먼저 스타일을 변경한 후(<code>super-big</code>이 클래스에 추가되었기 때문에), 레이아웃을 실행해야 한다. 이는 불필요하고, 비용도 많이 드는 작업이다.</p>
<p>때문에, 항상 스타일 읽기를 일괄적으로 처리하여 먼저 수행한 다음, 스타일 쓰기를 작성해야 한다.</p>
<p>결국, 위의 코드를 올바르게 수정하자면 아래와 같아진다.</p>
<pre><code class="language-js">function logBoxHeight() {
  // Gets the height of the box in pixels
  // and logs it out.
  console.log(box.offsetHeight);

  box.classList.add('super-big');
}
</code></pre>
<p>대부분의 경우 스타일을 적용한 다음에 그 값을 쿼리할 필요가 없다. 이전의 프레임 값을 사용하면 충분하기 때문이다. 브라우저가 원하는 시간보다 일찍 스타일 계산과 레이아웃을 동시에 실행하지 않도록 하자.</p>
<h3 id="레이아웃-스래싱을-피하라"><a class="header" href="#레이아웃-스래싱을-피하라"><strong>레이아웃 스래싱을 피하라</strong></a></h3>
<p>많은 레이아웃을 연속적으로 빠르게 실행한다면 강제 동기식 레이아웃이 더 악화된다.</p>
<pre><code class="language-js">function resizeAllParagraphsToMatchBlockWidth() {
  // Puts the browser into a read-write-read-write cycle.
  for (let i = 0; i &lt; paragraphs.length; i++) {
    paragraphs[i].style.width = box.offsetWidth + 'px';
  }
}
</code></pre>
<p>위 코드는 매 루프마다 스타일 값(<code>box.offsetWidth</code>)을 읽은 다음 이 값을 즉시 사용해 너비(<code>paragraphs[i].style.width</code>)를 업데이트한다.</p>
<p>스타일링의 변경을 일으킨 직후에 <code>box.offsetWidth</code>를 요구하였기 때문에, 이 시점에서 강제 동기식 레이아웃이 발생한다.</p>
<p>이 경우, 바로 루프의 바로 다음부터 시작해 매 반복마다 스타일이 변경되었음을 확인하고, 이에 따라 스타일 변경을 적용하고, 레이아웃을 실행하게 된다.</p>
<p>이를 수정하려면, 기존 프레임의 하나의 값을 읽은 다음 계속해서 사용해야 한다.</p>
<pre><code class="language-js">// Read.
const width = box.offsetWidth;

function resizeAllParagraphsToMatchBlockWidth() {
  for (let i = 0; i &lt; paragraphs.length; i++) {
    // Now write.
    paragraphs[i].style.width = width + 'px';
  }
}
</code></pre>
<p>이런 레이아웃 스레싱(Layout thrashing)을 없애기 위해 <a href="https://github.com/wilsonpage/fastdom">fastDOM</a>이라는 라이브러리도 존재한다.</p>
<h2 id="페인트-최적화"><a class="header" href="#페인트-최적화">페인트 최적화</a></h2>
<p>페인트 과정은 최종적으로 사용자의 화면에 픽셀을 채우는 과정이며, 파이프라인의 모든 작업 중 대체로 실행시간이 가장 긴 작업이기 때문에 가급적 피해야 한다.</p>
<h3 id="언제-페인팅이-이루어지는가"><a class="header" href="#언제-페인팅이-이루어지는가"><strong>언제 페인팅이 이루어지는가??</strong></a></h3>
<p>페인트가 트리거되는 경우는 다음의 두가지이다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/frame.jpg"/>
<ol>
<li>레이아웃이 트리거되면, <strong>항상</strong> 페인트 역시 트리거된다.</li>
</ol>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/frame-no-layout.jpg" />
<ol start="2">
<li>레이아웃이 필요없는 비기하학적 속성(배경 / 텍스트 색상, 그림자)을 변경하는 경우에도 페인트가 트리거된다.</li>
</ol>
<h3 id="이동되거나-페이드되는-요소를-승격promote해라"><a class="header" href="#이동되거나-페이드되는-요소를-승격promote해라"><strong>이동되거나 페이드되는 요소를 승격(Promote)해라</strong></a></h3>
<p>페인트가 항상 메모리 상에 단일 이미지로 수행되는 것은 아닌데, 실제로 필요에 따라서 브라우저가 다중 이미지 혹은 컴포지터 레이어로 페인트를 할 수 있다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/layers.jpg" />
<p>이러한 접근방식의 이점은, 정기적으로 페인트하거나 변형에 의해 화면에서 움직이는 요소를 다른 요소에 영향을 주지 않으면서 처리할 수 있다는 것이다.</p>
<p>이는 Photoshop과 같은 툴에서 볼 수 있는 레이어의 개념과 유사한데, 최상위에서 개별 레이어를 처리 / 합성하여 최종적인 이미지를 생성할 수 있다.</p>
<p>새로운 레이어를 생성하는 가장 좋은 방법은 <code>will-change</code> CSS 속성을 사용하는 것이다. 이는 Chrome, Opera 및 Firefox에서 작동하며, <code>transform</code> 값으로 새 컴포지터 레이어를 생성한다.</p>
<pre><code class="language-css">.moving-element {
  will-change: transform;
}
</code></pre>
<p>Safari처럼 <code>will-change</code>를 지원하지는 않으나, 레이어 생성은 활용하는 브라우저의 경우 3D 변형을 사용해 새 레이어를 강제적으로 적용해야 한다.</p>
<pre><code class="language-css">.moving-element {
  transform: translateZ(0);
}
</code></pre>
<p>단, 각 레이어는 메모리와 관리가 요구되기 때문에 너무 많은 레이어를 생성하는 것은 오히려 독이 될 수 있다. 또한 요소를 새 레이어로 승격시키는 경우, 이렇게 하는 것이 성능 상으로 이점이 있는지부터 먼저 확인해야 한다.</p>
<h3 id="페인트-영역을-줄여라"><a class="header" href="#페인트-영역을-줄여라"><strong>페인트 영역을 줄여라</strong></a></h3>
<p>앞선 설명처럼 요소를 승격시켰음에도 불구하고 페인팅 작업이 여전히 요구되는 경우가 있다. 페인트의 커다란 문제점은 브라우저가 페인팅이 필요한 두 영역을 합치고 나면, 전체 스크린에 대해 다시 페인팅 작업을 수행할 수도 있다는 점이다. 예를 들어, 페이지 상단에 고정된(fixed) 헤더를 갖고 있더라도, 스크린 아래쪽에서 페인팅이 이루어진다면 그냥 스크린 전체가 리페인팅될 수 있다.</p>
<blockquote>
<p><strong>참고</strong>: 높은 DPI를 가진 디바이스의 경우 <code>fixed</code> position을 가진 요소는 자동으로 컴포지터 레이어(Compositor layer)로 승격된다. 반면, 낮은 DPI를 가진 경우는 해당하지 않는데, 이 경우 승격은 텍스트 렌더링을 서브픽셀(subfixel)에서 그레이스케일로 변경하고, 레이어 승격은 수동적으로 이루어져야 하기 때문이다.</p>
</blockquote>
<p><strong>페인트 영역을 줄이는 것</strong>은 일반적으로 다음과 같은 방법을 통해 이루어질 수 있다.</p>
<ol>
<li>애니메이션과 트랜지션이 가능한 겹치지 않도록 조율하는 것</li>
<li>한 페이지의 특정 부분에 애니메이션을 적용하는 것을 피하는 것</li>
</ol>
<h3 id="페인트-복잡성-단순화"><a class="header" href="#페인트-복잡성-단순화"><strong>페인트 복잡성 단순화</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/profiler-chart.jpg"/>
<p>페인트는 작업에 따라 그 비용에 차이가 있다. 다만, 이 기준이 CSS 관점에서 항상 명확한 것은 아니다.
페인트 프로파일러를 사용하면 현재 페인트 작업에 어느 정도의 비용이 드는지를 확인할 수 있고, 이를 대체하기 위한 스타일링에 대해 생각해볼 수 있다.</p>
<p>프레임 당 <strong>10ms</strong>는 일반적으로, 특히 모바일 디바이스에서는 페인팅 작업을 수행할 만큼 긴 시간이 아니다.
때문에 애니메이션 도중에는 항상 페인팅 작업을 피하기를 원할 수 있다.</p>
<h2 id="합성-composition-최적화"><a class="header" href="#합성-composition-최적화">합성 (Composition) 최적화</a></h2>
<p>합성은 화면에 표시하기 위해 페이지에서 페인트된 부분들을 합치는 과정이다.
이 영역에서 페이지 성능에 영향을 주는 두 가지 핵심 요소가 있다.</p>
<ol>
<li>관리가 필요한 컴포지터 레이어 수</li>
<li>애니메이션에 사용하는 속성</li>
</ol>
<h3 id="애니메이션에-변형transform-또는-불투명도opacity-변경을-사용하라"><a class="header" href="#애니메이션에-변형transform-또는-불투명도opacity-변경을-사용하라"><strong>애니메이션에 변형(<code>transform</code>) 또는 불투명도(<code>opacity</code>) 변경을 사용하라</strong></a></h3>
<p>앞서 레이아웃과 페인트를 모두 피하고 <strong>합성</strong>에 대한 변경만 요구하는 픽셀 파이프라인이 최고의 성능을 제공한다고 살펴봤었다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/stick-to-compositor-only-properties-and-manage-layer-count/frame-no-layout-paint.jpg"/>
<p>이를 위해서는 컴포지터가 혼자서 처리할 수 있는 변경 속성을 사용해야 하는데, 현재로서 <strong>이에 해당하는 것은 <code>transform</code>과 <code>opacity</code> 두 가지 속성 뿐이다.</strong></p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/stick-to-compositor-only-properties-and-manage-layer-count/safe-properties.jpg" />
<p>해당 속성들을 사용할 시에 주의할 점은 이러한 속성을 변경하는 요소가 자체적인 컴포지터 레이어에 있어야 하는데, <strong>즉, 레이어를 만들기 위해 요소를 승격해야 한다.</strong></p>
<blockquote>
<p><strong>참고</strong> : 애니메이션을 이 속성들로만 제한할 수 없을 것 같다고 생각되면 <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP 원칙</a>을 참조하라. 이는 비용이 많이 드는 속성을 <code>transform</code>과 <code>opacity</code>를 이용한 방법으로 다시 작성하도록 도와준다.</p>
</blockquote>
<h3 id="애니메이션-적용-요소를-승격해라"><a class="header" href="#애니메이션-적용-요소를-승격해라"><strong>애니메이션 적용 요소를 승격해라</strong></a></h3>
<p>위의 페인트 최적화 섹션에서 언급한 것처럼, 애니메이션 적용 요소에 대해 자체 레이어로 승격해야 한다.</p>
<pre><code class="language-css">.moving-element {
  will-change: transform;
}
</code></pre>
<p>또는 이전 브라우저나 <code>will-change</code>를 지원하지 않는 브라우저에 대해서는 다음을 사용한다.</p>
<pre><code class="language-css">.moving-element {
  transform: translateZ(0);
}
</code></pre>
<h3 id="레이어-관리-및-레이어-급증-피하기--요소를-불필요하게-레이어-승격하지-마라"><a class="header" href="#레이어-관리-및-레이어-급증-피하기--요소를-불필요하게-레이어-승격하지-마라"><strong>레이어 관리 및 레이어 급증 피하기 : 요소를 불필요하게 레이어 승격하지 마라</strong></a></h3>
<p>레이어 승격이 성능 개선에 도움이 된다고 해서 페이지 모든 요소를 승격시켜버리는 것이 자칫 이상적으로 들릴지 모른다.</p>
<pre><code class="language-css">* {
  will-change: transform;
  transform: translateZ(0);
}
</code></pre>
<p>이 경우의 문제는, 생성하는 모든 레이어가 메모리 및 관리가 요구되며, 이는 공짜로 생겨나는 것이 아니라는 점이다. 결국, 무작정 레이어를 생성하는 경우 오히려 안하느니만 못하다.</p>
<h2 id="입력-핸들러-디바운싱"><a class="header" href="#입력-핸들러-디바운싱">입력 핸들러 디바운싱</a></h2>
<p>입력 핸들러는 프레임 완성을 차단시킬 수 있기 때문에 불필요한 추가 레이아웃 작업을 유발할 수 있다.</p>
<h3 id="오래-걸리는-입력-핸들러를-피하라"><a class="header" href="#오래-걸리는-입력-핸들러를-피하라"><strong>오래 걸리는 입력 핸들러를 피하라</strong></a></h3>
<p>가장 빠른 경우의 예시를 먼저 들자면, 이용자가 페이지와 상호작용할 때, 페이지의 컴포지터 쓰레드가 이용자의 터치 입력을 감지하고, 컨텐츠를 단순히 이동시킨다.
이 경우, 메인 쓰레드에서 요구되는 동작(JS, 레이아웃, 스타일, 페인트)이 없다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/compositor-scroll.jpg" />
<p>그런데, 만약 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code>와 같은 입력 핸들러를 추가한다면, 컴포지터 쓰레드는 해당 핸들러의 처리과정이 끝날때까지 기다려야 한다.
왜냐하면 <code>preventDefault()</code>가 호출될지도 모르기 때문인데, 만약 호출되었다면 컴포지터 쓰레드는 기본 스크롤 동작을 멈춰야만 한다.</p>
<p>심지어 <code>preventDefault()</code>를 호출하지 않았더라도, 컴포지터는 기다려야만 한다. 이처럼 컴포지터가 기다리는 동안에 이용자의 스크롤 동작을 막게 되며, 이에 따라 버벅거리거나 프레임이 손실되는 결과가 나타난다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/ontouchmove.jpg" />
<p>쉽게 말해, <strong>입력 핸들러는 빠르게 처리되어야 한다.</strong> 그래야 컴포지터가 원래 해야하는 일을 할 수 있으니까.</p>
<h3 id="입력-핸들러-내에서의-스타일-변경을-피하라"><a class="header" href="#입력-핸들러-내에서의-스타일-변경을-피하라"><strong>입력 핸들러 내에서의 스타일 변경을 피하라</strong></a></h3>
<p>스크롤과 터치 같은 입력 핸들러들은 <code>requestAnimationFrame</code> 콜백 이전에 실행되도록 되어있다.
만약 이러한 핸들러 내부에서 스타일 변경을 시도한다면, <code>requestAnimationFrame</code>이 시작될 때 스타일 변경이 보류된다.</p>
<p>만약 <code>requestAnimationFrame</code> 콜백이 시작할 때 스타일 정보들을 읽어오고자 한다면, 위쪽에서 언급했던 **강제 동기 레이아웃(Forced synchronous layout)**이 발생한다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/frame-with-input.jpg" />
<h3 id="스크롤-핸들러-디바운스"><a class="header" href="#스크롤-핸들러-디바운스"><strong>스크롤 핸들러 디바운스</strong></a></h3>
<p>위의 두가지 문제(입력 핸들러 간소화 + 핸들러 내 스타일 변경 회피)를 해결하는 방법은 동일한데, 시각적 변경에 대해 항상 다음 <code>requestAnimationFrame</code> 콜백으로 디바운스 하는 것이다.</p>
<pre><code class="language-js">function onScroll(evt) {
  // Store the scroll value for laterz.
  lastScrollY = window.scrollY;

  // Prevent multiple rAF callbacks.
  if (scheduledAnimationFrame) return;

  scheduledAnimationFrame = true;
  requestAnimationFrame(readAndUpdatePage);
}

window.addEventListener('scroll', onScroll);
</code></pre>
<p>이 경우, 컴퓨팅 비용이 많이 드는 코드에서도 스크롤이나 터치를 차단하지 않으므로 입력 핸들러를 가볍게 유지할 수 있다는 이점이 있다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../js/web-api/canvas/shapes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../js/guides/custom-el-checklist.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../js/web-api/canvas/shapes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../js/guides/custom-el-checklist.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>

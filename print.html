<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shubi Docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item "><div><strong aria-hidden="true">1.</strong> Web</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="web/web-performance/index.html"><strong aria-hidden="true">1.1.</strong> 웹 성능 최적화 기법</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="web/web-performance/what-is-web-performance.html"><strong aria-hidden="true">1.1.1.</strong> 웹 성능이란 무엇인가?</a></li><li class="chapter-item "><a href="web/web-performance/web-optimization.html"><strong aria-hidden="true">1.1.2.</strong> 웹 최적화</a></li><li class="chapter-item "><a href="web/web-performance/basic-optimization.html"><strong aria-hidden="true">1.1.3.</strong> 웹 사이트 성능을 개선하는 기본적인 방법</a></li></ol></li></ol></li><li class="chapter-item "><a href="js/index.html"><strong aria-hidden="true">2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/exec-ctx.html"><strong aria-hidden="true">2.1.</strong> 실행 컨텍스트</a></li><li class="chapter-item "><a href="js/class.html"><strong aria-hidden="true">2.2.</strong> 클래스</a></li><li class="chapter-item "><a href="js/arrow-func.html"><strong aria-hidden="true">2.3.</strong> 화살표 함수</a></li><li class="chapter-item "><a href="js/binding-function.html"><strong aria-hidden="true">2.4.</strong> 함수 바인딩</a></li><li class="chapter-item "><a href="js/call-apply.html"><strong aria-hidden="true">2.5.</strong> call, apply</a></li><li class="chapter-item "><a href="js/closure.html"><strong aria-hidden="true">2.6.</strong> 클로저</a></li><li class="chapter-item "><a href="js/func-exp-and-dec.html"><strong aria-hidden="true">2.7.</strong> 함수 표현식 vs 함수 선언문</a></li><li class="chapter-item "><a href="js/event-loop.html"><strong aria-hidden="true">2.8.</strong> 이벤트 루프</a></li><li class="chapter-item "><a href="js/new.html"><strong aria-hidden="true">2.9.</strong> new와 생성자 함수</a></li><li class="chapter-item "><a href="js/properties.html"><strong aria-hidden="true">2.10.</strong> 프로퍼티</a></li><li class="chapter-item "><a href="js/prototype.html"><strong aria-hidden="true">2.11.</strong> 프로토타입</a></li><li class="chapter-item "><a href="js/this.html"><strong aria-hidden="true">2.12.</strong> this</a></li><li class="chapter-item "><a href="js/var.html"><strong aria-hidden="true">2.13.</strong> var를 쓰지 않는 이유</a></li><li class="chapter-item "><a href="js/babel.html"><strong aria-hidden="true">2.14.</strong> Babel</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.15.</strong> Web APIs</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/web-api/intersection.html"><strong aria-hidden="true">2.15.1.</strong> Intersection Observer</a></li><li class="chapter-item "><a href="js/web-api/mutation.html"><strong aria-hidden="true">2.15.2.</strong> Mutation Observer</a></li><li class="chapter-item "><a href="js/web-api/template.html"><strong aria-hidden="true">2.15.3.</strong> Template Element</a></li><li class="chapter-item "><a href="js/web-api/shadow-dom/intro.html"><strong aria-hidden="true">2.15.4.</strong> Shadow DOM</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/web-api/shadow-dom/slot.html"><strong aria-hidden="true">2.15.4.1.</strong> Slot</a></li><li class="chapter-item "><a href="js/web-api/shadow-dom/styling.html"><strong aria-hidden="true">2.15.4.2.</strong> Styling</a></li><li class="chapter-item "><a href="js/web-api/shadow-dom/events.html"><strong aria-hidden="true">2.15.4.3.</strong> Events</a></li></ol></li><li class="chapter-item "><a href="js/web-api/canvas/intro.html"><strong aria-hidden="true">2.15.5.</strong> Canvas API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/web-api/canvas/shapes.html"><strong aria-hidden="true">2.15.5.1.</strong> 도형 그리기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.16.</strong> Guides</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="js/guides/render-opt.html"><strong aria-hidden="true">2.16.1.</strong> 렌더링 최적화</a></li><li class="chapter-item "><a href="js/guides/custom-el-checklist.html"><strong aria-hidden="true">2.16.2.</strong> Custom Element 체크리스트</a></li></ol></li></ol></li><li class="chapter-item "><a href="ts/index.html"><strong aria-hidden="true">3.</strong> TypeScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/intro/index.html"><strong aria-hidden="true">3.1.</strong> 타입스크립트 알아보기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/intro/ts_js.html"><strong aria-hidden="true">3.1.1.</strong> TS와 JS의 관계</a></li><li class="chapter-item "><a href="ts/intro/setting.html"><strong aria-hidden="true">3.1.2.</strong> TS 설정 이해하기</a></li><li class="chapter-item "><a href="ts/intro/transpile.html"><strong aria-hidden="true">3.1.3.</strong> 코드 생성과 타입이 관계없음을 이해하기</a></li><li class="chapter-item "><a href="ts/intro/typing.html"><strong aria-hidden="true">3.1.4.</strong> 구조적 타이핑에 익숙해지기</a></li><li class="chapter-item "><a href="ts/intro/no_any.html"><strong aria-hidden="true">3.1.5.</strong> any 타입 지양하기</a></li></ol></li><li class="chapter-item "><a href="ts/types/index.html"><strong aria-hidden="true">3.2.</strong> 타입스크립트의 타입 시스템</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/types/use_editor.html"><strong aria-hidden="true">3.2.1.</strong> 편집기를 사용하여 타입 시스템 탐색하기</a></li><li class="chapter-item "><a href="ts/types/set.html"><strong aria-hidden="true">3.2.2.</strong> 타입이 값들의 집합이라고 생각하기</a></li><li class="chapter-item "><a href="ts/types/symbol.html"><strong aria-hidden="true">3.2.3.</strong> 타입 공간과 값 공간의 심벌 구분하기</a></li><li class="chapter-item "><a href="ts/types/type-def.html"><strong aria-hidden="true">3.2.4.</strong> 타입 단언보다는 타입 선언을 사용하기</a></li><li class="chapter-item "><a href="ts/types/wrapper.html"><strong aria-hidden="true">3.2.5.</strong> 객체 래퍼 타입 피하기</a></li><li class="chapter-item "><a href="ts/types/excess-type-check.html"><strong aria-hidden="true">3.2.6.</strong> 잉여 속성 체크의 한계 인지하기</a></li><li class="chapter-item "><a href="ts/types/function-expression.html"><strong aria-hidden="true">3.2.7.</strong> 함수 표현식에 타입 적용하기</a></li><li class="chapter-item "><a href="ts/types/type-and-interface.html"><strong aria-hidden="true">3.2.8.</strong> 타입과 인터페이스의 차이점 알기</a></li><li class="chapter-item "><a href="ts/types/generics.html"><strong aria-hidden="true">3.2.9.</strong> 타입 연산과 제너릭 사용으로 반복 줄이기</a></li><li class="chapter-item "><a href="ts/types/index-signature.html"><strong aria-hidden="true">3.2.10.</strong> 동적 데이터에 인덱스 시그니처 사용하기</a></li><li class="chapter-item "><a href="ts/types/no-index-signature.html"><strong aria-hidden="true">3.2.11.</strong> number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></li><li class="chapter-item "><a href="ts/types/readonly.html"><strong aria-hidden="true">3.2.12.</strong> 변경 관련된 오류 방지를 위해 readonly 사용하기</a></li><li class="chapter-item "><a href="ts/types/mapped-type.html"><strong aria-hidden="true">3.2.13.</strong> 매핑된 타입을 사용하여 값을 동기화하기</a></li></ol></li><li class="chapter-item "><a href="ts/type-inference/index.html"><strong aria-hidden="true">3.3.</strong> 타입 추론</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/type-inference/use-inferable-types.html"><strong aria-hidden="true">3.3.1.</strong> 추론 가능한 타입을 사용해 장황한 코드 방지하기</a></li><li class="chapter-item "><a href="ts/type-inference/use-const.html"><strong aria-hidden="true">3.3.2.</strong> 다른 타입에는 다른 변수 사용하기</a></li><li class="chapter-item "><a href="ts/type-inference/type-widening.html"><strong aria-hidden="true">3.3.3.</strong> 타입 넓히기</a></li><li class="chapter-item "><a href="ts/type-inference/type-narrowing.html"><strong aria-hidden="true">3.3.4.</strong> 타입 좁히기</a></li><li class="chapter-item "><a href="ts/type-inference/create-object-at-once.html"><strong aria-hidden="true">3.3.5.</strong> 한꺼번에 객체 생성하기</a></li><li class="chapter-item "><a href="ts/type-inference/avoid-aliasing.html"><strong aria-hidden="true">3.3.6.</strong> 일관성있는 별칭 사용하기</a></li><li class="chapter-item "><a href="ts/type-inference/use-async.html"><strong aria-hidden="true">3.3.7.</strong> 비동기 코드에는 콜백 대신 async 함수 사용하기</a></li><li class="chapter-item "><a href="ts/type-inference/context-inference.html"><strong aria-hidden="true">3.3.8.</strong> 타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></li><li class="chapter-item "><a href="ts/type-inference/well-typed-lib.html"><strong aria-hidden="true">3.3.9.</strong> 함수형 기법과 라이브러리로 타입 흐름 유지하기</a></li></ol></li><li class="chapter-item "><a href="ts/design/index.html"><strong aria-hidden="true">3.4.</strong> 타입 설계</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/design/valid-states.html"><strong aria-hidden="true">3.4.1.</strong> 유효한 상태만 표현하는 타입을 지향하기</a></li><li class="chapter-item "><a href="ts/design/loose-accept-strict-produce.html"><strong aria-hidden="true">3.4.2.</strong> 사용할 때는 너그럽게, 생성할 때는 엄격하게</a></li><li class="chapter-item "><a href="ts/design/jsdoc-repeat.html"><strong aria-hidden="true">3.4.3.</strong> 문서에 타입 정보를 쓰지 않기</a></li><li class="chapter-item "><a href="ts/design/null-values-to-perimeter.html"><strong aria-hidden="true">3.4.4.</strong> 타입 주변에 null값 배치하기</a></li><li class="chapter-item "><a href="ts/design/union-of-interfaces.html"><strong aria-hidden="true">3.4.5.</strong> 유니온의 인터페이스보다는 인터페이스의 유니온 사용하기</a></li><li class="chapter-item "><a href="ts/design/avoid-strings.html"><strong aria-hidden="true">3.4.6.</strong> string 타입보다 더 구체적인 타입 사용하기</a></li><li class="chapter-item "><a href="ts/design/incomplete-over-innacurate.html"><strong aria-hidden="true">3.4.7.</strong> 부정확한 타입보다는 미완성 타입을 사용하기</a></li><li class="chapter-item "><a href="ts/design/consider-codegen.html"><strong aria-hidden="true">3.4.8.</strong> 데이터가 아닌, API와 명세를 보고 타입 만들기</a></li><li class="chapter-item "><a href="ts/design/language-of-domain.html"><strong aria-hidden="true">3.4.9.</strong> 해당 분야의 용어로 타입 이름 짓기</a></li><li class="chapter-item "><a href="ts/design/brands.html"><strong aria-hidden="true">3.4.10.</strong> 공식 명칭에는 상표를 붙이기</a></li></ol></li><li class="chapter-item "><a href="ts/any/index.html"><strong aria-hidden="true">3.5.</strong> any 다루기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/any/narrowest-any.html"><strong aria-hidden="true">3.5.1.</strong> any 타입은 가능한 한 좁은 범위에서만 사용하기</a></li><li class="chapter-item "><a href="ts/any/specific-any.html"><strong aria-hidden="true">3.5.2.</strong> any를 구체적으로 변형해서 사용하기</a></li><li class="chapter-item "><a href="ts/any/hide-unsafe-casts.html"><strong aria-hidden="true">3.5.3.</strong> 함수 안으로 타입 단언문 감추기</a></li><li class="chapter-item "><a href="ts/any/evolving-any.html"><strong aria-hidden="true">3.5.4.</strong> any의 진화를 이해하기</a></li><li class="chapter-item "><a href="ts/any/never-unknown.html"><strong aria-hidden="true">3.5.5.</strong> 모르는 타입의 값에는 any 대신 unknown을 사용하기</a></li><li class="chapter-item "><a href="ts/any/type-safe-monkey.html"><strong aria-hidden="true">3.5.6.</strong> 몽키 패치보다는 안전한 타입을 사용하기</a></li><li class="chapter-item "><a href="ts/any/type-percentage.html"><strong aria-hidden="true">3.5.7.</strong> 타입 커버리지를 추적하여 타입 안정성 유지하기</a></li></ol></li><li class="chapter-item "><a href="ts/declarations/index.html"><strong aria-hidden="true">3.6.</strong> 타입 선언과 @types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/declarations/dev-dependencies.html"><strong aria-hidden="true">3.6.1.</strong> devDependencies에 typescript와 @types 추가하기</a></li><li class="chapter-item "><a href="ts/declarations/understand-ts-types.html"><strong aria-hidden="true">3.6.2.</strong> 타입 선언과 관련된 세 가지 버전 이해하기</a></li><li class="chapter-item "><a href="ts/declarations/export-your-types.html"><strong aria-hidden="true">3.6.3.</strong> 공개 API에 등장하는 모든 타입을 export하기</a></li><li class="chapter-item "><a href="ts/declarations/use-tsdoc.html"><strong aria-hidden="true">3.6.4.</strong> API 주석에 TSDoc 사용하기</a></li><li class="chapter-item "><a href="ts/declarations/this-in-callbacks.html"><strong aria-hidden="true">3.6.5.</strong> 콜백에서 this에 대한 타입 제공하기</a></li><li class="chapter-item "><a href="ts/declarations/conditional-overload.html"><strong aria-hidden="true">3.6.6.</strong> 오버로딩 타입보다는 조건부 타입을 사용하기</a></li><li class="chapter-item "><a href="ts/declarations/mirror-types-for-deps.html"><strong aria-hidden="true">3.6.7.</strong> 의존성 분리를 위해 미러 타입 사용하기</a></li><li class="chapter-item "><a href="ts/declarations/test-your-types.html"><strong aria-hidden="true">3.6.8.</strong> 테스팅 타입의 함정에 주의하기</a></li></ol></li><li class="chapter-item "><a href="ts/write-run/index.html"><strong aria-hidden="true">3.7.</strong> 코드를 작성하고 실행하기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/write-run/avoid-non-ecma.html"><strong aria-hidden="true">3.7.1.</strong> 타입스크립트 기능보다는 ECMASCript 기능을 사용하기</a></li><li class="chapter-item "><a href="ts/write-run/iterate-objects.html"><strong aria-hidden="true">3.7.2.</strong> 객체를 순회하는 노하우</a></li><li class="chapter-item "><a href="ts/write-run/understand-the-dom.html"><strong aria-hidden="true">3.7.3.</strong> DOM 계층 구조 이해하기</a></li><li class="chapter-item "><a href="ts/write-run/private-rely.html"><strong aria-hidden="true">3.7.4.</strong> 정보를 감추는 목적으로 private 사용하지 않기</a></li><li class="chapter-item "><a href="ts/write-run/source-maps-debug.html"><strong aria-hidden="true">3.7.5.</strong> 소스맵을 사용하여 타입스크립트 디버깅하기</a></li></ol></li><li class="chapter-item "><a href="ts/migrate/index.html"><strong aria-hidden="true">3.8.</strong> 타입스크립트로 마이그레이션하기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ts/migrate/write-modern-js.html"><strong aria-hidden="true">3.8.1.</strong> 모던 자바스크립트로 작성하기</a></li><li class="chapter-item "><a href="ts/migrate/jsdoc-tscheck.html"><strong aria-hidden="true">3.8.2.</strong> 타입스크립트 도입 전에 @ts-check와 JsDoc으로 시험해 보기</a></li><li class="chapter-item "><a href="ts/migrate/allow-js.html"><strong aria-hidden="true">3.8.3.</strong> allowJs로 타입스크립트와 자바스크립트 같이 사용하기</a></li><li class="chapter-item "><a href="ts/migrate/convert-up-the-graph.html"><strong aria-hidden="true">3.8.4.</strong> 의존성 관계에 따라 모듈 단위로 전환하기</a></li><li class="chapter-item "><a href="ts/migrate/start-loose.html"><strong aria-hidden="true">3.8.5.</strong> 마이그레이션의 완성을 위해 noImplicitAny 설정하기</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> React</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="react/why.html"><strong aria-hidden="true">4.1.</strong> 왜 React인가?</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> Redux</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="redux/pure.html"><strong aria-hidden="true">5.1.</strong> 왜 Reducer는 순수해야 하는가?</a></li></ol></li><li class="chapter-item "><a href="svelte/intro.html"><strong aria-hidden="true">6.</strong> Svelte</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="svelte/reactivity.html"><strong aria-hidden="true">6.1.</strong> Reactivity</a></li><li class="chapter-item "><a href="svelte/props.html"><strong aria-hidden="true">6.2.</strong> Props</a></li><li class="chapter-item "><a href="svelte/logic.html"><strong aria-hidden="true">6.3.</strong> Logic</a></li><li class="chapter-item "><a href="svelte/events.html"><strong aria-hidden="true">6.4.</strong> Events</a></li><li class="chapter-item "><a href="svelte/bindings.html"><strong aria-hidden="true">6.5.</strong> Bindings</a></li><li class="chapter-item "><a href="svelte/lifecycle.html"><strong aria-hidden="true">6.6.</strong> Life Cycle</a></li><li class="chapter-item "><a href="svelte/stores.html"><strong aria-hidden="true">6.7.</strong> Stores</a></li><li class="chapter-item "><a href="svelte/motion.html"><strong aria-hidden="true">6.8.</strong> Motion</a></li><li class="chapter-item "><a href="svelte/transition.html"><strong aria-hidden="true">6.9.</strong> Transitions</a></li><li class="chapter-item "><a href="svelte/animations.html"><strong aria-hidden="true">6.10.</strong> Animations</a></li><li class="chapter-item "><a href="svelte/actions.html"><strong aria-hidden="true">6.11.</strong> Actions</a></li><li class="chapter-item "><a href="svelte/classes.html"><strong aria-hidden="true">6.12.</strong> Classes</a></li><li class="chapter-item "><a href="svelte/composition.html"><strong aria-hidden="true">6.13.</strong> Component Composition</a></li><li class="chapter-item "><a href="svelte/context.html"><strong aria-hidden="true">6.14.</strong> Context API</a></li><li class="chapter-item "><a href="svelte/specials.html"><strong aria-hidden="true">6.15.</strong> Special Elements</a></li><li class="chapter-item "><a href="svelte/module.html"><strong aria-hidden="true">6.16.</strong> Module Context</a></li><li class="chapter-item "><a href="svelte/debug.html"><strong aria-hidden="true">6.17.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="graphql/intro.html"><strong aria-hidden="true">7.</strong> GraphQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="graphql/execution.html"><strong aria-hidden="true">7.1.</strong> Execution</a></li><li class="chapter-item "><a href="graphql/query-mutation.html"><strong aria-hidden="true">7.2.</strong> Query & Mutation</a></li><li class="chapter-item "><a href="graphql/schema-type.html"><strong aria-hidden="true">7.3.</strong> Schema & Type</a></li><li class="chapter-item "><a href="graphql/pagination.html"><strong aria-hidden="true">7.4.</strong> Pagination</a></li><li class="chapter-item "><a href="graphql/http.html"><strong aria-hidden="true">7.5.</strong> HTTP에서의 GraphQL</a></li></ol></li><li class="chapter-item "><a href="docker/setup.html"><strong aria-hidden="true">8.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="docker/sample.html"><strong aria-hidden="true">8.1.</strong> 샘플 애플리케이션</a></li><li class="chapter-item "><a href="docker/update.html"><strong aria-hidden="true">8.2.</strong> 애플리케이션 수정</a></li><li class="chapter-item "><a href="docker/share.html"><strong aria-hidden="true">8.3.</strong> 애플리케이션 공유</a></li><li class="chapter-item "><a href="docker/persist.html"><strong aria-hidden="true">8.4.</strong> DB 유지</a></li><li class="chapter-item "><a href="docker/bind-mounts.html"><strong aria-hidden="true">8.5.</strong> Bind Mounts</a></li><li class="chapter-item "><a href="docker/multi.html"><strong aria-hidden="true">8.6.</strong> 멀티 컨테이너 앱</a></li><li class="chapter-item "><a href="docker/docker-compose.html"><strong aria-hidden="true">8.7.</strong> Docker Compose</a></li><li class="chapter-item "><a href="docker/best-practices.html"><strong aria-hidden="true">8.8.</strong> 실전 이미지 빌딩</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> Etc.</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="etc/ssh.html"><strong aria-hidden="true">9.1.</strong> SSH</a></li><li class="chapter-item "><a href="etc/tdd.html"><strong aria-hidden="true">9.2.</strong> TDD</a></li><li class="chapter-item "><a href="etc/fp.html"><strong aria-hidden="true">9.3.</strong> 함수형 프로그래밍</a></li><li class="chapter-item "><a href="etc/rp.html"><strong aria-hidden="true">9.4.</strong> 반응형 프로그래밍</a></li></ol></li><li class="chapter-item "><a href="ml/index.html"><strong aria-hidden="true">10.</strong> Machine Learning</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/problem-framing/index.html"><strong aria-hidden="true">10.1.</strong> Problem Framing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/problem-framing/common-problems.html"><strong aria-hidden="true">10.1.1.</strong> Common ML Problems</a></li><li class="chapter-item "><a href="ml/problem-framing/mindset.html"><strong aria-hidden="true">10.1.2.</strong> The ML Mindset</a></li><li class="chapter-item "><a href="ml/problem-framing/good.html"><strong aria-hidden="true">10.1.3.</strong> Identifying Good Problems for ML</a></li><li class="chapter-item "><a href="ml/problem-framing/hard.html"><strong aria-hidden="true">10.1.4.</strong> Hard ML Problems</a></li><li class="chapter-item "><a href="ml/problem-framing/framing.html"><strong aria-hidden="true">10.1.5.</strong> Deciding on ML</a></li><li class="chapter-item "><a href="ml/problem-framing/formulate.html"><strong aria-hidden="true">10.1.6.</strong> Formulate Your Problem as an ML Problem</a></li></ol></li><li class="chapter-item "><a href="ml/crash-course/index.html"><strong aria-hidden="true">10.2.</strong> Crash Course</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ml/crash-course/framing.html"><strong aria-hidden="true">10.2.1.</strong> Framing</a></li><li class="chapter-item "><a href="ml/crash-course/descending-into-ml.html"><strong aria-hidden="true">10.2.2.</strong> Descending into ML</a></li><li class="chapter-item "><a href="ml/crash-course/reducing-loss.html"><strong aria-hidden="true">10.2.3.</strong> Reducing Loss</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">11.</strong> AWS</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="aws/iam.html"><strong aria-hidden="true">11.1.</strong> IAM</a></li><li class="chapter-item "><a href="aws/ec2.html"><strong aria-hidden="true">11.2.</strong> EC2</a></li><li class="chapter-item "><a href="aws/ami.html"><strong aria-hidden="true">11.3.</strong> AMI</a></li><li class="chapter-item "><a href="aws/ebs.html"><strong aria-hidden="true">11.4.</strong> EBS</a></li><li class="chapter-item "><a href="aws/efs.html"><strong aria-hidden="true">11.5.</strong> EFS</a></li><li class="chapter-item "><a href="aws/ebs-vs-efs.html"><strong aria-hidden="true">11.6.</strong> EBS vs. EFS</a></li><li class="chapter-item "><a href="aws/elb.html"><strong aria-hidden="true">11.7.</strong> ELB</a></li><li class="chapter-item "><a href="aws/rds.html"><strong aria-hidden="true">11.8.</strong> RDS</a></li><li class="chapter-item "><a href="aws/route53.html"><strong aria-hidden="true">11.9.</strong> Route 53</a></li><li class="chapter-item "><a href="aws/eb.html"><strong aria-hidden="true">11.10.</strong> Elastic Beanstalk</a></li><li class="chapter-item "><a href="aws/s3.html"><strong aria-hidden="true">11.11.</strong> S3</a></li><li class="chapter-item "><a href="aws/cf.html"><strong aria-hidden="true">11.12.</strong> CloudFront</a></li><li class="chapter-item "><a href="aws/storage-extra.html"><strong aria-hidden="true">11.13.</strong> Storage Extras</a></li><li class="chapter-item "><a href="aws/decouple-applications.html"><strong aria-hidden="true">11.14.</strong> Decoupling Applications</a></li><li class="chapter-item "><a href="aws/containers.html"><strong aria-hidden="true">11.15.</strong> Containers</a></li><li class="chapter-item "><a href="aws/serverless.html"><strong aria-hidden="true">11.16.</strong> Serverless</a></li><li class="chapter-item "><a href="aws/databases.html"><strong aria-hidden="true">11.17.</strong> Databases</a></li><li class="chapter-item "><a href="aws/data-analytics.html"><strong aria-hidden="true">11.18.</strong> Data & Analytics</a></li><li class="chapter-item "><a href="aws/machine-learning.html"><strong aria-hidden="true">11.19.</strong> Machine Learning</a></li><li class="chapter-item "><a href="aws/monitoring.html"><strong aria-hidden="true">11.20.</strong> Monitoring & Audit</a></li><li class="chapter-item "><a href="aws/iam-advanced.html"><strong aria-hidden="true">11.21.</strong> IAM Advanced</a></li><li class="chapter-item "><a href="aws/security.html"><strong aria-hidden="true">11.22.</strong> Security & Encryption</a></li><li class="chapter-item "><a href="aws/vpc.html"><strong aria-hidden="true">11.23.</strong> Networking - VPC</a></li><li class="chapter-item "><a href="aws/disaster-recovery.html"><strong aria-hidden="true">11.24.</strong> Disaster Recovery & Migrations</a></li><li class="chapter-item "><a href="aws/more-solution-architectures.html"><strong aria-hidden="true">11.25.</strong> More Solution Architectures</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> Network</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="network/osi-model.html"><strong aria-hidden="true">12.1.</strong> OSI Model</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shubi Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>각 문서의 순서는 그다지 상관이 없습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="웹-성능-최적화-기법"><a class="header" href="#웹-성능-최적화-기법">웹 성능 최적화 기법</a></h1>
<p><strong>웹 성능 최적화 기법</strong> 도서를 읽고 내용을 정리합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="웹-성능이란-무엇인가"><a class="header" href="#웹-성능이란-무엇인가">웹 성능이란 무엇인가?</a></h1>
<h2 id="1-웹"><a class="header" href="#1-웹">1. 웹</a></h2>
<h3 id="웹의-대표적인-요소"><a class="header" href="#웹의-대표적인-요소">웹의 대표적인 요소</a></h3>
<ul>
<li>URL</li>
<li>네트워크 프로토콜 (대개는 HTTP)</li>
<li>HTML</li>
</ul>
<h2 id="2-웹-성능이-중요한-이유"><a class="header" href="#2-웹-성능이-중요한-이유">2. 웹 성능이 중요한 이유</a></h2>
<p><strong>웹 성능</strong>이란 <em>콘텐츠가 신속하게 전달되어 사용자가 원하는 서비스를 빠르게 전달받을 수 있도록 하는 시스템들의 성능</em>을 의미한다. (≒ 웹 로딩 시간)</p>
<blockquote>
<p>3초의 법칙 ~ 3초 안에 웹 사이트에 접속한 사용자의 관심을 끄는 것이 필요하다. (그렇지 않으면 사용자가 이탈한다.)</p>
</blockquote>
<h2 id="3-웹-성능-측정-방법"><a class="header" href="#3-웹-성능-측정-방법">3. 웹 성능 측정 방법</a></h2>
<h3 id="대표적인-서비스"><a class="header" href="#대표적인-서비스">대표적인 서비스</a></h3>
<ul>
<li>브라우저 개발자 도구</li>
<li><a href="http://www.webpagetest.org/">WebPageTest</a></li>
<li><a href="https://pagespeed.web.dev/">구글 PageSpeed</a></li>
</ul>
<h2 id="4-웹-성능을-만드는-지표"><a class="header" href="#4-웹-성능을-만드는-지표">4. 웹 성능을 만드는 지표</a></h2>
<ul>
<li>스티브 사우더스의 14가지 웹 성능 최적화 기법</li>
</ul>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">최적화</th>
    <th class="tg-0pky" colspan="4">내용</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">백엔드</td>
    <td class="tg-0pky" colspan="4">1.Expires 헤더를 추가한다.<br>2. gzip으로 압축한다.<br>3. redirect를 피한다.<br>4. ETag를 설정한다.<br>5. 캐시를 지원하는 AJAX를 만든다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">프런트엔드</td>
    <td class="tg-0pky" colspan="4">1. HTTP 요청을 줄인다.<br>2. 스타일 시트는 상단에 넣는다.<br>3. 스크립트는 하단에 넣는다.<br>4. CSS 표현식은 피한다.<br>5. 자바스크립트와 CSS는 외부 파일에 넣는다.<br>6. 자바스크립트는 작게 한다.<br>7. 중복 스크립트는 제거한다.</td>
  </tr>
  <tr>
    <td class="tg-0pky">네트워크</td>
    <td class="tg-0pky" colspan="4">1. 콘텐츠 전송 네트워크(CDN)을 사용한다.<br>2. DNS 조회를 줄인다.</td>
  </tr>
</tbody>
</table>
<ul>
<li><a href="http://yslow.org/">yslow</a></li>
</ul>
<h2 id="5-웹-성능과-프런트엔드"><a class="header" href="#5-웹-성능과-프런트엔드">5. 웹 성능과 프런트엔드</a></h2>
<p>대다수 웹 사이트의 웹 성능 측정 시 가장 주요한 것은 프론트엔드 영역이며, 이는 웹 성능의 측정 기준이 <em>사용자 관점에서 원하는 콘텐츠를 전달받았는지</em>가 되기 때문이다.</p>
<h3 id="브라우저-렌더링"><a class="header" href="#브라우저-렌더링">브라우저 렌더링</a></h3>
<ul>
<li>FCP (First Contentful Paint) : 첫 번째 텍스트 또는 이미지가 표시되는 데 걸린 시간</li>
<li>SI (Speed Index) : 페이지 콘텐츠가 얾마나 빨리 표시되는지에 대한 정보</li>
<li>LCP (Largest Contentful Paint) : 가장 큰 텍스트 또는 이미지가 표시된 시간</li>
<li>TTI (Time to Interactive) : 사용자와 페이지가 상호 작용할 수 있게 된 시간</li>
<li>TBT (Total Blocking Time) : FCP와 TTI 사이 모든 시간의 합</li>
<li>CLS (Cumulative Layout Shift) : 표시 영역 안에 보이는 요소들이 얼마나 이동하는지에 대한 정보</li>
</ul>
<h2 id="6-웹-성능-예산"><a class="header" href="#6-웹-성능-예산">6. 웹 성능 예산</a></h2>
<p>웹 성능 예산(web performance budget)이란, <em>웹 성능에 영향을 미치는 다양한 요소를 제어하는 한계값</em>을 의미한다. 웹 성능 지표를 계량할 수 있도록 수치화하여 최적화의 목표치로 삼기 위해 사용한다.</p>
<h3 id="정량-기반-지표-quantity-based-metrics"><a class="header" href="#정량-기반-지표-quantity-based-metrics">정량 기반 지표 (quantity based metrics)</a></h3>
<p>웹 페이지 구성 요소에 대한 한계값</p>
<p>ex.) 이미지 파일의 최대 크기, JS 파일 크기 합...</p>
<h3 id="시간-기반-지표-timing-based-metrics--milestone-timing"><a class="header" href="#시간-기반-지표-timing-based-metrics--milestone-timing">시간 기반 지표 (timing based metrics ~ milestone timing)</a></h3>
<p>실제로 브라우저에서 측정 가능한 시간적 수치에 대한 시간에 대한 한계값</p>
<p>ex.) FCP, TTI</p>
<h3 id="규칙-기반-지표-rule-based-metrics"><a class="header" href="#규칙-기반-지표-rule-based-metrics">규칙 기반 지표 (rule based metrics)</a></h3>
<p>성능 측정 도구들을 통해 측정된 점수에 대한 한계값</p>
<p>ex.) WebPageTest의 성능 점수, 구글 Lighthouse의 성능 점수</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="웹-최적화"><a class="header" href="#웹-최적화">웹 최적화</a></h1>
<h2 id="1-웹-최적화란"><a class="header" href="#1-웹-최적화란">1. 웹 최적화란</a></h2>
<h3 id="1---1-프런트엔드-최적화"><a class="header" href="#1---1-프런트엔드-최적화">1 - 1. 프런트엔드 최적화</a></h3>
<ul>
<li>스크립트를 병합하여 브라우저의 호출 개수를 줄임</li>
<li>스크립트 크기를 최소화하여 바이트 자체를 줄임</li>
<li>스크립트를 gzip 등으로 압축하여 전달</li>
<li>WebP 등으로 브라우저 이미지 형식을 최적화</li>
<li>이미지 손실, 무손실 압축</li>
<li>Cache-Control 응답 헤더를 통해 브라우저 캐시를 충실히 사용</li>
<li>도메인 수를 줄여 DNS 조회를 최소화</li>
<li>DNS 정보 미리 읽어 오기</li>
<li>CSS를 HTML 상단에, 자바스크립트를 HTML 하단에 위치시키기</li>
<li>페이지 미리 읽어오기 (page prefetching)</li>
<li>타사 스크립트가 웹 성능을 방해하지 않도록 조정</li>
</ul>
<h3 id="1---2-백엔드-최적화"><a class="header" href="#1---2-백엔드-최적화">1 - 2. 백엔드 최적화</a></h3>
<ul>
<li>DNS 응답이 빨라지도록 서버 증설</li>
<li>DNS 응답을 빠르게 할 수 있도록 DNS 정보를 최대한 캐싱</li>
<li>웹 서버가 있는 데이터 센터의 네트워크 출력(throughput)/대역폭(bandwidth) 증설</li>
<li>웹 서버, 웹 애플리케이션 서버의 CPU/RAM 증설</li>
<li>프록시 서버를 설정하여 웹 콘텐츠를 캐싱</li>
<li>CDN(Content Delivery Network)을 사용해 인터넷 상에 콘텐츠 캐싱</li>
<li>데이터베이스 정규화로 디스크 I/O 최적화</li>
<li>데이터베이스 캐싱으로 응답을 빠르게</li>
<li>로드 밸런싱을 통해 가장 성능이 좋은 웹 서버로 요청을 연결</li>
<li>웹 애플리케이션 로직을 가볍고 빠르게 개발</li>
</ul>
<h3 id="1---3-프로토콜-최적화"><a class="header" href="#1---3-프로토콜-최적화">1 - 3. 프로토콜 최적화</a></h3>
<ul>
<li>웹 콘텐츠를 전달하는 HTTP/HTTPS 프로토콜 자체의 효과를 극대화</li>
</ul>
<h2 id="2-tcpip-프로토콜"><a class="header" href="#2-tcpip-프로토콜">2. TCP/IP 프로토콜</a></h2>
<p>TCP와 웹 성능도 밀접한 관련이 있어 TCP 성능이 나빠지는 웹 성능 역시 영향을 받는다.</p>
<ul>
<li>TCP 네트워크의 대표적인 성능 지표
<ul>
<li>대역폭(bandwidth): 특정 시간 동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는지?</li>
<li>지연 시간(latency): 클라이언트 - 서버 간 콘텐츠 전달에 얼마만큼의 시간이 걸리는지?</li>
</ul>
</li>
</ul>
<h3 id="2---1-tcp-혼잡-제어-tcp-congestion-control"><a class="header" href="#2---1-tcp-혼잡-제어-tcp-congestion-control">2 - 1. TCP 혼잡 제어 (TCP congestion control)</a></h3>
<p>TCP 혼잡 붕괴 (TCP congestion collapse): TCP 통신량이 실제 처리량보다 많아 문제가 발생하는 것</p>
<p>패킷을 보내는 쪽에서 네트워크에서 수용 가능한 양을 파악해 그 만큼의 패킷을 보내는 약속으로 TCP혼잡을 해결한다.</p>
<p>받는 쪽에서 패킷이 정상적으로 송신되었음을 알리는 ACK 패킷을 보내고, ACK 패킷을 받은 호스트에서는 지속적으로 패킷을 보낼 수 있다.</p>
<h4 id="느린-시작-slow-start"><a class="header" href="#느린-시작-slow-start">느린 시작 (slow start)</a></h4>
<p>TCP 연결 시작 시 전송 가능한 버퍼 양인 혼잡 윈도우(Congestion Window, CWND)의 초깃값을 작게 설정하여 전송하고, 해당 패킷에 대한 ACK를 받으면, 처음 보낸 패킷의 2배에 해당하는 패킷을 전송한다. 이런 식으로 패킷 유실(packet drop)이 발생하여 적절한 혼잡 윈도우의 크기를 파악하기 전까지 반복한다.</p>
<h4 id="빠른-재전송-fast-retransmit"><a class="header" href="#빠른-재전송-fast-retransmit">빠른 재전송 (fast retransmit)</a></h4>
<p>먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 수신자가 일단은 ACK 패킷을 보낸다. 중간에 패킷이 하나 손실되는 경우, 송신자가 중복된 ACK 패킷을 통해 이를 감지하고 전송되지 않은 패킷을 재전송한다. 중복된 패킷을 3개 받으면 반드시 손실된 패킷을 재전송하고, 동시에 혼잡 제어가 필요한 상황임을 인식해 혼잡 윈도우의 크기를 줄이는 작업도 수행한다.</p>
<h4 id="흐름-제어-flow-control"><a class="header" href="#흐름-제어-flow-control">흐름 제어 (flow control)</a></h4>
<p>TCP 송신자가 데이터를 너무 빠르게 혹은 너무 많이 전송하여 수신자의 버퍼가 오버플로되는 현상을 방지하는 기술이다. 송신자가 데이터를 전송하는 속도를 애플리케이션 프로세스를 읽는 속도와 유사한 수준으로 만들어 트래픽 수신 속도를 송신 속도와 일치시킨다.</p>
<h2 id="3-http-프로토콜"><a class="header" href="#3-http-프로토콜">3. HTTP 프로토콜</a></h2>
<p>웹은 HTTP 프로토콜을 통해 전달되므로, HTTP 성능의 개선 역시 웹 성능의 향상에 도움을 줄 수 있다.</p>
<h3 id="3---1-http-최적화-기술"><a class="header" href="#3---1-http-최적화-기술">3 - 1. HTTP 최적화 기술</a></h3>
<p>HTTP/0.9 : 클라이언트 ~ 서버 간 인터넷 통신 정상화, 가용성, 신뢰성 등 기능에 초점</p>
<p>HTTP/1.0 : 클라이언트 ~ 서버 간 요청과 응답을 빠르게 할 수 있는 연구</p>
<p>HTTP/1.1 이후 : 멀티 호스트 기능과 클라이언트 ~ 서버 간 사이에서 TCP/IP 연결을 재사용하능 기능을 추가</p>
<h3 id="3---2-http-지속적-연결"><a class="header" href="#3---2-http-지속적-연결">3 - 2. HTTP 지속적 연결</a></h3>
<p>3-way handshake: TCP 통신을 연결하는 방식으로, <code>SYN, SYN-ACK, ACK</code>의 3번의 요청/응답으로 이루어짐.</p>
<p>HTTP 초기에서는 요청과 응답을 위해 이와 같은 방식으로 TCP 연결을 수행했으나, 매 요청과 응답 간에 TCP 연결을 맺고 끊는 것을 반복해야 했는데, 점차 웹 페이지에서는 많은 양의 웹 콘텐츠를 전달해야 했으므로, 이러한 방식에는 번거로움이 따랐다.</p>
<p><strong>keep-alive</strong> 혹은 연결 재사용이라는 용어로 불리는 지속적 연결 방식은 클라이언트와 서버가 TCP 상에서 한번 연결되면 연결이 완전히 끊어지기 전까지 맺어진 연결을 지속적으로 재사용하는 기술이다. <strong>HTTP/1.0</strong> 기반에서 지속적 연결을 원하는 클아이언트가 해당 기능을 지원하는 웹 서버에 아래의 요청 헤더를 이용하여 지속적 연결을 요청할 수 있게 되었다.</p>
<pre><code>Connection: keep-alive
</code></pre>
<p><strong>HTTP/1.1</strong> 버전에서는 Connection 헤더를 사용하지 않아도 모든 요청과 응답이 이러한 지속적 연결을 기본으로 지원하며, HTTP 응답이 완료되거나 TCP 연결을 끊어야 하는 경우에만 이 Connection 헤더를 사용했다.</p>
<p><strong>HTTP/2</strong> 버전은 단일 TCP 연결로 클라이어늩와 서버 사이 응답 지연 없이 스트림(stream) 형태로 다수의 HTTP 요청과 응답을 주고받을 수 있는 멀티플렉싱 기술의 토대를 만들었다. 즉, HTTP/2를 사용한다면 더 이상 지속적 연결에 대해 고민을 필요가 없어졌다.</p>
<h3 id="3---3-http-파이프라이닝"><a class="header" href="#3---3-http-파이프라이닝">3 - 3. HTTP 파이프라이닝</a></h3>
<p>HTTP 파이프라이닝은 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 수신자 측에 전송하는 기술이다. 이는 기존의 선입선출(FIFO) 방식의 단점을 극복하기 위한 것으로, 중간에 응답 지연이 발생하더라도 클라이언트는 먼저 서버 측의 응답을 받을 수 있어 전반적으로 빠른 웹 로딩을 구현할 수 있다.</p>
<h2 id="4-dns"><a class="header" href="#4-dns">4. DNS</a></h2>
<h3 id="4---1-dns-작동-원리"><a class="header" href="#4---1-dns-작동-원리">4 - 1. DNS 작동 원리</a></h3>
<p>DNS는 인터넷 호스트명을 클라이언트와 서버가 이해할 수 있는 IP 주소로 변환해주는 시스템이다. DNS의 질의와 응답 성능이 나쁘면 웹 사이트 로딩에 영향을 줄 수 있다.</p>
<blockquote>
<p>로컬 DNS 서버 -&gt; 루트 DNS 서버 -&gt; .com DNS 서버 -&gt; example.com DNS 서버</p>
</blockquote>
<h3 id="4---2-사용-중인-다양한-도메인-확인-방법"><a class="header" href="#4---2-사용-중인-다양한-도메인-확인-방법">4 - 2. 사용 중인 다양한 도메인 확인 방법</a></h3>
<p>오픈소스 등으로 다양한 서비스들을 사용하게 되면서, 자신이 운영 중인 웹 서비스 도메인의 성능이 빠르다고 해서 DNS 조회 시에는 웹 성능에 문제가 업삳고 판단하기 어려워졌다. 이에 따라 특정 모듈 서비스의 DNS 조회가 불가능하거나 느리다면 해당 모듈을 자체 웹 서버에 업로드 후 제공하는 방법을 고려해야 한다.</p>
<h3 id="4---3-웹-성능을-최적화하는-도메인-운용-방법"><a class="header" href="#4---3-웹-성능을-최적화하는-도메인-운용-방법">4 - 3. 웹 성능을 최적화하는 도메인 운용 방법</a></h3>
<p>직접 개발한 내부 서비스에 도메인 분할을 하고자 한다면 상위 도메인을 동일하게 해 DNS 질의를 최대한 적게 만들자.</p>
<p>HTML의 DNS 프리패치(prefetch) 기능을 사용하면 웹 페이지에 사용된 도메인들의 DNS를 조회하는 시간이 좀 더 빨라진다. 이는 웹 페이지를 여는 시점에 멀티스레드 방식으로 미리 DNS를 조회해 빠르게 IP 주소를 불러오도록 하는 기술이다.</p>
<pre><code class="language-html">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.feoorea.com&quot; /&gt;
</code></pre>
<h2 id="5-브라우저"><a class="header" href="#5-브라우저">5. 브라우저</a></h2>
<h3 id="5---1-네비게이션-타이밍-api"><a class="header" href="#5---1-네비게이션-타이밍-api">5 - 1. 네비게이션 타이밍 API</a></h3>
<p>웹 사이트의 성능을 측정하는 데 사용할 수 있는 데이터를 Web API에서 제공한다. -&gt; <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance">window.performance</a></p>
<h3 id="5---2-네비게이션-타이밍-속성"><a class="header" href="#5---2-네비게이션-타이밍-속성">5 - 2. 네비게이션 타이밍 속성</a></h3>
<p>performance.timing은 페이지 요청 등의 탐색 이벤트 시간이나 DOM 로딩 시작 등의 페이지 로드 이벤트 시간을 파악하기 위해 사용할 수 있지만, 현 시점에서는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/timing">deprecated되고 있으므로,</a> 이는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming">PerformanceNavigationTiming</a> 인터페이스를 사용하는 것으로 대체되는 것이 좋겠다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="웹-사이트-성능을-개선하는-기본적인-방법"><a class="header" href="#웹-사이트-성능을-개선하는-기본적인-방법">웹 사이트 성능을 개선하는 기본적인 방법</a></h1>
<h2 id="1-http-요청-수-줄이기"><a class="header" href="#1-http-요청-수-줄이기">1. HTTP 요청 수 줄이기</a></h2>
<h3 id="1---1-스크립트-파일-병합"><a class="header" href="#1---1-스크립트-파일-병합">1 - 1. 스크립트 파일 병합</a></h3>
<p>여러 개로 나뉜 JS 파일을 하나로 병합하여 사용한다. 이는 요청을 줄일 뿐더러, 인터넷 상 프록시나 브라우저에 캐시될 확률을 좀 더 높인다.</p>
<h3 id="1---2-인라인-이미지"><a class="header" href="#1---2-인라인-이미지">1 - 2. 인라인 이미지</a></h3>
<p>이미지 파일을 따로 호출하여 받아오는 대신, base64 등을 이용해 이미지를 인라인으로 삽입하는 방식이다. 다만, 이 경우 이미지 파일 자체는 인터넷이나 브라우저를 통해 캐시되지 않으므로, 무조건적인 성능 향상을 보장하진 않기 때문에, 선택적으로 사용해야 한다.</p>
<h3 id="1--3-css-스프라이트"><a class="header" href="#1--3-css-스프라이트">1- 3. CSS 스프라이트</a></h3>
<p>여러 이미지를 하나의 이미지로 결합해, 필요한 이미지가 위치한 픽셀 좌표 정보를 사용해 필요한 이미지만 가져다 사용하는 방식이다. 주로 아이콘이나 버튼 같은 작은 이미지를 사용할 때 유용하다.</p>
<h2 id="2-콘텐츠-파일-크기-줄이기"><a class="header" href="#2-콘텐츠-파일-크기-줄이기">2. 콘텐츠 파일 크기 줄이기</a></h2>
<h3 id="2---1-스크립트-파일-압축-전달"><a class="header" href="#2---1-스크립트-파일-압축-전달">2 - 1. 스크립트 파일 압축 전달</a></h3>
<p>HTTP 프로토콜은 <code>Accept-Encoding</code>, <code>Content-Encoding</code> 헤더를 사용해 파일 압축 방식의 정보 교환을 지원한다. 요청 헤더는 <code>Accept-Encoding</code>, 응답 헤더는 <code>Content-Encoding</code>을 사용한다.</p>
<pre><code>// 클라이언트 요청 헤더
Accept-Encoding: gzip, deflate, sdch

// 웹 서버의 응답 헤더
Content-Encoding: gzip
</code></pre>
<h3 id="2---2-스크립트-파일-최소화"><a class="header" href="#2---2-스크립트-파일-최소화">2 - 2. 스크립트 파일 최소화</a></h3>
<p>HTML, CSS, JS 파일 내 실제 로직에는 아무 영향을 주지 않는 부분을 제거하거나, 간소화시켜 파일을 최소화하는 방법이다.</p>
<h3 id="2---3-이미지-파일-압축"><a class="header" href="#2---3-이미지-파일-압축">2 - 3. 이미지 파일 압축</a></h3>
<p><a href="https://tinypng.com/">tinyPNG</a> 등의 서비스를 사용하여 손실 압축 방식으로 이미지 파일을 압축할 수 있다.</p>
<h3 id="2---4-브라우저가-선호하는-이미지-포맷-사용"><a class="header" href="#2---4-브라우저가-선호하는-이미지-포맷-사용">2 - 4. 브라우저가 선호하는 이미지 포맷 사용</a></h3>
<ul>
<li>구글 - WebP</li>
<li>마이크로소프트 - JPEG XR</li>
</ul>
<h3 id="2---5-큰-파일은-작게-나누어-전송"><a class="header" href="#2---5-큰-파일은-작게-나누어-전송">2 - 5. 큰 파일은 작게 나누어 전송</a></h3>
<p>몇 GB에 해당하는 동영상 파일을 웹 사이트에 삽입했다고 하는 경우, 해당 파일을 한꺼번에 가져오는 것은 버퍼링을 유발할 수도 있고, 실제로 보지 않을 부분까지 가져올 가능성도 있어 자원 낭비가 이루어진다.</p>
<p>이에 부분 요청/응답을 수행할 수 있는데, 해당 기능의 지원 여부는 아래와 같이 웹 서버의 응답 헤더를 통해 확인할 수 있다.</p>
<pre><code class="language-bash">curl -I http://www.example.com/bigfile.jpg

HTTP/1.1
// ...
Accept-Ranges: bytes
Content-Length: 50000000
</code></pre>
<ul>
<li><code>Accept-Ranges</code>: byte 단위로 파일의 부분 지원 기능을 수락한다는 의미.</li>
<li><code>Content-Length</code>: 해당 파일의 전체 크기가 50MB라는 정보를 전달.</li>
</ul>
<p>이 응답의 내용에 기반하여 클라이언트가 특정 부분을 요청할 수 있다.</p>
<pre><code class="language-bash">curl -v http://www.example.com/bigfile.jpg -H &quot;Range: bytes=0-1023&quot;

HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/50000000
Content-Length: 1024
</code></pre>
<ul>
<li><code>Range: bytes=0-1023</code>: 파일의 처음(0)부터 1023바이트까지만 요청</li>
<li><code>Content-Range: bytes 0-1023/50000000</code>: 전체 파일 범위(<code>50000000</code> 중 처음부터 1023 바이트 까지만 전달한다는 의미</li>
<li><code>Content-Length: 1024</code>: 현재 전달한 부분 파일의 전체 용량이 시작 위치와 끝 위치를 알려주는 데이터를 포함하여 1024 바이트임을 명시</li>
</ul>
<p>이러한 요청을 여러 개의 범위를 갖는 것도 가능하다.</p>
<pre><code class="language-bash">curl -v http://www.example.com/bigfile.jpg -H &quot;Range: bytes=0-50, 100-150&quot;
</code></pre>
<h2 id="3-캐시-최적화하기"><a class="header" href="#3-캐시-최적화하기">3. 캐시 최적화하기</a></h2>
<h3 id="3---1-인터넷-캐시-사용"><a class="header" href="#3---1-인터넷-캐시-사용">3 - 1. 인터넷 캐시 사용</a></h3>
<p>프록시 서버 - 서버와 클라이언트 간에 통신을 대신해주는 역할을 하는 서버</p>
<h3 id="3---2-브라우저-캐시-사용"><a class="header" href="#3---2-브라우저-캐시-사용">3 - 2. 브라우저 캐시 사용</a></h3>
<p>웹 콘텐츠 중 일부를 클라이언트 측에 저장해 인터넷 상의 요청을 아예 수행하지 않도록 할 수 있다.</p>
<p>특정 콘첸츠를 브라우저에서 캐시하도록 하고, 얼마나 오랫동안 할 것인지에 대해 웹 서버는 <code>Cache-Control</code> 응답 헤더에 캐시 기간을 설정하여 클라이언트에게 전달한다. 해당 기간을 캐시의 생존 기간이라는 의미에서 TTL(Time To Live)이라고도 한다.</p>
<pre><code>Cache-Control: max-age=3600 // 1시간
</code></pre>
<p>Cache-Control의 설정값에는 다음과 같은 것들이 있다.</p>
<ul>
<li><code>no-store</code>: 브라우저가 캐시하지 않도록 설정함(ex. 민감 정보 등 절대 캐시해선 안되는 콘텐츠)</li>
<li><code>no-cache</code>: 브라우저 캐시를 사용하되, 원본 서버의 콘텐츠 갱신 여부를 미리 조사해 변경이 없을 때만 캐시 콘텐츠를 사용</li>
<li><code>must-revalidate</code>: 캐시 사용 전 웹 서버에서 설정한 캐시 가능 주기를 먼저 확인하여 해당 시간 범위 내에서만 캐시를 사용</li>
<li><code>public</code>: 해당 콘텐츠를 명확히 캐시할 수 있음</li>
</ul>
<p>반면, 콘텐츠를 특정 날짜의 특정 시간까지, datetime의 형태로 설정하고자 하는 경우에는 <code>Expires</code> 응답 헤더를 사용한다.</p>
<pre><code>Expires: Mon, 30 Nov 2020 07:00:00 GMT
</code></pre>
<h2 id="4-cdn-사용하기"><a class="header" href="#4-cdn-사용하기">4. CDN 사용하기</a></h2>
<p>CDN(Content Delivery Network): 인터넷 상에서 생산/소비되는 웹 콘텐츠를 사용자에게 빠르게 전달하기 위해 대용량 인터넷 캐시 영역에 콘텐츠를 저장해 사용하는 네트워크 방식이다. 여러 개의 분산된 서버로 이루어져 있고, 원본 서버라 불리는 콘텐츠 서버와 사용자 사이에서 프록시 역할을 한다.</p>
<p>CDN을 사용하면 다음과 같은 장점을 얻을 수 있다.</p>
<ol>
<li>인터넷 상 원거리에 있는 콘텐츠를 전달받는 과정에서 발생할 수 있는 네트워크 지연(network latency)와 패킷 손실(packet loss) 현상을 줄일 수 있다.</li>
<li>사용자는 가까운 에지 서버에 캐시된 콘텐츠를 전달받으므로, 전송에 필요한 RTT(Rount Trip Time)이 줄어들어 빠르게 콘텐츠를 받을 수 있다.</li>
<li>CDN의 에지 서버가 캐시된 콘텐츠를 전송하므로 원본 서버의 부하를 줄일 수 있다.</li>
<li>콘텐츠가 에지 서버와 주변 에지 서버 사이에 ICP(Internet Cache Protocol)를 이용한 서버 전파를 할 수 있어 캐시 콘텐츠의 재사용률이 매우 높다.</li>
<li>CDN 서비스들은 사용자 요청 트래픽이나 기술적 특이 사항을 모니터링하는 시스템을 갖추고 있어 인터넷 전송이 필요한 콘텐츠의 시스템과 인적 관리 비용이 절감된다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>실제 코드를 작성하다보면 놓치기 쉬운 JS의 개념들에 대해 작성합니다.</p>
<p>거의 모든 문서는 <a href="js/ko.javascript.info">ko.javascript.info</a>를 참고했습니다. (제 생각엔 진짜 최고의 JS 참고서입니다.)</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">여기</a>의 문서를 번역하여, 임의로 정리한 내용입니다.</p>
<h1 id="실행-컨텍스트-execution-context"><a class="header" href="#실행-컨텍스트-execution-context">실행 컨텍스트 (Execution Context)</a></h1>
<p>JS에서의 호스팅, 스코프, 클로저와 같은 개념들을 이해하기 위해서는 실행 컨텍스트(Execution Context)와 실행 스택(Execution Stack)에 대해서 이해해야 합니다.</p>
<h2 id="실행-컨텍스트란"><a class="header" href="#실행-컨텍스트란">실행 컨텍스트란?</a></h2>
<p>단순히 말해서, 실행 컨텍스트는 JS 코드가 평가되고 실행되는 환경의 추상적인 개념입니다. 어떤 코드가 JS에서 실행될 때, 이는 실행 컨텍스트 내에서 실행됩니다.</p>
<h2 id="실행-컨텍스트의-종류"><a class="header" href="#실행-컨텍스트의-종류">실행 컨텍스트의 종류</a></h2>
<p>다음 세 종류의 실행 컨텍스트가 있습니다.</p>
<ul>
<li>
<p><strong>전역 실행 컨텍스트</strong> : 기본 실행 컨텍스트로서, 어떤 함수에도 포함되어 있지 않은 코드의 경우, 전역 실행 컨텍스트에 포함됩니다. 브라우저를 기준으로, <code>window</code>에 해당하는 글로벌 객체를 생성하고, 해당 글로벌 객체를 <code>this</code>로 설정합니다. 하나의 프로그램에는 하나의 전역 실행 컨텍스트만 존재할 수 있습니다.</p>
</li>
<li>
<p><strong>함수 실행 컨텍스트</strong> : 함수가 실행될 때마다, 해당 함수에 대한 새로운 실행 컨텍스트가 생성됩니다. 각 함수들은 자신의 실행 컨텍스트를 보유하지만, 이는 해당 함수가 실행될 때에 생성됩니다. 함수 실행 컨텍스트는 여러개가 될 수 있습니다.</p>
</li>
<li>
<p><strong>Eval 함수 실행 컨텍스트</strong> : <code>eval</code>함수 내에서 실행되는 코드들도 자신의 실행 컨텍스트를 보유합니다. 다만, <code>eval</code>은 JS 개발자들 사이에 자주 사용되지 않으므로, 여기에서 언급하지 않겠습니다.</p>
</li>
</ul>
<h2 id="실행-스택"><a class="header" href="#실행-스택">실행 스택</a></h2>
<p><strong>호출 스택</strong>이라고도 불리는 실행 스택은, LIFO(후입선출) 스택 구조로 이루어진 하나의 스택입니다. 실행 스택은 코드 실행 중에 생성되는 모든 실행 컨텍스트를 담고 있습니다.</p>
<p>JS 엔진이 처음으로 스크립트에 마주치면, 전역 실행 객체를 생성한 후, 이를 현재 실행 스택에 추가(push)합니다. 이후 JS 엔진이 함수 실행을 발견할 때마다, 새로운 실행 컨텍스트를 생성하여 스택의 최상단에 추가합니다.</p>
<p>엔진은 실행 컨텍스트가 스택의 최상단에 있는 함수를 실행합니다. 해당 함수가 완료되면, 실행 스택은 스택으로부터 제거(pop)되며, 그 다음 컨텍스트로 넘어가게 됩니다.</p>
<pre><code class="language-js">let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
console.log('Inside Global Execution Context');
</code></pre>
<img src="https://miro.medium.com/max/2000/1*ACtBy8CIepVTOSYcVwZ34Q.png" />
<h2 id="실행-컨텍스트의-생성"><a class="header" href="#실행-컨텍스트의-생성">실행 컨텍스트의 생성</a></h2>
<p>이제 JS에서 실행 컨텍스트가 어떻게 생성도는지에 다루어보겠습니다.</p>
<p>실행 컨텍스트는 두 단계를 통해 생성됩니다. <strong>첫째는 생성 단계(Creation Phase)이고, 두번째는 실행 단계(Execution Phase)입니다.</strong></p>
<h2 id="생성-단계-creation-phase"><a class="header" href="#생성-단계-creation-phase">생성 단계 (Creation Phase)</a></h2>
<p>실행 컨텍스트는 생성 단계에서 생성됩니다. 해당 단계에서는 아래와 같은 일들이 일어납니다.</p>
<ol>
<li>렉시컬 환경(Lexical Environment)이 생성됩니다.</li>
<li>변수 환경(Variable Environment)이 생성됩니다.</li>
</ol>
<p>따라서, 실행 컨텍스트는 개념적으로 아래와 같이 나타낼 수 있습니다.</p>
<pre><code>ExecutionContext = {
  LexicalEnvironment = &lt;ref. to LexicalEnvironment in memory&gt;,
  VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;,
}
</code></pre>
<h3 id="렉시컬-환경lexical-environment"><a class="header" href="#렉시컬-환경lexical-environment">렉시컬 환경(Lexical Environment)</a></h3>
<p>렉시컬 환경은, 식별자-변수(Identifier-Variable) 매핑을 하는 자료구조입니다. (여기서, 식별자란 변수 또는 함수의 이름을 가리키며, 변수는 실제 객체에 대한 참조 또는 원시값을 가리킵니다.)</p>
<p>예를 들어, 아래의 코드를 살펴봅시다.</p>
<pre><code class="language-js">var a = 20;
var b = 40;
function foo() {
  console.log('bar');
}
</code></pre>
<p>위의 코드에서 렉시컬 환경은 다음과 같아질 것입니다.</p>
<pre><code>lexicalEnvironment = {
  a: 20,
  b: 40,
  foo: &lt;ref. to foo function&gt;
}
</code></pre>
<p>각각의 렉시컬 환경은 다음의 셋으로 구성되어 있습니다.</p>
<ol>
<li>환경 레코드 (Environment Record)</li>
<li>외부 환경에 대한 참조 (Reference to the outer environment)</li>
<li>This 바인딩</li>
</ol>
<h4 id="환경-레코드"><a class="header" href="#환경-레코드">환경 레코드</a></h4>
<p>환경 레코드는 렉시컬 환경 내에서 변수와 함수의 선언이 보관되는 장소입니다. 환경 레코드에는 두가지 타입이 있습니다.</p>
<ul>
<li>
<p>선언 환경 레코드(Declaration Environment Record) : 변수 및 함수 선언을 저장합니다. 함수 코드에 대한 렉시컬 환경은 선언 환경 레코드를 포함합니다.</p>
</li>
<li>
<p>객체 환경 레코드 (Object Environment Record) : 전역 코드에 대한 렉시컬 환경은 객체 환경 레코드를 포함합니다. 이는 변수와 함수 선언 외에도, 전역 바인딩 객체(Global binding object: 브라우저 상에서는 <code>window</code>)도 담고 있습니다. 따라서 레코드 내에 해당 바인딩 객체의 각 프로퍼티에 대한 새로운 항목이 생성됩니다.</p>
</li>
</ul>
<p>참고로, 함수 코드를 위해, 환경 레코드는 <code>arguments</code> 객체를 포함하고 있습니다. 이 <code>arguments</code>객체에는 인덱스와 함수에 전달되는 인수(arguments) 간의 매핑과, 함수에 넘겨지는 인수의 갯수(length)가 담겨있습니다. 예를 들어, 아래 함수에서 <code>argument</code> 객체는 다음과 같은 형태일 것입니다.</p>
<pre><code class="language-js">function foo(a, b) {
  var c = a + b;
}
foo(2, 3);
// argument object
Arguments: {0: 2, 1: 3, length: 2},
</code></pre>
<h4 id="외부-환경에-대한-참조"><a class="header" href="#외부-환경에-대한-참조">외부 환경에 대한 참조</a></h4>
<p>&quot;외부 환경에 대한 참조&quot;는 외부 렉시컬 환경에 대한 접근을 의미합니다. 이는 JS 엔진이 현재 렉시컬 환경에서 원하는 변수를 찾지 못하면, 외부 환경으로 뻗어나가 해당 변수를 찾을 수 있다는 것을 의미합니다.</p>
<h4 id="this-바인딩"><a class="header" href="#this-바인딩">This 바인딩</a></h4>
<p>전역 실행 컨텍스트에서, <code>this</code>의 값은 전역 객체에 바인딩됩니다. (브라우저 상에서 <code>window</code> 객체)</p>
<p>함수 실행 컨텍스트에서, <code>this</code>의 값은 어떻게 해당 함수가 호출되느냐에 따라 달라집니다. 객체 참조에 의해서 호출되는 경우 <code>this</code>의 값은 해당 객체가 됩니다. 그렇지 않은 경우에 <code>this</code>는 전역 객체가 되며, strict 모드 상에서는 <code>undefined</code>가 됩니다.</p>
<pre><code class="language-js">const person = {
  name: 'peter',
  birthYear: 1994,
  calcAge: function () {
    console.log(2018 - this.birthYear);
  },
};
person.calcAge();
// `this`는 `person`이 됩니다. `calcAge`가 `person` 객체 참조에 의해 호출되었기 때문입니다.
const calculateAge = person.calcAge;
calculateAge();
// `this`는 전역 객체에 해당하는 `window`입니다. 별도로 넘겨받은 객체 참조가 없기 때문입니다. strict 모드라면, `undefined`가 됩니다.
</code></pre>
<p>지금까지의 내용을 되짚어보자면, 렉시컬 환경은 추상적으로 다음과 같이 생겼을겁니다.</p>
<pre><code>GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // Identifier bindings go here
    }
    outer: &lt;null&gt;,
    this: &lt;global object&gt;
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Declarative&quot;,
      // Identifier bindings go here
    }
    outer: &lt;Global or outer function environment reference&gt;,
    this: &lt;depends on how function is called&gt;
  }
}
</code></pre>
<h3 id="변수-환경-variable-environment"><a class="header" href="#변수-환경-variable-environment">변수 환경 (Variable Environment)</a></h3>
<p>이 또한 실행 컨텍스트 내에서 <code>VariableStatements</code>를 통해 생성된 바인딩을 환경 레코드에 보관하는 렉시컬 환경입니다.</p>
<p>위에서 말했듯, 변수 환경 또한 렉시컬 환경입니다. 따라서 앞서 말했던 렉시컬 환경이 갖고 있는 모든 구성요소와 프로퍼티를 갖고 있습니다.</p>
<p>ES6 상에서, 렉시컬 환경과 변수 환경의 한가지 차이는, 렉시컬 환경이 함수 선언과 <code>let</code>, <code>const</code> 변수 바인딩에 사용되는 반면, 변수 환경은 오직 <code>var</code> 변수의 바인딩에만 사용된다는 것입니다.</p>
<h2 id="실행-단계-execution-phase"><a class="header" href="#실행-단계-execution-phase">실행 단계 (Execution Phase)</a></h2>
<p>이 단계에서 모든 변수에 대한 할당이 완료되고, 코드가 마침내 실행됩니다.</p>
<p>아래 예시 코드를 살펴봅시다.</p>
<pre><code class="language-js">let a = 20;
const b = 30;
var c;

function multiply(e, f) {
  var g = 20;
  return e * f * g;
}

c = multiply(20, 30);
</code></pre>
<p>위의 코드가 실행될 때, JS 엔진은 전역 코드를 실행하기 위해 전역 실행 컨텍스트를 먼저 생성합니다. 따라서 전역 실행 컨텍스트는 생성 단계를 거쳐 아래와 같아질 것입니다.</p>
<pre><code>GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // Identifier bindings go here
      a: &lt; uninitialized &gt;,
      b: &lt; uninitialized &gt;,
      multiply: &lt; func &gt;
    }
    outer: &lt;null&gt;,
    ThisBinding: &lt;Global Object&gt;
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: &quot;Object&quot;,
      // Identifier bindings go here
      c: undefined,
    }
    outer: &lt;null&gt;,
    ThisBinding: &lt;Global Object&gt;
  }
}
</code></pre>
<p>실행 단계에서는 변수 할당이 수행됩니다. 따라서 전역 실행 컨텍스트 실행 단계를 거쳐 아래와 같아질 것입니다.</p>
<pre><code>GlobalExectionContext = {
  LexicalEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Object&quot;,
        // Identifier bindings go here
        a: 20,
        b: 30,
        multiply: &lt; func &gt;
      }
      outer: &lt;null&gt;,
      ThisBinding: &lt;Global Object&gt;
    },
  VariableEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Object&quot;,
        // Identifier bindings go here
        c: undefined,
      }
      outer: &lt;null&gt;,
      ThisBinding: &lt;Global Object&gt;
    }
}
</code></pre>
<p>이후, <code>multiply(20, 30)</code> 함수의 호출을 마주치면, 해당 함수 코드를 실행하기 위해 새로운 함수 실행 컨텍스트가 생성됩니다. 따라서, 생성 단계를 거쳐 다음과 같이 새로운 함수 실행 컨텍스트가 만들어집니다.</p>
<pre><code>FunctionExectionContext = {
  LexicalEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        Arguments: {0: 20, 1: 30, length: 2},
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;,
    },
  VariableEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        g: undefined
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;
    }
}
</code></pre>
<p>그 다음, 실행 컨텍스트는 실행 단계를 거쳐 아래와 같이 변수 할당이 완수됩니다. 따라서, 함수 실행 컨텍스트는 실행 단계를 거쳐 다음과 같은 형태가 됩니다.</p>
<pre><code>FunctionExectionContext = {
  LexicalEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        Arguments: {0: 20, 1: 30, length: 2},
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;,
    },
  VariableEnvironment: {
      EnvironmentRecord: {
        Type: &quot;Declarative&quot;,
        // Identifier bindings go here
        g: 20
      },
      outer: &lt;GlobalLexicalEnvironment&gt;,
      ThisBinding: &lt;Global Object or undefined&gt;
    }
}
</code></pre>
<p>이후 함수의 실행이 완료되면, 반환 값이 <code>c</code>에 보관됩니다. 따라서 전역 렉시컬 환경이 갱신됩니다. 이후, 전역 코드가 모두 완료되고, 프로그램은 종료됩니다.</p>
<p><strong>참고</strong> - 아마 위의 과정을 따라가면서, 최초에 <code>let</code>과 <code>const</code>에는 아무런 값도 할당되지 않은 것을 확인했을 것입니다. 반면에 <code>var</code>에는 <code>undefined</code>로 값이 할당됩니다.</p>
<p>이런 일이 발생하는 이유는, 생성 단계를 통해 코드의 변수 및 함수 선언에 대해 스캔하는 동안, 함수 선언은 환경에 전체적으로 저장되는 반면, 각 변수는 <code>undefined</code>로 설정되거나(<code>var</code>의 경우), 초기화되지 않은 상태(initialized)로 설정되기 때문입니다.(<code>let</code> 또는 <code>const</code>의 경우)</p>
<p>이것이 <code>var</code>를 사용할 때, <code>var</code>가 선언되기도 전에 상단에서 접근할 수 있게되는 이유입니다. 반면에 <code>let</code> 또는 <code>const</code>의 경우 이들이 선언되기 전에는 참조 에러를 발생시킬 것입니다.</p>
<p>그리고, <code>var</code>에 나타나는 이러한 현상을 우리는 <strong>호이스팅</strong>이라고 합니다.</p>
<p><strong>참고</strong> - 실행 단계에서, JS 엔진이 <code>let</code> 키워드로 선언된 변수의 값을 찾지 못하는 경우, <code>undefined</code>로 이를 할당합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="class"><a class="header" href="#class">Class</a></h1>
<h2 id="클래스와-기본-문법"><a class="header" href="#클래스와-기본-문법">클래스와 기본 문법</a></h2>
<p>클래스는 다음과 같은 문법을 통해 만들 수 있다.</p>
<pre><code class="language-js">class MyClass {
  constructor() {}
  method1() {}
  method2() {}
  ...
}
</code></pre>
<p>이렇게 클래스를 만들고, <code>new MyClass()</code>를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성된다.</p>
<p>객체의 기본 상태를 설정해주는 생성자 메서드 <code>constructor()</code>는 <code>new</code>에 의해 자동으로 호출되므로, 별다른 절차 없이 객체를 초기화할 수 있다.</p>
<pre><code class="language-js">class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
}

// 사용법:
let user = new User('John');
user.sayHi();
</code></pre>
<p>위에서 <code>new User(&quot;John&quot;)</code>을 호출하면 다음과 같은 일이 일어난다.</p>
<ol>
<li>새로운 객체가 생성된다.</li>
<li>넘겨받은 인수와 함께 <code>constructor</code>가 자동으로 실행된다. 이 때, 인수 <code>&quot;John&quot;</code>이 <code>this.name</code>에 할당된다.</li>
</ol>
<p>이런 과정을 거친 후에 <code>user.sayHi()</code> 같은 객체 메서드를 호출할 수 있다.</p>
<h3 id="그래서-클래스란"><a class="header" href="#그래서-클래스란">그래서 클래스란??</a></h3>
<p><code>class User {...}</code> 문법 구조가 진짜 하는 일은 다음과 같다.</p>
<ol>
<li><code>User</code>라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 <code>constructor</code>에서 가져온다. 생성자 메서드가 없으면 비워진 채로 함수가 만들어진다.</li>
<li><code>sayHi</code>같은 클래스 내에서 정의한 메서드를 <code>User.prototype</code>에 저장한다.</li>
</ol>
<p><code>new User</code>를 호출해 객체를 만들고, 이후 객체의 메서드가 호출되면 메서드를 프로토타입에서 가져온다. 이 덕분에 객체에서 클래스 메서드에 접근할 수 있다.</p>
<pre><code class="language-js">class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

// 클래스는 함수입니다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일합니다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장됩니다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개입니다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
</code></pre>
<h3 id="클래스는-단순-syntactic-sugar가-아니다"><a class="header" href="#클래스는-단순-syntactic-sugar가-아니다">클래스는 <strong>단순 Syntactic Sugar가 아니다.</strong></a></h3>
<p>이건 나도 잘못 알고있었던 내용이다. 아래처럼 <code>prototype</code>을 이용하면 순수 함수로도 클래스 역할을 하는 함수를 만들 수 있다. 때문에 <code>class</code>를 단순한 Syntactic Sugar로 여기고 있었다.</p>
<pre><code class="language-js">// class User와 동일한 기능을 하는 순수 함수를 만들어보겠습니다.

// 1. 생성자 함수를 만듭니다.
function User(name) {
  this.name = name;
}
// 모든 함수의 프로토타입은 'constructor' 프로퍼티를 기본으로 갖고 있기 때문에
// constructor 프로퍼티를 명시적으로 만들 필요가 없습니다.

// 2. prototype에 메서드를 추가합니다.
User.prototype.sayHi = function () {
  alert(this.name);
};

// 사용법:
let user = new User('John');
user.sayHi();
</code></pre>
<p>근데 둘 사이에는 중요한 차이가 몇 가지 있다.</p>
<ol>
<li><code>class</code>로 만든 함수엔 특수 내부 프로퍼티인 <code>[[FunctionKind]]: &quot;classConstructor&quot;</code>가 이름표처럼 붙는다. 이것만으로도 두 방법엔 차이가 있다. 이런 검증 과정 때문에, <strong>클래스 생성자는 <code>new</code>와 함께 호출하지 않으면 에러가 발생한다.</strong></li>
</ol>
<p>더불어, 대부분의 JS엔진에서 클래스 생성자를 문자열로 표현할 때 <code>class ...</code>로 시작하게 된다는 차이도 생긴다.</p>
<pre><code class="language-js">class User {
  constructor() {}
}

alert(typeof User); // function
User(); // TypeError: Class constructor User cannot be invoked without 'new'
</code></pre>
<pre><code class="language-js">class User {
  constructor() {}
}

alert(User); // class User { ... }
</code></pre>
<ol start="2">
<li>
<p>클래스 메서드는 열거할 수 없다.(non-enumerable) 클래스의 <code>prototype</code> 프로퍼티에 추가된 메서드 전체의 <code>enumerable</code> 플래그는 <code>false</code>이고, <code>for..in</code>으로 객체를 순회할 때, 이는 순회 대상에서 제외된다. 보통 메서드는 순회 대상에서 제외하고자 하므로, 이 특징은 제법 유용하다.</p>
</li>
<li>
<p>클래스는 항상 엄격모드로 실행된다.(<code>use strict</code>) 클래스 생성자 안 코드 전체엔 자동으로 엄격모드가 적용된다.</p>
</li>
</ol>
<h3 id="클래스-표현식"><a class="header" href="#클래스-표현식">클래스 표현식</a></h3>
<p>함수처럼 클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.
먼저 클래스 표현식을 만들어보자.</p>
<pre><code class="language-js">let User = class {
  sayHi() {
    alert('Hello');
  }
};
</code></pre>
<p>기명 함수 표현식(Named Function Expression)과 유사하게 클래스 표현식에도 이름을 붙일 수 있다.
클래스 표현식에 이름을 붙이면, 이 이름은 오직 클래스 내부에서만 사용할 수 있다.</p>
<pre><code class="language-js">// 기명 클래스 표현식(Named Class Expression)
// (명세서엔 없는 용어이지만, 기명 함수 표현식과 유사하게 동작합니다.)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass라는 이름은 오직 클래스 안에서만 사용할 수 있습니다.
  }
};

new User().sayHi(); // 제대로 동작합니다(MyClass의 정의를 보여줌).

alert(MyClass); // ReferenceError: MyClass is not defined, MyClass는 클래스 밖에서 사용할 수 없습니다.
</code></pre>
<p>필요에 따라 동적인 생성 역시 가능하다.</p>
<pre><code class="language-js">function makeClass(phrase) {
  // 클래스를 선언하고 이를 반환함
  return class {
    sayHi() {
      alert(phrase);
    }
  };
}

// 새로운 클래스를 만듦
let User = makeClass('Hello');

new User().sayHi(); // Hello
</code></pre>
<h3 id="getter와-setter"><a class="header" href="#getter와-setter">getter와 setter</a></h3>
<p>리터럴을 사용해 만든 객체처럼 클래스도 getter나 setter, 계산된 프로퍼티(computed property)를 포함할 수 있다.</p>
<pre><code class="language-js">class User {
  constructor(name) {
    // setter를 활성화합니다.
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length &lt; 4) {
      alert('이름이 너무 짧습니다.');
      return;
    }
    this._name = value;
  }
}

let user = new User('John');
alert(user.name); // John

user = new User(''); // 이름이 너무 짧습니다.
</code></pre>
<p>이런 방법으로 클래스를 선언하면 <code>User.prototype</code>에 getter와 setter가 만들어지는 것과 동일하다.</p>
<h3 id="계산된-메서드명-"><a class="header" href="#계산된-메서드명-">계산된 메서드명 [...]</a></h3>
<p>대괄호 <code>[...]</code>을 이용해 계산된 메서드 이름(computed method name)을 만드는 예시도 있다.</p>
<pre><code class="language-js">class User {
  ['say' + 'Hi']() {
    alert('Hello');
  }
}

new User().sayHi();
</code></pre>
<h3 id="클래스-필드"><a class="header" href="#클래스-필드">클래스 필드</a></h3>
<p>이는 비교적 최근에 생겨난 기능으로, 구식 브라우저에서는 폴리필이 필요할 수도 있다.</p>
<p>지금까지 살펴본 예시엔 메서드가 하나만 있었다.</p>
<p>'클래스 필드(Class Field)'라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.</p>
<p>클래스 <code>User</code>에 <code>name</code> 프로퍼티를 추가해보자.</p>
<pre><code class="language-js">class User {
  name = 'John';

  sayHi() {
    alert(`Hello, {this.name}!`);
  }
}

new User().sayHi(); // Hello, John!
</code></pre>
<p>클래스를 정의할 때 <code>&lt;프로퍼티명&gt; = &lt;값&gt;</code>을 써주면 간단히 클래스 필드를 만들 수 있다.]</p>
<p>클래스 필드의 중요한 특징 중 하나는 <code>User.prototype</code>이 아닌 개별 객체에<strong>만</strong> 클래스 필드가 설정된다는 점이다.</p>
<pre><code class="language-js">class User {
  name = 'John';
}

let user = new User();
alert(user.name); // John
alert(User.prototype.name); // undefined
</code></pre>
<p>클래스 필드는 생성자가 그 역할을 다 한 이후에 처리된다. 따라서 복잡한 표현식이나 함수 호출 결과를 사용할 수 있다.</p>
<pre><code class="language-js">class User {
  name = prompt('이름을 알려주세요.', '보라');
}

let user = new User();
alert(user.name); // 보라
</code></pre>
<h3 id="클래스-필드로-바인딩-된-메서드-만들기"><a class="header" href="#클래스-필드로-바인딩-된-메서드-만들기">클래스 필드로 바인딩 된 메서드 만들기</a></h3>
<p>JS의 함수는 알다시피 동적인 <code>this</code>를 갖는다.</p>
<p>따라서 객체 메서드를 여기저기 전달해 다른 컨텍스트에서 호출하게 되면 <code>this</code>는 원래 객체를 참조하지 않는다.</p>
<p>관련 예시를 살펴보자. 예시를 실행하면 <code>undefined</code>가 출력된다.</p>
<pre><code class="language-js">class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button('hello');

setTimeout(button.click, 1000); // undefined
</code></pre>
<p>이렇게 <code>this</code>의 컨텍스트를 알수 없게 되어버리는 문제를 <strong>Losing this</strong>라고 한다.</p>
<p>문제를 해결하기 위해선 두 개의 방법이 있다.</p>
<ol>
<li><code>setTimeout(() =&gt; button.click(), 1000)</code>같이 래퍼 함수를 전달</li>
<li>생성자 안 등에서 메서드를 객체에 바인딩</li>
</ol>
<p>여기에 더해, 클래스 필드는 또 다른 훌륭한 방법을 제공한다.</p>
<pre><code class="language-js">class Button {
  constructor(value) {
    this.value = value;
  }
  click = () =&gt; {
    alert(this.value);
  };
}

let button = new Button('hello');

setTimeout(button.click, 1000); // hello
</code></pre>
<p>클래스 필드 <code>click = () =&gt; {...}</code>는 각 <code>Button</code> 객체마다 독립적인 함수를 만들고 함수의 <code>this</code>를 해당 객체에 바인딩시켜준다. 따라서 개발자는 <code>button.click</code>과 같은 메서드를 아무 곳에나 전달할 수 있고, <code>this</code>에는 항상 의도한 값이 들어가게 된다.</p>
<p>대체로 클래스 필드의 이런 기능은 <strong>브라우저 환경에서 메서드를 이벤트 리스너로 설정해야 할 때 특히 유용하다.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="화살표-함수-다시보기"><a class="header" href="#화살표-함수-다시보기">화살표 함수 다시보기</a></h1>
<p>화살표 함수(Arrow Function)에 대해 다시 생각해보자.</p>
<p>화살표 함수는 단순히 함수를 짧게 쓰기 위해 쓰지 않는다. 화살표 함수는 몇 가지 독특하고 유용한 기능을 제공한다.</p>
<h2 id="화살표-함수에는-this가-없다"><a class="header" href="#화살표-함수에는-this가-없다">화살표 함수에는 <code>this</code>가 없다.</a></h2>
<p>화살표 함수 본문에서 <code>this</code>에 접근하면 외부에서 값을 가져온다.</p>
<p>이런 특징은 객체의 메서드(<code>showList()</code>)안에서 동일 객체의 프로퍼티(<code>students</code>)를 대상으로 순회를 하는 데 사용할 수 있다.</p>
<pre><code class="language-js">let group = {
  title: '1모둠',
  students: ['보라', '호진', '지민'],

  showList() {
    this.students.forEach((student) =&gt; alert(this.title + ': ' + student));
  },
};

group.showList();
</code></pre>
<p>예시의 <code>forEach</code>에서 화살표 함수를 사용했기 때문에 화살표 함수 본문에 있는 <code>this.title</code>은 화살표 함수 바깥에 있는 메서드인 <code>showList</code>가 가리키는 대상과 동일해진다. 즉 <code>this.title</code>은 <code>group.title</code>과 같다.</p>
<p>위 예시에서 화살표 함수 대신 일반 함수를 사용했다면 에러가 발생했을 것이다.</p>
<pre><code class="language-js">let group = {
  title: '1모둠',
  students: ['보라', '호진', '지민'],

  showList() {
    this.students.forEach(function (student) {
      // TypeError: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student);
    });
  },
};

group.showList();
</code></pre>
<p>이는 <code>forEach</code>에 전달되는 함수의 <code>this</code>가 <code>undefined</code>이기 때문에 발생한다. <code>alert</code> 함수에서 <code>undefined.title</code>에 접근하려 했기 때문에 에러가 발생한다.</p>
<p>반면, 화살표 함수에는 <code>this</code>라는 개념 자체가 없기 때문에 이런 에러가 발생하지 않는다.</p>
<p>또한, <code>this</code>가 없기 때문에 <code>new</code>와 함께 사용할 수 없기도 하다.</p>
<h2 id="화살표-함수에는-arguments가-없다"><a class="header" href="#화살표-함수에는-arguments가-없다">화살표 함수에는 <code>arguments</code>가 없다.</a></h2>
<p>화살표 함수는 일반 함수와 다르게 모든 인수에 접근할 수 있게 해주는 유사 배열(Array) 객체 <code>arguments</code>를 지원하지 않는다.</p>
<p>이런 특징은 현재 <code>this</code>값과 <code>arguments</code> 정보를 함께 실어 호출을 포워딩해주는 데코레이터를 만들 때 유용하게 사용된다.</p>
<pre><code class="language-js">function defer(f, ms) {
  return function () {
    setTimeout(() =&gt; f.apply(this, arguments), ms);
  };
}

function sayHi(who) {
  alert('안녕, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred('철수'); // 2초 후 &quot;안녕, 철수&quot;가 출력됩니다.
</code></pre>
<p>이것을 화살표 함수 없이 구현하려 했다면 아래와 같이 가독성이 떨어지는 형태가 된다.</p>
<pre><code class="language-js">function defer(f, ms) {
  return function (...args) {
    let ctx = this;
    setTimeout(function () {
      return f.apply(ctx, args);
    }, ms);
  };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-바인딩"><a class="header" href="#함수-바인딩">함수 바인딩</a></h1>
<p><code>setTimeout</code>에 메서드를 전달할 때처럼, 객체 메서드를 콜백으로 전달할 때는 <code>this</code>가 사라지는 문제가 생긴다.</p>
<h2 id="사라진-this"><a class="header" href="#사라진-this">사라진 <code>this</code></a></h2>
<p>앞서 다양한 예제를 통해 <code>this</code> 정보가 사라지는 문제를 경험했다. 객체 메서드가 객체 내부가 아닌 다른 곳에 전달되어 호출되면 <code>this</code>가 사라진다.</p>
<p>대표적인 예는 <code>setTimeout</code>등에서 콜백함수로 넘겨지는 경우에 발생하는 것이다.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
</code></pre>
<p>이런 문제는 콜백함수를 전달 할 때, 객체에서 메서드가 분리(<code>user.sayHi</code>)되어 하나의 함수로써 전달되기 때문이다.</p>
<h3 id="해결-1--래퍼wrapper-함수"><a class="header" href="#해결-1--래퍼wrapper-함수">해결 1 : 래퍼(Wrapper) 함수</a></h3>
<p>가장 간단한 해결책은 래퍼 함수를 사용하는 것이다.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

setTimeout(function () {
  user.sayHi(); // Hello, John!
}, 1000);
</code></pre>
<p>위 예시가 의도대로 동작하는 이유는, 외부 렉시컬 환경에서 <code>user</code>를 받아 보통 때와 똑같이 메서드를 호출하기 때문이다.</p>
<p>단, 이 경우 약간의 취약성이 생기는데, <code>setTimeout</code>이 트리거 되기 전, <code>user</code>에 변경이 가해지면, 변경된 상태의 객체 메서드를 호출한다는 점이다.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

setTimeout(() =&gt; user.sayHi(), 1000);

// 1초가 지나기 전에 user의 값이 바뀜
user = {
  sayHi() {
    alert('또 다른 사용자!');
  },
};

// setTimeout에 또 다른 사용자!
</code></pre>
<p>이런 문제는 두 번째 방법을 사용함으로써 방지할 수 있다.</p>
<h3 id="방법-2--bind"><a class="header" href="#방법-2--bind">방법 2 : bind</a></h3>
<p>모든 함수는 <code>this</code>를 수정하게 해주는 내장 메서드 <code>bind</code>를 제공한다.</p>
<p>기본 문법은 다음과 같다.</p>
<pre><code class="language-js">// 더 복잡한 문법은 뒤에 나옵니다.
let boundFunc = func.bind(context);
</code></pre>
<p><code>func.bind(context)</code>는 함수처럼 호출 가능한 '특수 객체(exotic object)'를 반환한다. 이 객체를 호출하면 <code>this</code>가 <code>context</code>로 고정된 함수 <code>func</code>이 반환된다.</p>
<p>이제 <code>boundFunc</code>를 호출하면 <code>this</code>가 고정된 <code>func</code>를 호출하는 것과 동일한 효과를 본다.</p>
<p>아래 <code>funcUser</code>에는 <code>this</code>가 <code>user</code>로 고정된 <code>func</code>이 할당된다.</p>
<p>이제 객체 메서드에 <code>bind</code>를 적용해보자.</p>
<pre><code class="language-js">let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, {this.firstName}!`);
  },
};

let sayHi = user.sayHi.bind(user); // (*)

// 이제 객체 없이도 객체 메서드를 호출할 수 있습니다.
sayHi(); // Hello, John!

setTimeout(sayHi, 1000); // Hello, John!

// 1초 이내에 user 값이 변화해도
// sayHi는 기존 값을 사용합니다.
user = {
  sayHi() {
    alert('또 다른 사용자!');
  },
};
</code></pre>
<h3 id="부분-적용-partial-application"><a class="header" href="#부분-적용-partial-application">부분 적용 (Partial Application)</a></h3>
<p>지금껏 <code>this</code>에 대해서만 이야기했지만, <code>this</code>뿐만 아니라 인수에 대해서도 바인딩이 가능하다. 이는 자주 쓰이진 않지만 가끔 유용하다.</p>
<p>```bind`의 전체 문법은 다음과 같다.</p>
<pre><code class="language-js">let bound = func.bind(context, [arg1], [arg2], ...);
</code></pre>
<p><code>bind</code>는 컨텍스트를 <code>this</code>로 고정하는 것 뿐만 아니라 함수의 인수도 고정해준다.</p>
<p>곱셈을 해주는 함수 <code>mul(a, b)</code>를 예시로 들어보고, <code>bind</code>를 통해 새로운 함수 <code>double</code>을 만들어본다.</p>
<pre><code class="language-js">function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert(double(3)); // = mul(2, 3) = 6
alert(double(4)); // = mul(2, 4) = 8
alert(double(5)); // = mul(2, 5) = 10
</code></pre>
<p>이처럼, <code>context</code>는 따로 넘겨주지 않고 인수에 대해서만 값을 전달해 고정해주는 방식을 **부분 적용(Partial Application)**이라고 한다.</p>
<p>이는 매우 포괄적인 함수를 기반으로 덜 포괄적인 변형 함수를 만들어 낼 수 있다는 점에서 유용하다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="call-apply-decorator-call-forwarding"><a class="header" href="#call-apply-decorator-call-forwarding">call, apply, decorator, call forwarding</a></h1>
<h2 id="데코레이터"><a class="header" href="#데코레이터">데코레이터</a></h2>
<p><strong>데코레이터(Decorator)는 특정 함수를 인수로 받아, 반환하는 값 자체는 동일하지만 그 외의 로직을 추가적으로 커스텀하는 함수를 의미한다.</strong></p>
<p>로직을 함수와 함수로 분리시킬 수 있기 때문에 한결 보기 편하다는 장점이 있다.</p>
<pre><code class="language-js">function slow(x) {
  // CPU 집약적인 작업이 여기에 올 수 있습니다.
  alert(`slow({x})을/를 호출함`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function (x) {
    if (cache.has(x)) {
      // cache에 해당 키가 있으면
      return cache.get(x); // 대응하는 값을 cache에서 읽어옵니다.
    }

    let result = func(x); // 그렇지 않은 경우엔 func를 호출하고,

    cache.set(x, result); // 그 결과를 캐싱(저장)합니다.
    return result;
  };
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1)이 저장되었습니다.
alert('다시 호출: ' + slow(1)); // 동일한 결과

alert(slow(2)); // slow(2)가 저장되었습니다.
alert('다시 호출: ' + slow(2)); // 윗줄과 동일한 결과
</code></pre>
<h2 id="funccall로-컨텍스트-지정하기"><a class="header" href="#funccall로-컨텍스트-지정하기"><code>func.call</code>로 컨텍스트 지정하기</a></h2>
<p>이러한 데코레이터는, 객체 메서드에서 사용하기에 적합하지 않다는 문제점이 있는데, 메서드가 기존 객체를 가리키던 <code>this</code>에 대한 컨텍스트를 잃어버리기 때문이다.</p>
<pre><code class="language-js">// worker.slow에 캐싱 기능을 추가해봅시다.
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // CPU 집약적인 작업이라 가정
    alert(`slow({x})을/를 호출함`);
    return x * this.someMethod(); // (*)
  },
};

// 이전과 동일한 코드
function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}

alert(worker.slow(1)); // 기존 메서드는 잘 동작합니다.

worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용

alert(worker.slow(2)); // 에러 발생!, Error: Cannot read property 'someMethod' of undefined
</code></pre>
<p><code>func.call</code>은 이때 사용할 수 있는데, 이는 <code>this</code>를 명시적으로 고정해 함수를 호출할 수 있게 해주는 내장 함수 메서드다. 기본적으로는 아래와 같은 형태다.</p>
<pre><code class="language-js">func.call(context, arg1, arg2, ...)
</code></pre>
<p>실제로 적용한다면 아래와 같아진다.</p>
<pre><code class="language-js">func(1, 2, 3);
func.call(obj, 1, 2, 3);
</code></pre>
<p>위의 두 실행은 거의 동일하다. 유일한 차이점은 <code>func.call</code>에서의 <code>this</code>는 <code>obj</code>로 고정된다는 점이다.</p>
<h2 id="funcapply도-동일한-역할을-한다"><a class="header" href="#funcapply도-동일한-역할을-한다">func.apply도 동일한 역할을 한다.</a></h2>
<p><code>func.apply</code>를 사용해도 된다. 이는 아래와 같은 형태다.</p>
<pre><code class="language-js">func.apply(context, args);
</code></pre>
<p><code>apply</code>는 <code>func</code>의 <code>this</code>를 <code>context</code>로 고정시켜주고, 유사 배열 객체 <code>args</code>를 인수로 사용할 수 있게 해준다. <code>call</code>과의 문법적 차이는 <code>call</code>이 여러 개의 인수들을 따로따로 받는 대신 <code>apply</code>는 배열을 인수로 받는 다는 점 뿐이다.</p>
<p>따라서 아래의 두 코드는 거의 같은 역할을 한다.</p>
<pre><code class="language-js">func.call(context, ...args);
func.apply(context, args);
</code></pre>
<p>이렇게 인수 전체를 다른 함수에 전달하는 것을 <strong>콜 포워딩(Call Forwarding)</strong> 이라고 한다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="closure와-변수의-유효범위"><a class="header" href="#closure와-변수의-유효범위">Closure와 변수의 유효범위</a></h1>
<h2 id="렉시컬-환경-lexical-environment"><a class="header" href="#렉시컬-환경-lexical-environment">렉시컬 환경 (Lexical Environment)</a></h2>
<p>렉시컬 환경은 JS가 어떻게 동작하는지 설명하기 위한 <strong>이론상의</strong> 객체이다.
이를 이해하는 것이 클로저에 대한 명확한 이해를 돕기 때문에, 먼저 이에 대해 익혀보자.</p>
<p>이는 두 부분으로 구성된다.</p>
<ol>
<li>환경 레코드(Environment Record) : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체. <code>this</code>값과 같은 기타 정보도 여기에 저장된다.</li>
<li>외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조(Reference) : 외부 코드와 연관</li>
</ol>
<p>즉, <strong>변수</strong>는 특수 내부 객체인 <strong>환경 레코드</strong>의 프로퍼티일 뿐이다. 때문에 <strong>변수를 가져오거나 변경</strong>하는 것은 곧 <strong>환경 레코드의 프로퍼티를 가져오거나 변경</strong>하는 것을 의미한다.</p>
<pre><code class="language-js">// phrase: &lt;uninitialized&gt;
let phrase = 'Hello';
// phrase: undefined
phrase = 'Hello';
// phrase: 'Hello'
phrase = 'Bye';
// phrase: 'Bye'
</code></pre>
<p><strong>함수</strong>는 변수와 마찬가지로 <strong>값</strong>인데, 다만 <strong>함수 선언문(Function Declaration)으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다는 점에서 차이가 있다.</strong> 즉, 변수는 선언 전까지 사용할 수 없지만, 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다. 물론, <strong>함수 표현식</strong>의 경우는 변수를 함수에 할당한 것이므로 변수와 동일하게 취급된다.</p>
<pre><code class="language-js">let phrase = 'Hello';

function say(name) {
  alert(`&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;se&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{name}`);
}
</code></pre>
<p><strong>함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다.</strong> 이 렉시컬 환경엔 함수 호출 시에 넘겨받은 매개변수와 함수의 지역 변수가 저장된다. 즉, 위에서 <code>say('John')</code>을 호출하면 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경에서 가리키는 외부(여기서는 전역) 렉시컬 환경으로 두개를 갖게 된다.</p>
<p>내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖는다.</p>
<p><strong>코드 내에서 변수에 접근하는 경우, 먼저 내부 렉시컬 환경을 검색하며, 여기서 원하는 변수를 찾지 못하는 경우 검색 범위를 확장하여 외부 렉시컬 환경을 참조한다. 이는 검색 범위가 전역 렉시컬 환경에 도달할 때까지 반복된다.</strong></p>
<h2 id="반환함수"><a class="header" href="#반환함수">반환함수</a></h2>
<p>자, 이제 아래의 예시를 보자.</p>
<pre><code class="language-js">function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCounter();
</code></pre>
<p><code>makeCounter()</code>를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어진다. 그리고 이 렉시컬 환경 객체에는 <code>makeCounter</code>를 실행하는데 필요한 변수들이 저장된다.</p>
<p>단, 위의 경우는 <code>makeCounter</code>가 실행되는 도중에 별도의 중첩 함수가 생성되었다. 현재는 <strong>생성</strong>까지만 하고, <strong>실행</strong>은 되지 않았다.</p>
<p>이제 중요한 사실이 하나 더 있다. <strong>모든 함수는 본인이 생성된 곳의 렉시컬 환경을 기억한다</strong>는 점이다. 함수는 <code>[[Environment]]</code>라는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 위치의 렉시컬 환경에 대한 참조가 저장된다.</p>
<p>따라서, 위의 변수 <code>counter</code>에 저장된 함수의 <code>[[Environment]]</code>에는 <code>{count: 0}</code>이 있는 렉시컬 환경에 대한 참조가 저장된다. 이를 통해 어디에서 호출되던 상관없이 자신이 어디에서 생성되었는지를 알 수 있으며, <code>[[Environment]]</code>는 함수가 생성될 때 처음 딱 한번 그 값이 생성되고, 이는 영원히 변하지 않는다.</p>
<p><code>counter()</code>를 호출하면 각 호출마다 새로운 렉시컬 환경이 만들어진다. 그리고 각 렉시컬 환경은 <code>[[Environment]]</code>에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조하게 되는데, 이는 모두 똑같이 <code>{count}</code>이 있는 렉시컬 환경이다.</p>
<p><strong>따라서, <code>counter()</code>를 여러번 호출하게 되면, <code>count</code> 변수가 <code>1, 2, 3...</code> 으로 점차 증가하게 된다.</strong></p>
<h2 id="클로저"><a class="header" href="#클로저">클로저</a></h2>
<p><strong>클로저(Closure)는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다.</strong></p>
<p>설명하기 용이하게는, <strong>선언될 당시의 환경을 기억했다가 나중에 호출되었을 때에 기억했던 환경에 따라 실행되는 함수</strong>가 되겠다.</p>
<p>JS에서는 모든 함수가 자연스럽게 클로저가 되는데, JS에서의 함수는 숨김 프로퍼티인 <code>[[Environment]]</code>를 통해서 본인이 어디서 생성되었는지를 기억하고 있으며, 함수 내부의 코드는 이 <code>[[Environment]]</code>를 향해 확장하며 외부 변수에 접근하기 때문이다.</p>
<h2 id="가비지-컬렉션"><a class="header" href="#가비지-컬렉션">가비지 컬렉션</a></h2>
<p>함수의 호출이 끝나면, 렉시컬 환경은 메모리에서 제거되며, 함수와 관련된 변수들은 이 시점에서 모두 사라진다.</p>
<p>다시 가비지 컬렉션을 떠올려보자. JS에서의 모든 객체는 <strong>도달 가능한 상태</strong>라면 메모리에 유지된다.</p>
<p>위와 같은 형태의 중첩 함수를 구현하게 되면, <code>[[Environment]]</code> 프로퍼티에 생성 당시의 외부 함수 렉시컬 환경에 대한 정보가 저장되고, 따라서 <strong>도달 가능한 상태</strong>가 되는데, 이 때문에 함수 호출 자체가 끝났어도 렉시컬 환경이 메모리에 여전히 유지될 수 있는 것이다.</p>
<h2 id="js엔진에-의한-최적화"><a class="header" href="#js엔진에-의한-최적화">JS엔진에 의한 최적화</a></h2>
<p>앞서 말했듯, 이론 상으로는 중첩함수를 통해 함수가 살아있는 경우에 모든 외부 변수들 역시 메모리에 유지된다.</p>
<p>그러나 실제로는 JS 엔진(특히 <strong>V8</strong>)이 이를 지속해서 최적화하게 되는데, 엔진이 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거하기 때문이다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-표현식-vs-함수-선언문-function-expression-vs-function-declaration"><a class="header" href="#함수-표현식-vs-함수-선언문-function-expression-vs-function-declaration">함수 표현식 vs. 함수 선언문 (Function Expression vs. Function Declaration)</a></h1>
<h3 id="1-문법에서의-차이"><a class="header" href="#1-문법에서의-차이">1. <strong>문법</strong>에서의 차이</a></h3>
<p>다음은 함수 선언문이다.</p>
<pre><code class="language-JS">// 함수 선언문은 독자적인 구문 형태로 존재한다.

function sum(a, b) {
  return a + b;
}
</code></pre>
<p>그리고 다음은 함수 표현식이다.</p>
<pre><code class="language-js">// 함수 표현식은 표현식(Expression)이나 구문 구성(Syntax construct) 내부에 생성된다.

let sum = function (a, b) {
  return a + b;
};
</code></pre>
<h2 id="2-언제-함수를-생성하는지의-차이"><a class="header" href="#2-언제-함수를-생성하는지의-차이">2. <strong>언제</strong> 함수를 생성하는지의 차이</a></h2>
<ul>
<li><strong>함수 표현식</strong>은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달하고 나서야 해당 함수를 사용할 수 있다.</li>
<li><strong>함수 선언문</strong>은 선언문이 정의되기 전에도 호출할 수 있다.</li>
</ul>
<h2 id="3-스코프에서의-차이"><a class="header" href="#3-스코프에서의-차이">3. <strong>스코프</strong>에서의 차이</a></h2>
<p><code>strict</code> 모드에서 <strong>함수 선언문</strong>이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근하지 못한다.</p>
<h3 id="그래서-둘-중에-무엇을-써야하는가"><a class="header" href="#그래서-둘-중에-무엇을-써야하는가">그래서 둘 중에 무엇을 써야하는가???</a></h3>
<p>일반적으로는 함수 선언문을 통해 함수를 만드는 것이 먼저 고려된다. 다음과 같은 장점이 있다.</p>
<blockquote>
<ol>
<li>함수가 선언되기 이전에 호출할 수 있어 코드 구성을 좀 더 자유롭게 할 수 있다.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>가독성 측면에서 조금 더 유리하다.</li>
</ol>
</blockquote>
<p>하지만 무조건적인 정답은 아니므로, 경우에 따라 필요한 경우 함수 표현식을 사용해야 한다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="js의-비동기성에-관하여"><a class="header" href="#js의-비동기성에-관하여">JS의 비동기성에 관하여</a></h2>
<p>JS는 싱글 스레드 언어입니다. 이는 다시 말해, JS는 하나의 콜 스택만을 활용하기 때문에, 한번에 하나의 코드만을 실행시킬 수 있다는 뜻입니다.</p>
<p>실제로, JS 엔진은 어떤 작업을 수행하고 있는 중에는 렌더링이나 새로운 이벤트에 대한 핸들링이 즉각적으로 일어나지 않습니다.</p>
<p>근데 이상하죠? 우리는 이미 JS의 콜백 함수나, 프라미스, async를 통해 비동기 함수들을 다루어왔는데 말이죠.</p>
<p>이것이 가능한 이유는 브라우저가 단순한 JS 런타임 그 이상을 갖추고 있기 때문입니다. JS 런타임은 실제로 싱글 스레드 언어이지만, 브라우저가 Web API와 같은 것들을 제공합니다. 이들은 JS에서 호출할 수 있는 스레드를 효과적으로 지원합니다.</p>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbfbD9D%2Fbtqw7vo9Ptt%2FkCkBhgG920sxKfg3NZsLN0%2Fimg.png" />
<h2 id="web-api"><a class="header" href="#web-api">Web API</a></h2>
<p>Web API는 브라우저가 제공하는 JS 런타임 내 별도의 API입니다.</p>
<p>여기에는 <code>setTimeout</code>이나, AJAX를 활용하는 <code>fetch</code> 등이 포함됩니다.</p>
<p>Web API에서 제공하는 이들 함수를 활용할 때, JS 엔진은, 해당 함수의 호출이 일어나면, Web API가 내부적으로 이들을 처리하도록 맡기고, 계속해서 코드를 진행해나갑니다.</p>
<h2 id="태스크-큐"><a class="header" href="#태스크-큐">태스크 큐</a></h2>
<p>이후, Web API는 해당 함수를 처리하고, (예를 들어, <code>setTimeout</code>을 실행하면, 정해놓은 시간이 지날때까지 기다리고, AJAX의 경우에는 적절한 응답을 받을때까지 기다립니다.) 이후 해당 함수에 전달했던 콜백을 태스크 큐로 넘깁니다.</p>
<h2 id="이벤트-루프"><a class="header" href="#이벤트-루프">이벤트 루프</a></h2>
<p>이제 이벤트 루프가 활약할 차례입니다. 사실 이벤트 루프가 하는 일은 굉장히 간단합니다. JS 엔진의 콜 스택이 빌 때까지 기다렸다가, 비고 나면, 태스크 큐의 태스크들을 먼저 들어온 순서대로 콜 스택에 넘깁니다.</p>
<p>결국 여기에는 &quot;콜 스택이 빌때까지&quot; 기다리는 시간도 포함되기 때문에, <code>setTimeout(cb, 1000)</code>은 결코 해당 <code>cb</code>가 정확히 1초 이후에 실행된다는 것을 의미하지 않습니다.</p>
<h2 id="매크로태스크와-마이크로태스크"><a class="header" href="#매크로태스크와-마이크로태스크">매크로태스크와 마이크로태스크</a></h2>
<img src="https://media.vlpt.us/images/dami/post/8e5c1b68-101c-4fff-8090-7024ff2730c0/%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A2%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3.gif" />
<p>기본적으로 <code>setTimeout</code>, <code>setInterval</code>, 그리고 이벤트 핸들러 등의 함수들은 매크로태스크에 해당됩니다.</p>
<p>반면, <strong>마이크로태스크</strong>는 우리가 종종 사용하는 프로미스와 같은 것들이 해당합니다.</p>
<p>마이크로태스크와 매크로태스크의 차이는 해당 태스크들의 실행 시점에서 발생한다고 할 수 있습니다.</p>
<p>브라우저는, <em>마이크로태스크 -&gt; 렌더링 -&gt; 매크로태스크</em>의 순서로 실행되며, 마이크로태스크는 결국, 브라우저의 렌더링이나 이벤트 핸들러의 처리 이전에 여러 마이크로태스크들이 실행되는 것을 보장합니다.</p>
<p>이것이 중요한 이유는, 마이크로태스크들이 모두 동일한 환경 내에서 처리되도록 보장하기 위해서입니다. 이를테면, 마우스 클릭 등의 다른 이벤트 핸들링에 의해서 마이크로태스크들을 처리하던 와중에 데이터의 변경이 일어나면, 여러 마이크로태스크들이 제각기 다른 환경에서 실행될 가능성이 있기 때문입니다.</p>
<h2 id="이벤트-루프의-활용"><a class="header" href="#이벤트-루프의-활용">이벤트 루프의 활용</a></h2>
<p>이러한 이벤트 루프의 동작 방식을 실제 업무에서는 어떻게 활용할 수 있을까요?</p>
<h3 id="1-무거운-작업을-쪼개서-수행"><a class="header" href="#1-무거운-작업을-쪼개서-수행">1. 무거운 작업을 쪼개서 수행</a></h3>
<pre><code class="language-js">let i = 0;

let start = Date.now();

function count() {
  // 스케줄링 코드를 함수 앞부분으로 옮김
  if (i &lt; 1e9 - 1e6) {
    setTimeout(count); // 새로운 호출을 스케줄링함
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert('처리에 걸린 시간: ' + (Date.now() - start) + 'ms');
  }
}

count();
</code></pre>
<p>기본적으로, JS 엔진은 싱글 스레드 기반이기 때문에, 동기적인 방식으로 동작하는 함수가 처리에 너무 오랜 시간이 걸린다면 그 동안에 새로운 이벤트나 렌더링 자체를 막아버리면서 유저와의 상호 작용을 무시하는 문제가 발생합니다.</p>
<p>이 경우, 이러한 작업들을 <code>setTimeout</code> 등을 통해 여러 태스크들로 쪼개서 처리한다면, 그 동안에 처리해야 할 이벤트 핸들링 및 렌더링을 막지 않으면서 거대한 작업을 수행할 수 있습니다.</p>
<p>이를 통해서 게임 로딩 등에서 활용되는 프로그레스 바와 같은 것도 구현할 수 있습니다.</p>
<h3 id="2-이벤트-처리가-끝난-이후에-작업하기"><a class="header" href="#2-이벤트-처리가-끝난-이후에-작업하기">2. 이벤트 처리가 끝난 이후에 작업하기</a></h3>
<pre><code class="language-js">menu.onclick = function () {
  // ...

  // 클릭한 메뉴 내 항목 정보가 담긴 커스텀 이벤트 생성
  let customEvent = new CustomEvent('menu-open', {
    bubbles: true,
  });

  // 비동기로 커스텀 이벤트를 디스패칭
  setTimeout(() =&gt; menu.dispatchEvent(customEvent));
};
</code></pre>
<p>이벤트 핸들러 내에 이벤트 버블링이 끝난 이후에 작동해야만 하는 액션이 존재하는 경우, 이를 <code>setTimout(cb, 0)</code>과 같이 콜백함수로 넘길 수 있습니다. 이 경우, 해당 이벤트의 버블링이 모두 완수된 이후에야 특정 콜백을 실행할 수 있게끔 할 수 있습니다.</p>
<h2 id="web-worker"><a class="header" href="#web-worker">Web Worker</a></h2>
<img src="https://assets.hongkiat.com/uploads/web-workers-javascript-api/web-workers.jpg" />
<p><code>setTimout</code>을 통해 여러 개의 태스크로 쪼개지 않더라도, 이벤트 루프를 막지 않아야 하는 거대한 작업의 경우에는 <strong>Web Worker</strong>를 사용할 수 있습니다.</p>
<p>이는 브라우저가 별도의 쓰레드를 통해, 백그라운드 상에서 코드를 실행할 수 있게끔 하는 Web API 스펙입니다.</p>
<p>Web Worker는 메인 쓰레드와 메시지를 교환하는 방식으로 소통할 수 있지만, 자신만의 변수와 이벤트 루프를 갖습니다.</p>
<p>또한, Web Worker는 DOM에 접근할 방법이 없기 때문에, 주로 여러 CPU 코어를 동시에 활용해야 하는, 계산적으로 버거운 작업을 처리해야 할때 유용합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="new와-생성자-함수"><a class="header" href="#new와-생성자-함수">new와 생성자 함수</a></h1>
<h2 id="1-생성자-함수"><a class="header" href="#1-생성자-함수">1. 생성자 함수</a></h2>
<p>생성자 함수 (Contructor function)와 일반 함수 사이의 기술적인 차이는 없다. 다만 생성자 함수는 아래의 두 관례를 따른다.</p>
<ol>
<li>함수 이름 첫 글자는 대문자</li>
<li>반드시 <code>new</code> 연산자를 붙여 사용한다.</li>
</ol>
<pre><code class="language-js">function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User('Jack');
</code></pre>
<p>위와 같은 관례를 따라 <code>new User(...)</code>를 써서 함수를 실행하면 아래와 같은 알고리즘이 동작한다.</p>
<ol>
<li>빈 객체를 만들어 <code>this</code>에 할당한다.</li>
<li>함수 본문을 실행하고 <code>this</code>에 새로운 프로퍼티를 추가해 <code>this</code>를 수정한다.</li>
<li><code>this</code>를 반환한다.</li>
</ol>
<p>즉, 내부적으로는 아래와 같은 일이 동작하는 것이다.</p>
<pre><code class="language-js">function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어짐)

  // 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // return this;  (this가 암시적으로 반환됨)
}
</code></pre>
<p>결국 생성자의 의의는 <strong>재사용할 수 있는</strong> 객체 생성 코드를 구현하기 위한 것이다.</p>
<p>모든 함수는 생성자 함수가 될 수 있다. <code>new</code>를 붙여 실행한다면 어떤 함수라도 위와 같은 일이 벌어진다. 첫 글자가 대문자인 함수는 <code>new</code>를 붙여 실행하는 것이 일종의 관례라는 점도 기억하자.</p>
<h3 id="new-function-"><a class="header" href="#new-function-">new function() {...}</a></h3>
<p>생성자를 이용해 함수에 <strong>캡슐화</strong>를 적용할 수도 있다.</p>
<pre><code class="language-js">let user = new (function () {
  this.name = 'John';
  this.isAdmin = false;

  // ...
})();
</code></pre>
<p>위의 생성자 함수는 익명함수이기 때문에, 어디에도 저장되지 않으며, 단 한번만 호출될 목적으로 만들어져 재사용이 불가능하다.</p>
<h3 id="이-없어도-된다"><a class="header" href="#이-없어도-된다">()이 없어도 된다.</a></h3>
<p>다만 좋은 코드 스타일은 아니다.</p>
<pre><code class="language-js">let user = new User(); // &lt;-- 괄호가 없음
// 아래 코드는 위 코드와 똑같이 동작합니다.
let user = new User();
</code></pre>
<h2 id="2-new-function"><a class="header" href="#2-new-function">2. <code>new Function()</code></a></h2>
<p>함수 표현식과 함수 선언문 이외에 함수를 만들 수 있는 방법이 하나 더 있다.</p>
<p>이는 자주 사용하는 방법은 아니지만, 마땅한 대안이 없을 때 사용될 수 있다.</p>
<p><code>new Function</code>을 이용은 다음과 같다.</p>
<pre><code class="language-js">let func = new Function([arg1, arg2, ...argN], functionBody);
</code></pre>
<p><code>new Function</code>을 이용하는 방법의 가장 큰 차이는 런타임 시점에 받는 문자열을 사용해 함수를 만들 수 있다는 점이다.</p>
<pre><code class="language-js">let sum = new Function('a', 'b', 'return a + b');

alert(sum(1, 2)); // 3
</code></pre>
<h3 id="클로저와의-미묘한-관계"><a class="header" href="#클로저와의-미묘한-관계">클로저와의 미묘한 관계</a></h3>
<p>클로저를 떠올려보자, 반환받은 중첩함수는 <code>[[Environment]]</code> 프로퍼티 덕분에 본인이 생성된 렉시컬 외부 환경을 기억할 수 있었다.</p>
<p>그런데, <code>new Function</code>을 이용해 함수를 만들게 되면 함수의 <code>[[Environment]]</code> 프로퍼티가 현재의 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 된다.</p>
<p>따라서, <code>new Function</code>을 통해 만든 함수는 외부 블록의 변수에 접근할 수 없고, 오직 전역 변수에만 접근할 수 있다.</p>
<pre><code class="language-js">function getFunc() {
  let value = 'test';

  let func = new Function('alert(value)');

  return func;
}

getFunc()(); // ReferenceError: value is not defined
</code></pre>
<p>이러한 특징은, 특정 함수 내부에서 이름이 겹치는 변수들을 사용해도 충돌을 하지 않는다는 이점이 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="properties프로퍼티"><a class="header" href="#properties프로퍼티">Properties(프로퍼티)</a></h1>
<p>알다시피, 객체에는 프로퍼티가 저장된다. 지금까지는 단순히 'key-value'의 관점에서 보일 수 있었겠지만, 사실 프로퍼티는 생각보다 더 유연하고 강력한 자료구조다.</p>
<p>프로퍼티 플래그를 사용하면 손쉽게 <code>getter</code>나 <code>setter</code>함수를 구현할 수 있다.</p>
<h2 id="프로퍼티-플래그-property-flag"><a class="header" href="#프로퍼티-플래그-property-flag">프로퍼티 플래그 (Property flag)</a></h2>
<ul>
<li>객체 프로퍼티는 <strong>값(value)</strong> 뿐만 아니라, **플래그(flag)**라 불리는 특별한 속성 세 가지를 갖는다.</li>
</ul>
<blockquote>
<p><strong>writable</strong> - <code>true</code>라면 값을 수정할 수 있다. 그렇지 않다면 읽기 전용이 된다.
<strong>enumarable</strong> - <code>true</code>라면 반복문을 통해 나열될 수 있다. 그렇지 않다면 나열되지 않는다.
<strong>configurable</strong> - <code>true</code>라면 프로퍼티 삭제나 플래그 수정이 가능하다. 그렇지 않다면 프로퍼티 삭제와 플래그 수정이 불가능하다.</p>
</blockquote>
<p>프로퍼티 플래그는 특별한 경우가 아니라면 쓰이지 않는다. 평범한 방식으로 프로퍼티를 만들면 해당 프로퍼티 플래그는 모두 <code>true</code>가 되고, 이렇게 설정된 플래그는 언제든 수정할 수 있다.</p>
<p>먼저 플래그를 얻는 방법에 대해 알아보자.</p>
<p><code>Object.getOwnPropertyDescriptor</code> 메서드는 특정 프로퍼티에 대한 정보를 모두 얻을 수 있게 해준다.</p>
<pre><code class="language-js">let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
</code></pre>
<p>해당 메서드를 호출하면 프로퍼티 설명자(descriptor)라고 불리는 객체가 반환되며, 여기에는 프로퍼티 값과 세 플래그에 대한 정보가 모두 담겨있다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert(JSON.stringify(descriptor, null, 2));
/* property descriptor:
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: true,
  &quot;enumerable&quot;: true,
  &quot;configurable&quot;: true
}
*/
</code></pre>
<p><code>Object.defineProperty</code>를 사용하면 플래그를 변경할 수 있다.</p>
<pre><code class="language-js">Object.defineProperty(obj, propertyName, descriptor);
</code></pre>
<p>이는 해당 프로퍼티가 이미 존재한다면, 해당 프로퍼티를 인자로 넘긴 플래그에 따라 변경해주고, 프로퍼티가 없으면 인수로 넘겨받은 정보를 통해 새로운 프로퍼티를 만든다. 플래그 정보가 따로 없는 경우는 자동으로 <code>false</code>가 된다.</p>
<p><code>Object.defineProperties</code>는 앞선 프로퍼티 정의 여러개를 한꺼번에 할 수 있다.</p>
<pre><code class="language-js">Object.defineProperties(user, {
  name: { value: 'John', writable: false },
  surname: { value: 'Smith', writable: false },
  // ...
});
</code></pre>
<p><code>Object.getOwnPropertyDescriptors</code>는 프로퍼티 설명자를 전부 한꺼번에 가져올 수 있게 한다. <code>Object.defineProperties</code>와 함께 사용하면 객체 복사 시 플래그도 함께 복사할 수 있다.</p>
<pre><code class="language-js">let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
</code></pre>
<h2 id="접근자-프로퍼티-getter--setter"><a class="header" href="#접근자-프로퍼티-getter--setter">접근자 프로퍼티 (Getter &amp; Setter)</a></h2>
<p>객체 프로퍼티는 두 종류로 나뉜다.</p>
<blockquote>
<ol>
<li><strong>데이터 프로퍼티(data property)</strong> - 지금껏 사용한 모든 프로퍼티는 데이터 프로퍼티다.</li>
<li><strong>접근자 프로퍼티(accessor property)</strong> - 접근자 프로퍼티의 본질은 함수인데, 이 함수는 값을 획득(get)하고, 설정(set)하는 역할을 담당한다. 그러나 외부 코드에서는 함수가 아닌 일반적인 프로퍼티처럼 <strong>보인다</strong>.</li>
</ol>
</blockquote>
<p>객체 리터럴 안에서 <code>getter</code>와 <code>setter</code> 메서드는 <code>get</code>과 <code>set</code>으로 나타낼 수 있다.</p>
<pre><code class="language-js">let obj = {
  get propName() {
    // getter, obj.propName을 실행할 때 실행되는 코드
  },

  set propName(value) {
    // setter, obj.propName = value를 실행할 때 실행되는 코드
  },
};
</code></pre>
<p><code>getter</code>를 구현하면, 마치 일반 프로퍼티인것처럼 동작한다. 이는 함수처럼 <strong>호출</strong>하지 않으며, 일반 프로퍼티에 접근하듯 평범히 <code>user.fullName</code>을 통해 값을 얻어올 수 있다. 실질적으로는 메서드를 호출하는 것이지만.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  surname: 'Smith',

  get fullName() {
    return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{this.surname}`;
  },
};

alert(user.fullName); // John Smith

user.fullName = 'Test'; // Error (프로퍼티에 getter 메서드만 있어서 에러가 발생합니다.)
</code></pre>
<p>또한, <code>getter</code>만 있는 경우는 값을 직접 할당할 수 없어 위와 같은 에러가 발생한다.</p>
<p>여기에 <code>setter</code>도 추가로 구현한다면 다음과 같아진다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  surname: 'Smith',

  get fullName() {
    return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(' ');
  },
};

// 주어진 값을 사용해 set fullName이 실행됩니다.
user.fullName = 'Alice Cooper';

alert(user.name); // Alice
alert(user.surname); // Cooper
</code></pre>
<p><code>getter</code>와 <code>setter</code> 메서드를 구현하면 객체에는 <code>fullName</code>이라는 가상 프로피터가 생기며, 이는 읽고 쓸수는 있지만 실제로 존재하진 않는다.</p>
<h3 id="접근자-프로퍼티의-설명자descriptor"><a class="header" href="#접근자-프로퍼티의-설명자descriptor">접근자 프로퍼티의 설명자(descriptor)</a></h3>
<p>데이터 프로퍼티의 설명자와 접근자 프로퍼티의 설명자는 다르다.
접근자 프로퍼티에는 <code>value</code>와 <code>writable</code> 대신에 <code>get</code>과 <code>set</code>이 있다.</p>
<blockquote>
<p><strong>get</strong> – 인수가 없는 함수로, 프로퍼티를 읽을 때 동작함
<strong>set</strong> – 인수가 하나인 함수로, 프로퍼티에 값을 쓸 때 호출됨
<strong>enumerable</strong> – 데이터 프로퍼티와 동일함
<strong>configurable</strong> – 데이터 프로퍼티와 동일함</p>
</blockquote>
<p>이는 앞서 <code>defineProperty</code>메서드 등을 사용할 때도 똑같이 적용된다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  surname: 'Smith',
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(' ');
  },
});

alert(user.fullName); // John Smith

for (let key in user) alert(key); // name, surname
</code></pre>
<p>프로퍼티는 접근자 프로퍼티나 데이터 프로퍼티 중 한 종류에만 속하고, 둘 다에 속할 수는 없다는 점을 유의하자.</p>
<h3 id="getter와-setter-똑똑하게-써먹기"><a class="header" href="#getter와-setter-똑똑하게-써먹기">getter와 setter 똑똑하게 써먹기</a></h3>
<p><code>getter</code>와 <code>setter</code>를 실제 프로퍼티 값을 감싸 래퍼(wrapper)처럼 활용하면 프로퍼티값을 원하는대로 통제할 수 있다.</p>
<pre><code class="language-js">let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length &lt; 4) {
      alert(
        '입력하신 값이 너무 짧습니다. 네 글자 이상으로 구성된 이름을 입력하세요.',
      );
      return;
    }
    this._name = value;
  },
};

user.name = 'Pete';
alert(user.name); // Pete

user.name = ''; // 너무 짧은 이름을 할당하려 함
</code></pre>
<p>위에서 <code>user</code>의 이름은 <code>_name</code>에 저장되고, 프로퍼티에 접근하는 것은 getter와 setter를 통해 이루어진다. <code>_name</code>과 같이 밑줄 <code>_</code>로 시작하는 프로퍼티는 관습 상 외부에서 건드리지 않는다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="프로토타입"><a class="header" href="#프로토타입">프로토타입</a></h1>
<h2 id="1-프로토타입-상속"><a class="header" href="#1-프로토타입-상속">1. 프로토타입 상속</a></h2>
<p>개발을 하다보면 기존에 있는 기능을 가져와 확장을 해야하는 경우가 생긴다.</p>
<p>이는 자바스크립트의 고유 기능인 포로토타입 상속(Prototypal Inheritance)를 이용하면 실현할 수 있다.</p>
<h3 id="prototype"><a class="header" href="#prototype">[[Prototype]]</a></h3>
<p>자바스크립트의 객체는 <code>[[Prototype]]</code>이라는 숨김 프로퍼티를 갖는다. 이 숨김 프로퍼티는 <code>null</code>이거나, 다른 객체에 대한 참조가 되는데 (<strong>그 외의 자료형은 무시된다.</strong>), 이것이 참조하는 대상을 **프로토타입(prototype)**이라고 부른다.</p>
<p>JS는 객체에서 프로퍼티를 찾다가, 해당 프로퍼티가 없으면 <strong>자동으로 프로토타입에서 프로퍼티를 찾는다.</strong> 프로그래밍에서는 이런 동작 방식을 <strong>프로토타입 상속</strong>이라 부른다.</p>
<p><code>[[Prototype]]</code> 프로퍼티는 내부 프로퍼티면서 숨김 프로퍼티지만, 다양한 방법을 사용해 개발자가 값을 설정할 수 있다.</p>
<p>그 중 하나는, <code>__proto__</code>를 사용해 값을 설정하는 것이다.</p>
<blockquote>
<p>참고로, <code>__proto__</code>는 <code>[[Prototype]]</code>용 getter / setter라는 점을 이해하자.
요즘에는 <code>__proto__</code>를 직접 쓰는 경우는 드물고, <code>Object.getPrototypeOf</code>나 <code>Object.setPrototypeOf</code>를 써서 프로토타입을 획득 혹은 설정한다. 왜 <code>__proto__</code>를 요즘은 쓰지 않는지에 대해서는 추후에 다루자.</p>
</blockquote>
<p><code>obj.hasOwnProperty(key)</code>는 해당 객체의 <code>key</code>에 해당하는 프로퍼티가 상속받은 것이 아닌, 직접 구현된 프로퍼티일 경우 <code>true</code>를 반환한다. <strong>프로토타입으로 부터의 프로퍼티인지</strong>를 체크하는 역할을 한다고 보면 되겠다.</p>
<h2 id="2-prototype-프로퍼티"><a class="header" href="#2-prototype-프로퍼티">2. <code>prototype</code> 프로퍼티</a></h2>
<p><code>new F()</code>와 같은 생성자 함수를 사용하면 새로운 객체를 만들 수 있다는 것을 앞서 배웠다. 그런데, 이 <code>F.prototype</code>이 객체라면, <code>new</code> 연산자는 <code>F.prototype</code>을 사용해 새롭게 생성된 객체의 <code>[[Prototype]]</code>을 설정한다.</p>
<p>과거엔 프로토타입에 직접 접근할 방법이 없었고, 그나마 믿고 사용할 수 있는 방법이 해당 방법 뿐이었다. 여전히 이 문법이 남아있는 이유다.</p>
<p>여기서 <code>F.prototype</code>은 그저 일반 프로퍼티라는 점에 주의해야 한다.</p>
<pre><code class="language-js">let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit('White Rabbit'); //  rabbit.__proto__ == animal

alert(rabbit.eats); // true
</code></pre>
<h2 id="contructor-프로퍼티"><a class="header" href="#contructor-프로퍼티"><code>contructor</code> 프로퍼티</a></h2>
<p>사실, 개발자가 따로 할당하지 않더라도, 모든 함수는 <code>prototype</code> 프로퍼티를 갖는다. 기본 프로퍼티인 <code>prototype</code>은 <code>constructor</code> 프로퍼티 하나만 있는 객체를 가리키는데, 이 <code>constructor</code> 프로퍼티는 함수 자신을 가리킨다. 이 관계를 코드로 나타내면 다음과 같다.</p>
<pre><code class="language-js">function Rabbit() {}

/* 기본 prototype
Rabbit.prototype = { constructor: Rabbit };
*/
</code></pre>
<pre><code class="language-js">function Rabbit() {}
// 기본 prototype:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // {constructor: Rabbit}을 상속받음

alert(rabbit.constructor == Rabbit); // true (프로토타입을 거쳐 접근함)
</code></pre>
<p><code>constructor</code>프로퍼티를 사용하면, 기존에 있던 객체의 <code>constructor</code>를 사용해서 새로운 객체를 만들 수 있다.</p>
<pre><code class="language-js">function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit('White Rabbit');

let rabbit2 = new rabbit.constructor('Black Rabbit');
</code></pre>
<p>이 <code>constructor</code>는 객체가 있는데, 이 객체를 만드는데 어떤 생성자가 사용되었는지 알수 없는 경우에 사용된다. <strong>단, 가장 중요한점은 JS가 알맞은 <code>constructor</code>값을 보장하진 않는다는 점이다.</strong> 함수에 기본으로 <code>prototype</code>값이 설정되지만 그것이 전부다. <code>constructor</code>에 벌어지는 모든 일은 전적으로 개발자에게 맡겨지며, 만약 함수의 기본 <code>prototype</code>값을 다른 객체로 바꾼다면 이 객체엔 <code>constructor</code>가 없어진다.</p>
<p>이를 방지하고 알맞은 <code>constructor</code>를 유지하기 위해서는 <code>prototype</code> 전체를 덮어쓰지 말고 기본 <code>prototype</code>에 원하는 프로퍼티를 추가/제거해야 한다. (참조 관계를 끊지 않기 위해서)</p>
<pre><code class="language-js">function Rabbit() {}

// Rabbit.prototype 전체를 덮어쓰지 말고
// 원하는 프로퍼티는 그냥 추가하세요.
Rabbit.prototype.jumps = true;
// 이렇게 하면 기본 Rabbit.prototype.constructor가 유지됩니다.
</code></pre>
<p>수동으로 <code>constructor</code> 프로퍼티를 다시 만들어주는 것도 대안이 된다.</p>
<pre><code class="language-js">Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit,
};

// 수동으로 추가해 주었기 때문에 알맞은 constructor가 유지됩니다.
</code></pre>
<h2 id="3-네이티브-프로토타입"><a class="header" href="#3-네이티브-프로토타입">3. 네이티브 프로토타입</a></h2>
<p><code>prototype</code> 프로퍼티는 JS 내부에서도 광범위하게 사용되는데, 모든 내장 생성자 함수에서 <code>prototype</code> 프로퍼티를 사용한다.</p>
<h3 id="objectprototype"><a class="header" href="#objectprototype">Object.prototype</a></h3>
<pre><code class="language-js">let obj = {};
alert(obj); // &quot;[object Object]&quot; ?
</code></pre>
<p>여기서 <code>&quot;[object Object]&quot;</code>를 생성하는 코드는 대체 어디에 있을까?? <code>obj</code>는 비어있는데.</p>
<p>참고로 <code>obj = {}</code>는 <code>obj = new Object()</code>를 줄인 것이다. 여기서 <code>Object</code>는 내장 객체 생성자 함수인데, 이 객체의 <code>prototype</code>은 <code>toString</code>을 비롯해 다양한 메서드들이 구현된 거대한 객체를 참조한다. 따라서 <code>obj.toString()</code>을 호출하면 <code>Object.prototype</code>에서 해당 메서드를 찾아 가져오게 된다.</p>
<pre><code class="language-js">let obj = {};

alert(obj.__proto__ === Object.prototype); // true

alert(obj.toString === obj.__proto__.toString); //true
alert(obj.toString === Object.prototype.toString); //true
</code></pre>
<p>단, 이때 <code>Object.prototype</code> 위에는 그 이상의 <code>[[Prototype]]</code>이 존재하지 않는다는 점을 주의하자.</p>
<pre><code class="language-js">alert(Object.prototype.__proto__); // null
</code></pre>
<h3 id="모든-것은-객체를-상속받는다"><a class="header" href="#모든-것은-객체를-상속받는다"><strong>모든 것은 객체를 상속받는다</strong></a></h3>
<p><code>Array</code>, <code>Date</code>, <code>Function</code>을 비롯한 내장 객체들 역시 프로토타입에 메서드를 저장해놓는다.</p>
<p>명세서 상에서는 모든 내장 프로토타입의 꼭대기에는 <code>Object.prototype</code>이 있어야 한다고 규정한다. 이 때문에 <strong>모든 것은 객체를 상속받는다</strong>는 말을 하기도 한다.</p>
<p>체인 상의 프로토타입에는 중복 메서드가 있을 수도 있는데, 이 경우, 체인 상에서 가까운 메서드를 사용하며, <code>Array</code>의 경우, <code>Array.prototype</code>의 메서드가 <code>Object.prototype</code>의 메서드보다 가깝기 때문에 해당 메서드가 사용된다.</p>
<h3 id="원시값primitive-value"><a class="header" href="#원시값primitive-value">원시값(Primitive Value)</a></h3>
<p>그럼 원시값은요?? 이들을 프로토타입을 통해 다루는 것은 상당히 까다롭다.</p>
<p>문자열과 숫자, 불린은 객체가 아니다. 그런데 이런 원시값들의 프로퍼티에 접근하려고 하면 내장 생성자 <code>String</code>, <code>Number</code>, <code>Boolean</code>을 사용하는 <strong>임시 래퍼(Wrapper) 객체가 생성</strong>된다. 이 래퍼 객체는 해당 메서드만 제공하고 나면 사라진다.</p>
<p>래퍼 객체는 보이지 않는 곳에서 만들어지고, 엔진에 의해 최적화된다.</p>
<p>참고로 <code>null</code>과 <code>undefined</code>에 대응하는 래퍼 객체는 없다. 떄문에 메서드와 프로퍼티는 물론, 당연히 프로토타입도 사용할 수 없다.</p>
<h3 id="네이티브-프로토타입-변경"><a class="header" href="#네이티브-프로토타입-변경">네이티브 프로토타입 변경</a></h3>
<p>이런 네이티브 프로토타입을 직접 변경할 수도 있다.</p>
<pre><code class="language-js">String.prototype.show = function () {
  alert(this);
};

'BOOM!'.show(); // BOOM!
</code></pre>
<p>다만, 이는 좋은 생각이 아닌데, 기본적으로 네이티브 프로토타입은 전역으로 영향을 미치기 때문이다. 때문에 이런식으로 네이티브 프로토타입을 수정하게 되면 다른 라이브러리의 메서드와 충돌할 가능성이 크다.</p>
<p>네이티브 프로토타입 변경이 허용되는 유일한 경우는 딱 하나인데, 바로 <strong>폴리필을 만들 때</strong>다.</p>
<p>폴리필은 JS 명세서에는 정의되어 있으나 특정 JS 엔진에서 해당 기능이 구현되지 않았을 경우 만들어 사용한다.</p>
<h3 id="프로토타입에서-빌려오기"><a class="header" href="#프로토타입에서-빌려오기">프로토타입에서 빌려오기</a></h3>
<p>네이티브 프로토타입에 구현된 메서드를 빌려와서 사용할 수도 있다.</p>
<p>다음은 객체 <code>obj</code>에 <code>Array</code>의 <code>join</code> 메서드를 구현하는 내용이다.</p>
<pre><code class="language-js">let obj = {
  0: 'Hello',
  1: 'world!',
  length: 2,
};

obj.join = Array.prototype.join;

alert(obj.join(',')); // Hello,world!
</code></pre>
<h2 id="모던하게-프로토타입을-다루기"><a class="header" href="#모던하게-프로토타입을-다루기"><strong>모던</strong>하게 프로토타입을 다루기</a></h2>
<p><code>__proto__</code>는 브라우저를 대상으로 개발한다면 구식의 방법이기에 더는 사용하지 않는다.</p>
<p>이를 대체할 아래의 모던한 메서드들이 있다.</p>
<p><strong>Object.create(proto, [descriptors])</strong> – [[Prototype]]이 proto를 참조하는 빈 객체를 만든다. 이때 프로퍼티 설명자({ value, enumarable, ...})를 추가로 넘길 수 있다.
<strong>Object.getPrototypeOf(obj)</strong> – obj의 [[Prototype]]을 반환한다.
<strong>Object.setPrototypeOf(obj, proto)</strong> – obj의 [[Prototype]]이 proto가 되도록 설정한다.</p>
<pre><code class="language-js">let animal = {
  eats: true,
};

// 프로토타입이 animal인 새로운 객체를 생성합니다.
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {}); // rabbit의 프로토타입을 {}으로 바꿉니다.
</code></pre>
<p>앞서 말한것처럼 프로퍼티 설명자를 선택적으로 전달할 수도 있다.</p>
<pre><code class="language-js">let animal = {
  eats: true,
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true,
  },
});

alert(rabbit.jumps); // true
</code></pre>
<p><code>Object.create</code>를 통해 객체를 효율적으로 (얕게) 복제할 수도 있다.
아래 코드는 <code>obj</code>의 모든 프로퍼티를 포함한 완벽한 사본을 만든다.</p>
<pre><code class="language-js">let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj),
);
</code></pre>
<p>주의해야 할 점은, 앞선 메서드들로 객체의 <code>[[Prototype]]</code>을 수정하는데 기술적인 문제는 전혀 없으나, 이는 권장되는 사항이 아니다. 이는 객체 프로퍼티 접근 관련 최적화를 망치기 때문에, JS 엔진의 속도를 매우 느리게 한다. 때문에 <code>[[Prototype]]</code>은 객체를 처음 생성할 때만 설정하는 것이 일반적이다.</p>
<h3 id="아주-단순한very-plain-객체"><a class="header" href="#아주-단순한very-plain-객체">아주 단순한(Very plain) 객체</a></h3>
<p><code>Object.create()</code>는 인자의 <code>[[Prototype]]</code>을 상속받은 객체를 생성한다. 이 때, 상속받는 객체 자체가 없다면 어떻게 될까??</p>
<p><code>Object.create(null)</code>은 <code>__proto__</code>를 상속받지 않는다. 때문에 <code>__proto__</code>가 키 값이 되어도 일반 데이터 프로퍼티처럼 처리하므로 버그가 발생하지 않는다.</p>
<p>이런 객체는 아주 단순한(Very plain), 혹은 순수 사전식(Pure dictionary) 객체라고 부른다. 일반 객체 <code>{...}</code>보다도 훨씬 단순하기 때문이다.</p>
<p>단, 이 단순한 객체는 프로토타입 자체가 없기 때문에 <strong>내장 메서드조차 없다.</strong></p>
<pre><code class="language-js">let obj = Object.create(null);

alert(obj); // Error: Cannot convert object to primitive value (toString이 없음)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="this와-메서드"><a class="header" href="#this와-메서드">this와 메서드</a></h1>
<h2 id="what-is-this"><a class="header" href="#what-is-this">what is <code>this</code>?</a></h2>
<p>JS에서 <code>this</code>는 이따금씩 개발자를 헷갈리게 만드는 존재다. 이는 쓰이는 상황에 따라 각각 다른 것을 가리키게 되는데, 일반적으로는 다음과 같은 상황들이 있다.</p>
<h2 id="1-메서드에서"><a class="header" href="#1-메서드에서">1. 메서드에서</a></h2>
<p>메서드 내부에서 사용하는 <code>this</code>는 해당 메서드가 선언된 객체를 가리킨다.</p>
<pre><code class="language-js">let user = {
  name: 'John',
  age: 30,

  sayHi() {
    alert(this.name);
  },
};

user.sayHi(); // John
</code></pre>
<h2 id="2-일반-함수에서"><a class="header" href="#2-일반-함수에서">2. 일반 함수에서</a></h2>
<p>다른 언어와 달리 JS는 모든 함수에서 <code>this</code>를 사용할 수 있는데, 이 경우는 런타임 시점에 <code>this</code>가 가리키는 것이 결정된다. 즉, <strong>컨텍스트</strong>에 따라 달라진다.</p>
<pre><code class="language-js">// 같은 함수라도 다른 객체에서 호출한다면 `this`가 달라진다.

let user = { name: 'John' };
let admin = { name: 'Admin' };

function sayHi() {
  alert(this.name);
}

// 별개의 객체에서 동일한 함수를 사용함
user.f = sayHi;
admin.f = sayHi;

// 'this'는 '점(.) 앞의' 객체를 참조하기 때문에
// this 값이 달라짐
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (점과 대괄호는 동일하게 동작함)
</code></pre>
<h2 id="3-화살표-함수에서"><a class="header" href="#3-화살표-함수에서">3. 화살표 함수에서</a></h2>
<p>화살표 함수는 일반 함수와 달리 고유한 <code>this</code>를 가지지 않는다. 화살표에서 <code>this</code>를 사용하면 외부 컨텍스트를 통해 <code>this</code>를 가져온다. 때문에 별도로 <code>this</code>를 만들기는 원치 않은 반면, 외부 컨텍스트의 <code>this</code>를 이용하고자 하는 경우는 화살표 함수를 이용하면 된다.</p>
<pre><code class="language-js">let user = {
  firstName: '보라',
  sayHi() {
    let arrow = () =&gt; alert(this.firstName);
    arrow();
  },
};

user.sayHi(); // 보라
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="var를-쓰지-않는-이유"><a class="header" href="#var를-쓰지-않는-이유"><code>var</code>를 쓰지 않는 이유</a></h1>
<h2 id="var에는-블록-스코프가-없다"><a class="header" href="#var에는-블록-스코프가-없다"><code>var</code>에는 <strong>블록 스코프</strong>가 없다.</a></h2>
<p><code>var</code>로 선언한 변수의 스코프는 <code>function-scoped</code> 혹은 <code>global-scoped</code>다. 블록을 기준으로 스코프가 생기지 않기 때문에, 혼동을 일으키기 매우 좋다. 아래는 그 덕분에 작성가능한 괴상망측한 코드다.</p>
<pre><code class="language-js">for (var i = 0; i &lt; 10; i++) {
  // ...
}

alert(i);
</code></pre>
<p>코드 블럭이 함수 안에 있다면, <code>var</code>는 함수 스코프<strong>만</strong> 적용된 변수가 된다.</p>
<pre><code class="language-js">function sayHi() {
  if (true) {
    var phrase = 'Hello';
  }

  alert(phrase); // 제대로 출력됩니다.
}

sayHi();
alert(phrase); // Error
</code></pre>
<h2 id="var는-재선언이-되는-척을-한다"><a class="header" href="#var는-재선언이-되는-척을-한다"><code>var</code>는 재선언이 되는 <strong>척</strong>을 한다</a></h2>
<p>아래는 실행 상 아무 문제가 없다. 다만 중간의 <code>John</code>값으로 <code>user</code>를 다시 선언/할당한 내용은 무시된다.</p>
<h2 id="var는-선언도-하기-전에-사용할-수-있다-호이스팅-hoisting"><a class="header" href="#var는-선언도-하기-전에-사용할-수-있다-호이스팅-hoisting"><code>var</code>는 선언도 하기 전에 사용할 수 있다. <strong>(호이스팅: Hoisting)</strong></a></h2>
<p><code>var</code> 선언은 함수가 시작될 때 처리된다. 전역에서 선언한 변수라면 스크립트가 시작될 때 처리된다.</p>
<p><strong>때문에, <code>var</code>로 변수를 선언한다면, 그 위치랑 상관없이 함수 본문이 시작되는 지점에서 정의가 된다.</strong></p>
<p>이렇게 <strong><code>var</code>로 인하여 변수의 선언이 함수 최상위로 끌어올려지는</strong> 현상을 호이스팅(Hoisting)이라고 한다.</p>
<p>아래 코드에서 <code>if</code>블럭 안의 코드는 절대 실행되지 않겠지만, 이는 호이스팅 자체에 전혀 영향을 주지 않기 때문에, 에러가 발생하지 않는다.</p>
<pre><code class="language-js">function sayHi() {
  phrase = 'Hello'; // (*)

  if (false) {
    var phrase;
  }

  alert(phrase);
}
sayHi();
</code></pre>
<p>다만, <strong>선언</strong>만 호이스팅되고 <strong>할당</strong>은 호이스팅 되지 않는다.</p>
<pre><code class="language-js">function sayHi() {
  alert(phrase);

  var phrase = 'Hello';
}

sayHi();
</code></pre>
<p>위 예시는 <code>var</code>를 이용했기 때문에 사실상 아래와 같이 실행된다.</p>
<pre><code class="language-js">function sayHi() {
  var phrase; // 선언은 함수 시작 시 처리됩니다.

  alert(phrase); // undefined

  phrase = 'Hello'; // 할당은 실행 흐름이 해당 코드에 도달했을 때 처리됩니다.
}

sayHi();
</code></pre>
<h2 id="iife즉시-실행-함수-표현식--var가-남긴-폐해의-잔재"><a class="header" href="#iife즉시-실행-함수-표현식--var가-남긴-폐해의-잔재">IIFE(즉시 실행 함수 표현식) : <code>var</code>가 남긴 폐해의 잔재</a></h2>
<p>과거에는 <code>var</code>만 쓸 수 있었고, 이를 쓰기 위해서 과거의 개발자들은 블록 레벨 스코프를 구현하기 위해 여러 방안을 고려했다. 그 결과 만들어진 것이 IIFE(Immediately Invoked Function Expressions)다.</p>
<p>요즘에는 쓰지 않으나, 오래된 스크립트에서 만나볼 수 있다.</p>
<pre><code class="language-js">(function () {
  let message = 'Hello';

  alert(message); // Hello
})();
</code></pre>
<h2 id="결론"><a class="header" href="#결론">결론</a></h2>
<p>결국, 두가지 끔찍한 이유 때문에 <code>var</code>를 사용하지 않는다.</p>
<ol>
<li><code>var</code>는 함수 스코프를 갖는다.</li>
<li><code>var</code>는 호이스팅을 유발한다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>공식 <a href="https://babeljs.io/docs/en/">문서</a>를 재구성한 내용입니다.</p>
<hr />
<h1 id="babel이-뭔가요"><a class="header" href="#babel이-뭔가요">Babel이 뭔가요?</a></h1>
<p>Babel은 JS 컴파일러다. 이는 주로 ECMAScript6+ 코드를 이전 버전의 JS로 변환하여 구형 브라우저 및 환경에서 동작하도록 해준다. 아래는 Babel이 해주는 주된 역할이다.</p>
<ul>
<li>Syntax 변환</li>
<li>Target 환경에 존재하지 않는 기능에 대한 폴리필 추가 (<code>@babel/polyfill</code>)</li>
<li>소스 코드 변경 (codemods)</li>
<li>그 외 등등...</li>
</ul>
<pre><code class="language-js">// Babel Input: ES2015 arrow function
[1, 2, 3].map((n) =&gt; n + 1);

// Babel Output: ES5 equivalent
[1, 2, 3].map(function (n) {
  return n + 1;
});
</code></pre>
<h2 id="어떻게-쓸-수-있을까"><a class="header" href="#어떻게-쓸-수-있을까">어떻게 쓸 수 있을까?</a></h2>
<h3 id="es6-사양의-프로젝트"><a class="header" href="#es6-사양의-프로젝트">ES6+ 사양의 프로젝트</a></h3>
<p>Babel은 최신 버전의 JS 사용을 구문 변환을 통해 지원해준다. Babel이 제공하는 플러그인들을 통해, 브라우저가 지원하지 않는 사양의 문법까지 사용할 수 있도록 한다.</p>
<h3 id="jsx와-react"><a class="header" href="#jsx와-react">JSX와 React</a></h3>
<p>Babel은 마찬가지로 JSX 구문도 변환할 수 있다.</p>
<pre><code class="language-bash">npm install --save-dev @babel/preset-react
</code></pre>
<h3 id="type-annotations-flow--typescript"><a class="header" href="#type-annotations-flow--typescript">Type Annotations (Flow &amp; TypeScript)</a></h3>
<p>Babel은 타입 주석(Type Annotation)을 제거할 수 있다. 사실, Babel 자체는 타입체킹을 수행하지 않으며, 타입 체킹을 위해서는 별도로 Flow나 TypeScript를 사용해야 함을 명심하자.</p>
<pre><code class="language-bash">npm install --save-dev @babel/preset-flow
</code></pre>
<pre><code class="language-bash">npm install --save-dev @babel/preset-typescript
</code></pre>
<h3 id="pluggable"><a class="header" href="#pluggable">Pluggable</a></h3>
<p>Babel은 여러 플러그인들로 구성되어 있다. 존재하는 플러그인 혹은 본인이 직접 작성한 플러그인을 통해 자신만의 구문 변환 파이프라인을 구성할 수 있다. 더 쉽게는 preset을 만들거나 사용해서 일련의 플러그인들을 사용해도 된다.</p>
<pre><code>// 사실, 플러그인은 그냥 함수일 뿐이다.
export default function ({types: t}) {
  return {
    visitor: {
      Identifier(path) {
        let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ
        path.node.name = name.split('').reverse().join('');
      }
    }
  };
}
</code></pre>
<h3 id="debuggable"><a class="header" href="#debuggable">Debuggable</a></h3>
<p><strong>Souce map</strong>은 컴파일된 코드를 쉽게 디버깅할 수 있도록 도와준다.</p>
<h3 id="spec-compliant-규격-준수"><a class="header" href="#spec-compliant-규격-준수">Spec Compliant (규격 준수)</a></h3>
<p>Babel은 가능한 ECMAScript 표준을 준수하려고 한다. 성능이 좀 떨어지더라도 표준 준수를 위해 더 구체적인 옵션을 가질 수 있다.</p>
<h3 id="compact-압축"><a class="header" href="#compact-압축">Compact (압축)</a></h3>
<p>Babel은 용량이 큰 런타임에 의존하지 않고 최대한 작은 양의 코드를 사용하려고 한다.</p>
<p>이는 상황에 따라 이루어지기 어려울 수도 있으며, 가독성, 파일 크기, 속도에 대한 규격을 준수하도록 하는 구체적인 변환에 대한 &quot;느슨한&quot; 옵션들이 존재한다.</p>
<h1 id="usage-guide"><a class="header" href="#usage-guide">Usage Guide</a></h1>
<p>일반적으로 Babel을 사용하는 케이스처럼, ES2015+ 문법들을 현재 브라우저에 적합한 사양으로 변환하고자 한다.</p>
<p>이러한 작업은 문법을 새로운 형태로 작성하고, 없는 기능에 대한 폴리필을 추가함으로써 이루어질 수 있다.</p>
<p>이에 대한 전반적인 과정은 아래와 같다.</p>
<h2 id="일단-훑어보기"><a class="header" href="#일단-훑어보기">일단 훑어보기</a></h2>
<ol>
<li>패키지 인스톨</li>
</ol>
<pre><code class="language-sh">npm install --save-dev @babel/core @babel/cli @babel/preset-env
npm install --save @babel/polyfill
</code></pre>
<ol start="2">
<li>프로젝트 루트에 <code>babel.config.json</code> (<code>v7.8.0</code> 이상 요구) config 파일 생성</li>
</ol>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/env&quot;,
      {
        &quot;targets&quot;: {
          &quot;edge&quot;: &quot;17&quot;,
          &quot;firefox&quot;: &quot;60&quot;,
          &quot;chrome&quot;: &quot;67&quot;,
          &quot;safari&quot;: &quot;11.1&quot;
        },
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: &quot;3.6.5&quot;
      }
    ]
  ]
}
</code></pre>
<p>위의 설정은 하나의 예시일 뿐이고, 본인이 지원하고자 하는 브라우저 스펙에 따라 이를 적절히 설정해주어야 한다.</p>
<p><a href="https://babeljs.io/docs/en/babel-preset-env">여기</a>에서 <code>@babel/preset-env</code>가 보유한 옵션들을 확인하자.</p>
<p><code>v7.8.0</code> 미만 버전의 Babel에서는 대신에 <code>babel.config.js</code>를 사용할 수 있다.</p>
<pre><code class="language-js">const presets = [
  [
    '@babel/env',
    {
      targets: {
        edge: '17',
        firefox: '60',
        chrome: '67',
        safari: '11.1',
      },
      useBuiltIns: 'usage',
      corejs: '3.6.4',
    },
  ],
];

module.exports = { presets };
</code></pre>
<ol start="3">
<li>이후 <code>src</code> 디렉토리에 있는 모든 코드에 대해 컴파일링을 수행하여 <code>lib</code>에 작성하고자 하는 경우 아래와 같이 cli를 이용할 수 있다.</li>
</ol>
<pre><code class="language-sh">./node_modules/.bin/babel src --out-dir lib
</code></pre>
<p>npm@5.2.0 이후부터 <code>./node_modules/.bin/babel</code>은 <code>npx babel</code>로 대체될 수 있다.</p>
<h2 id="cli-기초"><a class="header" href="#cli-기초">CLI 기초</a></h2>
<p>모든 Babel모듈들은 <code>@babel</code> 이라는 이름 하에 여러 개의 npm 패키지들로 나누어져 있다. (v7 이후)</p>
<p>이렇게 각각의 모듈로 디자인되어 있는 덕분에에, 각각의 상황에 적절하게 사용할 수 있다.</p>
<h3 id="core-library"><a class="header" href="#core-library">Core Library</a></h3>
<p>Babel의 핵심 기능들은 <code>@babel/core</code> 모듈에 위치해 있다.</p>
<pre><code class="language-sh">npm install --save-dev @babel/core
</code></pre>
<p>이를 직접 JS 상에서 사용할 수 있다.</p>
<pre><code class="language-js">const babel = require('@babel/core');

babel.transformSync('code', optionsObject);
</code></pre>
<h3 id="cli-툴"><a class="header" href="#cli-툴">CLI 툴</a></h3>
<p><code>@babel/cli</code>는 터미널을 통해서 babel을 사용할 수 있게 해주는 툴이다. 아래와 같이 설치한다.</p>
<pre><code class="language-sh">npm install --save-dev @babel/core @babel/cli
</code></pre>
<p>그리고 아래와 같이 사용한다.</p>
<pre><code class="language-sh">./node_modules/.bin/babel src --out-dir lib
</code></pre>
<p>위 명령어는 <code>src</code> 디렉토리 내에 위치한 모든 JS 파일들을 파싱하여 지정된 모든 변환 작업들을 수행한다. 이후 각각의 파일들은 <code>lib</code> 디렉토리에 위치한다.</p>
<p>현재까지는 아무런 변환 작업을 지정해주지 않았기 때문에, 출력된 코드는 입력과 동일하게 될 것이다.</p>
<p>CLI 툴이 어떤 옵션들을 보유하고 있는지에 대해 알고 싶다면 <code>--help</code>를 이용하자.</p>
<h2 id="plugins--presets"><a class="header" href="#plugins--presets">Plugins &amp; Presets</a></h2>
<p>Babel에서의 모든 변환들은 <strong>Plugin</strong>(이하 플러그인)을 통해서 이루어집니다. 이는 하나의 작은 JS 프로그램인데, Babel에게 코드를 어떤 식으로 변환해야 하는지 지시해주는 역할을 한다.</p>
<p>심지어 플러그인은 본인이 직접 작성할 수도 있다.</p>
<p><code>@babel/plugin-transform-arrow-functions</code> 플러그인을 적용하는 간단한 예시를 확인해보자.</p>
<pre><code class="language-sh">npm install --save-dev @babel/plugin-transform-arrow-functions

./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions
</code></pre>
<p>이후, 변환된 코드는 아래와 같아진다.</p>
<pre><code class="language-js">const fn = () =&gt; 1;

// converted to

var fn = function fn() {
  return 1;
};
</code></pre>
<p>기본적으로는 이렇게 하나의 플러그인을 통해 변환을 수행할 수 있지만, 이렇게 플러그인을 하나하나씩 추가하는 것은 다소 귀찮아 보인다.</p>
<p>이런 경우에 사용할 수 있는 것이 <strong>Preset</strong>(이하 프리셋)이며, 이는 플러그인의 묶음이라고 이해할 수 있다.</p>
<p>플러그인과 마찬가지로, 이러한 프리셋 역시 자신이 원하는 플러그인들을 임의로 지정해 만들어낼 수 있다.</p>
<p>Babel에서 자주 사용되는 preset으로는 <code>env</code>가 있다.</p>
<pre><code class="language-sh">npm install --save-dev @babel/preset-env

./node_modules/.bin/babel src --out-dir lib --presets=@babel/env
</code></pre>
<p>별 다른 설정을 하지 않더라도, <code>preset-env</code>는 모던 JS를 지원하기 위한 모든 플러그인들을 추가한다.</p>
<p>물론 프리셋 역시 옵션을 지정할 수 있으며, 이는 CLI 상에서 지정하는 것이 번거롭기에 아래처럼 config 파일을 생성하는 방식을 많이 이용한다.</p>
<h2 id="plugins--presets-1"><a class="header" href="#plugins--presets-1">Plugins &amp; Presets</a></h2>
<p>CLI를 통해 모든 옵션을 지정하기보다는 별도의 설정 파일을 만드는 방식이 종종 사용된다.</p>
<p>본인이 원하는 형태에 따라 작성해야 할 Configuration 파일 형태들이 조금씩 달라질 수 있다.</p>
<p>상세 설정에 관련해서는 여기 <a href="https://babeljs.io/docs/en/configuration">문서</a>를 참고하도록 하자.</p>
<p>v7.8.0 이상에서는 일반적으로 <code>babel.config.json</code>을 생성한다.</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/env&quot;,
      {
        &quot;targets&quot;: {
          &quot;edge&quot;: &quot;17&quot;,
          &quot;firefox&quot;: &quot;60&quot;,
          &quot;chrome&quot;: &quot;67&quot;,
          &quot;safari&quot;: &quot;11.1&quot;
        }
      }
    ]
  ]
}
</code></pre>
<p>이제 <code>env</code> 프리셋은 위에서 우리가 지정한 target 브라우저들에서 지원하지 않는 기능들에 대한 플러그인들만을 사용할 것이다.</p>
<p>이로써 문법 변환에 대해서는 모두 알아봤다.</p>
<p><code>v7.4.0</code> 미만의 버전에 대해서는 <code>@babel/polyfill</code> 모듈이 별도로 사용되지만, 이들 내용이 <code>core-js/stable</code>과 <code>regenerator-runtime/runtime</code> 플러그인에 각각 추가되었으므로 별도로 사용할 필요가 없게 되었다.</p>
<p>혹시나 <code>v.7.4.0</code> 미만의 Babel을 사용해야 하는데, polyfill이 필요한 경우에는 여기 <a href="https://babeljs.io/docs/en/usage#polyfill">문서</a>를 따로 찾아보자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="intersection-observer"><a class="header" href="#intersection-observer">Intersection Observer</a></h1>
<p>Intersection Observer는 브라우저의 뷰포트와 요소의 교차점을 관찰하여, 요소가 현재 뷰포트 상으로 <strong>보이는 상태인지</strong>를 체크하는 기능을 제공한다.</p>
<p>대표적인 사용은 무한 스크롤, 레이지 로딩 등이다.</p>
<p>앞선 예처럼, 종종 <code>scroll</code> 이벤트를 대체하는 용도로 사용되는데 큰 이유는 두가지에서다.</p>
<ol>
<li>
<p><code>scroll</code> 이벤트의 경우, 말그대로 스크롤을 하는 내내 이벤트가 발생하기 때문에, 핸들러가 무수하게 많이 호출된다. 이는 결국 불필요한 호출들을 일으키고, 이 때문에 <strong>Debouncing</strong>, <strong>Throttling</strong>과 같은 호출 제한 테크닉이 요구되어 왔다. Intersection Observer는 특정 요소가 화면에 보이는 시점에만 한번 이벤트가 동작하기 때문에, 이벤트 호출 빈도를 확실히 줄일 수 있다.</p>
</li>
<li>
<p><code>scroll</code> 이벤트에서는 현재 높이 값을 얻기 위해 <code>offsetTop</code> 값을 확인하는데, 이를 얻기 위해선 매번 layout을 새로 그리게 된다. 이를 reflow라고 하며, 해당 과정을 반복함에 따라 렌더링 상의 성능 이슈가 발생할 수 있다.</p>
</li>
</ol>
<h2 id="사용법"><a class="header" href="#사용법">사용법</a></h2>
<p>기본적으로는 MutationObserver와 얼추 비슷한 듯 다르다.</p>
<pre><code class="language-js">const observer = new IntersectionObserver(callback, options);
observer.observe(element);
</code></pre>
<h3 id="callback"><a class="header" href="#callback">callback</a></h3>
<p>감시 타겟이 등록되거나, 가시성(visibility)에 변화가 생기면, 옵저버는 콜백을 실행한다. 이때 해당 콜백은 2개의 인수(<code>entries</code>, <code>observer</code>)를 갖는다.</p>
<h4 id="entries"><a class="header" href="#entries">entries</a></h4>
<p><code>entries</code>는 <code>IntersectionObserverEntry</code> 인스턴스의 배열이며, 각각의 인스턴스는 다음 일기 전용 프로퍼티들을 포함한다.</p>
<ul>
<li><code>boundingClientRect</code> : target의 사각형 정보</li>
<li><code>intersectionRect</code> : target이 보여지는(교차한) 영역의 정보</li>
<li><code>intersectionRatio</code> : 뷰포트 기준 target영역의 백분율(교차한 영역의 백분율) <code>0.0 ~ 1.0</code></li>
<li><code>isIntersecting</code> : target이 보여진 상태(교차한 상태)에 대한 boolean</li>
<li><code>rootBounds</code> : 지정 루트 요소의 사각형 정보</li>
<li><code>target</code> : target</li>
<li><code>time</code> : 변경이 발생한 시간 정보</li>
</ul>
<h4 id="observer"><a class="header" href="#observer">observer</a></h4>
<p><code>observer</code>는 콜백을 실행시킨 해당 옵저버 자체다.</p>
<h3 id="options"><a class="header" href="#options">options</a></h3>
<h4 id="root"><a class="header" href="#root">root</a></h4>
<p>target이 보여지는지를 검사할 때, 기본 설정인 뷰포트 대신 사용할 요소(루트 요소)를 지정한다. target보다 상위 요소여야 하고, 기본값은 <code>null</code>이다.</p>
<h4 id="rootmargin"><a class="header" href="#rootmargin">rootMargin</a></h4>
<p>바깥의 margin을 이용해 Root 범위를 확장하거나 축소할 수 있다. CSS margin값과 똑같은 형태로 값을 받으며, 반드시 <code>px</code> 혹은 <code>%</code>의 단위를 입력해줘야 한다.</p>
<h4 id="threshold"><a class="header" href="#threshold">threshold</a></h4>
<p>옵저버가 콜백을 실행시키려면 target 요소가 어느정도의 가시성(visibility)를 가져야하는지에 대한 설정이다. <code>0 ~ 1</code> 사이의 <code>Number</code> 배열값을 받는다. 기본값으로는 <code>[0]</code>이지만, <code>Number</code> 타입의 단일 값으로도 작성할 수 있다. 배열로 값을 받는 경우, 배열 각각의 가시성에 대해서 매번 콜백을 호출한다.</p>
<h2 id="메서드"><a class="header" href="#메서드">메서드</a></h2>
<h3 id="observeelement"><a class="header" href="#observeelement">.observe(element)</a></h3>
<p>target 요소의 감시를 시작한다.</p>
<h3 id="unobserveelement"><a class="header" href="#unobserveelement">.unobserve(element)</a></h3>
<p>target 요소의 감시를 중지한다. 애초에 감시하던 요소가 아닌 경우 아무 일도 일어나지 않는다.</p>
<p>기본적으로 콜백 실행 시에 두번째 인수로 <code>observer</code>자체를 가져오므로, 이를 이용해, 한번 콜백을 실행한 후에 감시를 중지하도록 할수도 있다.</p>
<pre><code class="language-js">const observer = new IntersectionObserver((entries, observer) =&gt; {
  entries.forEach((entry) =&gt; {
    if (!entry.isIntersecting) {
      return;
    }

    // ...

    observer.unobserve(entry.target);
  });
}, options);
</code></pre>
<h3 id="disconnect"><a class="header" href="#disconnect">.disconnect()</a></h3>
<p>해당 <code>observer</code>가 감시하고 있는 <strong>모든 요소</strong>의 감시를 중지한다.</p>
<h3 id="takerecords"><a class="header" href="#takerecords">.takeRecords()</a></h3>
<p>이는 MutationObserver에서도 있는 메서드와 비슷한데, 도중에 작동이 중지된 경우에 처리되지 않은 IntersectionObserverEntry 객체 배열을 가져온다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="mutation-observer"><a class="header" href="#mutation-observer">Mutation Observer</a></h1>
<p><code>MutationObserver</code>는 DOM 요소를 감시하다가 변화를 감지하면 콜백을 호출하는 내장 객체이다.</p>
<h2 id="문법"><a class="header" href="#문법">문법</a></h2>
<p><code>MutationObserver</code>를 사용하는 것은 간단하다.</p>
<p>먼저, 콜백함수를 인자로 넘기는 옵저버를 만든다.</p>
<pre><code class="language-js">let observer = new MutationObserver(callback);
</code></pre>
<p>그리고, 이를 DOM 노드에 덧붙인다.</p>
<pre><code class="language-JS">observer.observe(node, config);
</code></pre>
<p><code>config</code>은 boolean 옵션들을 갖고 있는 객체인데, 이는 <strong>어떤 종류의 변화에 반응할 것인가</strong>를 나타낸다.</p>
<ul>
<li><code>childList</code> - <code>node</code> 본인의 바로 아래 자식 요소에서의 변화</li>
<li><code>subtree</code> - <code>node</code> 본인의 모든 자손</li>
<li><code>attributes</code> - <code>node</code>의 속성</li>
<li><code>attributeFilter</code> - 속성 이름들이 담긴 배열을 받는다. 오직 여기에 포함된 속성들만 감시한다.</li>
<li><code>characterData</code> - <code>node.data</code>(text content)를 감시할지에 대한 boolean</li>
</ul>
<p>그 밖에 다른 옵션들도 있다.</p>
<ul>
<li><code>attributeOldValue</code> - 만약 <code>true</code>라면, 콜백 함수 호출 시 '변경 전'과 '변경 후'의 값을 모두 넘겨준다. <code>false</code>라면 변경 후의 값만 넘긴다. (<code>attribute</code> 옵션이 필요하다.)</li>
<li><code>characterDataOldValue</code> - 만약 <code>true</code>라면, <code>node.data</code>의 '변경 전'과 '변경 후'의 값을 모두 넘겨준다. <code>false</code>라면 변경 후의 값만 넘겨준다. (<code>characterData</code> 옵션이 필요하다.)</li>
</ul>
<p>이후 어떤 변화라도 감지된다면, <code>callback</code>이 실행된다. 변경된 내용은 <code>MutationRecord</code> 객체의 배열로 첫번째 인자로 넘겨진다. 그리고 옵저버 자체는 두번째 인자가 된다.</p>
<p><code>MutaitonRecord</code> 객체는 다음과 같은 프로퍼티들을 갖는다.</p>
<ul>
<li><code>type</code> - 뮤테이션 타입이다. 다음 중 하나다.
<ul>
<li><code>attributes</code>: 수정된 속성</li>
<li><code>characterData</code>: 수정된 <code>node.data</code>, 텍스트 노드로 쓰인다.</li>
<li><code>childList</code>: 추가/삭제된 자식 요소들</li>
</ul>
</li>
<li><code>target</code> - 변화가 감지된 곳의 요소</li>
<li><code>addedNodes/removedNodes</code> - 추가/삭제된 노드들</li>
<li><code>previousSibling/nextSibling</code> - 추가/삭제된 노드들의 이전/다음 형제 노드</li>
<li><code>attributeName/attributeNamespace</code> - 변경된 속성의 이름/네임스페이스(XML에서 사용)</li>
<li><code>oldValue</code> - 속성이나 텍스트가 변경되기 전의 값. <code>attributeOldValue</code>/<code>characterDataOldValue</code>이 <code>true</code>여야한다.</li>
</ul>
<p>다음은 간단한 예시다.</p>
<pre><code class="language-html">&lt;div contenteditable id=&quot;elem&quot;&gt;Click and &lt;b&gt;edit&lt;/b&gt;, please&lt;/div&gt;

&lt;script&gt;
  let observer = new MutationObserver((mutationRecords) =&gt; {
    console.log(mutationRecords); // console.log(the changes)
  });

  // observe everything except attributes
  observer.observe(elem, {
    childList: true, // observe direct children
    subtree: true, // and lower descendants too
    characterDataOldValue: true, // pass old data to callback
  });
&lt;/script&gt;
</code></pre>
<p>그리고 위에서 변화를 감지할 때마다 콜백함수에서 넘겨받는 <code>mutationRecords</code>는 아래와 같다.</p>
<pre><code class="language-js">[{
  type: &quot;characterData&quot;,
  oldValue: &quot;edit&quot;,
  target: &lt;text node&gt;,
  // other properties empty
}];
</code></pre>
<p>만약, <code>&lt;b&gt;edit&lt;/b&gt;</code>를 한번에 지우는 것과 같이 여러 작업이 동시에 일어나면, <code>mutationRecords</code>에도 여러 객체가 담긴다.</p>
<pre><code>[{
  type: &quot;childList&quot;,
  target: &lt;div#elem&gt;,
  removedNodes: [&lt;b&gt;],
  nextSibling: &lt;text node&gt;,
  previousSibling: &lt;text node&gt;
  // other properties empty
}, {
  type: &quot;characterData&quot;
  target: &lt;text node&gt;
  // ...mutation details depend on how the browser handles such removal
  // it may coalesce two adjacent text nodes &quot;edit &quot; and &quot;, please&quot; into one node
  // or it may leave them separate text nodes
}];
</code></pre>
<p>즉, <code>MutationObserver</code>는 DOM subtree에 발생하는 어떤 변화든지 대응할 수 있다.</p>
<h2 id="활용-사례"><a class="header" href="#활용-사례">활용 사례</a></h2>
<p>그래서, 언제 이를 활용할 수 있을까?</p>
<p>만약, 서드파티 라이브러리를 사용하는데, 원치않는 광고가 포함되어 있다고 해보자. 이를테면 <code>&lt;div class='ads'&gt;...&lt;/ads&gt;</code>와 같이.</p>
<p><code>MutationObserver</code>를 사용하면, DOM에 생겨난 원치 않는 요소를 감지하여 제거할 수 있다.</p>
<p>그 밖에도, 여러가지를 감지하여 동적인 변화를 줄 수 있다. 이를 테면 어떤 요소의 사이즈를 변경한다던가.</p>
<h2 id="아키텍쳐에-활용"><a class="header" href="#아키텍쳐에-활용">아키텍쳐에 활용</a></h2>
<p><code>MutationObserver</code>가 구조적인 부분에서 유용하게 쓰이는 상황이 있다.</p>
<p>웹 프로그래밍과 관련한 웹사이트를 만들고자 한다고 하자. 각각의 문서들이 소스 코드 조각들을 담고 있을 것이다.</p>
<p>이때, 이 코드 조각들이 다음과 같은 모양을 띈다고 하자.</p>
<pre><code class="language-js">...
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code&gt;
  // here's the code
  let hello = &quot;world&quot;;
&lt;/code&gt;&lt;/pre&gt;
...
</code></pre>
<p>이를 더 가독성이 좋게 하기 위해서, 꾸미고 싶다고 하자. 이 경우 우리는 <strong>Prism.js</strong>와 같은 문장 하이라이팅 라이브러리를 사용할 수 있다. 이는 <code>Prism.highlightElem(pre)</code>와 같은 식으로 특정 요소에 대해 하이라이트를 적용해준다.</p>
<p>그래서, 이제 이 메서드를 정확히 <strong>언제</strong> 사용해야 할까? <code>DOMContentLoaded</code> 이벤트 발생 시에 사용하는 것을 고려해볼 수 있겠다. 이후 각각의 코드 조각들에 대해 다음과 같이 하이라이팅을 적용시킬 수 있다.</p>
<pre><code class="language-js">document
  .querySelectorAll('pre[class*=&quot;language&quot;]')
  .forEach(Prism.highlightElem);
</code></pre>
<p>지금까지는 수월해보인다. 근데, 만약에 서버를 통해 또 다른 코드 조각들을 가져와서 화면에 띄워주어야 한다면, 이는 어떻게 해결할 수 있을까?</p>
<pre><code class="language-js">let article =
  /* fetch new content from server */
  (articleElem.innerHTML = article);

let snippets = articleElem.querySelectorAll('pre[class*=&quot;language-&quot;]');
snippets.forEach(Prism.highlightElem);
</code></pre>
<p>위의 방법처럼, 해당 코드조각을 가져올 때 마다 다시 각각의 코드조각들에 대해 하이라이팅을 적용시켜줄 수 있다. 근데 이는 다소 비효율적인데, 코드 조각들이 있을만한 모든 요소들에 대해 위와 같은 코드를 추가해야 하기 때문이다.</p>
<p>결국, 이 역시 <code>MutationObserver</code>를 통해 페이지 내에 삽입되는 코드 조각들을 감지하여 처리할 수 있다.</p>
<pre><code class="language-js">let observer = new MutationObserver((mutations) =&gt; {
  for (let mutation of mutations) {
    // examine new nodes, is there anything to highlight?

    for (let node of mutation.addedNodes) {
      // we track only elements, skip other nodes (e.g. text nodes)
      if (!(node instanceof HTMLElement)) continue;

      // check the inserted element for being a code snippet
      if (node.matches('pre[class*=&quot;language-&quot;]')) {
        Prism.highlightElement(node);
      }

      // or maybe there's a code snippet somewhere in its subtree?
      for (let elem of node.querySelectorAll('pre[class*=&quot;language-&quot;]')) {
        Prism.highlightElement(elem);
      }
    }
  }
});

let demoElem = document.getElementById('highlight-demo');

observer.observe(demoElem, { childList: true, subtree: true });
</code></pre>
<h2 id="추가적인-메서드"><a class="header" href="#추가적인-메서드">추가적인 메서드</a></h2>
<p>노드를 감시하는 것을 멈추는 메서드가 있다.</p>
<ul>
<li><code>observer.disconnect()</code> - 감시를 멈춘다.</li>
</ul>
<p>감시가 멈출 때, 해당 옵저버가 특정 작업을 처리하던 중이었을 수도 있다. 이런 경우에는 아래 메서드를 통해 확인할 수 있다.</p>
<ul>
<li><code>observer.takeRecords()</code> - 처리되지 않은 <code>MutationRecord</code> 배열들을 가져온다. (변경은 감지했으나, 콜백이 호출되지 않은 경우를 말한다.)</li>
</ul>
<p>이 메서드들은 함께 쓰일 수 있다.</p>
<pre><code class="language-js">// get a list of unprocessed mutations
// should be called before disconnecting,
// if you care about possibly unhandled recent mutations
let mutationRecords = observer.takeRecords();

// stop tracking changes
observer.disconnect();
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="template-element"><a class="header" href="#template-element">Template Element</a></h1>
<p>내장 <code>&lt;template&gt;</code> 요소는 HTML 마크업 템플릿에 대한 저장요소로 취급된다. 브라우저는 이를 무시하고, 오로지 문법 상 온전한지만을 체크하는데, 우리가 우너한다면, 이를 이용해서 다른 요소들을 만들어낼 수도 있다.</p>
<p>사실, 우리는 이미 이론 상 보이지 않는 요소들을 어디서든 만들어 낼 수 있다. 대체 이 <code>&lt;template&gt;</code>가 특별한 점은 무엇일까?</p>
<p><strong>먼저</strong>, 이들의 내용(content)는 문법상 올바른 HTML이면 무엇이든 가능하다. 다시 말해, 적절히 태그만 열고닫았으면 문제가 없다.</p>
<p>무슨 소리냐고? 단순히 우리가 <code>&lt;tr&gt;</code>과 <code>&lt;td&gt;</code>만을 이용해서 테이블을 만들면, 브라우저는 부적절한 DOM 구조를 감지하고, 알아서 <code>&lt;table&gt;</code>을 추가해 DOM 구조를 수정해준다. 반면 <code>&lt;template&gt;</code>의 경우는 우리가 작성한 내용 그대로를 유지시켜준다.</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;tr&gt;
    &lt;td&gt;Contents&lt;/td&gt;
  &lt;/tr&gt;
&lt;/template&gt;
</code></pre>
<p>마찬가지로, <code>&lt;template&gt;</code>에는 스타일과 스크립트 태그가 포함될 수 있다.</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;style&gt;
    p { font-weight: bold; }
  &lt;/style&gt;
  &lt;script&gt;
    alert(&quot;Hello&quot;);
  &lt;/script&gt;
&lt;/template&gt;
</code></pre>
<p>브라우저는 <code>&lt;template&gt;</code>의 내용들을 <strong>문서와 상관없는 것</strong>으로 간주한다. 때문에 스타일은 적용되지 않고, 스크립트 역시 마찬가지다.</p>
<h2 id="템플릿-삽입하기"><a class="header" href="#템플릿-삽입하기">템플릿 삽입하기</a></h2>
<p>템플릿의 내용은 <code>content</code> 프로퍼티를 통해 이용할 수 있는데, 이는 <strong>DocumentFragment</strong>라는 특수한 DOM 노드 타입이다.</p>
<p>이는 다른 DOM 노드들과 거의 동일하게 다룰 수 있으나, 유일한 차이점은, 어딘가에 삽입되는 경우, 노드 본인이 아닌 자식들이 대신 삽입된다는 점이다.</p>
<pre><code class="language-HTML">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;script&gt;
    alert(&quot;Hello&quot;);
  &lt;/script&gt;
  &lt;div class=&quot;message&quot;&gt;Hello, world!&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  let elem = document.createElement('div');

  // 재사용을 위해 템플릿 컨텐츠를 복사하여 사용한다.
  elem.append(tmpl.content.cloneNode(true));

  document.body.append(elem);
  // append에 의해 body에 요소가 추가되고 나서야 위의 script가 동작한다.
&lt;/script&gt;
</code></pre>
<p>Shadow DOM과 함께 사용해보자.</p>
<pre><code class="language-HTML">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt; p { font-weight: bold; } &lt;/style&gt;
  &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;
&lt;/template&gt;

&lt;div id=&quot;elem&quot;&gt;Click me&lt;/div&gt;

&lt;script&gt;
  elem.onclick = function() {
    elem.attachShadow({mode: 'open'});

    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)

    elem.shadowRoot.getElementById('message').innerHTML = &quot;Hello from the shadows!&quot;;
  };
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom"><a class="header" href="#shadow-dom">Shadow DOM</a></h1>
<p>섀도우 DOM은 캡슐화를 위해 제공된다. 이는 하나의 컴포넌트가 스스로의 <strong>shadow DOM tree</strong>를 가질 수 있게 하며, 메인 문서에서 접근 할 수 없으며, 로컬 스타일 규칙을 보유할 수 있다.</p>
<h2 id="빌트인-섀도우-dom"><a class="header" href="#빌트인-섀도우-dom">빌트인 섀도우 DOM</a></h2>
<p><code>&lt;input type=&quot;range&quot;&gt;</code>과 같은 것들은 브라우저마다 다른 자체적인 스타일을 보유한다. 이는 섀도우 DOM을 통해 브라우저 자체적으로 스타일링을 하고 있기 때문인데, 기본적으로 이는 이용자들로부터 숨겨져있다. 이를 보고자 한다면 개발자 도구의 옵션을 건드려야 한다.</p>
<h2 id="섀도우-트리-shadow-tree"><a class="header" href="#섀도우-트리-shadow-tree">섀도우 트리 (Shadow Tree)</a></h2>
<p>하나의 DOM 요소에는 두가지 유형의 DOM 서브트리가 존재한다.</p>
<ol>
<li>Light Tree - 일반적인 DOM 서브트리. 우리가 기존에 알고 쓰던 모든 서브트리는 이에 해당한다.</li>
<li>Shadow Tree - 숨겨진 DOM 서브트리. HTML 상에 보여지지 않는다.</li>
</ol>
<p>만약, 두 가지 유형의 서브트리를 모두 갖는 요소가 있다면, 브라우저는 오직 섀도우 트리만을 렌더링한다. 물론 각각을 적절히 조합하도록 설정할 수도 있는데, 이에 대해선 추후에 설명한다.</p>
<p>섀도우 트리는 커스텀 요소 내에서 <strong>컴포넌트 내부 요소들을 숨기고</strong>, 컴포넌트 자체적인 <strong>로컬 스타일링</strong>을 위해 사용된다.</p>
<p>예를 들어, 아래와 같이 <code>&lt;show-hello&gt;</code>라는 커스텀 요소를 만들어낼 수 있다.</p>
<pre><code class="language-html">&lt;script&gt;
  customElements.define(
    'show-hello',
    class extends HTMLElement {
      connectedCallback() {
        const shadow = this.attachShadow({ mode: 'open' });
        shadow.innerHTML = `&lt;p&gt;
      Hello, {this.getAttribute('name')}
    &lt;/p&gt;`;
      }
    },
  );
&lt;/script&gt;

&lt;show-hello name=&quot;John&quot;&gt;&lt;/show-hello&gt;
</code></pre>
<p>커스텀 요소를 만들기 위해서는 먼저 <code>elem.attachShadow({mode: ...})</code>를 호출해야 한다. 여기엔 두 가지 제한이 있다.</p>
<ol>
<li>각 요소 당 하나의 섀도우 루트(shadow-root)만 가질 수 있다.</li>
<li><code>elem</code>은 반드시 커스텀 요소이거나, 다음 중 하나여야 한다. (“article”, “aside”, “blockquote”, “body”, “div”, “footer”, “h1…h6”, “header”, “main” “nav”, “p”, “section”, “span”)</li>
</ol>
<p><code>mode</code>옵션은 캡슐화 레벨을 설정한다. 다음의 둘 중 하나여야 한다.</p>
<ul>
<li><code>open</code> : 어디서든 해당 요소의 섀도우 루트에 <code>elem.shadowRoot</code>로 접근할 수 있다.</li>
<li><code>closed</code> : <code>elem.shadowRoot</code>가 항상 <code>null</code>이 된다.</li>
</ul>
<p>대부분의 브라우저 자체적인 섀도우 트리들은 <code>closed</code> 상태이며, 때문에 이들의 섀도우 트리에 접근할 방법이 없다.</p>
<p><code>attachShadow</code>를 통해 반환되는 **섀도우 루트(shadow root)**는 요소와 같다. <code>innerHTML</code>이나 <code>append</code> 같은 DOM 프로퍼티 및 메서드를 사용할 수 있다.</p>
<ul>
<li>섀도우 루트가 있는 요소는 **섀도우 트리 호스트(shadow tree host)**라고 불리며, 이는 섀도우 루트의 <code>host</code> 프로퍼티는 통해 접근할 수 있다.</li>
</ul>
<pre><code class="language-js">// assuming {mode: &quot;open&quot;}, otherwise elem.shadowRoot is null
alert(elem.shadowRoot.host === elem); // true
</code></pre>
<h2 id="캡슐화-encapsulation"><a class="header" href="#캡슐화-encapsulation">캡슐화 (Encapsulation)</a></h2>
<p>섀도우 DOM은 메인 문서(document)으로부터 완전히 구분된다.</p>
<ol>
<li>
<p>light DOM에서의 <code>querySelector</code>에 의해 탐색되지 않는다. 때문에 light DOM에 동일한 id가 존재하더라도 섀도우 트리 내에서만 고유하다면 상관없다.</p>
</li>
<li>
<p>섀도우 DOM은 스스로의 스타일시트를 보유한다. 그 외의 스타일 규칙은 이에 적용되지 않는다.</p>
</li>
</ol>
<p>이에 따라, 아래 예시를 보자.</p>
<pre><code class="language-html">&lt;style&gt;
  /* document style won't apply to the shadow tree inside #elem (1) */
  p {
    color: red;
  }
&lt;/style&gt;

&lt;div id=&quot;elem&quot;&gt;&lt;/div&gt;

&lt;script&gt;
  elem.attachShadow({ mode: 'open' });
  // shadow tree has its own style (2)
  elem.shadowRoot.innerHTML = `
    &lt;style&gt; p { font-weight: bold; } &lt;/style&gt;
    &lt;p&gt;Hello, John!&lt;/p&gt;
  `;

  // &lt;p&gt; is only visible from queries inside the shadow tree (3)
  alert(document.querySelectorAll('p').length); // 0
  alert(elem.shadowRoot.querySelectorAll('p').length); // 1
&lt;/script&gt;
</code></pre>
<ol>
<li>문서 자체에서 적용한 <code>style</code>은 섀도우 트리에 아무 영향도 미치지 않는다.</li>
<li>허나, <code>elem.shadowRoot.innerHTML</code>에서 직접 지정한 스타일링은 적용된다.</li>
<li>섀도우 트리에서 요소를 가져오고자 하는 경우, 반드시 섀도우 트리 내에서 <code>querySelector</code>와 같은 메서드를 사용해야 한다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom---slots-composition"><a class="header" href="#shadow-dom---slots-composition">Shadow DOM - slots, composition</a></h1>
<p>탭, 갤러리 등 많은 종류의 컴포넌트들은 렌더링할 <strong>내용</strong>들이 필요하다.</p>
<p>내장 <code>&lt;select&gt;</code> 태그가 <code>&lt;option&gt;</code> 태그들을 요구하는 것처럼, 우리가 임의로 만든 태그 역시 임의의 태그를 요구할 수 있다.</p>
<pre><code class="language-html">&lt;custom-menu&gt;
  &lt;title&gt;Candy menu&lt;/title&gt;
  &lt;item&gt;Lollipop&lt;/item&gt;
  &lt;item&gt;Fruit Toast&lt;/item&gt;
  &lt;item&gt;Cup Cake&lt;/item&gt;
&lt;/custom-menu&gt;
</code></pre>
<p>우리는 이것을 동적으로 요소들의 내용을 분석하고, DOM 노드들을 조작해서 구현할 수 있다. 하지만, shadow DOM의 경우, 문서에서의 스타일링이 적용되지 않으며, 때문에 어느 정도의 추가 코드을 요구한다.</p>
<p>다행히도 Shadow DOM은 여기서 <code>&lt;slot&gt;</code> 요소를 제공한다. 이는 light DOM으로부터 가져온 내용들로 Shadow DOM의 내용을 채울 수 있게 해준다.</p>
<h2 id="named-slots"><a class="header" href="#named-slots">Named slots</a></h2>
<p>간단한 예시로부터 살펴보자. 여기 <code>&lt;user-card&gt;</code> shadow DOM은 두개의 슬롯(slot)을 사용하며, 이는 light DOM으로부터 아래와 같이 채워질 수 있다.</p>
<pre><code class="language-HTML">&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      &lt;div&gt;Name:
        &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div&gt;Birthday:
        &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    `;
  }
});
&lt;/script&gt;

&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<p>섀도우 DOM에서, <code>&lt;slot name='X'&gt;</code>은 <strong>삽입 지점</strong>을 의미하며, 여기에는 추후 <code>slot='X'</code>를 light DOM에서 지정한 요소가 위치하게 된다.</p>
<p>이후 브라우저는 <strong>합성_composition</strong>을 수행하는데, 이는 light DOM에서 요소를 가져와 이에 대응하는 shadow DOM의 slot에 렌더링시키는 과정이다.</p>
<p>스크립트가 동작한 후, 아직 <strong>합성_composition</strong>이 동작하지 않은 상태의 DOM 구조는 아래와 같다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  #shadow-root
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<p>현 시점에서는, shadow DOM까지는 생성되었으나(이에 따라 <code>#shadow-root</code>가 보인다), 현재 요소는 light와 shadow DOM 모두를 갖고 있다.</p>
<p>렌더링을 하기 위해, shadow DOM에서의 각 <code>&lt;slot name=&quot;...&quot;&gt;</code>에서 브라우저는 light DOM에서 동일한 이름을 가진 <code>slot=&quot;...&quot;</code>을 찾는다. 이후 이 요소들은 각 slot 안에 렌더링된다.</p>
<p>그 결과로 만들어진 아래의 DOM 구조를 <strong>flatten DOM</strong> 이라고 한다.</p>
<pre><code class="language-html">&lt;user-card&gt;
  #shadow-root
  &lt;div&gt;
    Name:
    &lt;slot name=&quot;username&quot;&gt;
      &lt;!-- slotted element is inserted into the slot --&gt;
      &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
    &lt;/slot&gt;
  &lt;/div&gt;
  &lt;div&gt;
    Birthday:
    &lt;slot name=&quot;birthday&quot;&gt;
      &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
    &lt;/slot&gt;
  &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<p>다만, 유의해야 할 점이 있다. <strong>flatten DOM은 오직 렌더링과 이벤트 핸들링의 목적으로 존재한다</strong>. 이는 어떤 식으로 동작하는지를 보여주기 위한 것이며, 실제 문서의 노드들은 어디로도 이동하지 않는다.</p>
<p>이는 단순히 <code>querySelectorAll</code>를 통해 확인해볼 수 있다.</p>
<pre><code class="language-js">// light DOM &lt;span&gt; nodes are still at the same place, under `&lt;user-card&gt;`
alert(document.querySelectorAll('user-card span').length); // 2
</code></pre>
<p>결국, flatten DOM은 shadow DOM에서 slot에 대한 삽입을 통해 만들어진다. 브라우저는 이를 렌더링, 스타일 상속, 이벤트 전파의 목적으로 활용한다. 하지만, JS는 여전히 flatten이 이루어지기 전의 문서만을 볼 수 있다.</p>
<h3 id="유의"><a class="header" href="#유의"><strong>유의!</strong></a></h3>
<pre><code class="language-html">&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;div&gt;
    &lt;!-- invalid slot, must be direct child of user-card --&gt;
    &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
  &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<blockquote>
<p><code>slot-'...'</code> 속성을 가진 태그는 최상위의 자식 노드여야 한다. 보다 깊은 곳에 위치한 노드들은 무시된다.</p>
</blockquote>
<p>한편, 똑같은 slot에 지정된 여러개의 요소들이 light DOM에 존재한다면, <strong>이들은 갱신되는 것이 아니라, 순서대로 slot에 추가된다.</strong></p>
<p>예를 들어, 앞선 예시에 대해 아래와 같이 light DOM을 구성했다고 가정하자.</p>
<pre><code class="language-html">&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John&lt;/span&gt;
  &lt;span slot=&quot;username&quot;&gt;Smith&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<p>그렇다면, 그 결과 생겨난 flatten DOM의 결과는 아래와 같다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  #shadow-root
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;
        &lt;span slot=&quot;username&quot;&gt;John&lt;/span&gt;
        &lt;span slot=&quot;username&quot;&gt;Smith&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<h2 id="slot-fallback-content"><a class="header" href="#slot-fallback-content">Slot fallback content</a></h2>
<p>만약, <code>&lt;slot&gt;</code>태그에 어떤 값이 존재한다면, 이는 <strong>fallback</strong>(대비책)이 된다. 다시말해, <strong>default</strong>값이 된다. 브라우저는 light DOM에서 상응하는 <code>slot='...'</code> 요소를 찾지 못하는 경우 해당 기본값을 렌더링한다.</p>
<pre><code class="language-html">&lt;div&gt;
  Name:
  &lt;slot name=&quot;username&quot;&gt;Anonymous&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<h2 id="default-slot-first-unnamed"><a class="header" href="#default-slot-first-unnamed">Default slot: first unnamed</a></h2>
<p>shadow DOM에서 <code>name</code>이 존재하지 않는 첫번째 <code>&lt;slot&gt;</code>은 <strong>default slot</strong>이 된다. 여기에는 light DOM에서부터 slot 처리가 되지 않은 모든 요소들이 추가된다.</p>
<p>예를 들어, 아래처럼 <code>&lt;user-card&gt;</code>에 default slot을 추가해보면, 별도로 slot을 지정해주지 않은 모든 요소들을 자동으로 default slot에 추가시킨다.</p>
<pre><code class="language-html">&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;Other information&lt;/legend&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/fieldset&gt;
    `;
      }
    },
  );
&lt;/script&gt;

&lt;user-card&gt;
  &lt;div&gt;I like to swim.&lt;/div&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
  &lt;div&gt;...And play volleyball too!&lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<p>이 역시 기존의 slot과 마찬가지로 갱신을 하는 것이 아니라, 추가하는 방식으로 동작한다. 따라서 그 결과인 flatten DOM은 아래와 같아진다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  #shadow-root
    &lt;div&gt;Name:
      &lt;slot name=&quot;username&quot;&gt;
        &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    &lt;div&gt;Birthday:
      &lt;slot name=&quot;birthday&quot;&gt;
        &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;About me&lt;/legend&gt;
      &lt;slot&gt;
        &lt;div&gt;Hello&lt;/div&gt;
        &lt;div&gt;I am John!&lt;/div&gt;
      &lt;/slot&gt;
    &lt;/fieldset&gt;
&lt;/user-card&gt;
</code></pre>
<h2 id="updating-slots"><a class="header" href="#updating-slots">Updating slots</a></h2>
<p>만약 외부의 코드를 통해 slot에 들어간 item들을 동적으로 추가/삭제하고 싶다면 어떻게 하면 좋을까?</p>
<p>기본적으로, <strong>브라우저가 slot들을 모니터링하며, 이에 따라 slot 처리된 요소들을 알아서 추가/삭제하여 렌더링해준다.</strong></p>
<p>또한, light DOM 노드들은 복제된 것이 아니라, 단순히 slot 안에 렌더링된 것이다. 때문에 변화가 즉시 가시적으로 반영된다.</p>
<p>따라서, 우리는 <strong>렌더링 업데이트에 대해 신경 쓸 필요 없다.</strong> 단, 만약 slot이 업데이트되는 <strong>특정 시점에 대해 이벤트를 적용하고 싶다면 <code>slotchange</code> 이벤트를 활용하면 된다.</strong></p>
<p><code>slotchange</code> 이벤트는, 최초에 1) 초기화 할 때 발생하고, 이후 2) slot에 변경이 생길 때마다 발생한다.</p>
<p>보다 상세한 처리가 요구되는 경우, <strong>MutationObserver</strong>를 사용할 수도 있다.</p>
<h2 id="slot-api"><a class="header" href="#slot-api">Slot API</a></h2>
<p>마지막으로, slot과 관련된 JS 메서드들을 살펴보자.</p>
<p>앞서 말했듯, JS는 오직 실제 DOM만을 바라본다. flatten DOM에 대해선 신경쓰지 않는다.</p>
<p>하지만, **만약 shadow tree가 `<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">:</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span class="mord">‘</span><span class="mord hangul_fallback">옵션을갖고있다면</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">요소로부터</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">을유추할수있고</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">반대의경우도가능하다</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">‘</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">Sl</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord hangul_fallback">노드가지정된</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">‘</span><span class="mord hangul_fallback">요소를반환한다</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">es</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span><span class="mclose">)</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">에지정된</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mord hangul_fallback">노드를가져온다</span><span class="mord">.</span><span class="mord hangul_fallback">기본적으로</span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord">‘</span><span class="mord hangul_fallback">옵션은</span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mord">‘</span><span class="mord hangul_fallback">인데</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">만약</span><span class="mord">‘</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord">‘</span><span class="mord hangul_fallback">라면</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mord hangul_fallback">을통해처리가끝난형태를반환한다</span><span class="mord">.</span><span class="mord hangul_fallback">지정된노드가없다면</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord hangul_fallback">을반환한다</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span><span class="mclose">)</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">에지정된</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mord hangul_fallback">요소들을반환한다</span><span class="mord">.</span><span class="mord hangul_fallback">위와동일하지만</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord hangul_fallback">요소만</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∗</span><span class="mord hangul_fallback">반환한다는차이가있다</span><span class="mord">.</span><span class="mord hangul_fallback">위와같은메서드들은단순히브라우저를통해출력하는것외에</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">컨텐츠들을추적해야할필요가있는경우에유용하다</span><span class="mord">.</span><span class="mord hangul_fallback">예를들어</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">아래에서</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">‘</span><span class="mord hangul_fallback">는</span><span class="mord">‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">han</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord">‘</span><span class="mord hangul_fallback">이벤트핸들러를통해</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">에무엇이보여지고있는지를추적하고있다</span><span class="mord">.‘‘‘</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">an</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">tl</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">an</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">i</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">i</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">sse</span><span class="mord mathnormal">x</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.08125em;">sH</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">nn</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">:</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">wR</span><span class="mord mathnormal">oo</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">inn</span><span class="mord mathnormal" style="margin-right:0.08125em;">erH</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">tl</span><span class="mord mathnormal">e</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">‘</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">//</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">tt</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">re</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ce</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">s</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.00773em;">wR</span><span class="mord mathnormal">oo</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal" style="margin-right:0.01968em;">tEl</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.07153em;">tC</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">L</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">han</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em;">El</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mopen">((</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.07153em;">tC</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">t</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">:</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">+</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span><span class="mpunct">;</span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">//</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">1</span><span class="mord mathnormal">seco</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.13889em;">tT</span><span class="mord mathnormal">im</span><span class="mord mathnormal">eo</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">((</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord">.</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.02778em;">ser</span><span class="mord mathnormal">t</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">ja</span><span class="mord mathnormal">ce</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.10903em;">TM</span><span class="mord mathnormal">L</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">ore</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct"><span class="mpunct">,</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">&quot;</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.07153em;">pC</span><span class="mord mathnormal" style="margin-right:0.03148em;">ak</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">&gt;</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">;</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1000</span><span class="mclose">)</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">i</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">‘‘‘</span></span></span></span></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom-styling"><a class="header" href="#shadow-dom-styling">Shadow DOM styling</a></h1>
<p>shadow DOM은 <code>&lt;style&gt;</code> 태그와 <code>&lt;link rel='stylesheet' href='...'&gt;</code> 태그를 모두 포함할 수 있다. 그 중 <code>&lt;link&gt;</code> 태그의 경우, <strong>HTTP 캐싱</strong>이 되며, 여러번 다운로드 되지 않는다.</p>
<p>일반적인 스타일 규칙으로는, shadow DOM은 오직 shadow tree 내의 로컬 스타일 규칙에만 영향을 받는다. 하지만 몇가지 예외가 존재한다.</p>
<h2 id="host"><a class="header" href="#host">:host</a></h2>
<p><code>:host</code> 선택자는 shadow 호스트(shadow tree를 보유한 요소)를 선택하는 것을 허용한다.</p>
<p>예를 들어, <code>&lt;custom-dialog&gt;</code>요소가 가운데에 위치하길 원한다면, 아래와 같은 방법으로 스타일을 추가할 수 있다.</p>
<pre><code class="language-html">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt;
    /* the style will be applied from inside to the custom-dialog element */
    :host {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  &lt;/style&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/template&gt;

&lt;script&gt;
  customElements.define(
    'custom-dialog',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' }).append(
          tmpl.content.cloneNode(true),
        );
      }
    },
  );
&lt;/script&gt;

&lt;custom-dialog&gt; Hello! &lt;/custom-dialog&gt;
</code></pre>
<h2 id="cascading"><a class="header" href="#cascading">Cascading</a></h2>
<p>shadow 호스트(<code>&lt;custom-dialog&gt;</code> 태그 그 자체)는 light DOM에 위치한다. 따라서, 이는 문서 자체의 CSS 규칙에 영향을 받는다.</p>
<p>만약, shadow tree에 로컬로 <code>:host</code> 스타일이 존재함과 동시에, 문서 자체에도 스타일이 존재한다면, 문서의 스타일링이 더 우선시된다.</p>
<p>따라서, 위의 코드에서 아래와 같이 문서에 스타일링을 추가하는 경우</p>
<pre><code class="language-html">&lt;style&gt;
  custom-dialog {
    padding: 0;
  }
&lt;/style&gt;
</code></pre>
<p><code>&lt;custom-dialog&gt;</code>는 더 이상 padding을 갖지 않는다.</p>
<p>이는 제법 편리한데, 이를 통해 <code>:host</code>에는 <strong>기본(default) 컴포넌트 스타일</strong>을 지정하고, 문서를 통해서 스타일링을 쉽게 덮어씌울 수 있기 때문이다.</p>
<p>예외는 로컬 스타일링에 <code>!important</code>를 적용하는 경우다.</p>
<h2 id="hostselector"><a class="header" href="#hostselector">:host(selector)</a></h2>
<p><code>:host</code>와 동일하되, 주어진 선택자(<code>selector</code>)에 해당하는 경우에만 적용된다.</p>
<p>예를 들어, 앞선 <code>&lt;custom-dialog&gt;</code>에서, <code>center</code> 속성(attribute)를 보유한 경우에만 가운데 정렬을 하고싶다면, 아래와 같이 활용할 수 있다.</p>
<pre><code class="language-html">&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt;
    :host([centered]) {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-color: blue;
    }

    :host {
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  &lt;/style&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/template&gt;

&lt;script&gt;
  customElements.define(
    'custom-dialog',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' }).append(
          tmpl.content.cloneNode(true),
        );
      }
    },
  );
&lt;/script&gt;

&lt;custom-dialog centered&gt; Centered! &lt;/custom-dialog&gt;

&lt;custom-dialog&gt; Not centered. &lt;/custom-dialog&gt;
</code></pre>
<h2 id="host-contextselector"><a class="header" href="#host-contextselector">:host-context(selector)</a></h2>
<p><code>:host</code>와 동일하되, shadow 호스트 자신, 혹은 그 상위에 있는 요소 중 해당 <code>selector</code>에 해당하는 경우에만 적용된다.</p>
<p>예를 들어, <code>:host-context(.dark-theme)</code>를 사용한 아래 예시에서, <code>&lt;custom-dialog&gt;</code>에 <code>dark-theme</code> 클래스가 존재하는 경우에만 스타일링이 적용된다.</p>
<pre><code class="language-html">&lt;body class=&quot;dark-theme&quot;&gt;
  &lt;!--
    :host-context(.dark-theme) applies to custom-dialogs inside .dark-theme
  --&gt;
  &lt;custom-dialog&gt;...&lt;/custom-dialog&gt;
&lt;/body&gt;
</code></pre>
<p>요약하자면, <code>:host</code> 종류들은 컴포넌트의 메인 요소들을 스타일링 하기 위해 활용할 수 있는 선택자이다. 이를 활용해 적용한 스타일들은 문서 자체에서의 스타일링에 덮어씌여질 수 있다.</p>
<h2 id="slotted-content-스타일링"><a class="header" href="#slotted-content-스타일링">slotted content 스타일링</a></h2>
<p>이제, <code>slot</code>을 사용하는 경우를 보자.</p>
<p>slot 처리 된 요소 자체는 light DOM에서 온다. 따라서, 그들 요소는 문서의 스타일링을 따르며, shadow tree 측에서의 로컬 스타일링은 여기에 영향을 미치지 않는다.</p>
<p>예를 들어보자. 아래에 slot으로 삽입된 <code>&lt;span&gt;</code>은 문서 스타일링에 따라 <code>bold</code> 폰트 굵기를 갖는다. 하지만 shadow Root에서의 스타일링에 영향 받지 않기 때문에 붉은 바탕(<code>background: red</code>)이 아니다.</p>
<pre><code class="language-html">&lt;style&gt;
  span {
    font-weight: bold;
  }
&lt;/style&gt;

&lt;user-card&gt;
  &lt;div slot=&quot;username&quot;&gt;&lt;span&gt;John Smith&lt;/span&gt;&lt;/div&gt;
&lt;/user-card&gt;

&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
      &lt;style&gt;
      span { background: red; }
      &lt;/style&gt;
      Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    `;
      }
    },
  );
&lt;/script&gt;
</code></pre>
<p>만약, slot 처리된 요소들에 대해 컴포넌트 안에서 스타일링하고 싶다면, 두가지 선택지가 있다.</p>
<p><strong>첫번째는,</strong> 컴포넌트 내에서 CSS 상속에 기반해 <code>&lt;slot&gt;</code> 그 자체를 스타일링하는 것이다.</p>
<pre><code class="language-HTML">&lt;user-card&gt;
  &lt;div slot=&quot;username&quot;&gt;&lt;span&gt;John Smith&lt;/span&gt;&lt;/div&gt;
&lt;/user-card&gt;

&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      &lt;style&gt;
      slot[name=&quot;username&quot;] { font-weight: bold; }
      &lt;/style&gt;
      Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    `;
  }
});
&lt;/script&gt;
</code></pre>
<p>이제 <code>&lt;p&gt;John Smith&lt;/p&gt;</code>는 bold 굵기가 된다. 왜냐하면 CSS 상속에 의해 하위 요소들에게도 영향을 미치기 때문이다. 단, CSS 자체의 속성들이 상속되지는 않는다.</p>
<p><strong>두번째 선택지는</strong> 바로 <code>::slotted(selector)</code> 의사 클래스를 사용하는 것이다. 이 때는 두가지 조건에 따라 해당하는 요소를 구분한다.</p>
<ol>
<li>light DOM를 통해서 전달된 slot 처리된 요소(<code>slot='...'</code>를 포함)여야 한다. <code>name</code> 자체는 중요하지 않다. 단, 오직 그 요소 자체에만 해당하며, 하위 요소들은 해당하지 않는다.</li>
<li>요소가 <code>selector</code> 선택자에 해당해야 한다.</li>
</ol>
<p>예를 들어, <code>::slotted(div)</code>는 정확히 <code>&lt;div slot='username'&gt;</code>에만 적용되며, 하위 요소들에는 적용되지 않는다.</p>
<pre><code class="language-html">&lt;user-card&gt;
  &lt;div slot=&quot;username&quot;&gt;
    &lt;div&gt;John Smith&lt;/div&gt;
  &lt;/div&gt;
&lt;/user-card&gt;

&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
      &lt;style&gt;
      ::slotted(div) { border: 1px solid red; }
      &lt;/style&gt;
      Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    `;
      }
    },
  );
&lt;/script&gt;
</code></pre>
<p>기억하자. <code>::slotted</code> 선택자는 하위 요소들을 확인하지 않는다.</p>
<pre><code class="language-css">::slotted(div span) {
  /* our slotted &lt;div&gt; does not match this */
}

::slotted(div) p {
  /* can't go inside light DOM */
}
</code></pre>
<h2 id="커스텀-프로퍼티를-이용한-css-hook"><a class="header" href="#커스텀-프로퍼티를-이용한-css-hook">커스텀 프로퍼티를 이용한 CSS Hook</a></h2>
<p>메인 문서를 통해 shadow DOM 컴포넌트 내부의 요소들을 스타일링하려면, 어떻게 해야할까?</p>
<p><code>:host</code> 선택자는 <code>&lt;custom-dialog&gt;</code> 자체에 대해서 스타일링을 적용할 수 있다. 그런데, 그것보다 깊숙히 위치한 요소들에 스타일링을 적용하고 싶다면 어떻게 할까?</p>
<p>사실, 문서에서 shadow DOM의 스타일에 직접 영향을 줄 수 있는 선택자는 없다. 그러나, 원한다면, CSS 변수(custom CSS properties)를 활용해 이를 구현할 수 있다.</p>
<p>왜냐하면, <strong>커스텀 CSS 프로퍼티는 light와 shadow 모두에 존재하기 때문이다.(공유한다)</strong></p>
<p>예를 들어, 먼저 아래처럼 <code>--user-card-field-color</code>라는 CSS 변수를 사용해 <code>.field</code>를 기본 스타일링할 수 있다.</p>
<pre><code class="language-html">&lt;style&gt;
  .field {
    color: var(--user-card-field-color, black);
    /* if --user-card-field-color is not defined, use black color */
  }
&lt;/style&gt;
&lt;div class=&quot;field&quot;&gt;Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
&lt;div class=&quot;field&quot;&gt;Birthday: &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
</code></pre>
<p>이후, 문서에서 <code>&lt;user-card&gt;</code>에 대해 앞서 만든 property를 활용하여 스타일링을 변경할 수 있다.</p>
<pre><code class="language-css">user-card {
  --user-card-field-color: green;
}
</code></pre>
<p>커스텀 CSS 프로퍼티는 shadow DOM 전반에 유효하기 때문에, 어디서든 활용할 수 있다.</p>
<pre><code class="language-HTML">&lt;style&gt;
  user-card {
    --user-card-field-color: green;
  }
&lt;/style&gt;

&lt;template id=&quot;tmpl&quot;&gt;
  &lt;style&gt;
    .field {
      color: var(--user-card-field-color, black);
    }
  &lt;/style&gt;
  &lt;div class=&quot;field&quot;&gt;Name: &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
  &lt;div class=&quot;field&quot;&gt;Birthday: &lt;slot name=&quot;birthday&quot;&gt;&lt;/slot&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));
  }
});
&lt;/script&gt;

&lt;user-card&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
  &lt;span slot=&quot;birthday&quot;&gt;01.01.2001&lt;/span&gt;
&lt;/user-card&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="shadow-dom-and-events"><a class="header" href="#shadow-dom-and-events">Shadow DOM and events</a></h1>
<p>shadow tree에 담긴 기본 아이디어는 컴포넌트 내부적인 실행 세부사항에 대해 캡슐화를 적용하는 것이다.</p>
<p><code>&lt;user-card&gt;</code>의 shadow DOM 내부에 클릭 이벤트가 발생했다고 가정하자. 이 때, 메인 문서는 shadow DOM 내부에 대해 알 수 있는 방법이 없다. 이는 특히 서드파티 라이브러리로부터의 컴포넌트를 활용할 때 더 두드러진다.</p>
<p>따라서, 캡슐화를 유지하기 위해, 브라우저는 이벤트를 리타겟팅(<strong>retarget</strong>)한다.</p>
<p><strong>shadow DOM 내부에서 일어나는 이벤트들은 컴포넌트 외부에서 볼 때, 그들의 <strong>host</strong> 요소를 <code>target</code>으로 삼는다.</strong></p>
<p>말이 좀 헷갈릴 수 있는데, 다시 말해, shadow DOM 측에서 봤을 때는 <code>div</code>, <code>span</code> 등에서 이벤트가 발생했더라도, 메인 문서 측에서는 해당 이벤트의 타겟을 항상 <code>user-card</code>와 같은 host로 본다.</p>
<p>아래는 간단한 예시다.</p>
<pre><code class="language-html">&lt;user-card&gt;&lt;/user-card&gt;

&lt;script&gt;
  customElements.define(
    'user-card',
    class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `&lt;p&gt;
      &lt;button&gt;Click me&lt;/button&gt;
    &lt;/p&gt;`;
        this.shadowRoot.firstElementChild.onclick = (e) =&gt;
          alert('Inner target: ' + e.target.tagName);
      }
    },
  );

  document.onclick = (e) =&gt; alert('Outer target: ' + e.target.tagName);
&lt;/script&gt;
</code></pre>
<p>위 예시에서는, shadow DOM과 light DOM에서 바라보는 target이 달라지게 된다.</p>
<ol>
<li>
<p>내부 타겟: <code>BUTTON</code> - shadow DOM을 통한 컴포넌트 내부의 이벤트 핸들러는 올바른 <code>target</code>을 가져온다.</p>
</li>
<li>
<p>외부 타겟: <code>USER-CARD</code> - 문서에서 사용하는 이벤트 핸들러는 shadow host(<code>user-card</code>)를 타겟으로 가져온다.</p>
</li>
</ol>
<p>이벤트 리타겟팅은 마땅히 존재해야 하는데, 컴포넌트 내부에서 발생하는 일들에 대해 외부의 문서가 신경을 쓸 필요가 없기 떄문이다. 때문에, 문서의 관점에서는 단순히 <code>&lt;user-card&gt;</code>에서 발생한 이벤트라고만 인식하는 것이다.</p>
<p><strong>리타겟팅은 slot 처리된 요소에서는 발생하지 않는데, 왜냐하면 애초에 해당 요소는 light DOM에서부터 온 것이기 때문이다.</strong></p>
<p>예를 들어, 아래 예시에서 <code>&lt;span slot='username'&gt;</code>의 이벤트 타겟은 정확히 <code>span</code>이 된다. 이는 shadow와 light 이벤트 핸들러 양측이 동일하다.</p>
<pre><code class="language-HTML">&lt;user-card id=&quot;userCard&quot;&gt;
  &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
&lt;/user-card&gt;

&lt;script&gt;
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `&lt;div&gt;
      &lt;b&gt;Name:&lt;/b&gt; &lt;slot name=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;`;

    this.shadowRoot.firstElementChild.onclick =
      e =&gt; alert(&quot;Inner target: &quot; + e.target.tagName);
  }
});

userCard.onclick = e =&gt; alert(`Outer target: {e.target.tagName}`);
&lt;/script&gt;
</code></pre>
<p>단, 위 예시에서 <code>&lt;b&gt;Name:&lt;/b&gt;</code>과 같이 slot에 해당하지 않는 요소로부터 발생한 이벤트는 마찬가지로 host를 타겟으로 삼는다.</p>
<h2 id="버블링-eventcomposedpath"><a class="header" href="#버블링-eventcomposedpath">버블링, event.composedPath()</a></h2>
<p>flattened DOM은 이벤트 버블링을 위해서 사용된다.</p>
<p>따라서, 만약 slot 처리된 요소가 존재한다면, 그 안에서 발생한 이벤트는 <code>&lt;slot&gt;</code>을 거쳐 상위로 버블링된다.</p>
<p>shadow 요소들을 포함한 원래 이벤트 타겟에 대한 전체 경로(full-path)는 <code>event.composedPath()</code> 메서드를 통해 확인할 수 있다. 메서드의 이름에서부터 알 수 있듯이, 여기서 반환받는 경로는 composition 단계 이후의 path이다.</p>
<p>예를 들어, 아래의 flatten DOM이 있다고 가정하자.</p>
<pre><code class="language-HTML">&lt;user-card id=&quot;userCard&quot;&gt;
  #shadow-root
    &lt;div&gt;
      &lt;b&gt;Name:&lt;/b&gt;
      &lt;slot name=&quot;username&quot;&gt;
        &lt;span slot=&quot;username&quot;&gt;John Smith&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
&lt;/user-card&gt;
</code></pre>
<p>이제, <code>&lt;span slot='username'&gt;</code>을 클릭했을 때, <code>event.composedPath()</code>를 확인한다면, 다음 배열을 반환한다.</p>
<p><code>[span, slot, div, shadow-root, user-card, body, html, document, window]</code></p>
<p>이는 composition 이후 생성된 flatten DOM에서의 타겟 요소로부터 부모로 뻗어나가는 체이닝이다.</p>
<h3 id="주의"><a class="header" href="#주의">주의</a></h3>
<blockquote>
<p>shadow tree의 세부사항들은 오직 <code>{mode: 'open'}</code> 옵션이 있을 때만 제공된다.
만약, 그렇지 않다면 <code>event.composedPath()</code>역시 <code>user-card</code>에서부터 시작한다.
이는 shadow DOM이 동작하는 다른 메서드의 원칙과 유사한데, 닫힌(closed) 트리는 내부적으로 완전히 숨겨진다.</p>
</blockquote>
<h2 id="eventcomposed"><a class="header" href="#eventcomposed">event.composed</a></h2>
<p>대부분의 이벤트들은 shadow DOM 경계를 거쳐 완전히 버블링된다. 하지만 몇개의 예외가 존재한다.</p>
<p>이 경우 <code>composed</code> 이벤트 객체 프로퍼티에 의해 제어될 수 있는데, 만약 <code>true</code>에 해당하는 경우, 해당 이벤트는 shadow DOM의 경계를 넘어간다. <code>false</code>인 경우, 이벤트는 오직 shadow DOM 내부에서만 탐색된다.</p>
<p>아래 대부분의 이벤트는 <code>composed: true</code>이다.</p>
<ul>
<li><code>blur</code>, <code>focus</code>, <code>focusin</code>, <code>focusout</code></li>
<li><code>click</code>, <code>dblclick</code></li>
<li><code>mousedown</code>, <code>mouseup</code>, <code>mousemove</code>, <code>mouseout</code>, <code>mouseover</code></li>
<li><code>wheel</code></li>
<li><code>beforeinput</code>, <code>input</code>, <code>keydown</code>, <code>keyup</code></li>
</ul>
<p>모든 터치 이벤트와 포인터 이벤트 역시 <code>composed: true</code>로 설정된다.</p>
<p>아래는 <code>composed: false</code>에 해당하는 일부 이벤트들이다.</p>
<ul>
<li><code>mouseenter</code>, <code>mouseleave</code> (얘넨 애초에 버블링이 없다.)</li>
<li><code>load</code>, <code>unload</code>, <code>abort</code>, <code>error</code></li>
<li><code>select</code></li>
<li><code>slotchange</code></li>
</ul>
<p>해당 이벤트들은 오직 해당 요소가 동일하게 위치한 DOM 내에서만 확인될 수 있다.</p>
<h2 id="커스텀-이벤트"><a class="header" href="#커스텀-이벤트">커스텀 이벤트</a></h2>
<p>임의로 작성한 커스텀 이벤트를 발생시킬 때, <code>bubble</code>과 <code>composed</code> 프로퍼티를 설정할 수 있다.</p>
<p>예를 들어, 아래에서 <code>div#outer</code>의 shadow DOM에 <code>div#inner</code>을 만들고 거기에 두 이벤트를 트리거하자. 그러면, 오직 <code>composed: true</code>로 설정한 이벤트만이 DOM 경계를 넘어 문서 바깥으로 나올 수 있다.</p>
<pre><code class="language-HTML">&lt;div id=&quot;outer&quot;&gt;&lt;/div&gt;

&lt;script&gt;
outer.attachShadow({mode: 'open'});

let inner = document.createElement('div');
outer.shadowRoot.append(inner);

/*
div(id=outer)
  #shadow-dom
    div(id=inner)
*/

document.addEventListener('test', event =&gt; alert(event.detail));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: true,
  detail: &quot;composed&quot;
}));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: false,
  detail: &quot;not composed&quot;
}));
&lt;/script&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Canvas API에 대한 정리는 <a href="https://developer.mozilla.org/ko/docs/Web/API/Canvas_API/Tutorial/Basic_usage#%3Ccanvas%3E_%EC%9A%94%EC%86%8C">MDN</a>의 문서를 쭉 따라갈 예정입니다.</p>
<p>먼저 <code>&lt;canvas&gt;</code> 태그의 형태에 대해 살펴봅시다.</p>
<pre><code class="language-html">&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p><code>width</code>와 <code>height</code> 어트리뷰트를 지정하지 않는 경우, 캔버스의 최초 너비는 <strong>300px</strong>이고, 높이는 <strong>150px</strong>이 됩니다. 해당 요소는 CSS에 의해 임의로 크기가 변경될 수 있으나, 비율이 고려되지 않는 경우 왜곡되어 보입니다.</p>
<blockquote>
<p>노트: 만약 렌더링이 왜곡된 것처럼 보인다면, CSS를 사용하지 않고, 직접 <code>&lt;canvas&gt;</code> 태그의 <code>width</code>와 <code>height</code> 어트리뷰트를 지정하는 것이 좋습니다.</p>
</blockquote>
<h2 id="대체-콘텐츠"><a class="header" href="#대체-콘텐츠">대체 콘텐츠</a></h2>
<p><code>&lt;canvas&gt;</code> 태그 안에 콘텐츠가 삽입된 경우, <code>&lt;canvas&gt;</code> 태그를 지원하지 않는 브라우저에 대해서는 해당 콘텐츠를 보여줍니다. 브라우저가 <code>&lt;canvas&gt;</code>태그를 지원하는 경우, 이는 무시됩니다. 참고로, <code>&lt;canvas&gt;</code>는, 이러한 방식으로 인해 반드시 닫는 태그가 필요합니다.</p>
<pre><code class="language-html">&lt;canvas id=&quot;stockGraph&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;
  current stock price: 3.15 +0.15
&lt;/canvas&gt;

&lt;canvas id=&quot;clock&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;
  &lt;img src=&quot;images/clock.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot; /&gt;
&lt;/canvas&gt;
</code></pre>
<h2 id="rendering-context"><a class="header" href="#rendering-context">Rendering Context</a></h2>
<p>캔버스는 최초에 비어있으며, 어떤 것을 표시하기 위해 스크립트를 통해 렌더링 컨텍스트에 접근하여, 이를 그려내야 합니다.</p>
<pre><code class="language-js">const canvas = document.getElementById('tutorial');
const ctx = canvas.getContext('2d');
</code></pre>
<h2 id="기본-예제"><a class="header" href="#기본-예제">기본 예제</a></h2>
<p>간단한 직사각형 두개를 그려낸 예제를 살펴보겠습니다. 현재는 아래를 통해 대략적인 형태에 대해서만 이해하면 됩니다.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;script type=&quot;application/javascript&quot;&gt;
      function draw() {
        const canvas = document.getElementById('canvas');
        if (canvas.getContext) {
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = 'rgb(200,0,0)';
          ctx.fillRect(10, 10, 50, 50);
          ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';
          ctx.fillRect(30, 30, 50, 50);
        }
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload=&quot;draw();&quot;&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><canvas id="canvas"></canvas></p>
<script>
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgb(200,0,0)';
  ctx.fillRect(10, 10, 50, 50);
  ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';
  ctx.fillRect(30, 30, 50, 50);
</script>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="도형-그리기"><a class="header" href="#도형-그리기">도형 그리기</a></h1>
<p>기본적으로 캔버스 상의 좌표 공간은 아래의 형태를 따릅니다. 좌상단을 기준으로 x, y 좌표를 판단합니다.</p>
<img src="https://mdn.mozillademos.org/files/224/Canvas_default_grid.png" />
<h2 id="직사각형-그리기"><a class="header" href="#직사각형-그리기">직사각형 그리기</a></h2>
<p>캔버스 상에서 직사각형을 그리기는 데에는 세가지 함수가 있습니다.</p>
<ol>
<li><code>fillRect(x, y, width, height)</code></li>
</ol>
<ul>
<li>색칠된 직사각형을 그립니다.</li>
</ul>
<ol start="2">
<li><code>strokeRect(x, y, width, height)</code></li>
</ol>
<ul>
<li>직사각형 윤곽선을 그립니다.</li>
</ul>
<ol start="3">
<li><code>clearRect(x, y, width, height)</code></li>
</ol>
<ul>
<li>직사각형 모양으로 해당 부분들을 완전히 지웁니다.</li>
</ul>
<ol start="4">
<li><code>rect(x, y, width, height)</code></li>
</ol>
<ul>
<li>직사각형 모양으로 경로를 추가합니다. 이후 좌표가 해당 경로로 이동합니다.</li>
</ul>
<p>이들을 이용해 하나의 예제를 살펴봅시다.</p>
<pre><code class="language-js">ctx.fillRect(25, 25, 100, 100);
ctx.clearRect(45, 45, 60, 60);
ctx.strokeRect(50, 50, 50, 50);
</code></pre>
<p><canvas id="example1" ></canvas></p>
<script>
const ctx1 = example1.getContext('2d');
ctx1.fillRect(25, 25, 100, 100)
ctx1.clearRect(45, 45, 60, 60);
ctx1.strokeRect(50, 50, 50, 50);
</script>
<h2 id="경로-그리기"><a class="header" href="#경로-그리기">경로 그리기</a></h2>
<p>경로는 직사각형 외의 유일한 원시형(primitive) 도형입니다. 경로를 통해 도형을 그리기 위해서는 다음의 단계를 거치게 됩니다.</p>
<ol>
<li>경로를 생성</li>
<li>그리기 명령들을 통해 경로 상에 그립니다.</li>
<li>그린 경로에 대한 윤곽선을 그리거나 도형 내부를 채웁니다.</li>
</ol>
<p>이러한 단계들을 수행하게 아래의 함수들이 사용됩니다.</p>
<ol>
<li><code>beginPath()</code></li>
</ol>
<ul>
<li>새로운 경로를 만듭니다.</li>
</ul>
<ol start="2">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D#paths">여러 Path 메서드들</a></li>
</ol>
<ul>
<li>이후에 계속 살펴보겠지만, 여러 경로들을 설정하기 위해 사용됩니다.</li>
</ul>
<ol start="3">
<li><code>closePath()</code></li>
</ol>
<ul>
<li>현재 경로의 시작점과 연결되는 직선을 추가합니다. 이는 옵션 사항입니다.</li>
</ul>
<ol start="4">
<li><code>stroke()</code></li>
</ol>
<ul>
<li>윤곽선을 통해 도형을 그립니다.</li>
</ul>
<ol start="5">
<li><code>fill()</code></li>
</ol>
<ul>
<li>경로 내부를 채워 색칠된 도형을 그립니다. 이 경우 별도로 <code>closePath()</code>를 해줄 필요가 없습니다.</li>
</ul>
<p>이를 통해 간단한 삼각형을 그려봅시다.</p>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(75, 50);
ctx.lineTo(100, 75);
ctx.lineTo(100, 25);
ctx.fill();
</code></pre>
<p><canvas id='example2' ></canvas></p>
<script>
const ctx2 = example2.getContext('2d');
ctx2.beginPath();
ctx2.moveTo(75, 50);
ctx2.lineTo(100, 75);
ctx2.lineTo(100, 25);
ctx2.fill();
</script>
<h2 id="펜-이동하기"><a class="header" href="#펜-이동하기">펜 이동하기</a></h2>
<ul>
<li><code>moveTo(x, y)</code>
<ul>
<li>이를 이용하면, 펜을 해당 좌표로 옮기기만 하고, 그리진 않습니다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">ctx.beginPath();
ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
ctx.moveTo(110, 75);
ctx.arc(75, 75, 35, 0, Math.PI, false); // Mouth (clockwise)
ctx.moveTo(65, 65);
ctx.arc(60, 65, 5, 0, Math.PI * 2, true); // Left eye
ctx.moveTo(95, 65);
ctx.arc(90, 65, 5, 0, Math.PI * 2, true); // Right eye
ctx.stroke();
</code></pre>
<p><canvas id="example3"></canvas></p>
<script>
const ctx3 = example3.getContext('2d');
ctx3.beginPath();
ctx3.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
ctx3.moveTo(110, 75);
ctx3.arc(75, 75, 35, 0, Math.PI, false); // Mouth (clockwise)
ctx3.moveTo(65, 65);
ctx3.arc(60, 65, 5, 0, Math.PI * 2, true); // Left eye
ctx3.moveTo(95, 65);
ctx3.arc(90, 65, 5, 0, Math.PI * 2, true); // Right eye
ctx3.stroke();
</script>
<h2 id="선-그리기"><a class="header" href="#선-그리기">선 그리기</a></h2>
<ul>
<li><code>lineTo(x, y)</code>
<ul>
<li>이는 현재 위치에서 해당 좌표 위치까지 선을 그려냅니다.</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// Filled triangle
ctx.beginPath();
ctx.moveTo(25, 25);
ctx.lineTo(105, 25);
ctx.lineTo(25, 105);
ctx.fill();

// Stroked triangle
ctx.beginPath();
ctx.moveTo(125, 125);
ctx.lineTo(125, 45);
ctx.lineTo(45, 125);
ctx.closePath();
ctx.stroke();
</code></pre>
<p><canvas id="example4"></canvas></p>
<script>
  const ctx4 = example4.getContext('2d');
  // Filled triangle
  ctx4.beginPath();
  ctx4.moveTo(25, 25);
  ctx4.lineTo(105, 25);
  ctx4.lineTo(25, 105);
  ctx4.fill();

  // Stroked triangle
  ctx4.beginPath();
  ctx4.moveTo(125, 125);
  ctx4.lineTo(125, 45);
  ctx4.lineTo(45, 125);
  ctx4.closePath();
  ctx4.stroke();
</script>
<h2 id="호arc-또는-원-그리기"><a class="header" href="#호arc-또는-원-그리기">호(Arc) 또는 원 그리기</a></h2>
<ol>
<li><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code></li>
</ol>
<ul>
<li>해당 좌표에, 반지름 <code>radius</code>를 갖도록 <code>startAngle</code> 각도에서 <code>endAngle</code>각도까지 <code>anticlockwise</code> 방향으로 호를 그려냅니다.</li>
</ul>
<ol start="2">
<li><code>arcTo(x1, y1, x2, y2, radius)</code></li>
</ol>
<ul>
<li>주어진 각 제어점과 반지름으로 호를 그리고, 이전 점과 직선으로 연결합니다.</li>
<li>이에 대해서는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo">여기</a>를 살펴봅시다.</li>
</ul>
<p>&lt;img src=&quot;&gt;</p>
<blockquote>
<p><strong>주의!</strong>: <code>arc</code>함수에서의 각도는 degree가 아닌 radian 단위를 사용합니다. 따라서 degree 단위를 사용하려면 별도의 변환이 요구됩니다.</p>
<p><code>radians = (Math.PI/180)*degrees</code></p>
</blockquote>
<pre><code class="language-js">const startAngle = 0;
const endAngle = (Math.PI / 180) * 90;
ctx.beginPath();
ctx.arc(120, 120, 100, startAngle, endAngle, true);
ctx.stroke();
</code></pre>
<p><canvas id="example5" height="250"></canvas></p>
<script>
const ctx5 = example5.getContext('2d');
const startAngle = 0;
const endAngle = (Math.PI / 180) * 90;
ctx5.beginPath();
ctx5.arc(120, 120, 100, startAngle, endAngle, true);
ctx5.stroke();
</script>
<h2 id="베지어bezier-곡선과-이차quadratic-곡선"><a class="header" href="#베지어bezier-곡선과-이차quadratic-곡선">베지어(Bezier) 곡선과 이차(Quadratic) 곡선</a></h2>
<img src="https://mdn.mozillademos.org/files/223/Canvas_curves.png" />
<p>베지어 곡선은 주로 복잡한 형태를 그려내는데 사용됩니다.</p>
<ol>
<li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code></li>
</ol>
<ul>
<li><code>cp1x</code> 및 <code>cp1y</code>로 지정된 제어점을 통해 현재 펜 위치에서 <code>x</code>, <code>y</code>로 지정된 끝점까지 이차 베지어 곡선을 그립니다.</li>
</ul>
<ol start="2">
<li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code></li>
</ol>
<ul>
<li>각 제어점을 통해 <code>x</code>, <code>y</code>로 지정된 끝점까지 삼차 베지어 곡선을 그립니다.</li>
</ul>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(75, 25);
ctx.quadraticCurveTo(25, 25, 25, 62.5);
ctx.quadraticCurveTo(25, 100, 50, 100);
ctx.quadraticCurveTo(50, 120, 30, 125);
ctx.quadraticCurveTo(60, 120, 65, 100);
ctx.quadraticCurveTo(125, 100, 125, 62.5);
ctx.quadraticCurveTo(125, 25, 75, 25);
ctx.stroke();
</code></pre>
<p><canvas id="example6"></canvas></p>
<script>
const ctx6 = example6.getContext('2d');
ctx6.beginPath();
ctx6.moveTo(75, 25);
ctx6.quadraticCurveTo(25, 25, 25, 62.5);
ctx6.quadraticCurveTo(25, 100, 50, 100);
ctx6.quadraticCurveTo(50, 120, 30, 125);
ctx6.quadraticCurveTo(60, 120, 65, 100);
ctx6.quadraticCurveTo(125, 100, 125, 62.5);
ctx6.quadraticCurveTo(125, 25, 75, 25);
ctx6.stroke();
</script>
<pre><code class="language-js">ctx.beginPath();
ctx.moveTo(75, 40);
ctx.bezierCurveTo(75, 37, 70, 25, 50, 25);
ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
ctx.bezierCurveTo(20, 80, 40, 102, 75, 120);
ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
ctx.bezierCurveTo(85, 25, 75, 37, 75, 40);
ctx.fill();
</code></pre>
<p><canvas id="example7"></canvas></p>
<script>
const ctx7 = example7.getContext('2d');
ctx7.beginPath();
ctx7.moveTo(75, 40);
ctx7.bezierCurveTo(75, 37, 70, 25, 50, 25);
ctx7.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
ctx7.bezierCurveTo(20, 80, 40, 102, 75, 120);
ctx7.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
ctx7.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
ctx7.bezierCurveTo(85, 25, 75, 37, 75, 40);
ctx7.fill();
</script>
<h2 id="path2d-오브젝트"><a class="header" href="#path2d-오브젝트">Path2D 오브젝트</a></h2>
<ul>
<li><code>Path2D()</code>
<ul>
<li><code>new</code> 키워드와 함께 사용되어 새로운 <code>Path2D</code> 객체를 반환합니다. 기존 경로 혹은 SVG 경로를 인자로 받을 수도 있습니다.</li>
</ul>
</li>
</ul>
<p>SVG 경로 데이터를 활용하는 경우, 아래와 같은 형태가 됩니다.</p>
<pre><code class="language-js">const p = new Path2D('M10 10 h 80 v 80 h -80 Z');
</code></pre>
<p>이를 활용하면, 하나의 컨텍스트로 이리저리 옮겨가며 그리던 방식에서 벗어나, 객체의 형태로 각 경로를 변수에 저장할 수 있습니다.</p>
<pre><code class="language-js">const rectangle = new Path2D();
rectangle.rect(10, 10, 50, 50);

const circle = new Path2D();
circle.moveTo(125, 35);
circle.arc(100, 35, 25, 0, 2 * Math.PI);

ctx.stroke(rectangle);
ctx.fill(circle);
</code></pre>
<p><canvas id='example8'></canvas></p>
<script>
  const ctx8 = example8.getContext('2d');
  const rectangle = new Path2D();
  rectangle.rect(10, 10, 50, 50);

  const circle = new Path2D();
  circle.moveTo(125, 35);
  circle.arc(100, 35, 25, 0, 2 * Math.PI);

  ctx8.stroke(rectangle);
  ctx8.fill(circle);
</script>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<ul>
<li>해당 md는 <a href="https://developers.google.com/web/fundamentals">여기</a>의 글을 재구성한 것입니다.</li>
</ul>
<h1 id="렌더링-최적화"><a class="header" href="#렌더링-최적화">렌더링 최적화</a></h1>
<h2 id="픽셀-파이프라인"><a class="header" href="#픽셀-파이프라인">픽셀 파이프라인</a></h2>
<img src='https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg' />
<p>위 그림은 작업 시 유의해야하는 5가지 주요 영역이며, 픽셀 - 화면 파이프라인의 핵심 요소이다.</p>
<ul>
<li><strong>JS / CSS</strong> : JS 및 CSS를 통해 이루어지는 시각적 변화의 트리거를 가리킨다.</li>
<li><strong>Style</strong> : <code>.headline</code>과 같은 선택자에 따라 어떤 CSS 규칙을 어떤 요소에 적용할지 계산하는 프로세스이다.</li>
<li><strong>Layout</strong> : 브라우저가 각 요소에 어떤 규칙을 적용할 지 알고난 후, 실제로 어디에, 어느 정도의 공간을 차지하며 위치할지를 계산하는 과정. 한 요소가 다른 요소에 영향을 줄 수 있기 때문에 해당 과정이 필요하다.</li>
<li><strong>Paint</strong> : 실제로 화면의 픽셀을 채우는 과정. 텍스트 / 색 / 경계 및 그림자 등 요소의 모든 시각적 부분을 그려낸다. 일반적으로 레이어라고 하는 여러 개의 표면에서 수행된다.</li>
<li><strong>Composition</strong> : 페이지의 각 부분들이 여러 레이어를 통해 그려졌기 때문에, 페이지가 정확히 렌더링되기 위해 정확한 순서대로 화면에 그려내는 과정.</li>
</ul>
<p>JS / CSS를 통해 시각적인 변경이 이루어졌을 때, 파이프라인이 동작하는 세가지 형태가 존재한다.</p>
<h3 id="1-js--css---style---layout---paint---composition"><a class="header" href="#1-js--css---style---layout---paint---composition"><strong>1. JS / CSS -&gt; Style -&gt; Layout -&gt; Paint -&gt; Composition</strong></a></h3>
<img src='https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg' />
<ul>
<li>너비 / 높이 / 위치 등 요소의 기하학적 형태에 영향을 주는 Layout 속성들을 변경하면 브라우저가 다른 요소들을 확인하고 페이지에 대해 <strong>리플로우(Reflow)</strong> 작업을 수행해야 한다. 이후 영향을 받은 영역이 있다면 다시 페인트해야 하고, 최종적으로 페인트한 요소는 다시 합성이 이루어져야 한다.</li>
</ul>
<h3 id="2-js--css---style---paint---composition"><a class="header" href="#2-js--css---style---paint---composition"><strong>2. JS / CSS -&gt; Style -&gt; Paint -&gt; Composition</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg" />
<ul>
<li>페이지의 레이아웃에 영향을 주지 않는 배경 이미지, 텍스트 색상 또는 그림자 등 Paint Only 속성을 변경하면, 브라우저가 레이아웃 작업을 건너뛰고 페인트 작업부터 수행한다.</li>
</ul>
<h3 id="3-js--css---style---composition"><a class="header" href="#3-js--css---style---composition"><strong>3. JS / CSS -&gt; Style -&gt; Composition</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg" />
<ul>
<li>레이아웃과 페인트 모두 필요없는 속성을 변경하게 되면 브라우저가 바로 합성 단계로 건너뛴다.</li>
</ul>
<p>각 속성을 변경함에 있어 위 중 어떤 과정을 거치게 되는지에 대해 알고 싶다면 <a href="https://csstriggers.com/">CSS Triggers</a>를 참조하자.</p>
<p>아래부터는 파이프라인의 각 부분에 있어서 발생할 수 있는 일반적인 문제와 그 진단 / 해결방법에 대해 살펴보자.</p>
<h2 id="js-실행-최적화"><a class="header" href="#js-실행-최적화">JS 실행 최적화</a></h2>
<p>실행 타이밍이 안좋거나, 실행 시간이 긴 JS는 렌더링 성능에 영향을 미칠 수 있다.</p>
<h3 id="시각적-업데이트에-settimeout-또는-setinterval을-피하고-대신-항상-requestanimationframe을-사용하라"><a class="header" href="#시각적-업데이트에-settimeout-또는-setinterval을-피하고-대신-항상-requestanimationframe을-사용하라"><strong>시각적 업데이트에 setTimeout 또는 setInterval을 피하고 대신 항상 requestAnimationFrame을 사용하라.</strong></a></h3>
<p><code>setTimeout</code>에 의해 특정 시점에 콜백이 실행되는 경우, 종종 프레임이 누락되어 버벅거리는 현상이 발생할 수 있다. <code>requestAnimationFrame</code>을 이용한 방법은 JS가 프레임 시작 시에 실행되도록 보장한다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/optimize-javascript-execution/settimeout.jpg" />
<pre><code class="language-js">/**
 * If run as a requestAnimationFrame callback, this
 * will be run at the start of the frame.
 */
function updateScreen(time) {
  // Make visual updates here.
}

requestAnimationFrame(updateScreen);
</code></pre>
<h3 id="메인-스레드를-벗어나-오래-실행되는-자바스크립트를-web-workers로-이전하라"><a class="header" href="#메인-스레드를-벗어나-오래-실행되는-자바스크립트를-web-workers로-이전하라"><strong>메인 스레드를 벗어나 오래 실행되는 자바스크립트를 Web Workers로 이전하라.</strong></a></h3>
<p>원하는 작업에 DOM 액세스가 필요하지 않은 경우에는 Web Worker의 사용을 고려해볼 수 있다. 정렬 / 검색 또는 순회(traversal)는 대개 이 모델에 적합하며, 로드 및 모델 생성도 마찬가지다.</p>
<pre><code class="language-js">const dataSortWorker = new Worker('sort-worker.js');
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function (evt) {
  const sortedData = evt.data;
  // Update data on screen...
});
</code></pre>
<h3 id="마이크로-작업을-사용하여-여러-프레임을-통해-dom을-변경하라"><a class="header" href="#마이크로-작업을-사용하여-여러-프레임을-통해-dom을-변경하라"><strong>마이크로 작업을 사용하여 여러 프레임을 통해 DOM을 변경하라.</strong></a></h3>
<p>단, 반대로 말해서 DOM 액세스를 요구하는 작업의 경우 이런 방식이 적합하지 않다. 이와 같이 작업이 메인 스레드에 있어야 한다면, 큰 작업을 몇 개의 마이크로 작업으로 세분화하여, 각각의 프레임에서 <code>requestAnimationFrame</code> 핸들러를 통해 실행하는 방식을 고려해볼 수 있다.</p>
<pre><code class="language-js">const var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
  const taskFinishTime;

  do {
    // Assume the next task is pushed onto a stack.
    const nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
    taskFinishTime = window.performance.now();
  } while (taskFinishTime - taskStartTime &lt; 3);

  if (taskList.length &gt; 0) requestAnimationFrame(processTaskList);
}
</code></pre>
<p>이러한 접근 방식을 활용하는 경우, UX/UI를 통해 특정 작업을 계속 수행하고 있음을 이용자에게 나타내는 것이 중요하다. 또한 앱의 메인 스레드를 계속해서 사용 가능한 상태를 유지하여 사용자의 상호작용에 계속 반응할 수 있도록 해야한다.</p>
<h3 id="chrome-devtools의-timeline-및-자바스크립트-프로파일러를-사용하여-자바스크립트의-영향을-평가한다"><a class="header" href="#chrome-devtools의-timeline-및-자바스크립트-프로파일러를-사용하여-자바스크립트의-영향을-평가한다"><strong>Chrome DevTools의 Timeline 및 자바스크립트 프로파일러를 사용하여 자바스크립트의 영향을 평가한다.</strong></a></h3>
<p>프레임별로 JS 코드의 실행 비용을 평가하는 것 역시 중요한데, 이는 특히 트랜지션이나 스크롤처럼 성능이 중요한 애니메이션 작업 시에 더욱 중요하다.</p>
<p>JS 비용 및 성능 프로필을 측정하기 위한 가장 좋은 방법은 DevTools를 사용하는 것이다. (Timeline, Profiler)</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/optimize-javascript-execution/high-js-detail.jpg" />
<h3 id="js-미세-최적화micro-optimization를-피하라"><a class="header" href="#js-미세-최적화micro-optimization를-피하라"><strong>JS 미세 최적화(Micro Optimization)를 피하라.</strong></a></h3>
<p><code>offsetTop</code>이 <code>getBoundingClientRect()</code> 계산보다 빠른 것처럼, 브라우저는 일부 작업을 다른 작업보다 100배 가까이 빨리 처리할 수 있다. 하지만 실제로 함수 호출 시의 프레임 당 시간은 거의 항상 짧기 때문에, JS의 성능적인 측면에 중점을 두는 것은 일반적으로 시간 낭비에 가깝다. 이러한 노고를 통해 절약되는 시간이 거의 밀리초의 일부에 불과하기 때문이다. 단, 게임이나 컴퓨팅 비용이 비싼 앱의 경우엔 예외인데, 일반적으로 많은 계산이 단일 프레임에 적용되고, 이 경우에는 모든 것이 도움이 되기 때문이다. 거꾸로 말하면, 그렇지 않은 경우(게임 등을 개발하는 것이 아닌 경우)에는 적절하지 않으므로 피해야 한다.</p>
<h2 id="style-계산의-스코프--복잡성-최적화"><a class="header" href="#style-계산의-스코프--복잡성-최적화">Style 계산의 스코프 / 복잡성 최적화</a></h2>
<p>요소의 스타일링 규칙을 정하는 단계에서, 더 간단한 규칙을 지닌 더 작은 트리가 큰 트리나 복잡한 규칙보다 더 효율적으로 처리된다.</p>
<p>다음의 각각은 동일한 요소를 대상으로 하기 위해 지정한 선택자지만, 브라우저가 이를 계산하는데에 드는 시간 비용에는 차이가 생긴다.</p>
<pre><code class="language-css">.box:nth-last-child(-n + 1) .title {
  /* styles */
}
</code></pre>
<pre><code class="language-css">.final-box-title {
  /* styles */
}
</code></pre>
<p>BEM과 같은 CSS 아키텍처 역시 이러한 선택기 매칭의 성능 이점에서 구현된다.</p>
<pre><code>.list { }
.list__list-item { }
.list__list-item--last-child {}
</code></pre>
<h2 id="레이아웃-최적화"><a class="header" href="#레이아웃-최적화">레이아웃 최적화</a></h2>
<p>레이아웃은 브라우저가 요소의 기하학적인 정보를 파악하는 장소이며, 각 요소는 사용한 CSS, 요소의 컨텐츠 또는 상위 요소에 따라 명시적 / 암시적인 크기 지정 정보를 갖게된다. 해당 프로세스를 Chrome, Opera, Safari 및 IE에서는 레이아웃이라고 하며, Firefox에서는 리플로우(Reflow)라고 한다.</p>
<h3 id="레이아웃의-범위는-거의-항상-전체-문서로-지정된다"><a class="header" href="#레이아웃의-범위는-거의-항상-전체-문서로-지정된다"><strong>레이아웃의 범위는 거의 항상 전체 문서로 지정된다.</strong></a></h3>
<p>요소가 많은 경우 모든 요소의 위치와 크기를 파악하는데 오랜 시간이 걸린다. 레이아웃을 피할 수 없는 경우, DevTools의 Timeline을 통해 해당 레이아웃에 시간이 얼마나 걸리는지에 대한 파악이 필요하다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/big-layout.jpg" />
<p>위의 예에서는 레이아웃 내부에서 20ms 이상 소요된 것을 확인할 수 있는데, 애니메이션 화면에서 프레임당 16ms가 필요한 경우 이에 비해 훨씬 높은 값이다. 또한 트리 크기(위에서는 1,618 요소) 및 레이아웃에 필요한 노드 수도 확인할 수 있다.</p>
<h3 id="flexbox는-동일한-수의-요소에-대해-레이아웃-시간을-훨씬-덜-소요한다"><a class="header" href="#flexbox는-동일한-수의-요소에-대해-레이아웃-시간을-훨씬-덜-소요한다"><strong>Flexbox는 동일한 수의 요소에 대해 레이아웃 시간을 훨씬 덜 소요한다.</strong></a></h3>
<p>브라우저에 따라 Flexbox를 지원하지 않는 경우도 있겠지만.. 결국 Flexbox의 사용 여부 이전에 레이아웃 트리거 자체를 완전히 피하려고 노력하는 것이 좋다. 아래는 float를 사용하는 레이아웃과 flex를 사용한 레이아웃 간의 처리시간 차이를 나타내는 결과다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-float.jpg" />
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/layout-flex.jpg" />
<h3 id="강제-동기식-레이아웃을-피하라"><a class="header" href="#강제-동기식-레이아웃을-피하라"><strong>강제 동기식 레이아웃을 피하라</strong></a></h3>
<p>화면에 프레임을 추가하는 순서는 다음과 같다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/avoid-large-complex-layouts-and-layout-thrashing/frame.jpg" />
<p>JS를 실행한 후 -&gt; 스타일 계산을 수행한 후에 -&gt; 레이아웃을 실행한다.</p>
<p>하지만, JS를 사용해 브라우저가 레이아웃을 더 일찍 수행하도록 하는 것도 가능한데, 이를 **강제 동기식 레이아웃(forced synchronous layouts)**이라고 한다.</p>
<p>JS가 실행될 때, <strong>이전</strong> 프레임의 모든 레이아웃 값은 알려져 있고, 이를 쿼리에 사용할 수 있다. 이를테면 프레임 시작 시 요소의 높이를 기록하려면 다음과 같이 작성할 수 있다.</p>
<pre><code class="language-js">// Schedule our function to run at the start of the frame.
requestAnimationFrame(logBoxHeight);

function logBoxHeight() {
  // Gets the height of the box in pixels and logs it out.
  console.log(box.offsetHeight);
}
</code></pre>
<p>헌데, 높이를 요청하기 <strong>전에</strong> 스타일을 먼저 변경한 경우 문제가 발생할 수 있다.</p>
<pre><code class="language-js">function logBoxHeight() {
  box.classList.add('super-big');

  // Gets the height of the box in pixels
  // and logs it out.
  console.log(box.offsetHeight);
}
</code></pre>
<p>이 경우, 정확한 높이를 구하기 위해 브라우저는 먼저 스타일을 변경한 후(<code>super-big</code>이 클래스에 추가되었기 때문에), 레이아웃을 실행해야 한다. 이는 불필요하고, 비용도 많이 드는 작업이다.</p>
<p>때문에, 항상 스타일 읽기를 일괄적으로 처리하여 먼저 수행한 다음, 스타일 쓰기를 작성해야 한다.</p>
<p>결국, 위의 코드를 올바르게 수정하자면 아래와 같아진다.</p>
<pre><code class="language-js">function logBoxHeight() {
  // Gets the height of the box in pixels
  // and logs it out.
  console.log(box.offsetHeight);

  box.classList.add('super-big');
}
</code></pre>
<p>대부분의 경우 스타일을 적용한 다음에 그 값을 쿼리할 필요가 없다. 이전의 프레임 값을 사용하면 충분하기 때문이다. 브라우저가 원하는 시간보다 일찍 스타일 계산과 레이아웃을 동시에 실행하지 않도록 하자.</p>
<h3 id="레이아웃-스래싱을-피하라"><a class="header" href="#레이아웃-스래싱을-피하라"><strong>레이아웃 스래싱을 피하라</strong></a></h3>
<p>많은 레이아웃을 연속적으로 빠르게 실행한다면 강제 동기식 레이아웃이 더 악화된다.</p>
<pre><code class="language-js">function resizeAllParagraphsToMatchBlockWidth() {
  // Puts the browser into a read-write-read-write cycle.
  for (let i = 0; i &lt; paragraphs.length; i++) {
    paragraphs[i].style.width = box.offsetWidth + 'px';
  }
}
</code></pre>
<p>위 코드는 매 루프마다 스타일 값(<code>box.offsetWidth</code>)을 읽은 다음 이 값을 즉시 사용해 너비(<code>paragraphs[i].style.width</code>)를 업데이트한다.</p>
<p>스타일링의 변경을 일으킨 직후에 <code>box.offsetWidth</code>를 요구하였기 때문에, 이 시점에서 강제 동기식 레이아웃이 발생한다.</p>
<p>이 경우, 바로 루프의 바로 다음부터 시작해 매 반복마다 스타일이 변경되었음을 확인하고, 이에 따라 스타일 변경을 적용하고, 레이아웃을 실행하게 된다.</p>
<p>이를 수정하려면, 기존 프레임의 하나의 값을 읽은 다음 계속해서 사용해야 한다.</p>
<pre><code class="language-js">// Read.
const width = box.offsetWidth;

function resizeAllParagraphsToMatchBlockWidth() {
  for (let i = 0; i &lt; paragraphs.length; i++) {
    // Now write.
    paragraphs[i].style.width = width + 'px';
  }
}
</code></pre>
<p>이런 레이아웃 스레싱(Layout thrashing)을 없애기 위해 <a href="https://github.com/wilsonpage/fastdom">fastDOM</a>이라는 라이브러리도 존재한다.</p>
<h2 id="페인트-최적화"><a class="header" href="#페인트-최적화">페인트 최적화</a></h2>
<p>페인트 과정은 최종적으로 사용자의 화면에 픽셀을 채우는 과정이며, 파이프라인의 모든 작업 중 대체로 실행시간이 가장 긴 작업이기 때문에 가급적 피해야 한다.</p>
<h3 id="언제-페인팅이-이루어지는가"><a class="header" href="#언제-페인팅이-이루어지는가"><strong>언제 페인팅이 이루어지는가??</strong></a></h3>
<p>페인트가 트리거되는 경우는 다음의 두가지이다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/frame.jpg"/>
<ol>
<li>레이아웃이 트리거되면, <strong>항상</strong> 페인트 역시 트리거된다.</li>
</ol>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/frame-no-layout.jpg" />
<ol start="2">
<li>레이아웃이 필요없는 비기하학적 속성(배경 / 텍스트 색상, 그림자)을 변경하는 경우에도 페인트가 트리거된다.</li>
</ol>
<h3 id="이동되거나-페이드되는-요소를-승격promote해라"><a class="header" href="#이동되거나-페이드되는-요소를-승격promote해라"><strong>이동되거나 페이드되는 요소를 승격(Promote)해라</strong></a></h3>
<p>페인트가 항상 메모리 상에 단일 이미지로 수행되는 것은 아닌데, 실제로 필요에 따라서 브라우저가 다중 이미지 혹은 컴포지터 레이어로 페인트를 할 수 있다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/layers.jpg" />
<p>이러한 접근방식의 이점은, 정기적으로 페인트하거나 변형에 의해 화면에서 움직이는 요소를 다른 요소에 영향을 주지 않으면서 처리할 수 있다는 것이다.</p>
<p>이는 Photoshop과 같은 툴에서 볼 수 있는 레이어의 개념과 유사한데, 최상위에서 개별 레이어를 처리 / 합성하여 최종적인 이미지를 생성할 수 있다.</p>
<p>새로운 레이어를 생성하는 가장 좋은 방법은 <code>will-change</code> CSS 속성을 사용하는 것이다. 이는 Chrome, Opera 및 Firefox에서 작동하며, <code>transform</code> 값으로 새 컴포지터 레이어를 생성한다.</p>
<pre><code class="language-css">.moving-element {
  will-change: transform;
}
</code></pre>
<p>Safari처럼 <code>will-change</code>를 지원하지는 않으나, 레이어 생성은 활용하는 브라우저의 경우 3D 변형을 사용해 새 레이어를 강제적으로 적용해야 한다.</p>
<pre><code class="language-css">.moving-element {
  transform: translateZ(0);
}
</code></pre>
<p>단, 각 레이어는 메모리와 관리가 요구되기 때문에 너무 많은 레이어를 생성하는 것은 오히려 독이 될 수 있다. 또한 요소를 새 레이어로 승격시키는 경우, 이렇게 하는 것이 성능 상으로 이점이 있는지부터 먼저 확인해야 한다.</p>
<h3 id="페인트-영역을-줄여라"><a class="header" href="#페인트-영역을-줄여라"><strong>페인트 영역을 줄여라</strong></a></h3>
<p>앞선 설명처럼 요소를 승격시켰음에도 불구하고 페인팅 작업이 여전히 요구되는 경우가 있다. 페인트의 커다란 문제점은 브라우저가 페인팅이 필요한 두 영역을 합치고 나면, 전체 스크린에 대해 다시 페인팅 작업을 수행할 수도 있다는 점이다. 예를 들어, 페이지 상단에 고정된(fixed) 헤더를 갖고 있더라도, 스크린 아래쪽에서 페인팅이 이루어진다면 그냥 스크린 전체가 리페인팅될 수 있다.</p>
<blockquote>
<p><strong>참고</strong>: 높은 DPI를 가진 디바이스의 경우 <code>fixed</code> position을 가진 요소는 자동으로 컴포지터 레이어(Compositor layer)로 승격된다. 반면, 낮은 DPI를 가진 경우는 해당하지 않는데, 이 경우 승격은 텍스트 렌더링을 서브픽셀(subfixel)에서 그레이스케일로 변경하고, 레이어 승격은 수동적으로 이루어져야 하기 때문이다.</p>
</blockquote>
<p><strong>페인트 영역을 줄이는 것</strong>은 일반적으로 다음과 같은 방법을 통해 이루어질 수 있다.</p>
<ol>
<li>애니메이션과 트랜지션이 가능한 겹치지 않도록 조율하는 것</li>
<li>한 페이지의 특정 부분에 애니메이션을 적용하는 것을 피하는 것</li>
</ol>
<h3 id="페인트-복잡성-단순화"><a class="header" href="#페인트-복잡성-단순화"><strong>페인트 복잡성 단순화</strong></a></h3>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/simplify-paint-complexity-and-reduce-paint-areas/profiler-chart.jpg"/>
<p>페인트는 작업에 따라 그 비용에 차이가 있다. 다만, 이 기준이 CSS 관점에서 항상 명확한 것은 아니다.
페인트 프로파일러를 사용하면 현재 페인트 작업에 어느 정도의 비용이 드는지를 확인할 수 있고, 이를 대체하기 위한 스타일링에 대해 생각해볼 수 있다.</p>
<p>프레임 당 <strong>10ms</strong>는 일반적으로, 특히 모바일 디바이스에서는 페인팅 작업을 수행할 만큼 긴 시간이 아니다.
때문에 애니메이션 도중에는 항상 페인팅 작업을 피하기를 원할 수 있다.</p>
<h2 id="합성-composition-최적화"><a class="header" href="#합성-composition-최적화">합성 (Composition) 최적화</a></h2>
<p>합성은 화면에 표시하기 위해 페이지에서 페인트된 부분들을 합치는 과정이다.
이 영역에서 페이지 성능에 영향을 주는 두 가지 핵심 요소가 있다.</p>
<ol>
<li>관리가 필요한 컴포지터 레이어 수</li>
<li>애니메이션에 사용하는 속성</li>
</ol>
<h3 id="애니메이션에-변형transform-또는-불투명도opacity-변경을-사용하라"><a class="header" href="#애니메이션에-변형transform-또는-불투명도opacity-변경을-사용하라"><strong>애니메이션에 변형(<code>transform</code>) 또는 불투명도(<code>opacity</code>) 변경을 사용하라</strong></a></h3>
<p>앞서 레이아웃과 페인트를 모두 피하고 <strong>합성</strong>에 대한 변경만 요구하는 픽셀 파이프라인이 최고의 성능을 제공한다고 살펴봤었다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/stick-to-compositor-only-properties-and-manage-layer-count/frame-no-layout-paint.jpg"/>
<p>이를 위해서는 컴포지터가 혼자서 처리할 수 있는 변경 속성을 사용해야 하는데, 현재로서 <strong>이에 해당하는 것은 <code>transform</code>과 <code>opacity</code> 두 가지 속성 뿐이다.</strong></p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/stick-to-compositor-only-properties-and-manage-layer-count/safe-properties.jpg" />
<p>해당 속성들을 사용할 시에 주의할 점은 이러한 속성을 변경하는 요소가 자체적인 컴포지터 레이어에 있어야 하는데, <strong>즉, 레이어를 만들기 위해 요소를 승격해야 한다.</strong></p>
<blockquote>
<p><strong>참고</strong> : 애니메이션을 이 속성들로만 제한할 수 없을 것 같다고 생각되면 <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP 원칙</a>을 참조하라. 이는 비용이 많이 드는 속성을 <code>transform</code>과 <code>opacity</code>를 이용한 방법으로 다시 작성하도록 도와준다.</p>
</blockquote>
<h3 id="애니메이션-적용-요소를-승격해라"><a class="header" href="#애니메이션-적용-요소를-승격해라"><strong>애니메이션 적용 요소를 승격해라</strong></a></h3>
<p>위의 페인트 최적화 섹션에서 언급한 것처럼, 애니메이션 적용 요소에 대해 자체 레이어로 승격해야 한다.</p>
<pre><code class="language-css">.moving-element {
  will-change: transform;
}
</code></pre>
<p>또는 이전 브라우저나 <code>will-change</code>를 지원하지 않는 브라우저에 대해서는 다음을 사용한다.</p>
<pre><code class="language-css">.moving-element {
  transform: translateZ(0);
}
</code></pre>
<h3 id="레이어-관리-및-레이어-급증-피하기--요소를-불필요하게-레이어-승격하지-마라"><a class="header" href="#레이어-관리-및-레이어-급증-피하기--요소를-불필요하게-레이어-승격하지-마라"><strong>레이어 관리 및 레이어 급증 피하기 : 요소를 불필요하게 레이어 승격하지 마라</strong></a></h3>
<p>레이어 승격이 성능 개선에 도움이 된다고 해서 페이지 모든 요소를 승격시켜버리는 것이 자칫 이상적으로 들릴지 모른다.</p>
<pre><code class="language-css">* {
  will-change: transform;
  transform: translateZ(0);
}
</code></pre>
<p>이 경우의 문제는, 생성하는 모든 레이어가 메모리 및 관리가 요구되며, 이는 공짜로 생겨나는 것이 아니라는 점이다. 결국, 무작정 레이어를 생성하는 경우 오히려 안하느니만 못하다.</p>
<h2 id="입력-핸들러-디바운싱"><a class="header" href="#입력-핸들러-디바운싱">입력 핸들러 디바운싱</a></h2>
<p>입력 핸들러는 프레임 완성을 차단시킬 수 있기 때문에 불필요한 추가 레이아웃 작업을 유발할 수 있다.</p>
<h3 id="오래-걸리는-입력-핸들러를-피하라"><a class="header" href="#오래-걸리는-입력-핸들러를-피하라"><strong>오래 걸리는 입력 핸들러를 피하라</strong></a></h3>
<p>가장 빠른 경우의 예시를 먼저 들자면, 이용자가 페이지와 상호작용할 때, 페이지의 컴포지터 쓰레드가 이용자의 터치 입력을 감지하고, 컨텐츠를 단순히 이동시킨다.
이 경우, 메인 쓰레드에서 요구되는 동작(JS, 레이아웃, 스타일, 페인트)이 없다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/compositor-scroll.jpg" />
<p>그런데, 만약 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code>와 같은 입력 핸들러를 추가한다면, 컴포지터 쓰레드는 해당 핸들러의 처리과정이 끝날때까지 기다려야 한다.
왜냐하면 <code>preventDefault()</code>가 호출될지도 모르기 때문인데, 만약 호출되었다면 컴포지터 쓰레드는 기본 스크롤 동작을 멈춰야만 한다.</p>
<p>심지어 <code>preventDefault()</code>를 호출하지 않았더라도, 컴포지터는 기다려야만 한다. 이처럼 컴포지터가 기다리는 동안에 이용자의 스크롤 동작을 막게 되며, 이에 따라 버벅거리거나 프레임이 손실되는 결과가 나타난다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/ontouchmove.jpg" />
<p>쉽게 말해, <strong>입력 핸들러는 빠르게 처리되어야 한다.</strong> 그래야 컴포지터가 원래 해야하는 일을 할 수 있으니까.</p>
<h3 id="입력-핸들러-내에서의-스타일-변경을-피하라"><a class="header" href="#입력-핸들러-내에서의-스타일-변경을-피하라"><strong>입력 핸들러 내에서의 스타일 변경을 피하라</strong></a></h3>
<p>스크롤과 터치 같은 입력 핸들러들은 <code>requestAnimationFrame</code> 콜백 이전에 실행되도록 되어있다.
만약 이러한 핸들러 내부에서 스타일 변경을 시도한다면, <code>requestAnimationFrame</code>이 시작될 때 스타일 변경이 보류된다.</p>
<p>만약 <code>requestAnimationFrame</code> 콜백이 시작할 때 스타일 정보들을 읽어오고자 한다면, 위쪽에서 언급했던 **강제 동기 레이아웃(Forced synchronous layout)**이 발생한다.</p>
<img src="https://developers.google.com/web/fundamentals/performance/rendering/images/debounce-your-input-handlers/frame-with-input.jpg" />
<h3 id="스크롤-핸들러-디바운스"><a class="header" href="#스크롤-핸들러-디바운스"><strong>스크롤 핸들러 디바운스</strong></a></h3>
<p>위의 두가지 문제(입력 핸들러 간소화 + 핸들러 내 스타일 변경 회피)를 해결하는 방법은 동일한데, 시각적 변경에 대해 항상 다음 <code>requestAnimationFrame</code> 콜백으로 디바운스 하는 것이다.</p>
<pre><code class="language-js">function onScroll(evt) {
  // Store the scroll value for laterz.
  lastScrollY = window.scrollY;

  // Prevent multiple rAF callbacks.
  if (scheduledAnimationFrame) return;

  scheduledAnimationFrame = true;
  requestAnimationFrame(readAndUpdatePage);
}

window.addEventListener('scroll', onScroll);
</code></pre>
<p>이 경우, 컴퓨팅 비용이 많이 드는 코드에서도 스크롤이나 터치를 차단하지 않으므로 입력 핸들러를 가볍게 유지할 수 있다는 이점이 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="custom-element-checklist"><a class="header" href="#custom-element-checklist">Custom Element CheckList</a></h1>
<blockquote>
<p>출처 : <a href="https://developers.google.com/web/fundamentals/web-components/best-practices?authuser=0">Google Developers</a></p>
</blockquote>
<p>커스텀 요소들은 HTML을 확장하여 본인 스스로의 태그를 갖게 해준다. 해당 기능은 어마어마하지만, 저수준의 기능이기도 해서, 어떻게 활용하는 것이 제일 좋은지 불명확한 경우가 많다.</p>
<p>커스텀 요소를 최적으로 활용하기 위해 해당 체크리스트를 확인하자. 제대로 동작하는 커스텀 요소들을 구성하는 내용들을 나눈 것이다.</p>
<h2 id="체크리스트"><a class="header" href="#체크리스트">체크리스트</a></h2>
<h3 id="shadow-dom-1"><a class="header" href="#shadow-dom-1"><strong>Shadow DOM</strong></a></h3>
<ul>
<li>
<p>스타일을 캡슐화하기 위해 섀도우 루트를 생성하라</p>
<blockquote>
<p>섀도우 루트에 스타일링을 캡슐화 시키는 것은 어디에서 해당 요소가 사용되든 해당 스타일링이 적용될 것을 보장한다.</p>
</blockquote>
</li>
<li>
<p>섀도우 루트는 <code>constructor</code> 내에서 생성하라</p>
<blockquote>
<p><code>constuctor</code>는 요소 본인에 관한 지식들을 보관하는 곳이다. 따라서 여기에는 다른 요소들을 활용하지 않는 구현 디테일들을 설정하기 적절하다. <br/> 만약, <code>connectedCallback</code>에서 이런 내용들을 수행하면, 요소가 분리/연결되는 경우의 상황을 고려해야 한다.</p>
</blockquote>
</li>
<li>
<p>커스텀 요소가 생성하는 하위 요소들은 섀도우 루트 안에 넣어라</p>
<blockquote>
<p>커스텀 요소에 의해 생성된 자식들은 <code>private</code>해야한다. 만약 섀도우 루트의 보호가 없다면, 해당 자식 요소들은 외부 JS에 의해 간섭받을 수 있다.</p>
</blockquote>
</li>
<li>
<p>light DOM에서의 자식들을 반영하기 위해 <code>&lt;slot&gt;</code>을 사용해라</p>
<blockquote>
<p><code>&lt;slot&gt;</code>을 활용하면 커스텀 요소가 담고 있는 요소들을 이용자들이 지정하기 편하게 만들 수 있다.</p>
</blockquote>
</li>
<li>
<p>기본적으로 <code>inline</code>으로 설정된 스타일링을 원하는 게 아니라면, <code>:host</code>의 <code>display</code> 스타일을 변경하라.</p>
</li>
</ul>
<blockquote>
<p>기본적으로 커스텀요소는 <code>display: inline</code> 설정을 갖는다. 따라서 단순히 <code>width</code>나 <code>height</code>를 설정하는 것은 아무 영향도 없다. 만약, 애초에 <code>inline</code> 디스플레이 설정을 의도하는 게 아니라면, 적절히 변경하라.</p>
</blockquote>
<ul>
<li><code>hidden</code> 속성에 대응하기 위한 <code>:host</code> 디스플레이 스타일을 추가하라
<blockquote>
<p>섀도우 루트에서 <code>:host</code>로 스타일링을 하게되면 이는 HTML 자체적인 <code>hidden</code> 속성을 덮어씌우게 된다. 때문에, <code>:host([hidden]) { display: none }</code>와 같은 식으로, <code>hidden</code>속성을 갖고 있는 경우에 대해 적절한 스타일링 처리가 필요하다.</p>
</blockquote>
</li>
</ul>
<h3 id="속성attributes와-프로퍼티"><a class="header" href="#속성attributes와-프로퍼티"><strong>속성(Attributes)와 프로퍼티</strong></a></h3>
<ul>
<li>글로벌 속성(global attributes)들을 덮어쓰지(override) 말아라
<blockquote>
<p>글로벌 속성들은 모든 HTML 요소들에 존재하는 것이다. 예를 들면 <code>tabindex</code>와 <code>role</code>이 이에 해당한다. 커스텀 요소가 기본적으로 <code>tabindex</code>를 0으로 초기화하게끔 설정하고 싶을 수도 있다. 그러나 항상 해당 커스텀 요소를 사용하는 개발자가 이를 다른 값으로 설정할 수 있음을 유의해라. 때문에 아래와 같은 체크가 필요하다.</p>
</blockquote>
</li>
</ul>
<pre><code class="language-js">connectedCallback() {
  if (!this.hasAttribute('role'))
    this.setAttribute('role', 'checkbox');
  if (!this.hasAttribute('tabindex'))
    this.setAttribute('tabindex', 0);
</code></pre>
<ul>
<li>
<p>항상 원시(primitive) 데이터들을 속성 혹은 프로퍼티 모두로 가져올 수 있게 하라.</p>
<blockquote>
<p>커스텀 요소들은 수정가능해야 한다. 그리고 이러한 수정은 속성 혹은 프로퍼티 어느쪽으로든 적절히 이루어질 수 있어야 한다. 결국, 이상적으로 모든 원시 속성들은 프로퍼티와 연결되어 있어야 한다.</p>
</blockquote>
</li>
<li>
<p>원시 데이터 속성과 프로퍼티들을 항상 동기화(sync)시키도록 해라. 프로퍼티는 속성에 반영되어야하고, 반대도 마찬가지다.</p>
<blockquote>
<p>요소를 활용하는 사람들이 어떤 식으로 해당 요소와 상호작용 할지는 알 수 없다. 때문에 속성과 프로퍼티가 서로를 항상 반영하도록 해야한다. 물론 예외도 존재한다. 비디오 플레이어의 <code>currentTime</code>과 같은 너무 변경 빈도가 잦은 프로퍼티는 매번 속성에 반영하는 것이 부적절하다.</p>
</blockquote>
</li>
<li>
<p>Object, Array와 같은 리치 데이터(rich data)들은 프로퍼티로만 받아와라</p>
<blockquote>
<p>사실,애초에 내장 HTML 요소에서 속성을 통해 이러한 류의 데이터를 받아들이는 예시 자체가 없다. 대신에 이런 데이터들은 메서드 호출이나 프로퍼티를 통해서 전달된다. 만약, 굳이 이들을 속성으로 전달하고자 하는 경우, 명확한 단점들이 몇가지 있다. 1) 거대한 객체를 문자열로 직렬화(Serialize)하는데에 너무 많은 비용이 들고, 2) 또한 이 문자열화(Stringify) 과정에서 객체에 대한 참조가 사라질 수도 있다.</p>
</blockquote>
</li>
<li>
<p>요소를 업그레이드하기 이전에, 이미 설정되었을지도 모르는 프로퍼티를 체크해봐라</p>
<blockquote>
<p>커스텀 요소를 활용하는 개발자들이 해당 요소를 불러오기 이전에 먼저 프로퍼티를 설정할지도 모른다. 이런 상황은 종종 로딩 컴포넌트를 핸들링하거나, 해당 컴포넌트를 페이지에 찍어내거나, 해당 프로퍼티를 모델에 바인딩하는 프레임워크를 사용하거나 할 때 종종 발생한다.</p>
</blockquote>
</li>
<li>
<p>클래스를 자동으로 적용시키지 마라</p>
<blockquote>
<p>요소들은 본인의 상태를 속성을 통해서 나타내야 한다. <code>class</code> 속성을 해당 요소를 사용하는 개발자들에 의한 것으로 간주되어야 하며, 이를 임의로 자동으로 설정하는 경우 개발자들의 <code>class</code> 관리를 망쳐버릴 수 있다.</p>
</blockquote>
</li>
</ul>
<h3 id="events"><a class="header" href="#events"><strong>Events</strong></a></h3>
<ul>
<li>내부 컴포넌트 활동에 따라 적절히 이벤트를 디스패치하라
<blockquote>
<p>오직 컴포넌트 본인만 알 수 있는 활동이 있을 수 있다. 이를테면 타이머나 애니메이션 완료, 혹은 로딩이 완료되는 시점과 같은 것들이다. 이러한 변화에 따라, 호스트에게 해당 컴포넌트의 상태가 변경되었음을 알려주게끔 이벤트를 전달하는 것이 좋다.</p>
</blockquote>
</li>
<li>프로퍼티 설정에 대해서는 별도로 이벤트를 디스패치할 필요없다.
<blockquote>
<p>호스트가 프로퍼티를 설정한 내용에 대해 이벤트를 전달하는 것은 불필요하다. 호스트가 직접 설정한 내용이기 때문에 현재 상태를 직접 인지할 수 있기 때문이다. 또한, 호스트가 프로퍼티를 설정한 것에 대한 반응으로 이벤트를 전달하는 경우, 데이터 바인딩과 함께 무한 루프를 유발할 수 있다.</p>
</blockquote>
</li>
</ul>
<h2 id="explainers"><a class="header" href="#explainers"><strong>Explainers</strong></a></h2>
<h3 id="프로퍼티를-lazy하게-만들어라"><a class="header" href="#프로퍼티를-lazy하게-만들어라">프로퍼티를 Lazy하게 만들어라</a></h3>
<p>개발자가 커스텀 요소를 불러오기 전에 먼저 프로퍼티를 설정하고자 할 수도 있다. 이는 로딩 컴포넌트를 다루는 프레임워크 등에서 특히 이루어진다.</p>
<p>아래 예시에서는, Angular가 <code>isChecked</code> 프로퍼티를 체크박스의 <code>checked</code> 프로퍼티에 바인딩하려고 한다. 만약 해당 커스텀 요소가 <strong>lazy-load</strong>된다면 Angular는 요소가 업그레이드되기 이전에 먼저 <code>checked</code>프로퍼티를 설정할 수 있을 것이다.</p>
<pre><code class="language-html">&lt;howto-checkbox [checked]=&quot;defaults.isChecked&quot;&gt;&lt;/howto-checkbox&gt;
</code></pre>
<p>커스텀 요소는 본인의 인스턴스에 어떤 요소가 이미 설정되어 있는지에 대해 확인함으로써 이러한 경우를 다룰 수 있다. 아래에서 <code>_upgradeProperty()</code> 메서드가 그러한 역할을 한다.</p>
<pre><code class="language-js">connectedCallback() {
  ...
  this._upgradeProperty('checked');
}

_upgradeProperty(prop) {
  if (this.hasOwnProperty(prop)) {
    let value = this[prop];
    delete this[prop];
    this[prop] = value;
  }
}
</code></pre>
<p><code>_upgradeProperty()</code>는 업그레이드되지 않은 인스턴스로부터 값을 가져온 후, 프로퍼티를 삭제하여 커스텀 요소가 자체적인 프로퍼티 <code>setter</code>를 사용하지 않도록 만든다. 이를 통해, 커스텀 요소가 최종적으로 로드되었을 때, 곧바로 수정된 상태를 반영할 수 있도록 만든다.</p>
<h3 id="재방문-이슈reentrancy-issues를-피해라"><a class="header" href="#재방문-이슈reentrancy-issues를-피해라">재방문 이슈(reentrancy issues)를 피해라</a></h3>
<p><code>attributeChangeCallback()</code>을 사용하여 상태를 기본 프로퍼티에 반영되도록 하자.</p>
<pre><code class="language-js">// When the [checked] attribute changes, set the checked property to match.
attributeChangedCallback(name, oldValue, newValue) {
  if (name === 'checked')
    this.checked = newValue;
}
</code></pre>
<p>헌데, 프로퍼티 설정자가 속성에도 반영되는 경우 무한 루프를 만들어내는 문제가 발생한다.</p>
<pre><code class="language-js">set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    // OOPS! This will cause an infinite loop because it triggers the
    // attributeChangedCallback() which then sets this property again.
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}
</code></pre>
<p>이에 대한 대안으로, 프로퍼티에 대한 setter와 getter를 모두 만들어 getter가 속성에 따라 값을 결정하도록 할 수 있다.</p>
<pre><code class="language-js">set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}

get checked() {
  return this.hasAttribute('checked');
}
</code></pre>
<p>이제, 속성을 삭제하거나 추가하는 작업은 프로퍼티에도 영향을 미칠 것이다.</p>
<p>끝으로, <code>attributeChangedCallback()</code>는 ARIA 상태를 적용하는 것과 같은 사이드 이펙트를 처리하는 데에 사용해라.</p>
<pre><code class="language-JS">attributeChangedCallback(name, oldValue, newValue) {
  const hasValue = newValue !== null;
  switch (name) {
    case 'checked':
      // Note the attributeChangedCallback is only handling the *side effects*
      // of setting the attribute.
      this.setAttribute('aria-checked', hasValue);
      break;
    ...
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>해당 문서에서는 <strong>이펙티브 타입스크립트</strong>를 읽고 스스로 정리해보도록 합니다. 제 개인적인 학습과 스터디를 목적으로 하고 있으며, 당연히 책의 모든 내용을 다루고 있지는 않습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트-알아보기"><a class="header" href="#타입스크립트-알아보기">타입스크립트 알아보기</a></h1>
<p>해당 챕터에서는 타입스크립트의 큰 그림을 이해하는데 도움이 될 내용을 다룹니다.</p>
<ul>
<li>타입스크립트는 무엇인지?</li>
<li>타입스크립트를 어떻게 여겨야 하는지?</li>
<li>자바스크립트와는 무슨 관계인지?</li>
<li>등등...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ts와-js의-관계"><a class="header" href="#ts와-js의-관계">TS와 JS의 관계</a></h1>
<p>많은 문서와, 웹 상의 여러 글들에서 타입스크립트는 다음과 같은 말로 정의됩니다.</p>
<blockquote>
<p>타입스크립트는 자바스크립트의 슈퍼셋(Superset = 상위집합)이다.</p>
</blockquote>
<p>이는 정확히 무엇을 의미할까요?</p>
<h2 id="실제로-ts는-문법적으로-js의-상위집합입니다"><a class="header" href="#실제로-ts는-문법적으로-js의-상위집합입니다">실제로 TS는 문법적으로 JS의 상위집합입니다.</a></h2>
<p>기존에 JS였던 파일의 확장자를 TS로 바꾼다고 해서 동작이 불가능하다거나 하지 않습니다. 하지만, 거꾸로 TS였던 파일들에 대해서는 JS로 확장자를 바꿀 때 모든 경우에 동작한다고 보장할 수 없습니다.</p>
<h2 id="타입스크립트는-정적-타입-시스템입니다"><a class="header" href="#타입스크립트는-정적-타입-시스템입니다">타입스크립트는 <strong>정적</strong> 타입 시스템입니다.</a></h2>
<p>기존 JS의 타입 체계는 동적입니다. 이러한 JS의 특징이 갖는 문제점은 바로 런타임 에러를 잡아내는 것이 쉽지않다는 것이죠. 타입 시스템의 목표 중 하나는 이러한 런타임 에러를 사전에 찾아내는 것입니다.
타입 스크립트가 정적 타입 시스템이라는 것은 바로 이 특징을 말하는 것인데, 그렇다고 해서 타입 체커가 모든 오류를 발견해낼 것이라고 보장할 수는 없죠.</p>
<p>기본적으로 타입스크립트에는 **타입 추론 (Type Inference)**이라는 것이 있어, 별도로 타입을 지정해주지 않더라도, 특정 변수의 타입이 명확한 경우에는 스스로 해당 타입을 정의해나갑니다.
이 덕분에 별도의 타입 구문 없이도 쓸만하지만, 직접 타입 구문을 추가해나간다면 훨씬 더 많은 오류를 사전에 잡아내고, 또 코드의 &quot;의도&quot;에 대해 타입스크립트에게 더 잘 전달해줄 수 있습니다.</p>
<h2 id="얼마나-엄격하게-작성할-것인가는-온전히-개발자의-몫입니다"><a class="header" href="#얼마나-엄격하게-작성할-것인가는-온전히-개발자의-몫입니다">'얼마나 엄격하게 작성할 것인가?'는 온전히 개발자의 몫입니다.</a></h2>
<p>확장자가 <code>.ts</code>인 파일을 작성하더라도, 편의를 위해 <code>any</code> 타입을 반복적으로 사용하고, 그저 JS를 쓰듯이 문법을 작성해나간다면, 굳이 TS를 쓸 이유가 없습니다.
거꾸로 완전 엄격한 형태로 TS를 작성하고자 하는 것도 쉬운 일이 아니죠. 그만큼 작성해야 할 타입 구문의 양이 많아지게 됩니다.
결국 얼마나 엄격한 형태로 개발을 해나갈 것이냐에 대한 문제는 온전히 취향의 차이이며, 우열을 가릴 수도 없는 문제라고 할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ts-설정-이해하기"><a class="header" href="#ts-설정-이해하기">TS 설정 이해하기</a></h1>
<p>아래의 코드는 오류 없이 타입 체커를 통과할 수 있을까요?</p>
<pre><code class="language-ts">function add(a, b) {
  return a + b;
}

add(10, null);
</code></pre>
<p>사실, 이건 설정이 어떻게 되어있으냐에 따라서 정답이 달라지는 문제입니다. TS 컴파일러는 무수한 설정을 갖고있습니다. 이는 CLI를 통해서, 또는 <code>tsconfig.json</code> 파일을 통해서 이루어질 수 있죠.</p>
<p>최초의 설정파일은 아래 CLI 명령으로 간단하게 생성할 수 있습니다.</p>
<pre><code>tsc --init
</code></pre>
<p>여기서는 100개가 넘는 TS 컴파일러의 설정들을 모두 짚고 넘어가지는 않을 겁니다. 대부분은 어디서 소스파일을 찾을지, 어떤 종류의 출력을 생성할지에 대해 제어하는 내용입니다.</p>
<p>반면, 언어 자체의 핵심 요소들을 제어하는 설정도 있는데, 대부분의 언어에서는 이를 허용하지 않는 고수준 설계의 설정입니다. 이를 어떻게 설정하느냐에 따라 완전히 다른 언어처럼 느낄 수도 있죠.</p>
<p>설정을 제대로 이해하려면 <code>noImplicitAny</code>와 <code>strictNullChecks</code> 설정에 대해 이해해야 합니다.</p>
<h2 id="noimplicitany"><a class="header" href="#noimplicitany">noImplicitAny</a></h2>
<p><code>noImplicitAny</code>는 변수들이 미리 정의된 타입을 가져야 하는지에 대한 여부를 제어합니다. 즉, 이를 설정할 경우 모든 변수들에 대해 직접 지정해주지 않는 한, <code>any</code> 타입을 허용하지 않습니다.
가급적 해당 설정은 기본적으로 가져가는 것이 좋습니다. 타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문이죠. 한 가지 예외라면, 기존에 JS로 작성되어 있던 프로젝트를 TS로 마이그레이션 해나가는 과정에서는 필요할 수도 있죠.
이 부분에 대해서는 추후에 다시 다뤄보도록 하겠습니다.</p>
<h2 id="strictnullchecks"><a class="header" href="#strictnullchecks">strictNullChecks</a></h2>
<p><code>strictNullChecks</code>는 <code>null</code>과 <code>undefined</code>가 모든 타입에서 허용되는지 확인하는 설정입니다. 이 경우, <code>string | null</code>과 같이 명시적으로 해당 변수가 <code>null</code> 타입이 될 수 있음을 알려주지 않으면, 에러가 발생합니다.</p>
<p>이러한 경우, 다음과 같은 Null Checking이나 Assertion이 필요하게 됩니다.</p>
<pre><code class="language-ts">// Null Check
if (el) {
  el.textContent = 'Ready';
}

// Type Assertion
el!.textContent = 'Ready';
</code></pre>
<p>해당 설정은 <code>null</code>과 <code>undefined</code>에 관련된 오류를 잡아 내는 데에 많은 도움을 주지만, 코드 작성이 비교적 어려워집니다. 프로젝트를 처음 생성한다면 이를 설정하는 것이 좋지만, JS 코드를 마이그레이션 해나가는 과정이라면 설정하지 않아도 괜찮습니다.
<code>strictNullCheck</code>를 설정하려면 <code>noImplicitAny</code>를 먼저 설정해야 합니다.</p>
<p>해당 설정이 필요한 이유는, 이것이 없을 경우 &quot;<strong><code>undefined</code>가 객체가 아닙니다</strong>&quot;라는 끔찍한 런타임 오류를 매번 마주할 수 있기 때문입니다. 프로젝트가 커질 수록 이러한 부분들이 훨씬 까다로워지기 때문에, 가능한 초기에 설정하는 것이 좋습니다.</p>
<p>그 밖에 언어에 의미적으로 영향을 미치는 설정(<code>noImplicitThis</code>, <code>strictFunctionTypes</code>)이 많지만, 앞의 두 설정만큼이나 중요한 것은 없습니다. 이 모든 타입 체크들을 설정하여 엄격한 환경 내에서 개발을 하고싶다면, <code>strict</code>를 설정하면 됩니다. 이 경우 대부분의 에러를 잡아냅니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="코드-생성과-타입이-관계없음을-이해하기"><a class="header" href="#코드-생성과-타입이-관계없음을-이해하기">코드 생성과 타입이 관계없음을 이해하기</a></h1>
<p>큰 그림에서, 타입스크립트 컴파일러는 다음의 두 가지 역할을 수행합니다.</p>
<ul>
<li>최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 트랜스파일합니다.</li>
<li>코드의 타입 에러를 체크합니다.</li>
</ul>
<p>여기서 놀라운 점은, 위의 두가지는 완벽히 별개의 일이라는 겁니다. 즉 어느 한쪽이 제대로 이루어지지 않더라도 다른 한쪽이 이루어지는데는 문제가 없습니다.</p>
<h2 id="타입-에러가-있어도-컴파일이-가능합니다"><a class="header" href="#타입-에러가-있어도-컴파일이-가능합니다">타입 에러가 있어도 컴파일이 가능합니다</a></h2>
<p>타입 체크와 컴파일이 동시에 이루어지는 자바나 C 같은 언어에서는 이것이 굉장히 황당할 겁니다. TS에서의 타입 에러는 C나 자바에서의 경고(WARNING)에 가깝습니다.
즉, 문제가 될 부분을 알려주지만, 그렇다고 해서 빌드하는 것을 멈추지는 않습니다.</p>
<p>이런 부분 떄문에, 얼핏 TS가 엉성한 언어처럼 보일 수 있지만, 오히려 이런 특징은 도움이 됩니다. TS는 타입 에러가 발생하더라도 여전히 컴파일링을 진행할 수 있기 때문에, 해당 부분 외의 애플리케이션은 여전히 테스트할 수 있는 상태가 됩니다.
만약, 에러가 발생했을 때 컴파일을 진행하지 않고자 한다면, <code>noEmitOnError</code>를 설정해주면 됩니다.</p>
<h2 id="런타임에는-타입-체크가-불가능합니다"><a class="header" href="#런타임에는-타입-체크가-불가능합니다">런타임에는 타입 체크가 불가능합니다</a></h2>
<p>자바스크립트로 컴파일되는 과정을 거치게 되면, 그 과정에서 모든 인터페이스, 타입, 그 외의 타입 구문들은 모두 제거됩니다.</p>
<p>만약 런타임 시에도 타입 정보를 유지하고자 한다면 몇 가지 방법이 있습니다.</p>
<h3 id="1-태그-기법"><a class="header" href="#1-태그-기법">1. &quot;태그&quot; 기법</a></h3>
<pre><code class="language-ts">interface Square {
  kind: 'square';
  width: number;
}

interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}

type Shape = Square | Rectangle;
</code></pre>
<p>위와 같이 인터페이스에 <code>kind</code> 값을 지정해서 런타임에서도 타입 정보를 손쉽게 유지할 수 있습니다. 런타임 시에 객체의 <code>kind</code>가 어떤 값인지를 체크하는 방식으로 이를 활용할 수 있죠. 이는 타입스크립트에서 실제로 흔하게 볼 수 있는 기법입니다.</p>
<h3 id="2-클래스"><a class="header" href="#2-클래스">2. 클래스</a></h3>
<pre><code class="language-ts">class Square {
  constructor(public width: number) {}
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle
</code></pre>
<p>클래스를 사용한다면 타입(런타임 접근 불가)와 값(런타임 접근 가능)을 동시에 사용할 수 있습니다. 위와 같이 선언된 클래스는 타입과 값 모두로 사용할 수 있게되므로 <code>shape instanceof Rectangle</code> 과 같은 형태로 런타임 타입 체크를 할 수 있습니다.</p>
<h2 id="타입-연산은-런타임에-영향을-주지-않습니다"><a class="header" href="#타입-연산은-런타임에-영향을-주지-않습니다">타입 연산은 런타임에 영향을 주지 않습니다</a></h2>
<p><code>value as number</code>와 같은 타입 연산은 실제로 컴파일된 이후의 런타임에는 아무런 역할도 하지 않습니다. 단순히 타입 체커에게 해당 <code>value</code>를 어떤 타입으로 고려하라고 알려줄 뿐입니다.</p>
<h2 id="런타임-타입은-선언된-타입과-다를-수-있습니다"><a class="header" href="#런타임-타입은-선언된-타입과-다를-수-있습니다">런타임 타입은 선언된 타입과 다를 수 있습니다</a></h2>
<p>타입스크립트에서는 런타임 타입과 선언된 타입이 매치되지 않는 상황이 생길 수도 있습니다. 이러한 상황은 가능한 피하는게 좋지만요.</p>
<h2 id="타입스크립트-타입으로는-함수를-오버로드할-수-없습니다"><a class="header" href="#타입스크립트-타입으로는-함수를-오버로드할-수-없습니다">타입스크립트 타입으로는 함수를 오버로드할 수 없습니다</a></h2>
<p>타입스크립트에도 함수 오버로딩 기능이 있긴 하지만, 그것은 온전히 타입 수준에서 동작하는 것입니다. 실제로 아래의 예시는 오직 하나의 함수만을 생성하죠.</p>
<pre><code class="language-ts">function add(a: number, b: number): number;
function add(a: string, b: string): string;
</code></pre>
<h2 id="타입스크립트-타입은-런타임-성능에-영향을-주지-않습니다"><a class="header" href="#타입스크립트-타입은-런타임-성능에-영향을-주지-않습니다">타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다</a></h2>
<p>여러 타입 구문은 JS로 변환되면서 전부 제거되기 떄문에, 실제 런타임의 성능에는 아무런 영향도 주지 않습니다. 따라서 타입스크립트의 정적 타입은 비용이 전혀 들지 않죠.</p>
<p>대신, 타입스크립트 컴파일러는 &quot;빌드타임&quot; 오버헤드가 있습니다. 다만 기본적으로 TS 컴파일러는 상당히 빠른 편이며, 특히 증분(Incremental) 빌드 시에 더욱 두드러집니다.
너무 오버헤드가 커진다면, 빌드 도구에서 트랜스파일만 진행(transpile only)하도록 설정하여 타입 체크를 건너뛸 수 있습니다.</p>
<p>타입스크립트가 컴파일하는 코드는 호환성을 높이고 성능 오버헤드를 감안할지, 아니면 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택할지의 문제에 맞닥뜨릴 수도 있습니다.
어떤 경우든지 이러한 호환성과 성능 간의 선택은 컴파일 타깃과 언어 레벨의 문제이며, 여전히 타입과는 전혀 무관합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="구조적-타이핑에-익숙해지기"><a class="header" href="#구조적-타이핑에-익숙해지기">구조적 타이핑에 익숙해지기</a></h1>
<p>JS는 본질적으로 덕 타이핑(Duck Typing) 기반입니다. 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용합니다.</p>
<p>TS도 이러한 특징을 그대로 고려하고 있습니다.</p>
<pre><code class="language-ts">interface Vector2D {
  x: number;
  y: number;
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}
</code></pre>
<p>이와 같이 정의를 한 상황에서, 아래와 같이 작성을 하더라도 아무런 문제가 없습니다.</p>
<pre><code class="language-ts">const v: NamedVector = { x: 3, y: 4, name: 'Zee' };
calculateLength(v); // 5
</code></pre>
<p>여기서 유의할 점은, <code>NamedVector</code>와 <code>Vector2D</code>의 관계에 대해서는 전혀 선언한 바가 없다는 것입니다. 기본적으로 TS의 타입 시스템은 JS의 런타임 동작을 모델링합니다. <code>NamedVector</code>의 구조가 <code>Vector2D</code>와 호환되기 때문에, 위의 코드는 정상으로 간주됩니다.
이렇듯 JS의 덕 타이핑을 모델링하기 위해 TS가 활용하는 타이핑 체계를 **구조적 타이핑(Structural Typing)**이라고 합니다.</p>
<p>이러한 특징이 오히려 문제를 일으키는 경우도 있을 수 있습니다. 하지만 이것이 좋든, 싫든 간에 TS에서 모든 타입은 열려(Open)있고, 봉인(Sealed)되어 있지 않습니다.</p>
<p>다만, 이러한 특징은 테스트에서는 오히려 도움이 됩니다. 특정 함수가 받는 매개변수의 인터페이스 규격에 맞기만 한다면, 이를 작성하고 테스트하는데 문제가 없기 때문이죠.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="any-타입-지양하기"><a class="header" href="#any-타입-지양하기">any 타입 지양하기</a></h1>
<p>타입스크립트의 타입 시스템은 다음과 같습니다.</p>
<ul>
<li>점진적(Gradual) - 프로젝트 전체에 타입을 추가할 필요 없이, 일부에 대해서만 사용할 수 있습니다.</li>
<li>선택적(Optional) - 언제든지 타입 체커를 해제할 수 있습니다.</li>
</ul>
<p>위 기능들의 핵심은 <code>any</code> 타입입니다.</p>
<p>타입스크립트가 발견해내는 대부분의 오류들은 사실 <code>any</code> 타입을 사용한다면 거의 대부분 넘어갈 수 있습니다.
하지만, 일부 특별한 경우를 제외하고는 <code>any</code> 타입의 사용은 TS의 수많은 장점을 누릴 수 없게 만듭니다.</p>
<h2 id="any-타입에는-타입-안전성이-없습니다"><a class="header" href="#any-타입에는-타입-안전성이-없습니다">any 타입에는 타입 안전성이 없습니다</a></h2>
<pre><code class="language-ts">let age: number;
age = &quot;12&quot; as any; // 문제 없음
</code></pre>
<p>분명 <code>age</code>는 <code>number</code> 타입이지만, <code>any</code> 타입을 통해 <code>string</code>을 할당했습니다. 이 경우 타입을 지정한 의미 자체가 없어진 셈입니다.</p>
<h2 id="any는-함수-시그니처를-무시해버립니다"><a class="header" href="#any는-함수-시그니처를-무시해버립니다">any는 함수 시그니처를 무시해버립니다</a></h2>
<p>함수 작성 시에는 시그니처를 명시해야 합니다. 즉, 함수의 호출과 출력에는 각각 약속된 타입이 정해져있어야 합니다. <code>any</code>는 이 자체를 무시합니다. JS에서는 암묵적인 Type Coercion이 빈번하게 일어나기 때문에, 이런 상황에서 특히 문제가 될 수 있습니다.</p>
<h2 id="any-타입은-ide-상의-피드백을-받을-수-없습니다"><a class="header" href="#any-타입은-ide-상의-피드백을-받을-수-없습니다">any 타입은 IDE 상의 피드백을 받을 수 없습니다</a></h2>
<p>기본적으로 적절한 타입을 지정해준다면 에디터는 상황에 따라 적절한 자동완성 기능과 도움말을 제공합니다. 그런데 <code>any</code> 타입의 사용은 이러한 피드백을 전혀 받아볼 수 없게 만듭니다.</p>
<h2 id="any-타입은-코드-리팩토링-시-버그를-감춥니다"><a class="header" href="#any-타입은-코드-리팩토링-시-버그를-감춥니다">any 타입은 코드 리팩토링 시 버그를 감춥니다</a></h2>
<p>리팩토링 시 적절한 타입의 유추가 어렵다는 이유로 <code>any</code>를 사용하게 되면, 리팩토링을 진행하는 도중에 발견해야할 에러를 알아내기 어렵습니다. 리팩토링에 앞서 구체적인 타입의 지정이 요구되는 이유입니다.</p>
<h2 id="any는-타입-설계를-감춰버립니다"><a class="header" href="#any는-타입-설계를-감춰버립니다">any는 타입 설계를 감춰버립니다</a></h2>
<p>애플리케이션의 상태 객체의 정의는 상당히 복잡합니다. 상태 객체 안의 수많은 프로퍼티 타입을 일일이 작성해야 하는데, 이는 사실 <code>any</code> 하나로 뚝딱 해결해버릴 수도 있습니다.
물론 이 때도 <code>any</code>를 사용해선 안 됩니다. 상태 객체가 어떻게 구성되어 있는지에 대한 인터페이스 자체를 감춰버리기 때문이죠.</p>
<h2 id="any는-타입-시스템의-신뢰도를-떨어뜨립니다"><a class="header" href="#any는-타입-시스템의-신뢰도를-떨어뜨립니다">any는 타입 시스템의 신뢰도를 떨어뜨립니다.</a></h2>
<p>사람은 누구나 실수를 합니다. 그런 상황에서 타입스크립트를 도입한다는 것은 곧 실수를 줄이기 위하여 신뢰할 만한 타입 체커를 구축해나간다는 것입니다.
헌데, <code>any</code> 타입의 사용은 이러한 타입 시스템 자체를 신뢰할 수 없게 만들어, TS를 쓰는 의미 자체를 잃어버리게 만듭니다.
코드에 존재하는 수많은 <code>any</code> 타입은 오히려 JS보다도 개발을 어렵게 만들 수 있습니다.</p>
<p>다만, 어쩔 수 없이 <code>any</code>를 써야만 하는 상황도 있습니다. 이에 대해서는 추후에 다뤄보도록 합시다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트의-타입-시스템"><a class="header" href="#타입스크립트의-타입-시스템">타입스크립트의 타입 시스템</a></h1>
<p>타입스크립트의 가장 중요한 역할은 타입 시스템에 있습니다. 해당 챕터에서는 타입 시스템의 기초를 살펴봅니다.</p>
<ul>
<li>타입 시스템이란 무엇인지?</li>
<li>어떻게 사용해야 하는지?</li>
<li>무엇을 결정해야 하는지?</li>
<li>가급적 사용하지 말아야 할 기능은 무엇인지?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="편집기를-사용하여-타입-시스템-탐색하기"><a class="header" href="#편집기를-사용하여-타입-시스템-탐색하기">편집기를 사용하여 타입 시스템 탐색하기</a></h1>
<p>타입스크립트를 설치하고 나면 다음의 두 가지를 실행할 수 있습니다.</p>
<ul>
<li>타입스크립트 컴파일러(<code>tsc</code>) : 일반적으로 사용하는 것</li>
<li>타입스크립트 서버(<code>tsserver</code>) : 백그라운드 상에서 타입스크립트 컴파일러를 동작시킬 수 있는 일종의 툴
<ul>
<li><a href="https://github.com/microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29">여기</a>에 따르면, VS Code는 자체적으로 <code>tsserver</code>를 통한 TypeScript의 언어 서비스를 지원하고 있습니다.</li>
</ul>
</li>
</ul>
<p>우리는 타입스크립트의 &quot;언어 서비스&quot;를 사용할 수 있는데, 이는 보통 에디터를 통해서 이루어지며, 별도로 타입스크립트 서버를 구축해서 이를 제공할 수도 있습니다.
&quot;언어 서비스&quot;에는 코드 자동완성, 명세(사양, Specification) 검사, 검색, 리팩토링이 포함됩니다.</p>
<p>타입스크립트를 제대로 활용하기 위해서는 이러한 언어 서비스를 적극적으로 활용하는 것이 좋습니다. VS Code 상에서 이를 활용하는 방법에 있어서는 <a href="https://code.visualstudio.com/docs/languages/typescript">여기</a>를 살펴봅시다.</p>
<p>에디터를 통하여 타입스크립트의 타입 시스템에 익숙해지기 위해 다음과 같은 방법들을 활용하는 것이 좋습니다.</p>
<ul>
<li>변수 위에 마우스 커서를 대면 TS가 해당 타입을 어떻게 판단하고 있는지 확인할 수 있습니다.</li>
<li>에디터 상에서 발생하는 타입 에러를 살펴볼 수 있습니다.</li>
<li>TS가 동작을 어떻게 모델링하는지 파악하기 위해선 타입 선언 파일을 찾아보는 것이 좋습니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입이-값들의-집합이라고-생각하기"><a class="header" href="#타입이-값들의-집합이라고-생각하기">타입이 값들의 집합이라고 생각하기</a></h1>
<p>타입스크립트에서의 타입은 <strong>할당 가능한 값들의 집합</strong>이라고 생각하면 이해가 쉽습니다.</p>
<h2 id="never"><a class="header" href="#never">never</a></h2>
<p>가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, TS 상에서는 <code>never</code>가 됩니다. 여기에는 아무런 값도 할당할 수 없습니다.</p>
<pre><code class="language-ts">const x: never = 12; // ERROR: '12' 형식은 never 타입에 할당할 수 없습니다.
</code></pre>
<h2 id="literal"><a class="header" href="#literal">literal</a></h2>
<p>그 다음 작은 집합은 한 가지 값만 포함하는 타입입니다. 이들은 TS 상에서 유닛(unit) 타입이라고도 불리는 리터럴(literal) 타입입니다.</p>
<pre><code class="language-ts">type A = 'A';
type B = 'B';
type Twelve = 12;
</code></pre>
<h2 id="union"><a class="header" href="#union">union</a></h2>
<p>가능한 타입을 여러 개로 묶은 것을 유니온(union) <code>|</code> 타입이라고 합니다.</p>
<pre><code class="language-ts">type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
</code></pre>
<h2 id="intersection"><a class="header" href="#intersection">intersection</a></h2>
<p>인터섹션(intersection) <code>&amp;</code> 타입은 각 인터페이스에 해당하는 모든 프로퍼티를 갖고 있어야 함을 의미합니다.</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person &amp; Lifespan;
</code></pre>
<h2 id="extends"><a class="header" href="#extends">extends</a></h2>
<p>다만 좀 더 일반적으로는 <code>extends</code> 키워드를 사용합니다. 타입은 일종의 집합이라는 관점에서, <code>extends</code>는 곧 <em>~의 부분집합</em> 이라는 의미로 이해할 수 있습니다.</p>
<pre><code class="language-ts">interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
</code></pre>
<p><code>extends</code> 키워드를 제네릭 타입에서 한정자로 쓰이기도 하는데, 이 때도 <em>~의 부분집합</em>이라는 의미가 됩니다.</p>
<pre><code class="language-ts">// 제네릭 타입 K는 string의 부분집합에 해당해야 합니다.
function getKey&lt;K extends string&gt;(val: any, key: K) {
  // ...
}

getKey({}, 'x'); // 정상
getKey({}, 12); // 12는 number이기 때문에 에러
</code></pre>
<h2 id="타입스크립트에서의-타입은-상속보다는-집합으로-이해하는-것이-편합니다"><a class="header" href="#타입스크립트에서의-타입은-상속보다는-집합으로-이해하는-것이-편합니다">타입스크립트에서의 타입은 상속보다는 집합으로 이해하는 것이 편합니다.</a></h2>
<p>결국, &quot;TS 상에서 어떤 값을 할당할 수 있느냐?&quot;라는 것은 해당 변수가 요구하는 타입 집합에 할당하고자 하는 값의 타입 집합이 부분 집합으로 속하느냐를 판단하는 것입니다. 이건 앞선 아이템4인 &quot;구조적 타이핑&quot;에서 설명했던 바와 유사합니다. 타입스크립트의 타입은 엄격한 상속 관계가 아니라, 겹쳐지는 집합의 형태로 표현될 수 있습니다. </p>
<p>집합의 관점에서 타입 시스템들을 이해한다면 아래와 같은 코드들도 쉽게 이해하고 작성할 수 있을겁니다.</p>
<pre><code class="language-ts">interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point; // 'x' | 'y'

// 제네릭 타입을 사용한 함수의 경우, 이를 사용하는 시점에야 구체적인 타입이 확정됩니다.
function sortBy&lt;K extends keyof T, T&gt;(vals: T[], key: K): T[] {
  // ...
}

const points = [{x: 1, y: 1}, {x: 2, y: -2}];

// type T = { x: number; y: number };
// type K = 'x' | 'y';
sortBy(points, 'y');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-공간과-값-공간의-심벌-구분하기"><a class="header" href="#타입-공간과-값-공간의-심벌-구분하기">타입 공간과 값 공간의 심벌 구분하기</a></h1>
<p>타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중 한 곳에 존재합니다. 
이름이 같은 심벌이더라도 속하는 공간에 따라 서로 다른 것을 의미할 수 있기 때문에 혼란스러울 수 있습니다.</p>
<pre><code class="language-ts">interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) =&gt; ({radius, height});
</code></pre>
<p>작성한 코드에 따라, 이후 상황에 따라서 <code>Cylinder</code>란 심벌은 값으로 쓰일 수도, 타입으로 쓰일 수도 있습니다.
이런 경우, 추후에 혼란을 일으킬 여지가 많습니다.</p>
<p>초기에 타입 공간과 값 공간, 각각에 대한 개념을 잡고자 한다면 <a href="https://www.typescriptlang.org/play">TS Playground</a>를 활용해보세요.
TS가 JS로 컴파일링된 이후에도 심벌이 남아있다면 값일테고, 그렇지 않다면 타입일 겁니다.</p>
<h2 id="타입과-값-구분하기"><a class="header" href="#타입과-값-구분하기">타입과 값 구분하기</a></h2>
<p>TS 코드 상에서 타입과 값 심벌은 번갈아 나올 수 있습니다. 
일반적으로 타입선언(<code>:</code>) 또는 단언문(<code>as</code>) 다음 나오는 심벌은 타입인 반면, <code>=</code> 다음 나오는 모든 심벌은 값이 됩니다.</p>
<h2 id="타입과-값-모두로-사용될-수-있는-경우"><a class="header" href="#타입과-값-모두로-사용될-수-있는-경우">타입과 값 모두로 사용될 수 있는 경우</a></h2>
<h3 id="class-1"><a class="header" href="#class-1">class</a></h3>
<p>한편, <code>class</code>는 타입과 값 모두로 사용될 수 있습니다.</p>
<pre><code class="language-ts">class Cylinder {
  radius = 1;
  height = 1;
}

// 여기서 Cylinder는 인터페이스로 사용되었습니다.
interface NamedCylinder extends Cylinder {
    name: string;
}

const namedCylinder: NamedCylinder = {
    radius: 1,
    height: 2,
    name: 'alan',
}

// 여기서 Cylinder는 생성자로 사용되었습니다.
const cylinder = new Cylinder();
</code></pre>
<p>클래스는 타입으로 쓰일 때 인터페이스로 사용되는 반면, 값으로 쓰일 때 생성자로 사용됩니다.</p>
<h3 id="typeof"><a class="header" href="#typeof">typeof</a></h3>
<p>연산자 <code>typeof</code>도 타입과 값 모두에서 사용될 수 있는데, 이는 비슷하면서도 상당히 다릅니다.</p>
<ul>
<li>타입의 관점에서 <code>typeof</code>는 TS 상에서의 타입을 반환합니다.</li>
<li>값의 관점에서 <code>typeof</code>는 JS 런타임의 연산자가 됩니다.</li>
</ul>
<p>위쪽의 예시의 연장선을 통해 이를 살펴보면 아래와 같습니다.</p>
<pre><code class="language-ts">const v = typeof Cylinder; // v는 'function' string value입니다.
type T = typeof Cylinder; // T는 Cylinder 생성자 함수의 Type입니다.
</code></pre>
<p>여기서 흥미로운 것은, 아래에 있는 타입 관점의 <code>typeof Cylinder</code>는 인스턴스의 타입이 아닌, 생성자 함수의 타입이 된다는 점입니다.
만약 이것을 인스턴스 타입으로 활용하고자 한다면 아래와 같이 전환해야 합니다.</p>
<pre><code class="language-ts">type T = typeof InstanceType&lt;typeof Cylindar&gt;;
</code></pre>
<h3 id="타입-프로퍼티-접근자-"><a class="header" href="#타입-프로퍼티-접근자-">타입 프로퍼티 접근자 <code>[]</code></a></h3>
<p>프로퍼티 접근자인 <code>[]</code>는 타입으로 쓰일 때에도 동일하게 동작합니다. 
하지만, <code>obj['field']</code>와 <code>obj.field</code>는 값이 동일하더라도 다른 타입을 가질 수 있기 때문에, 타입의 프로퍼티를 얻고자 한다면 반드시 첫 번째 방법을 사용해야 합니다.</p>
<pre><code class="language-ts">const myName: NamedCylinder['name'] = 'alan';
</code></pre>
<p>이에 대한 내용은 아이템 14에서 더 자세히 다룹니다.</p>
<h3 id="그-외에-두-공간-사이에서-다른-의미를-가지는-코드-패턴"><a class="header" href="#그-외에-두-공간-사이에서-다른-의미를-가지는-코드-패턴">그 외에 두 공간 사이에서 다른 의미를 가지는 코드 패턴</a></h3>
<ul>
<li><code>this</code> 
<ul>
<li>값으로 쓰일 때는 JS의 <code>this</code> 키워드</li>
<li>타입으로 쓰일 때는 <strong>다형성 this</strong>라고 불리는 TS 타입. 서브클래스의 메서드 체인을 구현할 때 유용합니다.</li>
</ul>
</li>
<li><code>&amp;</code>, <code>|</code>
<ul>
<li>값으로 쓰일 때는 AND와 OR 비트연산</li>
<li>타입으로 쓰일 때는 intersection과 union입니다.</li>
</ul>
</li>
<li><code>const</code>
<ul>
<li><code>const</code>는 새 변수를 선언하는 키워드이지만,</li>
<li><code>as const</code>는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿉니다.</li>
</ul>
</li>
<li><code>extends</code>
<ul>
<li>JS에서 그렇듯 서브클래스를 정의하는 데 사용되거나</li>
<li>TS 상에서 서브타입(<code>interface A extends B</code>) 또는 제너릭 타입의 한정자(<code>Generic&lt;T extends number&gt;</code>)를 정의할 수 있습니다.</li>
</ul>
</li>
</ul>
<p>이렇듯, 타입 공간과 값 공간에서 동일한 키워드로 사용되는 심벌들이 여럿 존재합니다. 그렇기 때문에 TS 코드가 본인이 의도한 대로 동작하지 않는다면, 타입 공간과 값 공간을 혼동하여 잘못 작성했을 가능성이 큽니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-단언보다는-타입-선언을-사용하기"><a class="header" href="#타입-단언보다는-타입-선언을-사용하기">타입 단언보다는 타입 선언을 사용하기</a></h1>
<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지 입니다.</p>
<pre><code class="language-ts">interface Person { name: string };
const alice: Person = { name: 'Alice' }; // Type Declaration -&gt; 타입 선언
const bob = { name: 'Bob' } as Person; // Type Assertion -&gt; 타입 단언
</code></pre>
<p>위의 둘은 비슷하면서도 다릅니다.</p>
<p>결론부터 말하자면, 우리는 Assertion 보다는 Declaration을 사용하는 편이 좋습니다. 
Assertion은 타입을 강제로 지정하여 타입 체커가 이로부터 비롯된 오류를 무시하게끔 만들기 때문입니다.
대부분의 상황에서는 안전성 체크까지 되는 Declaration을 사용하는 것이 맞습니다.</p>
<h3 id="언제-assertion을-쓸까요"><a class="header" href="#언제-assertion을-쓸까요">언제 Assertion을 쓸까요?</a></h3>
<p>Assertion은 타입 체커가 추론한 타입보다 우리가 생각하는 타입이 더 정확하다고 판단되는 경우에 사용되어야 합니다.</p>
<p>가령, 다음과 같은 상황입니다.</p>
<pre><code class="language-ts">document.querySelector('#myButton').addEventListener('click', e =&gt; {
  e.currentTarget; // EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button; // HTMLButtonElement
})
</code></pre>
<p>TS는 DOM에 접근할 수 없기 떄문에, <code>#myButton</code> id를 가진 요소가 버튼에 해당할 것이라는 것을 예상하지 못합니다.
이러한 상황에서는 직접 Assertion을 통해 타입을 지정해주는 것이 필요합니다.</p>
<p>이와 유사한 것으로, <code>!</code>를 통한 Assertion도 활용할 수 있습니다.</p>
<pre><code class="language-ts">const elNull = document.getElementById('foo'); // HTMLElement | null
const el = document.getElementById('foo')!; // HTMLElement
</code></pre>
<p><code>!</code>는 <code>null</code>이 아님을 확신하는 단언문입니다.
이 역시 특정 상황에서 해당 값은 <code>null</code>이 아니라고 확신을 할 수 있을 때 사용하여야 합니다.</p>
<p>덧붙여, Assertion은 단언하고자 하는 타입이 타입체커가 추론한 타입의 서브타입에 해당하지 않는다면 사용할 수 없습니다.
이를 무시하고 타입을 변환하고자 한다면 <code>unknown</code> 타입을 활용하면 됩니다.</p>
<pre><code class="language-ts">interface Person { name: string; }
const body = document.body;
const el = body as unknown as Person; 
</code></pre>
<p><code>unknown</code>은 모든 타입의 서브타입이기 때문에, 어떤 타입으로도 변환할 수 있습니다.
하지만 주의해야 합니다. <code>unknown</code> 타입을 사용한 이상 무엇인가 위험한 동작을 하고 있다는 뜻이니까요.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="객체-래퍼-타입-피하기"><a class="header" href="#객체-래퍼-타입-피하기">객체 래퍼 타입 피하기</a></h1>
<p>JS에는 객체 외에 일곱가지 기본형 값(Primitives)들이 있습니다.</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>symbol</code></li>
<li><code>bigint</code> -&gt; <code>number</code>의 최대치인 2^53-1보다 큰 값을 표현할 때 사용</li>
</ul>
<h3 id="기본형-값들의-특징"><a class="header" href="#기본형-값들의-특징">기본형 값들의 특징</a></h3>
<ul>
<li>불변(immutable)합니다.</li>
<li>메서드를 가지지 않습니다.</li>
</ul>
<p>이를 듣고 봤을 때, 언뜻 아래 코드는 앞서 설명한 바와 말이 다른 것처럼 보입니다.</p>
<pre><code class="language-js">'primitive'.charAt(3) // m
</code></pre>
<p>사실, <code>charAt</code>은 <code>string</code>의 메서드가 아닙니다. 
Primitive에 해당하는 <code>string</code>에는 메서드가 없는 대신, 이 <code>string</code>과 관련된 메서드를 지닌 <code>String</code> 객체 타입이 별도로 정의되어 있습니다.
여러모로 서로 간에 깊이 연관된 탓에, <code>string</code>과 <code>String</code>을 언뜻 동일한 것으로 이해하기 쉽지만, 둘 사이에는 분명한 차이가 있습니다.</p>
<p>대부분의 경우 사실 래퍼 객체들은 직접 사용할 일이 드뭅니다. 우리가 직접 사용하지 않더라도 내부적으로 필요한 경우에 사용되기 때문입니다.
이를테면 위에서 <code>string</code>에 <code>charAt</code>을 쓴 경우, 우리가 보지 못하는 다음의 일들이 일어납니다.</p>
<ol>
<li>기본값인 <code>string</code>을 <code>String</code> 객체로 래핑합니다.</li>
<li>이후 래핑한 <code>String</code> 객체에서 메서드를 호출합니다.</li>
<li>그리고나서 래핑한 객체를 버립니다.</li>
</ol>
<p>이러한 과정을 거치는 탓에, 아래와 같이 이상한 코드를 작성했을 때 에러는 발생하지 않지만, 그렇다고 의도대로 동작하지도 않습니다.</p>
<pre><code class="language-js">const x = 'hello';
x.language = 'English'
console.log(x.language) // undefined
</code></pre>
<h3 id="래퍼-객체는-오직-자기-자신하고만-동일합니다"><a class="header" href="#래퍼-객체는-오직-자기-자신하고만-동일합니다">래퍼 객체는 오직 자기 자신하고만 동일합니다.</a></h3>
<p>그렇기 때문에 아래의 코드는 틀린 내용입니다.</p>
<pre><code class="language-js">'hello' === new String('hello') // false
new String('hello') === new String('hello') // false
</code></pre>
<blockquote>
<p><strong>주의</strong> : 단, <code>new</code> 없이 호출된 객체 래퍼들은 기본형을 생성합니다.</p>
</blockquote>
<pre><code class="language-js">String('abc') === 'abc' // true
BigInt(1) === BigInt(1) // true
</code></pre>
<h3 id="래퍼-객체-타입보다는-기본형-타입을-사용하세요"><a class="header" href="#래퍼-객체-타입보다는-기본형-타입을-사용하세요">래퍼 객체 타입보다는 기본형 타입을 사용하세요.</a></h3>
<ul>
<li>string / String</li>
<li>number / Number</li>
<li>boolean / Boolean</li>
<li>symbol / Symbol</li>
<li>bigint / BigInt</li>
</ul>
<p>위처럼 TS에서도 기본형과 객체 래퍼 타입은 별도로 모델링되며, 엄연히 다른 타입입니다.
TS에서 타입을 다룰 때는 모든 경우에 기본형 타입을 사용하는 것이 옳습니다. <code>기본형 -&gt; 래퍼 객체</code>는 할당이 가능하지만, <code>래퍼 객체 -&gt; 기본형</code>은 할당이 불가능하기 때문입니다.
이 탓에 에러가 발생할 가능성이 높습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="잉여-속성-체크의-한계-인지하기"><a class="header" href="#잉여-속성-체크의-한계-인지하기">잉여 속성 체크의 한계 인지하기</a></h1>
<h2 id="잉여-속성-체크-excess-property-checking"><a class="header" href="#잉여-속성-체크-excess-property-checking">잉여 속성 체크 (Excess property checking)</a></h2>
<p>타입이 명시된 변수에 <strong>객체 리터럴</strong>을 할당할 때, TS는 해당 타입의 속성이 제대로 존재하는지, 그리고 <strong>그 외의 속성</strong>은 없는지 확인합니다.
이 <em>그 외의 속성이 없는지</em> 판단하는 과정을 **잉여 속성 체크(Excess property checking)**라고 합니다.</p>
<pre><code class="language-ts">interface Room {
  numDoors: number;
  ceilingHeightFn: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present', // 에러 발생
}
</code></pre>
<h3 id="잉여-속성-체크는-객체-리터럴에서만-발생합니다"><a class="header" href="#잉여-속성-체크는-객체-리터럴에서만-발생합니다">잉여 속성 체크는 객체 리터럴에서만 발생합니다.</a></h3>
<p>여기서 포인트는 <strong>객체 리터럴</strong>입니다. 다른 임시 변수를 통해 우회적으로 할당을 하는 경우에 이는 문제가 발생하지 않습니다.</p>
<pre><code class="language-ts">const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
}

const room: Room = obj; // 문제 없음
</code></pre>
<p>여기서 우리가 앞서 살펴봤던 덕 타이핑과 이에 따른 TS의 구조적 타이핑 체계를 떠올려봅시다. 
그러한 관점에서 생각해보면, 앞선 코드에서 문제가 발생하지 않는 것이 이상한 일은 아닙니다.</p>
<p>결국 중요한 포인트는, 일반적인 구조적 할당 가능성 체크와 <strong>잉여 속성 체크</strong>는 엄연히 별도의 과정으로써 동작한다는 점입니다.
그리고, 잉여 속성 체크는 <strong>객체 리터럴을 통해</strong> 할당 또는 함수에 값을 넘겨줄 경우에 발생한다는 것을 기억해야 합니다.</p>
<h3 id="잉여-속성-체크는-단언문assertion에서는-발생하지-않습니다"><a class="header" href="#잉여-속성-체크는-단언문assertion에서는-발생하지-않습니다">잉여 속성 체크는 단언문(Assertion)에서는 발생하지 않습니다.</a></h3>
<p>우리가 단언문(Assertion)보다는 선언문(Declaration)을 우선시 해야하는 단적인 이유 중 하나입니다.
객체 리터럴을 사용하더라도, 단언을 이용한 경우에는 잉여 속성 체크가 일어나지 않습니다.</p>
<pre><code class="language-ts">const room = { 
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
  } as Room; // 문제 없음
</code></pre>
<h3 id="잉여-속성-체크를-원치-않는다면-인덱스-시그니처를-사용하세요"><a class="header" href="#잉여-속성-체크를-원치-않는다면-인덱스-시그니처를-사용하세요">잉여 속성 체크를 원치 않는다면 인덱스 시그니처를 사용하세요.</a></h3>
<p>잉여 속성 체크를 원치 않는 상황, 다시 말해 추가적인 속성을 가질 수 있다고 판단되는 경우에는 인덱스 시그니처를 사용하면 됩니다.
이 인덱스 시그니처에 대해서는 아이템15에서 상세하게 다루겁니다.</p>
<pre><code class="language-ts">interface Options {
  darkMode?: boolean;
  [others: string]: unknown;
}

const options: Options = { darkmode: true }; // 문제 없음
</code></pre>
<h3 id="약한-타입에-대한-공통-속성-체크"><a class="header" href="#약한-타입에-대한-공통-속성-체크">약한 타입에 대한 공통 속성 체크</a></h3>
<p>선택적 속성만 가지는 <strong>약한(weak) 타입</strong>에도 유사한 체크가 동작하는데, 이는 잉여 속성이 아닌 공통 속성이 있는지를 확인한다는 점에서 조금 다릅니다.</p>
<pre><code class="language-ts">interface LineChartOptions {
  logscale?: boolean;
  inverteedYAxis?: boolean;
  areaChart?: boolean;
}

const opts = { logScale: true };

const options: LineChartOptions = opts; // 에러 발생
</code></pre>
<p>약한 타입에 대한 공통 속성 체크는 값과 타입 간에 공통된 속성이 있는지에 대해 확인하는 과정입니다.
그러나 잉여 속성 체크와는 다르게, 약한 타입과 관련된 할당마다 수행된다는 차이가 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-표현식에-타입-적용하기"><a class="header" href="#함수-표현식에-타입-적용하기">함수 표현식에 타입 적용하기</a></h1>
<p>JS 및 TS에서는 다음의 방법들로 함수를 나타낼 수 있습니다. 이는 큰 관점에서 Statement냐 Expression이냐로 나뉩니다.</p>
<pre><code class="language-ts">function rollDice1(sides: number): number { ... } // Statement
const rollDice2 = (sides: number): number =&gt; { ... } // Expression
const rollDice3 = function(sides: number): number { ... } // Expression
</code></pre>
<h2 id="ts에서는-함수-표현식function-expression을-사용하세요"><a class="header" href="#ts에서는-함수-표현식function-expression을-사용하세요">TS에서는 함수 표현식(Function Expression)을 사용하세요.</a></h2>
<p>결론부터 말하면, TS에서는 함수 표현식을 사용하는 것이 좋습니다.
함수 전체를 하나의 함수 타입으로 선언하여 여러 곳에 재사용할수 있다는 장점이 있기 때문입니다.</p>
<pre><code class="language-ts">type DiceRollFn = (sides: number) =&gt; number;
const rollDice: DiceRollFn = sides =&gt; { ... };
</code></pre>
<p>위의 예시가 짧아서 장점이 와닿지 않는다면 다음의 코드도 참고하세요.</p>
<pre><code class="language-ts">type BinaryFn = (a: number, b: number) =&gt; number;
const add: BinaryFn = (a, b) =&gt; a + b;
const sub: BinaryFn = (a, b) =&gt; a - b;
const mul: BinaryFn = (a, b) =&gt; a * b;
const div: BinaryFn = (a, b) =&gt; a / b;
</code></pre>
<h2 id="함수-타입에도-typeof를-사용할-수-있습니다"><a class="header" href="#함수-타입에도-typeof를-사용할-수-있습니다">함수 타입에도 typeof를 사용할 수 있습니다.</a></h2>
<p>함수 타입에도 <code>typeof</code>를 사용할 수 있는데, 이는 기존에 이미 작성되어 있던 네이티브 및 라이브러리 함수들의 타입을 재차 활용하고자 할 때 유용합니다.
아래 예시는 네이티브 <code>fetch</code> 함수에 대한 에러 핸들링을 추가하는 예시입니다.</p>
<pre><code class="language-ts">const checkedFetch: typeof fetch = async (input, init) =&gt; {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error('Request failed: ' + response.status);
  }
  return response;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입과-인터페이스의-차이점-알기"><a class="header" href="#타입과-인터페이스의-차이점-알기">타입과 인터페이스의 차이점 알기</a></h1>
<p>타입스크립트에서는 명명된 타입(named type)을 정의하기 위해 <b>타입 별칭(Type Alias, 이하 타입)</b>과 <b>인터페이스(Interface)</b>라는 두 가지 방법을 사용할 수 있습니다.</p>
<pre><code class="language-ts">// type
type TState = {
  name: string;
  capital: string;
}

// interface
interface IState {
  name: string;
  capital: string;
}
</code></pre>
<h2 id="타입과-인터페이스의-유사점"><a class="header" href="#타입과-인터페이스의-유사점">타입과 인터페이스의 유사점</a></h2>
<h3 id="인덱스-시그니처를-사용할-수-있습니다"><a class="header" href="#인덱스-시그니처를-사용할-수-있습니다">인덱스 시그니처를 사용할 수 있습니다.</a></h3>
<pre><code class="language-ts">type TDict = { [key: string]: string };

interface IDict {
  [key: string]: string;
}
</code></pre>
<h3 id="함수-타입을-정의할-수-있습니다"><a class="header" href="#함수-타입을-정의할-수-있습니다">함수 타입을 정의할 수 있습니다.</a></h3>
<pre><code class="language-ts">type TFn = (x: number) =&gt; string;

interface ifN {
  (X: number): string;
}
</code></pre>
<p>JS에서의 함수는 곧 객체라는 점을 떠올려보면, 아래처럼 추가로 프로퍼티를 정의할 수도 있습니다.</p>
<pre><code class="language-ts">type TFnWithProperties = {
  (x: number): number;
  prop: string;
}

interface IFnWithProperties {
  (x: number): number;
  prop: string;
}
</code></pre>
<h3 id="제네릭을-사용할-수-있습니다"><a class="header" href="#제네릭을-사용할-수-있습니다">제네릭을 사용할 수 있습니다.</a></h3>
<pre><code class="language-ts">type TPair&lt;T&gt; = {
  first: T;
  second: T;
}

interface IPair&lt;T&gt; {
  first: T;
  second: T;
}
</code></pre>
<h3 id="타입과-인터페이스는-서로-간에-확장이-가능합니다"><a class="header" href="#타입과-인터페이스는-서로-간에-확장이-가능합니다">타입과 인터페이스는 서로 간에 확장이 가능합니다.</a></h3>
<pre><code class="language-ts">interface IStateWithPop extends TState {
  population: number;
}

type TStateWithPop = IState &amp; { population: number; };
</code></pre>
<h3 id="클래스의-구현implements에-사용할-수-있습니다"><a class="header" href="#클래스의-구현implements에-사용할-수-있습니다">클래스의 구현(implements)에 사용할 수 있습니다.</a></h3>
<pre><code class="language-ts">class StateT implements TState {
  name: string = '';
  capital: string = '';
}

class StateI implements IState {
  name: string = '';
  capital: string = '';
}
</code></pre>
<h2 id="타입과-인터페이스의-차이점"><a class="header" href="#타입과-인터페이스의-차이점">타입과 인터페이스의 차이점</a></h2>
<h3 id="유니온은-타입으로만-표현할-수-있습니다"><a class="header" href="#유니온은-타입으로만-표현할-수-있습니다">유니온(<code>|</code>)은 타입으로만 표현할 수 있습니다.</a></h3>
<pre><code class="language-ts">type AorB = 'a' | 'b';
</code></pre>
<p>유니온을 인터페이스로 표현할 방법은 없습니다. 이러한 이유로 타입은 일반적으로 인터페이스보다 더 쓰임새가 많습니다.</p>
<pre><code class="language-ts">type Input = { /* ... */ };
type Output = { /* ... */ };

interface VariableMap {
  [name: string]: Input | Output;
}

type NamedVariable = (Input | Output) &amp; { name: string };
</code></pre>
<h3 id="튜플-배열-타입은-type-키워드를-이용해야-합니다"><a class="header" href="#튜플-배열-타입은-type-키워드를-이용해야-합니다">튜플, 배열 타입은 type 키워드를 이용해야 합니다.</a></h3>
<pre><code class="language-ts">type Pair = [number, number];
type Stringlist = string[];
type NamedNums = [string, ...number[]];
</code></pre>
<p>인터페이스로도 유사하게 구현할 수는 있으나, 이 경우엔 <code>.map</code>, <code>.concat</code> 등의 배열 메서드를 사용할 수 없게 됩니다.</p>
<pre><code class="language-ts">interface Tuple {
  0: number;
  1: number;
  length: 2;
}

const t: Tuple = [10, 20]; // 정상
t.concat([30, 40]); // ERROR : Property 'concat' does not exist on type 'Tuple'.
</code></pre>
<h3 id="인터페이스는-보강augment이-가능합니다"><a class="header" href="#인터페이스는-보강augment이-가능합니다">인터페이스는 보강(augment)이 가능합니다.</a></h3>
<pre><code class="language-ts">interface IState {
  name: string;
  capital: string;
}

interface IState {
  population: number;
}

const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 500_000,
}
</code></pre>
<p>위의 예제처럼 프로퍼티를 확장하는 것을 선언 병합(Declaration merging)이라고 합니다. 이는 주로 타입 선언 파일에서 사용됩니다. (일반 코드에서 쓰지 못하는 것은 아닙니다.) 다시 말해, 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 인터페이스를 사용해야 하며, 표준을 따라야 합니다.</p>
<h2 id="결론--그래서-둘-중-무엇을-써야-할까요"><a class="header" href="#결론--그래서-둘-중-무엇을-써야-할까요">결론 : 그래서 둘 중 무엇을 써야 할까요?</a></h2>
<ul>
<li>복잡한 타입의 정의가 필요한 경우 =&gt; <strong>타입</strong></li>
<li>보강의 가능성이 있는 경우 (ex. API) =&gt; <strong>인터페이스</strong></li>
</ul>
<p>그 외에 프로젝트의 일관된 스타일을 유지하게끔 일관적으로 타입 또는 인터페이스를 사용하면 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-연산과-제너릭-사용으로-반복-줄이기"><a class="header" href="#타입-연산과-제너릭-사용으로-반복-줄이기">타입 연산과 제너릭 사용으로 반복 줄이기</a></h1>
<p>같은 코드를 반복해서 작성하지 말라는 DRY(Don't Repeat Yourself) 원칙은 타입에 대해서도 유효합니다.</p>
<h3 id="타입에-이름-붙이기-named-type"><a class="header" href="#타입에-이름-붙이기-named-type">타입에 이름 붙이기 (Named Type)</a></h3>
<pre><code class="language-ts">function distanc(a: {x: number, y: number}, b: {x: number, y: number}) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
</code></pre>
<p>이를 별도의 이름을 가진 타입으로 쪼개어 작성하면 훨씬 보기 편해지고, 반복도 줄어듭니다.</p>
<pre><code class="language-ts">interface Point2D {
  x: number;
  y: number;
}

function distance(a: Point2D, b: point2D) { 
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
</code></pre>
<p>이는 함수에 있어서도 마찬가지입니다.</p>
<pre><code class="language-ts">type HTTPFunction = (url: string, opts: Options) =&gt; Promise&lt;Response&gt;;
const get: HTTPFunction = (url, opts) =&gt; { /* ... */ };
const post: HTTPFunction = (url, opts) =&gt; { /* ... */ };
</code></pre>
<h3 id="확장"><a class="header" href="#확장">확장</a></h3>
<p>이미 작성된 타입을 활용한 확장도 반복을 줄이는 방법 중 하나입니다. 이 중 <code>&amp;</code>을 이용하는 방법은 유니온 타입에서 확장을 하고자 하는 경우에 특히 유용한 패턴입니다. </p>
<pre><code class="language-ts">interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate extends Person {
  birth: Date;
}

// 또는
interface PersonWithBirthDate = Person &amp; { birth: Date };
</code></pre>
<h3 id="타입-인덱싱"><a class="header" href="#타입-인덱싱">타입 인덱싱</a></h3>
<p>기존에 존재하던 타입의 일부를 인덱싱으로 사용할 수도 있습니다. <code>Pick</code>, <code>Partial</code> 등 아래서 추가로 설명할 제너릭 타입들을 사용하면 더 쉽습니다.</p>
<pre><code class="language-ts">
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

type TopNavState = {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
};
</code></pre>
<p>단, 여전히 <code>State[...]</code>와 같이 반복되는 코드가 남아있는 데, 이부분에서 <a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html"><b>매핑된 타입</b></a>을 사용하면 더 나아집니다.</p>
<pre><code class="language-ts">type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]
};
</code></pre>
<p>유니온 타입에서 인덱싱을 사용하는 경우에도 유연하게 동작합니다.</p>
<pre><code class="language-ts">interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load';
  // ...
}
type Action = SaveAction | LoadAction;
type ActionType = Action['type'];  // Type is &quot;save&quot; | &quot;load&quot;
</code></pre>
<h3 id="typeof와-keyof"><a class="header" href="#typeof와-keyof"><code>typeof</code>와 <code>keyof</code></a></h3>
<p><code>keyof</code>는 특정 타입이 가진 프로퍼티 <code>key</code>들의 유니온을 반환합니다.</p>
<pre><code class="language-ts">interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
type OptionsKeys = keyof Options;
// Type is &quot;width&quot; | &quot;height&quot; | &quot;color&quot; | &quot;label&quot;
</code></pre>
<p>반면, <code>typeof</code>는 특정 <b>값(value)</b>의 형태에 대한 타입들을 가져올 수 있습니다. 여기서 <code>typeof</code> 뒤에 오는 것은 타입이 아닌 값임에 주의하세요.</p>
<pre><code class="language-ts">const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: '#00FF00',
  label: 'VGA',
};

type Options = typeof INIT_OPTIONS;

// interface Options {
//   width: number;
//   height: number;
//   color: string;
//   label: string;
// }
</code></pre>
<h2 id="표준-라이브러리의-제너릭을-활용하세요"><a class="header" href="#표준-라이브러리의-제너릭을-활용하세요">표준 라이브러리의 제너릭을 활용하세요.</a></h2>
<p>제너릭은 <strong>타입의 관점에서 사용하는 함수</strong>에 가깝습니다. 정의 시점에는 해당 타입이 명확하지 않지만, 이를 사용할 때 결과 타입을 반환받아 사용할 수 있게 됩니다. TS 표준 라이브러리에서는 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types</a>라는 이름으로 여러 제너릭을 제공하고 있습니다.</p>
<h3 id="partial"><a class="header" href="#partial">Partial</a></h3>
<p><code>Partial</code>는 기존 타입들의 프로퍼티를 선택적인 속성으로 만들어줍니다.</p>
<pre><code class="language-ts">interface Todo {
  title: string;
  description: string;
}

type UpdateTodoFields = Partial&lt;Todo&gt;; 

// interface UpdateTodoFields {
//  title?: string | undefined;
//  description?: string | undefined;
// }
</code></pre>
<h3 id="pick"><a class="header" href="#pick">Pick</a></h3>
<p><code>Pick</code>은 기존에 존재하던 타입 프로퍼티의 일부만을 가져와 새로 정의할 수 있도록 해줍니다.</p>
<pre><code class="language-ts">interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

type TopNavState = Pick&lt;State, 'userId' | 'pageTitle' | 'recentFiles'&gt;;

// interface State {
//   userId: string;
//   pageTitle: string;
//   recentFiles: string[];
// }
</code></pre>
<h3 id="returntype"><a class="header" href="#returntype">ReturnType</a></h3>
<p><code>ReturnType</code>은 기존의 함수 타입의 반환 타입을 가져올 수 있게 해주는 제너릭입니다.</p>
<pre><code class="language-ts">// 아래 getUserInfo는 함수 값(value)입니다.
type UserInfo = ReturnType&lt;typeof getUserInfo&gt;;
</code></pre>
<p>그 외에도 여러 유틸리티 타입들이 존재하는데, 여기선 모두 다루진 않도록 하겠습니다. 다른 유틸리티 함수에 대해서는 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">여기</a>를 참조하세요.</p>
<h2 id="제너릭의-매개변수를-extends를-통해-제한하세요"><a class="header" href="#제너릭의-매개변수를-extends를-통해-제한하세요">제너릭의 매개변수를 <code>extends</code>를 통해 제한하세요.</a></h2>
<p>TS 함수에서 매개변수의 값을 타입을 통해 제한하는 것처럼, TS의 제너릭에 있어서도 <code>extends</code>를 통해 타입을 제한할 수 있습니다. </p>
<pre><code class="language-ts">interface Name {
  first: string;
  last: string;
}
type DancingDuo&lt;T extends Name&gt; = [T, T];

const couple1: DancingDuo&lt;Name&gt; = [
  {first: 'Fred', last: 'Astaire'},
  {first: 'Ginger', last: 'Rogers'}
];  // OK
const couple2: DancingDuo&lt;{first: string}&gt; = [
                       // ~~~~~~~~~~~~~~~
                       // Property 'last' is missing in type
                       // '{ first: string; }' but required in type 'Name'
  {first: 'Sonny'},
  {first: 'Cher'}
];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="동적-데이터에-인덱스-시그니처-사용하기"><a class="header" href="#동적-데이터에-인덱스-시그니처-사용하기">동적 데이터에 인덱스 시그니처 사용하기</a></h1>
<p>JS의 장점을 객체 생성 문법이 간단하다는 것입니다. TS에서도 이렇게 유연한 형태로 객체 타입을 정의하고 싶다면 다음과 같이 사용하면 됩니다.</p>
<pre><code class="language-ts">type Rocket = {[property: string]: string};

const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
};
</code></pre>
<p>여기서 사용된 <code>[property: string]: string</code>이 <b>인덱스 시그니처</b>가 되며, 다음의 세 가지 의미를 담고 있습니다.</p>
<ul>
<li>키 이름(<code>property</code>): 키의 위치만 표시하며, 타입 체커에서는 실질적으로 사용하지 않습니다.</li>
<li>키 타입(<code>string</code>): <code>string</code>, <code>number</code> 또는 <code>symbol</code> 이어야하는데, 보통은 <code>string</code>을 사용합니다.</li>
<li>값 타입(<code>string</code>): 무엇이든 될 수 있습니다.</li>
</ul>
<p>다만, 위와 같은 방식으로 타입 체크를 수행하는 경우 다음의 문제들이 발생합니다.</p>
<ul>
<li>모든 키를 포함합니다. 즉, 의도와 다르게 키를 잘못 작성하더라도 에러가 발생하지 않습니다.</li>
<li>특정 키가 필요하지 않습니다. <code>{}</code>도 위의 <code>Rocket</code>타입에 유효합니다.</li>
<li>키마다 다른 타입을 가질 수 없습니다. 예를 들어 <code>thrust</code>는 <code>number</code>로도 표현될 여지가 있습니다.</li>
<li>TS 언어 서비스가 아무런 도움도 주지 못합니다. (자동 완성, 도움말 등..) 무엇이든 가능하기 때문입니다.</li>
</ul>
<p>결국, <strong>일반적인 상황에서는 인덱스 시그니처보다 그냥 인터페이스로 타입을 정의하는 것이 더 좋습니다.</strong></p>
<pre><code class="language-ts">interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}

const falconHeavy: Rocket = {
  name: 'Falcon Heavy',
  variant: 'v1',
  thrust_kN: 15_200
};
</code></pre>
<h2 id="인덱스-시그니처는-런타임-이전에-알-수-없는-동적인-데이터를-표현할-때-사용합니다"><a class="header" href="#인덱스-시그니처는-런타임-이전에-알-수-없는-동적인-데이터를-표현할-때-사용합니다">인덱스 시그니처는 런타임 이전에 알 수 없는 동적인 데이터를 표현할 때 사용합니다.</a></h2>
<p>아래 코드는 CSV 파일의 string을 받아 여러 개의 Row들을 가진 배열을 반환하는 함수입니다. 이 시점에서 우리는 어떤 CSV 파일이 사용될지 알 수 없기 때문에, 이러한 경우에는 인덱스 시그니처를 사용해야 합니다.</p>
<pre><code class="language-ts">// 현 시점에서 우리는 CSV 파일의 컬럼명이 무엇이 될지 알 수 없습니다.
function parseCSV(input: string): {[columnName: string]: string}[] {
  const lines = input.split('\n');
  const [header, ...rows] = lines;
  return rows.map(rowStr =&gt; {
    const row: {[columnName: string]: string} = {};
    rowStr.split(',').forEach((cell, i) =&gt; {
      row[header[i]] = cell;
    });
    return row;
  });
}
</code></pre>
<p>물론, 모든 열의 값들에 대해서 주어지지 않을 가능성이 있습니다. 이러한 부분을 염려하여 보다 엄격한 형태로 작성하고자 한다면 다음과 같이 활용해야 합니다. 물론 그만큼 추후 타입체킹이 더 번거로워 질 수는 있습니다.</p>
<pre><code class="language-ts">function safeParseCSV(
  input: string
): {[columnName: string]: string | undefined}[] {
  return parseCSV(input);
}
</code></pre>
<p>만약, 반환받은 값의 형태에 대해 명확히 알고 있는 경우라면 다음과 같이 Assertion을 활용하여 강제로 타입을 변환시킬 수 있습니다.</p>
<pre><code class="language-ts">interface ProductRow {
  productId: string;
  name: string;
  price: string;
}

let csvData: string;
const products = parseCSV(csvData) as unknown as ProductRow[];
</code></pre>
<h2 id="가능한-필드가-제한적이라면-인덱스-시그니처를-쓰지-마세요"><a class="header" href="#가능한-필드가-제한적이라면-인덱스-시그니처를-쓰지-마세요">가능한 필드가 제한적이라면 인덱스 시그니처를 쓰지 마세요.</a></h2>
<p>동적인 데이터를 다루더라도, 사용될 수 있는 필드가 제한되어 있는 경우라면 인덱스 시그니처를 쓰지 말아야 합니다. 너무 광범위하기 때문입니다. 이 때는 선택적 프로퍼티(Optional Property)나 유니온 타입(<code>|</code>)을 사용하는 편이 좋습니다.</p>
<pre><code class="language-ts">interface Row1 { [column: string]: number }  // 너무 광범위
interface Row2 { a: number; b?: number; c?: number; d?: number }  // 최선
type Row3 =
    | { a: number; }
    | { a: number; b: number; }
    | { a: number; b: number; c: number;  }
    | { a: number; b: number; c: number; d: number }; // 가장 정확하지만 번거로움
</code></pre>
<h2 id="키-타입에-제한두기"><a class="header" href="#키-타입에-제한두기">키 타입에 제한두기</a></h2>
<p>어떤 객체의 키 타입을 인덱스 시그니처를 통해 모두 <code>string</code>으로 정의해버리기 보다는, 더 명확하게 정의하고 사용하는 편이 좋습니다. 이에 대해 두 가지 대안을 고려해볼 수 있습니다.</p>
<h3 id="record-제너릭"><a class="header" href="#record-제너릭">Record 제너릭</a></h3>
<p>Record는 키 타입에 유연성을 제공하는 제너릭 타입으로, <code>string</code>의 부분 집합을 사용할 수 있습니다.</p>
<pre><code class="language-ts">type Vec3D = Record&lt;'x' | 'y' | 'z', number&gt;;
// Type Vec3D = {
//   x: number;
//   y: number;
//   z: number;
// }
</code></pre>
<h3 id="mapped-types-매핑된-타입"><a class="header" href="#mapped-types-매핑된-타입">Mapped Types (매핑된 타입)</a></h3>
<p>매핑된 타입은 Record 제네릭과 동일하게 사용할 수 있고, 조건부 타입(<code>?</code>)를 통해 키마다 별도의 타입을 사용하게 할 수도 있습니다. 조건부 타입에 대해서는 아이템 50에서 다룰 예정입니다.</p>
<pre><code class="language-ts">type Vec3D = {[k in 'x' | 'y' | 'z']: number};
// Type Vec3D = {
//   x: number;
//   y: number;
//   z: number;
// }

type ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number};
// Type ABC = {
//   a: number;
//   b: string;
//   c: number;
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기"><a class="header" href="#number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기">number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기</a></h1>
<p>JS에서 배열은 하나의 객체입니다. <code>number</code> 타입의 인덱스를 사용하지만, JS 내부적으로 사실 이는 문자열로 변환되어 사용된다는 특이점이 있습니다.
실제로도 배열에서의 인덱싱을 문자열로 하더라도 아무런 문제 없이 동작합니다.</p>
<pre><code class="language-js">const arr = ['a', 'b', 'c'];
console.log(arr[0]) // 'a'
console.log(arr['1']) // 'b'
</code></pre>
<p>TS의 경우, <strong>이와 같은 코드를 작성했을 때 에러를 발생해야 한다</strong>라고 책에는 적혀있는데, 현 시점의 <code>v4.4</code> 이상의 TS에서는 이러한 에러가 출력되지 않습니다.</p>
<pre><code class="language-ts">const xs = [1, 2, 3];
const x0 = xs[0];  // OK
const x1 = xs['1'];
           // 책(&lt; v4.4)에서는 아래와 같은 에러가 출력된다고 이야기하지만, v4.4 이상에서는 그렇지 않습니다.
           // ~~~ Element implicitly has an 'any' type
           //      because index expression is not of type 'number'

function get&lt;T&gt;(array: T[], k: string): T {
  return array[k];
            // 이 경우는 현 시점에서도 에러가 발생합니다.
            // ~ Element implicitly has an 'any' type
            //   because index expression is not of type 'number'
}
</code></pre>
<h2 id="인덱스-시그니처에-number를-사용하지-마세요"><a class="header" href="#인덱스-시그니처에-number를-사용하지-마세요">인덱스 시그니처에 number를 사용하지 마세요.</a></h2>
<p>다시 본론으로 돌아와서, <code>number</code> 타입을 통해 인덱싱을 해야하는 상황이라면, 굳이 객체에 인덱스 시그니처를 사용하기보다, Array 또는 Tuple 타입을 사용하세요.</p>
<pre><code class="language-ts">// 굳이 이렇게 만들지 말고
type MyArray = {
  [index: number]: string;
}

const myArr: MyArray = {
  1: 'a',
  2: 'b',
}

// 그냥 Array나 Tuple을 쓰세요.
const arr: Array&lt;string&gt; = ['a', 'b'];
const tup: [string, string] = ['a', 'b'];
</code></pre>
<p>만약 Array 프로토타입의 프로퍼티들을 갖는 것을 원치 않는 상황이라면, <code>ArrayLike&lt;T&gt;</code> 타입을 사용하면 됩니다.</p>
<pre><code class="language-ts">const tupleLike: ArrayLike&lt;string&gt; = {
  0: 'A',
  1: 'B',
  length: 2,
};

tupleLike[0] // 'A'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="변경-관련된-오류-방지를-위해-readonly-사용하기"><a class="header" href="#변경-관련된-오류-방지를-위해-readonly-사용하기">변경 관련된 오류 방지를 위해 readonly 사용하기</a></h1>
<h2 id="readonly"><a class="header" href="#readonly">readonly</a></h2>
<p>Array 또는 Tuple 타입을 <code>readonly</code>로 선언하면 다음과 같은 일이 생깁니다.</p>
<ul>
<li><code>length</code>를 포함한 해당 배열 요소들을 참조할 수는 있지만, 추가로 작성하거나 수정할 수는 없습니다.</li>
<li>배열에 변경을 가하는 <code>pop</code>, <code>push</code> 등의 메서드를 사용할 수 없습니다. (한편 <code>map</code>, <code>concat</code> 등은 가능합니다.)</li>
</ul>
<p>이는 함수의 매개변수 또는 새로운 값을 선언할 때 배열의 불변성(Immutability)을 명시적으로 유지하고자 하는 경우에 활용될 수 있습니다.
이 경우, 어떤 동작에서 해당 배열을 변경하려고 하는 경우 즉각적으로 피드백을 받을 수 있어 즉각적으로 대처가 가능합니다.</p>
<pre><code class="language-ts">function arraySum(arr: readonly number[]) {
  let sum = 0, num;
  while ((num = arr.pop()) !== undefined) {
                 // ~~~ 'pop' does not exist on type 'readonly number[]'
    sum += num;
  }
  return sum;
}
</code></pre>
<h3 id="readonly는-얕게shallow-동작한다는-점을-유의하세요"><a class="header" href="#readonly는-얕게shallow-동작한다는-점을-유의하세요">readonly는 얕게(shallow) 동작한다는 점을 유의하세요.</a></h3>
<p><code>readonly</code>는 얕게 동작합니다. 다시 말해, 아래 예시와 같이 보다 깊게 위치한 배열에 대해서는 불변성을 보장할 수 없습니다.</p>
<pre><code class="language-ts">const arrInArr: readonly string[][] = [[], ['a', 'b']];
arrInArr[1]?.pop(); // 문제 없음
</code></pre>
<h3 id="인덱스-시그니처에서도-사용할-수-있습니다"><a class="header" href="#인덱스-시그니처에서도-사용할-수-있습니다">인덱스 시그니처에서도 사용할 수 있습니다.</a></h3>
<p>인덱스 시그니처에서도 <code>readonly</code>를 사용할 수 있는데, 이 경우 객체의 프로퍼티가 변경되는 것을 방지할 수 있습니다.</p>
<pre><code class="language-ts">let obj: {readonly [k: string]: number} = {};
// Or Readonly&lt;{[k: string]: number}
obj.hi = 45;
//  ~~ Index signature in type ... only permits reading
obj = {...obj, hi: 12};  // OK
obj = {...obj, bye: 34};  // OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="매핑된-타입을-사용하여-값을-동기화하기"><a class="header" href="#매핑된-타입을-사용하여-값을-동기화하기">매핑된 타입을 사용하여 값을 동기화하기</a></h1>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html">매핑된 타입(Mapped Type)</a>은 기존에 작성한 다른 타입에 기반하여 새로운 타입을 쉽게 작성할 수 있는 방법입니다. 주로 <code>keyof</code> 키워드와 함께 사용됩니다.</p>
<pre><code class="language-ts">type FeatureFlags = {
  darkMode: () =&gt; void;
  newUserProfile: () =&gt; void;
};

type OptionsFlags&lt;Type&gt; = {
  [Property in keyof Type]: boolean;
};

type FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;;
// type FeatureOptions = {
//     darkMode: boolean;
//     newUserProfile: boolean;
// }
</code></pre>
<p>이는 꼭 제네릭으로 사용되어야 하는 것은 아닙니다. 인덱스 시그니처에서도 매핑된 타입을 사용할 수 있습니다.</p>
<pre><code class="language-ts">const options: {[k in keyof FeatureFlags]: boolean} = {
  darkMode: false,
  newUserProfile: true,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-추론"><a class="header" href="#타입-추론">타입 추론</a></h1>
<p>3장에서는 타입 추론에서 발생할 수 있는 몇 가지 문제와 그 해법을 안내합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="추론-가능한-타입을-사용해-장황한-코드-방지하기"><a class="header" href="#추론-가능한-타입을-사용해-장황한-코드-방지하기">추론 가능한 타입을 사용해 장황한 코드 방지하기</a></h1>
<p>TS의 타입 추론은 생각보다 훨씬 정확해서, 일반적으로는 명시적인 타입 구문 자체가 필요하지 않습니다.
그렇기 때문에, 이러한 &quot;불필요한 타입 구문&quot;들은 가능한 줄이는 것이 좋습니다. 
tslint를 사용하고 있다면, <a href="https://palantir.github.io/tslint/rules/no-inferrable-types/"><code>no-inferrable-types</code></a> 옵션을 통해 작성된 모든 타입 구문이 정말로 필요한지에 대해 확인할 수 있습니다.</p>
<pre><code class="language-ts">const person = {
  name: 'Sojourner Truth',
  born: {
    where: 'Swartekill, NY',
    when: 'c.1797',
  },
  died: {
    where: 'Battle Creek, MI',
    when: 'Nov. 26, 1883'
  }
};

// typeof person: {
//     name: string;
//     born: {
//         where: string;
//         when: string;
//     };
//     died: {
//         where: string;
//         when: string;
//     };
// }
</code></pre>
<h2 id="함수와-메서드의-시그니처에는-타입-구문을-쓰세요"><a class="header" href="#함수와-메서드의-시그니처에는-타입-구문을-쓰세요">함수와 메서드의 시그니처에는 타입 구문을 쓰세요.</a></h2>
<p>타입스크립트에게 직접 타입을 명시적으로 지정해주어야 하는 경우는, 말 그대로 타입스크립트가 스스로 타입을 판단하기 어려운 경우입니다.
함수가 그 대표적인 예시가 되는데, <strong>이상적인 TS 코드는 함수 및 메서드 시그니처에 타입 구문을 포함하지만, 그 내부의 지역 변수들에서는 타입 구문을 넣지 않습니다.</strong></p>
<pre><code class="language-ts">interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const {id, name, price} = product;
  console.log(id, name, price);
}
</code></pre>
<p>물론 함수임에도 이러한 타입 구문이 필요하지 않은 경우도 있습니다.</p>
<h3 id="매개변수에-대한-기본값을-통해-타입-추론이-가능한-경우"><a class="header" href="#매개변수에-대한-기본값을-통해-타입-추론이-가능한-경우">매개변수에 대한 기본값을 통해 타입 추론이 가능한 경우</a></h3>
<pre><code class="language-ts">// `base`는 타입 추론에 따라 `number` 타입이 됩니다.
function parseNumber(str: string, base = 10) {
  // ...
}
</code></pre>
<h3 id="콜백함수로-넘겨짐에-따라-타입-추론이-가능한-경우"><a class="header" href="#콜백함수로-넘겨짐에-따라-타입-추론이-가능한-경우">콜백함수로 넘겨짐에 따라 타입 추론이 가능한 경우</a></h3>
<pre><code class="language-ts">// axios.get에 넘겨지는 콜백함수는 이미 본인의 매개변수 타입을 알고 있습니다.
app.get('/health', (request, response) =&gt; {
  response.send('OK');
});
</code></pre>
<h2 id="타입-추론이-가능하더라도-타입을-명시해야-하는-경우"><a class="header" href="#타입-추론이-가능하더라도-타입을-명시해야-하는-경우">타입 추론이 가능하더라도, 타입을 명시해야 하는 경우</a></h2>
<p>타입이 추론 가능하더라도, 여전히 직접 타입을 명시하는게 좋은 상황이 있습니다.</p>
<h3 id="객체-리터럴을-정의할-때"><a class="header" href="#객체-리터럴을-정의할-때">객체 리터럴을 정의할 때</a></h3>
<p>객체 리터럴을 정의할 때, 타입 구문이 없다면 앞선 아이템 11에서 살펴봤던 잉여 속성 체크가 동작하지 않고, 이 경우 속성에 대한 오타를 해당 시점에 잡아내지 못합니다.
이 경우, 추후 해당 객체가 직접 사용될 때 이르러서야 해당 객체를 사용한 곳에서 타입 에러가 발생하기에 혼동을 주기 쉽습니다.</p>
<pre><code class="language-ts">interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: string = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}

const furby = {
  name: 'Furby',
  id: 630509430963,
  price: 35,
};

logProduct(furby);
        // ~~~~~ Argument .. is not assignable to parameter of type 'Product'
        //         Types of property 'id' are incompatible
        //         Type 'number' is not assignable to type 'string'
</code></pre>
<h3 id="함수의-반환-타입"><a class="header" href="#함수의-반환-타입">함수의 반환 타입</a></h3>
<p>함수의 반환 타입 역시 알아서 추론이 가능하지만, 본인이 의도한 반환 타입과 다른 경우가 발생할 수 있으므로, 이를 미리 명시하고 제때 잡아내는 것이 필요합니다.
그렇지 않다면 구현 상의 문제가 <a href="https://github.com/grepp/hera-webapp/pull/2487/files">해당 함수를 사용하는 시점에서야 발견</a>됩니다.</p>
<pre><code class="language-ts">const cache: {[ticker: string]: number} = {};
function getQuote(ticker: string): Promise&lt;number&gt; {
  if (ticker in cache) {
    return cache[ticker];
        // ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'
  }
  // COMPRESS
  return Promise.resolve(0);
  // END
}
</code></pre>
<p>함수의 반환 타입을 명시해야 하는 두 번째 이유는 명명된 타입(Named Type)을 사용하기 위해서입니다. 구조 상으로는 동일하더라도, 타입이 일관적이지 않으면 당황스러울 수 있기 때문이죠.</p>
<pre><code class="language-ts">interface Vector2D { x: number; y: number; }
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y };
}
// function add(a: Vector2D, b: Vector2D): {
//     x: number;
//     y: number;
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="다른-타입에는-다른-변수-사용하기"><a class="header" href="#다른-타입에는-다른-변수-사용하기">다른 타입에는 다른 변수 사용하기</a></h1>
<p>JS는 <code>let</code>을 통해 하나의 변수를 여러 타입으로 수번에 걸쳐 재할당하여 사용해도 무방합니다. 
타입스크립트 상에서도 이를 시스템 상으로 막고있지는 않지만, 에러가 발생할 여지가 많습니다.</p>
<pre><code class="language-ts">function fetchProduct(id: string) {}
function fetchProductBySerialNumber(id: number) {}

let id = &quot;12-34-56&quot;; // 이건 string
fetchProduct(id);

id = 123456; // number로 재할당하려니 에러가 발생
// ~~ '123456' is not assignable to type 'string'.
fetchProductBySerialNumber(id);
                        // ~~ Argument of type 'string' is not assignable to
                        //    parameter of type 'number'
</code></pre>
<p>근본적인 이유는 값은 재할당되지만, 타입은 바뀌지 않기 때문인데, 이는 타입체커는 물론, 협업을 하는 동료에게도 혼란을 주기 쉽습니다.
기본적으로 TS에서는 <strong>하나의 타입에 대해 하나의 변수</strong>를 사용하는 것이 이상적인데, 그 이유는 다음과 같습니다.</p>
<ul>
<li>서로 관련 없는 두 개의 값을 분리합니다.</li>
<li>변수명을 더 구체적으로 지을 수 있습니다.</li>
<li>타입 추론을 향상시키며, 불필요한 타입 구문을 줄일 수 있습니다..</li>
<li>타입이 더 간결해집니다. (<code>string | number</code>를 쪼개서 <code>string</code>, <code>number</code>로 따로 쓰는 쪽을 권장)</li>
<li><code>let</code> 대신에 <code>const</code> 변수를 선언하게 됩니다.
<ul>
<li><code>const</code>로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋습니다.</li>
</ul>
</li>
</ul>
<p>앞선 예시의 &quot;재사용되는 변수&quot;와 아래 예시의 &quot;가려지는(shadowed) 변수&quot;는 엄연히 다릅니다.
아래의 경우는 TS 상에서 문제없이 동작하겠지만, 여전히 다른 동료 개발자들에게 혼란을 주기 쉽습니다.
실제 이러한 이유로 별도의 린팅 규칙을 통해 스타일 규칙으로 이를 막는 개발팀도 많습니다.</p>
<pre><code class="language-ts">function fetchProduct(id: string) {}
function fetchProductBySerialNumber(id: number) {}
const id = &quot;12-34-56&quot;;
fetchProduct(id);

{
  const id = 123456;  // OK
  fetchProductBySerialNumber(id);  // OK
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-넓히기"><a class="header" href="#타입-넓히기">타입 넓히기</a></h1>
<p>TS에서의 각 변수들은 정적 분석 시점에 &quot;가능한 값&quot;들의 집합에 해당하는 <strong>타입</strong>을 갖게 됩니다.
변수를 초기화할 때 타입을 직접 명시하지 않는 경우, 타입 체커가 스스로 타입을 결정하게 되죠.
다시 말해, 지정된 타입 값들을 바탕으로 할당 가능한 값들의 집합을 유출해야 한다는 의미로, TS에서는 이를 <b>넓히기(widening)</b>이라는 명칭으로 부릅니다.</p>
<p>타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 합니다.
그래서 별도로 타입을 명시하지 않은 경우에는, 충분히 구체적으로 타입을 추론하려 하지만, 잘못된 추론(false positive)을 할 정도로 구체적으로 수행하지는 않습니다.
가령 아래와 같은 예시를 들 수 있습니다.</p>
<pre><code class="language-ts">interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
let x = 'x'; // 이 경우 `x` 변수는 string 타입이 됩니다.
let vec = {x: 10, y: 20, z: 30};
getComponent(vec, x);
               // ~ Argument of type 'string' is not assignable to
               //   parameter of type '&quot;x&quot; | &quot;y&quot; | &quot;z&quot;'
</code></pre>
<p>위 예시에서, <code>x</code>는 추후 재할당될 가능성이 있으므로, <code>string</code> 타입으로 추론되며, 이에 따라, <code>'x' | 'y' | 'z'</code> 타입만 할당 가능한 <code>axis</code> 매개변수에 할당할 수 없습니다.</p>
<p>이를 해결할 가장 간단한 방법은 <code>let</code>이 아닌 <code>const</code>를 사용하는 것입니다.
<code>x</code> 변수는 &quot;재할당할 수 없음&quot;이라는 정보를 전달해줌에 따라 TS가 확신을 갖고 <code>x</code> 리터럴 타입으로 추론할 수 있게 됩니다.</p>
<h2 id="타입-추론의-강도를-직접-제어하기"><a class="header" href="#타입-추론의-강도를-직접-제어하기">타입 추론의 강도를 직접 제어하기</a></h2>
<p>타입 추론의 강도를 직접 제어하기 위해서는 TS의 기본 동작을 재정의해야 하는데, 여기에는 세 가지 방법이 있습니다.</p>
<h3 id="타입-명시"><a class="header" href="#타입-명시">타입 명시</a></h3>
<p>첫번째는 직접 변수의 타입을 명시해주는 방법입니다.</p>
<pre><code class="language-ts">const v: { x: 1|3|5 } = {
  x: 1, // type v.x = 1|3|5
};
</code></pre>
<h3 id="추가적인-문맥-제공하기"><a class="header" href="#추가적인-문맥-제공하기">추가적인 문맥 제공하기</a></h3>
<p>두번째는 추가적인 문맥을 제공하는 방법입니다. 아래에서 매개변수로 넘겨지는 객체의 형태는 동일하지만, 문맥에 따라 에러의 발생 여부가 다릅니다.</p>
<pre><code class="language-ts">type User = {
  type: 'customer' | 'guest';
  name: string;
  age: number;
}

const printUser = (user: User) =&gt; console.log(user);

const user = {
  type: 'customer', // string
  name: 'alan',
  age: 21,
};
printUser(user); 
// Argument of type '{ type: string; name: string; age: number; }' is not assignable to parameter of type 'User'.
//   Types of property 'type' are incompatible.
//     Type 'string' is not assignable to type '&quot;customer&quot; | &quot;guest&quot;'.(2345)

printUser({
  type: 'customer',
  name: 'alan',
  age: 21,
}) // 문제 없음
</code></pre>
<h3 id="const-단언문-사용"><a class="header" href="#const-단언문-사용">const 단언문 사용</a></h3>
<p><code>const</code> 단언문은 변수 선언에 쓰이는 <code>let</code>과 <code>const</code>와는 별개의 것이므로 혼동해서는 안됩니다.
<code>as const</code> 단언을 사용하면 TS는 최대한 좁은 타입으로 이를 추론하고자 합니다.</p>
<pre><code class="language-ts">interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
const v1 = {
  x: 1,
  y: 2,
};  // type = { x: number; y: number; }

const v2 = {
  x: 1 as const,
  y: 2,
};  // type = { x: 1; y: number; }

const v3 = {
  x: 1,
  y: 2,
} as const;  // type = { readonly x: 1; readonly y: 2; }
</code></pre>
<p>이를 배열을 튜플 타입으로 만들고자 할 때도 사용할 수 있습니다.</p>
<pre><code class="language-ts">interface Vector3 { x: number; y: number; z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}
const a1 = [1, 2, 3];  // Type is number[]
const a2 = [1, 2, 3] as const;  // Type is readonly [1, 2, 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-좁히기"><a class="header" href="#타입-좁히기">타입 좁히기</a></h1>
<p>타입 넓히기의 반대는 타입 좁히기(Type narrowing)입니다.
타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말합니다.</p>
<h3 id="null-체킹"><a class="header" href="#null-체킹"><code>null</code> 체킹</a></h3>
<p>가장 일반적인 예시는 <code>null</code> 체킹입니다.
TS가 문맥 상 해당 변수가 <code>null</code>이 아님을 확신할 수 있을 경우, 타입에서 <code>null</code>이 제거됩니다.</p>
<pre><code class="language-ts">const el = document.getElementById('foo'); // Type is HTMLElement | null
if (el) {
  el // Type is HTMLElement
  el.innerHTML = 'Party Time'.blink();
} else {
  el // Type is null
  alert('No element #foo');
}
</code></pre>
<pre><code class="language-ts">const el = document.getElementById('foo'); // Type is HTMLElement | null
if (!el) throw new Error('Unable to find #foo');
el; // Now type is HTMLElement
el.innerHTML = 'Party Time'.blink();
</code></pre>
<h3 id="instanceof"><a class="header" href="#instanceof">instanceof</a></h3>
<pre><code class="language-ts">function contains(text: string, search: string|RegExp) {
  if (search instanceof RegExp) {
    search  // Type is RegExp
    return !!search.exec(text);
  }
  search  // Type is string
  return text.includes(search);
}
</code></pre>
<h3 id="프로퍼티-체크"><a class="header" href="#프로퍼티-체크">프로퍼티 체크</a></h3>
<pre><code class="language-ts">interface A { a: number }
interface B { b: number }
function pickAB(ab: A | B) {
  if ('a' in ab) {
    ab // Type is A
  } else {
    ab // Type is B
  }
  ab // Type is A | B
}
</code></pre>
<h3 id="내장함수-사용"><a class="header" href="#내장함수-사용">내장함수 사용</a></h3>
<pre><code class="language-ts">function contains(text: string, terms: string|string[]) {
  const termList = Array.isArray(terms) ? terms : [terms];
  termList // Type is string[]
  // ...
}
</code></pre>
<h3 id="tagged-union-discriminated-union"><a class="header" href="#tagged-union-discriminated-union">Tagged Union (Discriminated Union)</a></h3>
<pre><code class="language-ts">interface UploadEvent { type: 'upload'; filename: string; contents: string }
interface DownloadEvent { type: 'download'; filename: string; }
type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case 'download':
      e  // Type is DownloadEvent
      break;
    case 'upload':
      e;  // Type is UploadEvent
      break;
  }
}
</code></pre>
<h2 id="user-defined-type-guards-사용자-정의-타입-가드"><a class="header" href="#user-defined-type-guards-사용자-정의-타입-가드">User-Defined Type Guards (사용자 정의 타입 가드)</a></h2>
<p>TS가 타입을 적절히 식별하도록 하기 위해, 커스텀 함수를 직접 작성하여 타입 좁히기에 관여할 수 있습니다.</p>
<pre><code class="language-ts">// 해당 함수가 true를 반환한다면 `el`은 HTMLInputElement 타입으로 좁혀집니다.
function isInputElement(el: HTMLElement): el is HTMLInputElement {
  return 'value' in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    el; // Type is HTMLInputElement
    return el.value;
  }
  el; // Type is HTMLElement
  return el.textContent;
}
</code></pre>
<pre><code class="language-ts">const jackson5 = ['Jackie', 'Tito', 'Jermaine', 'Marlon', 'Michael'];

function isDefined&lt;T&gt;(x: T | undefined): x is T {
  return x !== undefined;
}

const members = ['Janet', 'Michael'].map(
  who =&gt; jackson5.find(n =&gt; n === who) // Type is (string | undefined)[]
).filter(isDefined);  // Type is string[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="한꺼번에-객체-생성하기"><a class="header" href="#한꺼번에-객체-생성하기">한꺼번에 객체 생성하기</a></h1>
<p>타입스크립트의 타입은 일반적으로 변경되지 않기 때문에, 객체를 생성할 때는 속성을 하나씩 추가하기 보다는 여러 프로퍼티를 포함해 한꺼번에 생성해야 타입 추론에 유용합니다.</p>
<pre><code class="language-ts">interface Point { x: number; y: number; }

// Don't
const pt = {};
pt.x = 3; // Property 'x' does not exist on type '{}'.
pt.y = 4; // Property 'y' does not exist on type '{}'.

// Don't
const pt: Point = {}; // Type '{}' is missing the following properties from type 'Point': x, y
pt.x = 3;
pt.y = 4;

// Do
const pt: Point = {
  x: 3,
  y: 4,
};
</code></pre>
<p>객체 전개 연산자(Spread operator) <code>...</code>를 사용하면 여러 객체들을 통해 하나의 새로운 객체를 만들어내기에 용이합니다.</p>
<pre><code class="language-ts">interface Point { x: number; y: number; }
const pt = {x: 3, y: 4};
const id = {name: 'Pythagoras'};
const namedPoint = {...pt, ...id};
// type {
//     name: string;
//     x: number;
//     y: number;
// }
</code></pre>
<p>이를 통해 별도로 타입 명시를 하지 않고도 조건부 속성을 추론하게끔 할 수도 있습니다.
(아래 예시는 책에서 이야기한 것과는 다르게 의도한대로 추론됩니다.)</p>
<pre><code class="language-ts">declare let hasDates: boolean;
const nameTitle = { name: 'Khufu', title: 'Pharaoh' };
const pharaoh = {
    ...nameTitle,
    ...(hasDates ? {start: -2589, end: -2566}: {}),
}
// type {
//     start?: number | undefined;
//     end?: number | undefined;
//     name: string;
//     title: string;
// }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="일관성있는-별칭-사용하기"><a class="header" href="#일관성있는-별칭-사용하기">일관성있는 별칭 사용하기</a></h1>
<p>별칭(alias)을 남발해서 사용하면 제어 흐름을 분석하기 어렵습니다.
TS에서도 마찬가지로 별칭을 신중하게 사용해야합니다.
그래야 코드를 잘 이해할 수 있고, 오류도 쉽게 찾을 수 있기 때문입니다.</p>
<pre><code class="language-ts">interface Coordinate {
  x: number;
  y: number;
}

interface BoundingBox {
  x: [number, number];
  y: [number, number];
}

interface Polygon {
  exterior: Coordinate[];
  holes: Coordinate[][];
  bbox?: BoundingBox;
}
</code></pre>
<p>위와 같은 자료 구조가 있고, 이에 대해 아래와 같은 함수가 있다고 가정합시다.
현 시점에서 이는 타입에러도 없고, 잘 동작하지만 코드가 반복되는 부분이 존재합니다.</p>
<pre><code class="language-ts">function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  if (polygon.bbox) {
    if (pt.x &lt; polygon.bbox.x[0] || pt.x &gt; polygon.bbox.x[1] ||
        pt.y &lt; polygon.bbox.y[1] || pt.y &gt; polygon.bbox.y[1]) {
      return false;
    }
  }

  // ... more complex check
}
</code></pre>
<p>여기서 중복되는 부분들을 없애기 위해 별도로 <code>box</code>라는 이름의 별칭으로 <code>polygon.bbox</code>를 참조하도록 하는 방법을 사용할 수 있습니다.</p>
<pre><code class="language-ts">function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (box) {
    if (pt.x &lt; box.x[0] || pt.x &gt; box.x[1] ||
        pt.y &lt; box.y[1] || pt.y &gt; box.y[1]) {  // OK
      return false;
    }
  }
  // ...
}
</code></pre>
<p>사실 제일 이상적인 방법은 Destructuring(비구조화) 문법을 통해 <code>bbox</code>라는 일관된 이름을 사용하도록 하는 것입니다. 이를 적용하면 아래와 같아집니다.</p>
<pre><code class="language-ts">function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  // Destructuring을 통해 일관된 이름을 사용할 수 있도록 합니다.
  const { bbox } = polygon;
  if (bbox) {
    const { x, y } = bbox;
    if (pt.x &lt; x[0] || pt.x &gt; x[1] ||
        pt.y &lt; x[0] || pt.y &gt; y[1]) {
      return false;
    }
  }
  // ...
}
</code></pre>
<p>객체 프로퍼티에 직접 접근하지 않고 별도의 지역변수로 분리해낸다는 점은 타입 관점에서 더 안전합니다. 아래와 같이 프로퍼티를 직접 참조하는 경우 기존에 좁혀졌던 타입이 함수 호출 등으로 신뢰할 수 없는 상태가 될 수 있기 때문입니다.</p>
<pre><code class="language-ts">const deletePolygonBox = (polygon: Polygon) =&gt; {
    polygon.bbox = undefined;
}

function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
    polygon.bbox  // Type is BoundingBox | undefined
    if (polygon.bbox) {
    polygon.bbox  // Type is BoundingBox
    deletePolygonBox(polygon); // polygon.bbox = undefined;
    polygon.bbox  // Type is BoundingBox
    }
}
</code></pre>
<p>단, 지역변수로 분리한 경우 기존 프로퍼티 <code>polygon.bbox</code>와 <code>bbox</code>가 항상 같음을 보장할 수 없다는 점에 주의해야합니다.</p>
<pre><code class="language-ts">const resetPolygonBox = (polygon: Polygon) =&gt; {
    polygon.bbox = {
      x: [0, 0],
      y: [0, 0],
    };
}

function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
    const { bbox } = polygon;
    if (bbox) {
    resetPolygonBox(polygon); 
    // 이제 bbox와 polygon.bbox는 동일하지 않습니다.
    // ...
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="비동기-코드에는-콜백-대신-async-함수-사용하기"><a class="header" href="#비동기-코드에는-콜백-대신-async-함수-사용하기">비동기 코드에는 콜백 대신 async 함수 사용하기</a></h1>
<p>비동기 동작을 다룰 때에, 콜백보다는 프로미스를 사용해야 합니다. 이유는 다음과 같습니다.</p>
<ul>
<li>콜백보다는 프로미스가 코드를 작성하기 쉽습니다.</li>
<li>콜백보다는 프로미스가 타입을 추론하기 쉽습니다.</li>
</ul>
<pre><code class="language-ts">function fetchPagesCB() {
  let numDone = 0;
  const responses: string[] = [];
  const done = () =&gt; {
    const [response1, response2, response3] = responses;
    // ...
  };
  const urls = [url1, url2, url3];
  urls.forEach((url, i) =&gt; {
    fetchURL(url, r =&gt; {
      responses[i] = url;
      numDone++;
      if (numDone === urls.length) done();
    });
  });
}
</code></pre>
<p>위와 같은 콜백 기반의 비동기 함수는 프로미스를 통해 아래와 같은 형태가 될 수 있습니다.</p>
<pre><code class="language-ts">async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([
    fetch(url1), fetch(url2), fetch(url3)
  ]);
  // ...
}
</code></pre>
<p>그리고 프로미스보다는 async/await를 사용하는 편이 좋습니다. 이유는 아래와 같습니다.</p>
<ul>
<li>일반적으로 더 간결하고 직관적인 코드가 됩니다.</li>
<li>async 함수는 항상 프로미스를 반환하도록 강제합니다.</li>
</ul>
<p>&quot;함수가 항상 프로미스를 반환하도록 강제&quot;하는 것은 각 함수가 항상 동기 또는 비동기로 실행되어야 한다는 원칙을 쉽게 지키도록 해줍니다.
콜백이나 프로미스를 사용하면 실수로 반(half)동기 코드를 작성할 수 있지만, async 함수에 기반하는 경우 항상 비동기 코드로 작성되기 때문입니다.</p>
<p>아래의 콜백 기반의 함수 <code>fetchWithCache</code>는 얼핏 제대로 만들어진 반동기 함수인 듯 하지만, 실제로 사용할 때 문제를 일으킬 가능성이 있습니다. 캐시가 되어있는 경우에는 <code>callback(..)</code>가 동기적으로 동작할 것이기 때문입니다.</p>
<pre><code class="language-ts">const _cache: {[url: string]: string} = {};

function fetchWithCache(url: string, callback: (text: string) =&gt; void) {
  if (url in _cache) {
    callback(_cache[url]);
  } else {
    fetchURL(url, text =&gt; {
      _cache[url] = text;
      callback(text);
    });
  }
}

let requestStatus: 'loading' | 'success' | 'error';

// 캐시가 있는 경우 =&gt; requestStatus는 'loading'
// 캐시가 없는 경우 =&gt; requestStatus는 'success'
function getUser(userId: string) {
  fetchWithCache(`/user/{userId}`, profile =&gt; {
    requestStatus = 'success';
  });
  requestStatus = 'loading';
}
</code></pre>
<p>이를 async 함수로 대체하면 보다 간결하고, 일관적인 형태로 사용할 수 있게 됩니다.</p>
<pre><code class="language-ts">const _cache: {[url: string]: string} = {};

async function fetchWithCache(url: string) {
  if (url in _cache) {
    return _cache[url];
  }
  const response = await fetch(url);
  const text = await response.text();
  _cache[url] = text;
  return text;
}

let requestStatus: 'loading' | 'success' | 'error';

async function getUser(userId: string) {
  requestStatus = 'loading';
  const profile = await fetchWithCache(`/user/{userId}`);
  requestStatus = 'success';
}
</code></pre>
<p>한가지 유의점으로, async 함수 내에서 프로미스를 반환한다고 해서 <code>Promise&lt;Promise&lt;T&gt;&gt;</code> 반환타입이 되지는 않습니다. 이 경우에도 동일하게 <code>Promise&lt;T&gt;</code>가 됩니다. 타입 체커를 통해서도 이를 확인할 수 있습니다.</p>
<pre><code class="language-ts">// Function getJSON(url: string): Promise&lt;any&gt;
async function getJSON(url: string) {
  const response = await fetch(url);
  const jsonPromise = response.json();  // Type is Promise&lt;any&gt;
  return jsonPromise;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-추론에-문맥이-어떻게-사용되는지-이해하기"><a class="header" href="#타입-추론에-문맥이-어떻게-사용되는지-이해하기">타입 추론에 문맥이 어떻게 사용되는지 이해하기</a></h1>
<p>TS는 타입을 추론할 때 값 뿐만 아니라 문맥도 고려합니다. 함수로 값을 넘기는 경우가 대표적입니다.</p>
<h2 id="string-리터럴의-경우"><a class="header" href="#string-리터럴의-경우">string 리터럴의 경우</a></h2>
<pre><code class="language-ts">type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) { /* ... */ }

setLanguage('JavaScript');  // OK
// 'JavaScript' 리터럴은 `Language` 타입에 부합합니다.

let language = 'JavaScript'; // string으로 추론됩니다.
setLanguage(language);
// ~~~~~~~~ Argument of type 'string' is not assignable
//          to parameter of type 'Language'
</code></pre>
<p>이러한 문제를 해결하기 위해서는 크게 두가지 방법이 있습니다. 이는 당장의 string 리터럴 외에도 범용적으로 활용될 수 있습니다.</p>
<h3 id="타입-선언"><a class="header" href="#타입-선언">타입 선언</a></h3>
<p>하나는 직접 타입을 선언해서 해당 <code>language</code> 변수에 가능한 값을 제한시키는 방법입니다.</p>
<pre><code class="language-ts">let language: Language = 'JavaScript'; // type = Language
</code></pre>
<h3 id="상수로-만들기"><a class="header" href="#상수로-만들기">상수로 만들기</a></h3>
<p>다른 하나는 <code>const</code> 키워드를 통해 <code>language</code> 변수가 변경 가능성이 없음을 타입체커에게 알려줘 더 정확한 타입을 유추할 수 있도록 해주는 방법입니다.</p>
<pre><code class="language-ts">const language = 'JavaScript'; // type = `JavaScript`
</code></pre>
<h2 id="튜플의-경우"><a class="header" href="#튜플의-경우">튜플의 경우</a></h2>
<p>튜플의 경우에도 이러한 문제가 발생할 수 있어 주의해야 합니다.</p>
<pre><code class="language-ts">type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) { /* ... */ }
// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) { /* ... */ }

panTo([10, 20]);  // OK
// [10, 20]은 [number, number] 타입에 부합합니다.

const loc = [10, 20]; // number[]로 추론됩니다.
panTo(loc);
//    ~~~ Argument of type 'number[]' is not assignable to
//        parameter of type '[number, number]'
</code></pre>
<p>이 경우에도 마찬가지로 타입 선언을 통해 해결할 수 있습니다.</p>
<pre><code class="language-ts">const loc: [number, number] = [10, 20];
panTo(loc);  // OK
</code></pre>
<p>또는 해당 매개변수가 <strong>정말로 상수인 경우</strong>에는 <code>const</code> 단언을 사용할 수 있습니다. <code>const</code> 단언을 사용하면 해당 참조가 깊은(deeply) 상수라는 정보를 TS에 전달할 수 있습니다. 다만, 이 경우 해당 값이 <code>readonly</code>가 되어 전혀 변경할 수 없는 상태가 되기 때문에, 해당 값을 매개변수로 사용하는 함수 측에도 <code>readonly</code> 타입 정보를 추가해야 합니다.</p>
<pre><code class="language-ts">function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20] as const; // type = readonly [number, number]
panTo(loc);  // OK
</code></pre>
<p>다만, 해당 방식으로 문제를 해결하는 경우, <code>loc</code>에서 값을 할당하는 시점에 실수가 있었더라도, 정작 에러는 함수를 호출하는 곳에서 발생하기 때문에, 추후 혼란을 줄 수 있다는 문제가 있습니다.</p>
<pre><code class="language-ts">function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20, 30] as const;  // error is really here.
panTo(loc);
//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to
//        parameter of type 'readonly [number, number]'
//          Types of property 'length' are incompatible
//            Type '3' is not assignable to type '2'
</code></pre>
<h2 id="객체의-경우"><a class="header" href="#객체의-경우">객체의 경우</a></h2>
<p>객체의 경우에도 이러한 문제가 동일하게 발생할 수 있습니다.</p>
<pre><code class="language-ts">type Language = 'JavaScript' | 'TypeScript' | 'Python';
interface GovernedLanguage {
  language: Language;
  organization: string;
}

function complain(language: GovernedLanguage) { /* ... */ }

complain({ language: 'TypeScript', organization: 'Microsoft' });  // OK

const ts = {
  language: 'TypeScript', // type = string
  organization: 'Microsoft', // type = string
};
complain(ts);
//       ~~ Argument of type '{ language: string; organization: string; }'
//            is not assignable to parameter of type 'GovernedLanguage'
//          Types of property 'language' are incompatible
//            Type 'string' is not assignable to type 'Language'
</code></pre>
<p>이를 해결하고자 하는 경우에도 앞선 경우들과 마찬가지로 1)타입 선언을 추가하거나, 2)상수로 만들어주는 방법이 있습니다.</p>
<pre><code class="language-ts">// 1) 타입 선언을 추가하거나
const ts: GovernedLanguage = {
  language: 'TypeScript',
  organization: 'Microsoft',
};

// 2) 상수로 만드세요.
const ts = {
  language: 'TypeScript' as const,
  organization: 'Microsoft',
};
</code></pre>
<h2 id="콜백의-경우"><a class="header" href="#콜백의-경우">콜백의 경우</a></h2>
<p>TS는 콜백 함수의 매개변수를 유추하는 경우에도 문맥이 고려됩니다. 따라서 해당 콜백 함수를 따로 분리하는 경우에도 문제가 발생합니다.</p>
<pre><code class="language-ts">function callWithRandomNumbers(fn: (n1: number, n2: number) =&gt; void) {
  fn(Math.random(), Math.random());
}

// 콜백함수의 매개변수에 타입 명시를 하지 않더라도, 문맥으로 타입을 유추해냅니다.
callWithRandomNumbers((a, b) =&gt; {
  a;  // number
  b;  // number
});

// 하지만 아래의 경우는 문맥이 유실되어 타입 추론이 불가능합니다.
const fn = (a, b) =&gt; {
  // ~    Parameter 'a' implicitly has an 'any' type
  //    ~ Parameter 'b' implicitly has an 'any' type
}
callWithRandomNumbers(fn);
</code></pre>
<p>이 경우에도 타입 선언을 통해 해결해줄 수 있습니다.</p>
<pre><code class="language-ts">// 1) 매개변수에 타입을 명시하거나
const fn = (a: number, b: number) =&gt; {
  // ...
}

// 2) 함수 자체에 타입을 명시하세요.
type CallbackFn = (n1: number, n2: number) =&gt; void;
const fn: CallbackFn = (a, b) =&gt; {
  a // number
  b // number
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수형-기법과-라이브러리로-타입-흐름-유지하기"><a class="header" href="#함수형-기법과-라이브러리로-타입-흐름-유지하기">함수형 기법과 라이브러리로 타입 흐름 유지하기</a></h1>
<p>타입스크립트 상에서는 절차형(imperative) 프로그래밍의 형태로 구현하기 보다는, 내장된 함수형 기법이나 로대시 같은 유틸리티 라이브러리를 활용하는 것이 좋습니다.</p>
<ul>
<li>타입 흐름을 개선됩니다.</li>
<li>가독성이 높아집니다.</li>
<li>명시적인 타입 구문의 필요성이 줄어듭니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-설계"><a class="header" href="#타입-설계">타입 설계</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="유효한-상태만-표현하는-타입을-지향하기"><a class="header" href="#유효한-상태만-표현하는-타입을-지향하기">유효한 상태만 표현하는 타입을 지향하기</a></h1>
<p>효과적으로 타입을 설계하려면, <strong>유효한 상태만</strong> 표현할 수 있는 타입을 만들어 내는 것이 가장 중요합니다.
좋지 않은 예시를 하나 들어봅시다.</p>
<pre><code class="language-ts">interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
</code></pre>
<p>위와 같은 상태 구성은 다음과 같은 문제를 갖습니다.</p>
<ul>
<li>로딩 중이면서 동시에 에러가 발생할 수 있습니다.</li>
<li>상태 변경에 실수를 할 여지가 있습니다. (<code>error</code>는 선택 프로퍼티이며, <code>isLoading</code>은 단순한 <code>boolean</code>이기 때문에, 타입 관점에서 실수를 줄일 방법이 없습니다.)</li>
</ul>
<p>이 경우 상태를 좀 더 적절하게 표현하는 방법은 다음과 같습니다.</p>
<pre><code class="language-ts">interface RequestPending {
  state: 'pending';
}

interface RequestError {
  state: 'error';
  error: string;
}

interface RequestSuccess {
  state: 'ok';
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: {[page: string]: RequestState};
}
</code></pre>
<p>작성해야 하는 코드의 양 자체는 늘어났지만, 이는 유효한 상태만을 다루고 있습니다.
이 덕분에, 당장에 의미없는 상태 프로퍼티를 갖게되는 경우는 없게 되어, 이를 다루기가 훨씬 편해졌습니다.
이는 코드가 길어지고, 또 표현하기 어려운 작업이지만, 결국은 시간을 절약하고 고통을 줄일 수 있는 방법입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="사용할-때는-너그럽게-생성할-때는-엄격하게"><a class="header" href="#사용할-때는-너그럽게-생성할-때는-엄격하게">사용할 때는 너그럽게, 생성할 때는 엄격하게</a></h1>
<p>보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있으며, 실제로도 이 쪽이 사용하기 용이합니다.
이를 테면 다음과 같은 함수의 예를 들 수 있습니다.</p>
<pre><code class="language-ts">interface User {
  id: number;
  username?: string;
  age?: number;
}

const updateUser = (option: User) =&gt; {
  // ...
};
</code></pre>
<p>한편, 반환 타입의 경우에는 선택적인 프로퍼티 없이 더 명확하고 엄격해야 합니다.
실제로 넓은 타입 범위를 갖는 반환 타입은 사용하기가 굉장히 불편합니다.
값을 반환받은 이후에도 타입 체킹을 해주어야하는 일이 다분하기 때문입니다.</p>
<pre><code class="language-ts">const createUser = (option: User): User =&gt; {
  return {
    ...option,
  }
}

const { username } = createUser({ id: 1, username: '김앨런', age: 27 });
// type username = string | undefined

const firstName = username.charAt(0); 
// Object is possibly 'undefined'.
</code></pre>
<p>결국 이러한 문제를 해결하려면 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)으로 각각의 상황에 대한 타입을 별도로 두는 것이 좋습니다.</p>
<pre><code class="language-ts">// 기본 형태
interface User {
  id: number;
  name: string;
  age: number;
}

// 느슨한 형태
// type UserOptions = {
//     name?: string | undefined;
//     age?: number | undefined;
//   }
type UserOptions = Partial&lt;Omit&lt;User, 'id'&gt;&gt; 

const updateUser = (id: number, options: UserOptions) =&gt; {
  // ...
}

let id = 1;

const createUser = (options: UserOptions): User =&gt; ({
  id: id++,
  name: '이름없음',
  age: 1,
  ...options,
})

const user = createUser({ name: '김앨런', age: 27 });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="문서에-타입-정보를-쓰지-않기"><a class="header" href="#문서에-타입-정보를-쓰지-않기">문서에 타입 정보를 쓰지 않기</a></h1>
<p>기본적으로 주석은 코드와 동기화되지 않습니다. 다시 말해, 열심히 주석을 작성하더라도, 그것이 최신화된 것이며, 실제로 일치할 것이라는 보장이 없습니다.
또, TS의 타입 체커가 일일이 주석을 다는 것보다 훨씬 정교하기 때문에 때문에 주석을 일일이 작성하는 것은 의미가 없습니다.
결국, 한눈에 이해가 어려운 함수에 대한 설명을 위한 용도로만 주석을 간단하게 활용하는 것이 좋습니다.</p>
<pre><code class="language-ts">/** 애플리케이션 또는 특정 페이지의 배경색을 가져옵니다. */
function getForegroundColor(page?: string): Color {
  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};
}
</code></pre>
<p>불변성(Immutability)의 경우에도, 직접 주석으로 언급하기 보다는, 애초에 <code>readonly</code> 타입 선언으로 타입스크립트가 규칙을 강제하도록 하는 편이 더 좋습니다.</p>
<pre><code class="language-ts">// 이건 좋은 방법이 아닙니다.
/** nums를 변경하지 않습니다! XD */
function sort(nums: number[]) { /* ... */ }

// 주석보다는 타입의 관점에서 강제하세요.
function sort(nums: readonly number[]) { /* ... */ }
</code></pre>
<p>입출력에 대한 설명을 덧붙이고 싶다면 JSDoc을 활용하세요.</p>
<pre><code class="language-ts">/** 
 * @param {string} [page] optional.
*/
function getForegroundColor(page?: string) {
  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};
}
</code></pre>
<p>주석 뿐만 아니라 변수명에 대해서도 이를 그대로 적용할 수 있습니다. 변수명에 굳이 타입 정보를 넣을 필요는 없습니다.</p>
<pre><code class="language-ts">let ageNum; // 이러지 말고
let age: number; // 이렇게 하세요.
</code></pre>
<p>단, 단위가 존재하는 숫자들은 예외입니다. 단위가 무엇인지 확실하지 않은 경우에는 이를 변수명에 포함하여 명확하게 해주는 것이 좋습니다.</p>
<pre><code class="language-ts">let time = 1000 // 이것 보다는
let timeMs = 10000 // 이게 좋고

let temperature = 36.5 // 이것보다는
let temperatureC = 36.5 // 이게 좋습니다.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-주변에-null값-배치하기"><a class="header" href="#타입-주변에-null값-배치하기">타입 주변에 null값 배치하기</a></h1>
<p>다음의 최대, 최솟값을 계산하는 <code>extent</code> 함수가 있다고 생각해봅시다.</p>
<pre><code class="language-ts">// WARNING : 실제로는 타입 에러가 발생합니다!
function extent(nums: number[]) {
  let min, max; // undefined, undefined
  for (const num of nums) {
    if (min === undefined) { // 최초에 min이 undefined라면 min, max 모두에 첫번째 값을 할당합니다.
      min = num;
      max = num;
    } else {
      // min에 대해서만 undefined 체킹이 이루어졌습니다.
      min = Math.min(min, num); // type min = number
      max = Math.max(max, num); // type max = number | undefined
    }
  }
  
  // 로직 만을 생각해본다면 반환 타입은 [number, number] | [undefined, undefined] 여야 하지만, 
  return [min, max];  // 실제로는 (number | undefined)[] 입니다.
}
</code></pre>
<p>위 함수는 로직 상 <code>min</code>, <code>max</code>는 둘 다 <code>undefined</code> 이거나, 둘 다 <code>undefined</code>가 아니어야 하지만, 이를 타입 체커가 인지하지 못 한다는 문제점을 갖고 있습니다.
그래서 실제로 <code>strictNullChecks</code> 환경에서 에러가 발생합니다.</p>
<h2 id="함수의-반환-타입을-null이거나-null이-아니게-만드세요"><a class="header" href="#함수의-반환-타입을-null이거나-null이-아니게-만드세요">함수의 반환 타입을 <code>null</code>이거나, <code>null</code>이 아니게 만드세요</a></h2>
<p>이걸 해결하기 위해서는 해당 값들을 하나의 객체 또는 배열에 넣어 처리하면 됩니다.
반환값이 nullish하다면 반환 타입을 하나의 객체로 만들고 반환 타입 전체가 <code>null</code>이거나, 또는 전체가 <code>null</code>이 아니도록 만드는 편이 사람과 타입체커 모두에게 명료한 코드가 됩니다.</p>
<pre><code class="language-ts">function extent(nums: number[]) {
  let result: [number, number] | null = null;
  for (const num of nums) {
    if (!result) {
      result = [num, num];
    } else {
      result = [Math.min(num, result[0]), Math.max(num, result[1])]
    }
  }
  return result; // [number, number] | null
}

const [min, max] = extent([0, 1, 2])!;
</code></pre>
<h2 id="클래스-프로퍼티에는-null이-존재하지-않게-하세요"><a class="header" href="#클래스-프로퍼티에는-null이-존재하지-않게-하세요">클래스 프로퍼티에는 <code>null</code>이 존재하지 않게 하세요</a></h2>
<p>다음과 같이 프로퍼티에 nullish한 값이 존재한다면, 인스턴스를 생성하고 난 이후와 해당 클래스의 모든 메서드를 사용하기 어렵게 만듭니다.</p>
<pre><code class="language-ts">class UserPosts {
  user: UserInfo | null;
  posts: Post[] | null;

  constructor() {
    // 최초 인스턴스 생성 시에 각 프로퍼티가 null 입니다.
    this.user = null;
    this.posts = null;
  }

  async init(userId: string) {
    // 인스턴스 생성 이후에야 데이터를 가져옵니다.
    return Promise.all([
      async () =&gt; this.user = await fetchUser(userId),
      async () =&gt; this.posts = await fetchPostsForUser(userId)
    ]);
  }

  getUserName() {
    // 각 메서드에서 매번 프로퍼티에 대한 null 체킹을 해주어야 합니다.
    if (this.user) return this.user.name;
    else return null;
  }
}

const userPost = new UserPosts();

// 인스턴스 생성 이후에도 계속 null 체킹이 필요합니다.
userPost.user // type UserInfo | null;
</code></pre>
<p>이것을 개선하려면, 인스턴스 생성 이후 프로퍼티를 채워넣는 것이 아니라, 정적 메서드를 통해 애초에 완성된 인스턴스를 생성하도록 해야합니다.</p>
<pre><code class="language-ts">class UserPosts {
  user: UserInfo;
  posts: Post[];

  constructor(user: UserInfo, posts: Post[]) {
    // 최초 인스턴스 생성 시부터 모든 프로퍼티를 갖고 있습니다.
    this.user = user;
    this.posts = posts;
  }

  static async init(userId: string): Promise&lt;UserPosts&gt; {
    // 필요한 데이터들을 애초에 다 가져온 이후에
    const [user, posts] = await Promise.all([
      fetchUser(userId),
      fetchPostsForUser(userId)
    ]);
    // 인스턴스를 생성합니다.
    return new UserPosts(user, posts);
  }

  getUserName() {
    // 이제 null 체킹이 필요 없습니다!
    return this.user.name;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="유니온의-인터페이스보다는-인터페이스의-유니온-사용하기"><a class="header" href="#유니온의-인터페이스보다는-인터페이스의-유니온-사용하기">유니온의 인터페이스보다는 인터페이스의 유니온 사용하기</a></h1>
<p>다음 형태의 유니온 프로퍼티 타입을 갖는 인터페이스가 있다고 가정해봅시다.</p>
<pre><code class="language-ts">interface Family {
  parent: KimsParents | LeesParents | ParksParents;
  child: Kim | Lee | Park;
}
</code></pre>
<p>얼핏 문제가 없는 듯 보이지만, 해당 인터페이스는 추후에 사용하기가 어렵고, 에러가 발생할 여지가 많습니다.
타입 시스템 상으로 <code>KimsParent</code>가 부모일 때 <code>child</code>가 <code>Park</code>이거나 <code>Lee</code>인 경우를 허용하기 때문입니다.</p>
<p>만약 이것을 더 나은 방법으로 모델링하려면 각각의 타입 계층을 분리된 인터페이스로 두어야 합니다.</p>
<pre><code class="language-ts">interface KimsFamily {
  parent: KimsParent;
  child: Kim;
}

interface LeesFamily {
  parent: LeesParent;
  child: Lee;
}

interface ParksFamily {
  parent: ParksParent;
  child: Park;
}

// 이제 부모 자식 간의 관계가 꼬일 일이 없습니다!
type Family = KimsFamily | LeesFamily | ParksFamily;
</code></pre>
<h2 id="tagged-union"><a class="header" href="#tagged-union">Tagged Union</a></h2>
<p>이러한 패턴을 활용하는 가장 일반적인 예시는 Tagged Union 입니다.</p>
<pre><code class="language-ts">interface KimsFamily {
  lastName: 'kim';
  parent: KimsParent;
  child: Kim;
}

interface LeesFamily {
  lastName: 'lee';
  parent: LeesParent;
  child: Lee;
}

interface ParksFamily {
  lastName: 'park';
  parent: ParksParent;
  child: Park;
}

type Family = KimsFamily | LeesFamily | ParksFamily;
</code></pre>
<p>위의 각 인터페이스에서 쓰인 <code>lastName</code>(일반적으로는 <code>type</code>과 같은 이름)이 곧 <strong>태그</strong>가 됩니다.
이 태그는 런타임에 어떤 타입의 인터페이스가 쓰이는지 판단되어 <strong>타입 좁히기</strong>에 활용됩니다.</p>
<pre><code class="language-ts">function getChild = (family: Family) =&gt; {
  if (family.lastName === 'kim') {
    // type family = KimsFamily
  } else if (family.lastName === 'lee') {
    // type family = LeesFamily
  } else {
    // type family = ParksFamily
  }
}
</code></pre>
<h2 id="관련된-optional-프로퍼티는-하나로-묶으세요"><a class="header" href="#관련된-optional-프로퍼티는-하나로-묶으세요">관련된 Optional 프로퍼티는 하나로 묶으세요</a></h2>
<p>다음과 같이 관련이 깊은 두 속성의 경우는 하나의 객체로 묶는 것이 더 나은 설계입니다. 앞선 아이템에서 말한 내용과 유사합니다.</p>
<pre><code class="language-ts">// 이것보다는
interface Person {
  name: string;
  // 아래는 둘 다 존재하거나, 둘 다 없어야 합니다.
  placeOfBirth?: string;
  dateOfBirth?: Date;
}

// 이게 낫습니다.
interface Person {
  name: string;
  // 이제 두 프로퍼티 중 하나만 존재하는 일은 없습니다.
  birth?: {
    place: string;
    date: Date;
  }
}
</code></pre>
<p>하지만, 타입 구조를 직접 손댈 수 없는 경우(ex. API의 결과)라면, 앞서 말한 인터페이스의 유니온을 사용해 관계를 모델링할 수 있습니다.</p>
<pre><code class="language-ts">
   
interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;

function eulogize(p: Person) {
  // placeOfBirth 프로퍼티가 존재한다면 PersonWithBirth 입니다.
  if ('placeOfBirth' in p) {
    p // type p = PersonWithBirth
    const { dateOfBirth } = p  // type dateOfBirth = Date
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="string-타입보다-더-구체적인-타입-사용하기"><a class="header" href="#string-타입보다-더-구체적인-타입-사용하기">string 타입보다 더 구체적인 타입 사용하기</a></h1>
<p><code>string</code> 타입은 <code>any</code>와 유사한 문제를 갖고 있습니다. 잘못 사용하게 되는 경우 무효한 값을 허용하며, 타입 간의 관계도 감추어 버립니다.
리터럴 타입과 유니온을 통해 <code>string</code>의 부분 집합을 정의하여 타입 안정성과 가독성을 크게 높일 수 있습니다.</p>
<h2 id="가능하다면-더-구체적인-타입을-사용하세요"><a class="header" href="#가능하다면-더-구체적인-타입을-사용하세요">가능하다면 더 구체적인 타입을 사용하세요</a></h2>
<pre><code class="language-ts">// 이는 너무 광범위합니다.  
interface Album {
  artist: string;
  title: string;
  releaseDate: string;  // YYYY-MM-DD
  recordingType: string;  // E.g., &quot;live&quot; or &quot;studio&quot;
}

// 이렇게 쓰세요.
type RecordingType = 'live' | 'studio';

interface Album {
  artist: string;
  title: string;
  releaseDate: Date; // 굳이 string일 이유가 없습니다.
  recordingType: RecordingType;
}
</code></pre>
<h2 id="객체-프로퍼티명을-매개변수로-가져와야-할-때는-keyof를-사용하세요"><a class="header" href="#객체-프로퍼티명을-매개변수로-가져와야-할-때는-keyof를-사용하세요">객체 프로퍼티명을 매개변수로 가져와야 할 때는 <code>keyof</code>를 사용하세요</a></h2>
<p>다음은 underscore 라이브러리에 존재하는 <code>pluck</code> 유틸함수입니다.
특정 타입의 배열에서 원하는 키의 값들만 가져온 하나의 배열을 반환합니다.</p>
<pre><code class="language-ts">function pluck&lt;T, K extends keyof T&gt;(record: T[], key: K): T[K][] {
  return record.map(r =&gt; r[key]);
}

interface User {
  name: string;
}

const users: User[] = [{ name: '짱구' }, { name: '철수' }];

pluck(users, 'name'); // ['짱구', '철수']
</code></pre>
<p>이것이 만약 단순히 <code>key</code> 매개변수를 <code>string</code> 타입으로 가져오는 형태였다면 아래와 같았을겁니다.</p>
<pre><code class="language-ts">function pluck(record: any[], key: string): any[] {
  return record.map(r =&gt; r[key]);
}
</code></pre>
<p>이 경우 해당 함수의 반환값은 <code>any[]</code> 타입이기 때문에 타입 체킹에 크게 방해가 됩니다.
따라서 객체의 프로퍼티명을 매개변수로 가져와야 하는 경우에는 타입 공간에서의 <code>keyof</code>를 적절히 사용해 더 명확한 타입을 지정해주어야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="부정확한-타입보다는-미완성-타입을-사용하기"><a class="header" href="#부정확한-타입보다는-미완성-타입을-사용하기">부정확한 타입보다는 미완성 타입을 사용하기</a></h1>
<p><strong>타입이 없는 것보다, 타입이 잘못된 것이 더 나쁩니다.</strong>
정확하게 타입을 모델링할 수 없는 상황이라면, 굳이 부정확하게 모델링하지 말아야 합니다.</p>
<p>일반적으로 <code>any</code>와 같이 매우 추상적인 타입은 정제하는 것이 좋지만, 매번 타입이 구체적일수록 정확도가 무조건적으로 올라가지는 않습니다.</p>
<h2 id="any와-unknown은-다릅니다"><a class="header" href="#any와-unknown은-다릅니다"><code>any</code>와 <code>unknown</code>은 다릅니다</a></h2>
<p><code>any</code>와 <code>unknown</code>은 둘 다 어떤 값이든 될 수 있다는 특징을 갖지만, 주요한 차이점이 하나 있습니다.</p>
<p>먼저, <code>any</code>는 어떤 값이든 될 수 있고, 동시에 어디에든 할당되고, 어떤 방식으로든 사용 가능합니다.
물론 이러한 특징들이 오히려 독이 되기 때문에, 앞선 아이템들에서도 줄곧 말해왔듯 지양하는 것이 좋습니다.
any를 사용하지 말아야 하는 이유에 대해서는 앞서 <a href="http://localhost:3000/ts/intro/no_any.html">아이템 5</a>에서 다룬 바가 있습니다.</p>
<pre><code class="language-ts">let anyVal: any = 'abc';

anyVal.theresNoMethodLikeThis(); // 문제 없음

const num: number = anyVal; // 문제 없음
</code></pre>
<p>반면, <code>unknown</code>은 어떤 값이든 될 수는 있지만, <strong>단언이나 타입 체킹 없이는 다른 타입에 할당하거나 메서드 및 프로퍼티를 참조할 수 없습니다</strong>.</p>
<pre><code class="language-ts">let unknownVal: unknown = 'abc';

unknownVal.toUpperCase(); // ERROR: Object is of type 'unknown'.(2571)

// unknown 타입인 변수를 이용하려면 
// 1. 타입을 좁히거나
if (typeof unknownVal === 'string') unknownVal.toUpperCase();

// 2. 단언을 사용해야 합니다.
const str: string = unknownVal as string;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="데이터가-아닌-api와-명세를-보고-타입-만들기"><a class="header" href="#데이터가-아닌-api와-명세를-보고-타입-만들기">데이터가 아닌, API와 명세를 보고 타입 만들기</a></h1>
<p>프로젝트를 진행하다보면, 프로젝트 외부에서 비롯된 데이터와 API를 다루게 됩니다.
이 경우 기본적으로 해당 API에서 제공되는 타입 선언(<code>@types/...</code>)을 추가하거나, 이로부터 자동 생성되는 타입들을 사용하는 것이 좋습니다.</p>
<p>직접 본인의 경험에 기반하여 타입을 작성할 수도 있지만, 이 경우 모든 예외 케이스를 커버한다고 보장할 수 없습니다.
만약 직접 타입을 작성해야 한다면, 해당 API의 명세 정보를 확인하여 이에 기반하여 작성하는 것이 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="해당-분야의-용어로-타입-이름-짓기"><a class="header" href="#해당-분야의-용어로-타입-이름-짓기">해당 분야의 용어로 타입 이름 짓기</a></h1>
<p>코드로 표현하고자 하는 모든 분야에는 주제를 설명하기 위한 전문 용어들이 이미 존재합니다.
자체적으로 용어를 만들어 내려고 하지 말고, 해당 분야에 이미 존재하는 용어를 사용해야 합니다.
이를 통해 보다 소통에 유리하게끔 하며, 타입의 명확성을 올릴 수 있습니다.</p>
<pre><code class="language-ts">interface Animal {
  name: string;
  endangered: boolean;
  habitat: string;
}

// 변수명은 leopard지만, 프로퍼티 `name` 값은 `Snow Leopard`로, 별도의 의미를 지니는 것인지 모호함
const leopard: Animal = {
  name: 'Snow Leopard', // 동물의 학명인지? 일반적인 명칭인지?
  endangered: false, // 멸종 위기종 여부인지? 멸종 여부인지?
  habitat: 'tundra', // habitat라는 뜻 자체도 모호하고, 범위도 string으로 넓음
};
</code></pre>
<p>각 프로퍼티에 대한 의미가 모호하기 때문에, 이를 작성한 사람을 찾아 의도를 물어봐야만 하는 상황이 생깁니다.
이를 개선하자면 다음과 같이 변경할 수 있습니다.</p>
<pre><code class="language-ts">interface Animal {
  commonName: string;
  genus: string;
  species: string;
  status: ConservationStatus;
  climates: KoppenClimate[];
}

type ConservationStatus = 'EX' | 'EW' | 'CR' | 'EN' | 'VU' | 'NT' | 'LC';
type KoppenClimate = |
  'Af' | 'Am' | 'As' | 'Aw' |
  'BSh' | 'BSk' | 'BWh' | 'BWk' |
  'Cfa' | 'Cfb' | 'Cfc' | 'Csa' | 'Csb' | 'Csc' | 'Cwa' | 'Cwb' | 'Cwc' |
  'Dfa' | 'Dfb' | 'Dfc' | 'Dfd' |
  'Dsa' | 'Dsb' | 'Dsc' | 'Dwa' | 'Dwb' | 'Dwc' | 'Dwd' |
  'EF' | 'ET';

// 각 프로퍼티를 보다 구체적인 용어로 대체
const snowLeopard: Animal = {
  commonName: 'Snow Leopard',
  genus: 'Panthera',
  species: 'Uncia', 
  status: 'VU',  // vulnerable =&gt; IUCN의 표준 분류 체계를 따르도록 함
  climates: ['ET', 'EF', 'Dfd'],  // alpine or subalpine =&gt; 쾨펜 기후 분류를 따르도록 함
};
</code></pre>
<p>IUCN 및 쾨펜 기후 분류에 대한 도메인 지식이 없다면 당황스러울 수는 있지만, 이 경우 정보를 찾기 위해 코드 작성자에 의존할 필요가 없습니다.
애초에 해당 분류 체계에 대한 정보를 습득하거나, 온라인에 있는 무수한 내용들을 바탕으로 이를 찾을 수 있을 겁니다.</p>
<h2 id="이름을-정할-때-명심해야-할-세가지-규칙"><a class="header" href="#이름을-정할-때-명심해야-할-세가지-규칙">이름을 정할 때 명심해야 할 세가지 규칙</a></h2>
<ol>
<li>동일한 의미를 나타낼 때는 같은 용어를 사용합니다. 정말로 의미적으로 구분이 되어야 하는 경우에만 다른 용어를 사용합니다.</li>
<li><code>data</code>, <code>info</code>, <code>thing</code>, <code>item</code>, <code>object</code>, <code>entity</code> 같은 모호하고 의미 없는 이름은 피해야 합니다. 만약 <code>entity</code>라는 용어가 해당 분야에서 특별한 의미를 지니다면 문제가 없겠지만, 귀찮다고 무심코 의미 없는 이름을 붙여서는 안됩니다.</li>
<li>이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려해야 합니다. 예를 들어, <code>INodeList</code>보다는 <code>Directory</code>가 더 의미있는 이름입니다. 구현의 측면이 아니라 개념적인 측면에서 이름을 고려하세요.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="공식-명칭에는-상표를-붙이기"><a class="header" href="#공식-명칭에는-상표를-붙이기">공식 명칭에는 상표를 붙이기</a></h1>
<p>C++, Java, Swift와 같은 언어들에서는 Nominal Typing(명시적 타이핑, 명목적 타이핑) 체계를 활용합니다.
이 말인 즉슨 똑같은 구조를 가진다고 해도 동일한 타입으로 간주되지 않는 것을 의미합니다.</p>
<pre><code class="language-ts">// 의사 코드입니다!

class Foo {
  method(input: string): number { ... }
}

class Bar {
  method(input: string): number { ... }
}

let foo: Foo = new Bar(); // ERROR!!
</code></pre>
<p>한편 앞선 <a href="ts/design//ts/intro/typing.html">아이템 4</a>에서도 말한 것 처럼, TS는 구조적 타이핑(Structural Typing) 체계를 활용합니다.
이는 다시 말해, 해당 타입의 이름이 달라도 타입이 호환되기만 한다면 이용에 아무런 문제가 없음을 의미합니다.</p>
<pre><code class="language-ts">class Foo {
  method(input: string): number { return 2; }
}
class Bar {
  method(input: string): number { return 4; }
}

let foo: Foo = new Bar(); // Okay.
</code></pre>
<p>이러한 특징은 기본적으로 JS의 덕 타이핑을 모델링하기 위해 존재하는 것입니다. 하지만 때로 이러한 특성이 문제를 일으킬 수도 있죠.</p>
<pre><code class="language-ts">
interface Vector2D {
  x: number;
  y: number;
}
function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x * p.x + p.y * p.y);
}

calculateNorm({x: 3, y: 4});  // 정상입니다.
const vec3D = {x: 3, y: 4, z: 1};
calculateNorm(vec3D);  // 놀랍게도 이 역시 정상입니다.
</code></pre>
<p>위의 코드는 구조적 타이핑 관점에서 아무런 문제가 없지만, 우리가 개념적으로 생각했을 때는 분명 문제가 있는 코드입니다.
3D 벡터는 2D 벡터 매개변수에 전달되어서는 안된다는 것이죠.</p>
<h2 id="ts에서-nominal-typing을-흉내내는-법"><a class="header" href="#ts에서-nominal-typing을-흉내내는-법">TS에서 Nominal Typing을 흉내내는 법</a></h2>
<p>아이러니하게도, TS에서 Nominal Typing 체계를 흉내내기 위해선 하나의 프로퍼티를 추가적으로 사용해야 합니다.
이를 상표 기법(Branding)이라고 하는데, <code>_brand</code> (일종의 컨벤션)라는 프로퍼티로 타입이 아닌 값의 관점에서 해당 타입이 <code>Vector2D</code>임을 나타내는 것이죠.</p>
<pre><code class="language-ts">type Vector2D = {
  _brand: '2d';
  x: number;
  y: number;
}

function vec2D(x: number, y: number): Vector2D {
  return {x, y, _brand: '2d'};
}

function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x * p.x + p.y * p.y);
}

calculateNorm(vec2D(3, 4)); // OK, returns 5

const vec3D = {x: 3, y: 4, z: 1};
calculateNorm(vec3D);
           // ~~~~~ Property '_brand' is missing in type...
</code></pre>
<h3 id="원시-타입에도-적용할-수-있습니다"><a class="header" href="#원시-타입에도-적용할-수-있습니다">원시 타입에도 적용할 수 있습니다</a></h3>
<p>해당 기법이 재미있는 이유는, 객체가 아닌 어느 타입이든 활용할 수 있다는 점 때문입니다.
이를테면, <code>string</code>이나 <code>number</code>같은 기본적으로 프로퍼티를 가질 수 없는 타입에도 적용할 수 있습니다.</p>
<pre><code class="language-ts">type AbsolutePath = string &amp; {_brand: 'abs'};

function listAbsolutePath(path: AbsolutePath) {
  // ...
}

function isAbsolutePath(path: string): path is AbsolutePath {
  return path.startsWith('/');
}

function f(path: string) {
  if (isAbsolutePath(path)) {
    // 이제 `path`는 AbsolutePath로 간주됩니다. 실제론 `_brand` 프로퍼티가 없지만요.
    listAbsolutePath(path);
  }
  listAbsolutePath(path);
                // ~~~~ Argument of type 'string' is not assignable
                //      to parameter of type 'AbsolutePath'
}
</code></pre>
<p><code>number</code> 타입의 경우에도 상표를 붙일 수는 있으나, 추가적인 연산이 이루어지게 되면 상표가 사라지기 때문에 실제 이용은 어렵습니다.</p>
<pre><code class="language-ts">type Meters = number &amp; {_brand: 'meters'};
type Seconds = number &amp; {_brand: 'seconds'};

const meters = (m: number) =&gt; m as Meters;
const seconds = (s: number) =&gt; s as Seconds;

const oneKm = meters(1000);  // Type is Meters
const oneMin = seconds(60);  // Type is Seconds

const tenKm = oneKm * 10; // Type is number
const v = oneKm / oneMin; // Type is number
</code></pre>
<h3 id="표현하기-어려운-속성을-모델링할-수-있습니다"><a class="header" href="#표현하기-어려운-속성을-모델링할-수-있습니다">표현하기 어려운 속성을 모델링할 수 있습니다</a></h3>
<p>이를테면, Array 타입 자체만으로 해당 Array가 정렬 처리되었는지에 대한 여부를 나타내는 것은 상당히 어렵습니다.</p>
<pre><code class="language-ts">type SortedList&lt;T&gt; = T[];
</code></pre>
<p>Array가 정렬되었음을 나타내려면 마찬가지로 상표 기법을 사용하면 됩니다.</p>
<pre><code class="language-ts">type SortedList&lt;T&gt; = T[] &amp; {_brand: 'sorted'};

function isSorted&lt;T&gt;(xs: T[]): xs is SortedList&lt;T&gt; {
  for (let i = 1; i &lt; xs.length; i++) {
    if (xs[i] &gt; xs[i - 1]) {
      return false;
    }
  }
  return true;
}

const list = [1, 2, 3];

if (isSorted(list)) {
  // 이제 `list`는 `SortedList` 타입입니다.
  // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="any-다루기"><a class="header" href="#any-다루기">any 다루기</a></h1>
<p><code>any</code> 타입은 기본적으로는 지양해야하는 타입이지만, 프로그램의 일부분에만 타입 시스템을 적용할 수 있다는 TS의 특성 때문에 점진적인 마이그레이션에 큰 역할을 합니다.
<code>any</code>는 매우 강력한 권한을 갖고 있어 여기저기 남용될 소지가 높은데, 해당 장에서는 <code>any</code>를 현명하게 사용하는 방법에 대해 살펴보겠습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="any-타입은-가능한-한-좁은-범위에서만-사용하기"><a class="header" href="#any-타입은-가능한-한-좁은-범위에서만-사용하기">any 타입은 가능한 한 좁은 범위에서만 사용하기</a></h1>
<h2 id="any는-선언보다-단언을-활용하기"><a class="header" href="#any는-선언보다-단언을-활용하기">any는 선언보다 단언을 활용하기</a></h2>
<pre><code class="language-ts">// 이것보다는
const x: any = expressionReturningFoo();
processBar(x);

// 이게 낫습니다.
const x = expressionReturningFoo();
processBar(x as any);
</code></pre>
<p>위에서 앞선 예시의 문제는 <code>any</code> 타입으로 선언된 <code>x</code>를 이용함에 따라 다른 코드에도 지속적으로 영향을 미치기 때문입니다.
반면, 뒤쪽 예시의 경우는 <code>processBar</code>의 호출에 대해서만 x를 <code>any</code> 타입으로 단언한 것이므로 다른 코드에는 영향을 미치지 않습니다.</p>
<h2 id="가능한-좁게-any-타입을-사용하기"><a class="header" href="#가능한-좁게-any-타입을-사용하기">가능한 좁게 any 타입을 사용하기</a></h2>
<p>특정 객체의 한 프로퍼티가 타입 에러를 갖는 상황에 <code>any</code>를 사용해야만 한다면, 객체 전체를 <code>any</code>로 단언하기 보다는 해당 속성만 <code>any</code>로 단언하는 것이 좋습니다.</p>
<pre><code class="language-ts">// 이것보다는 
// Type is any
const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: value
  }
} as any;

// 이게 낫습니다.
// Type is { a: number, b: number, c: { key: any } }
const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: value as any
  }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="any를-구체적으로-변형해서-사용하기"><a class="header" href="#any를-구체적으로-변형해서-사용하기">any를 구체적으로 변형해서 사용하기</a></h1>
<p><code>any</code>는 말그대로 만능 타입입니다. 무엇이든 될 수 있습니다. <code>any</code> 타입을 사용할 때는 <strong>정말로 모든 값이 허용되어야 하는지</strong>에 대해 검토해보아야 합니다.
거꾸로 말해, 대부분의 상황에서는 <code>any</code>보다 더 구체적으로 표현할 수 있는 타입이 존재할 가능성이 높기 때문에 가능한 더 구체적인 타입을 찾아 타입 안정성을 높이도록 해야합니다.</p>
<h2 id="배열의-경우"><a class="header" href="#배열의-경우">배열의 경우</a></h2>
<pre><code class="language-ts">// 이것보다는
function getLengthBad(array: any) {  
  return array.length;
}

// 이게 낫습니다
function getLength(array: any[]) {
  return array.length;
}
</code></pre>
<h2 id="객체의-경우-1"><a class="header" href="#객체의-경우-1">객체의 경우</a></h2>
<pre><code class="language-ts">// 이것보다는
function hasTwelveLetterKey(o: any) {
  // ...
}

// 이게 낫고
function hasTwelveLetterKey(o: {[key: string]: any}) {
  // ...
}

// 이것도 괜찮습니다
function hasTwelveLetterKey(o: object) {
  // ... 
}
</code></pre>
<p>위 예시에서 <code>{[key: string]: any}</code>와 <code>object</code>의 차이는 프로퍼티의 접근 가능 여부에 있습니다.</p>
<pre><code class="language-ts">const obj: {[key: string]: any} = { a: 1 };
const obj2: object = { a: 1 };

obj.a
obj2.a // ERROR: Property 'a' does not exist on type 'object'.
</code></pre>
<h2 id="함수의-경우"><a class="header" href="#함수의-경우">함수의 경우</a></h2>
<p>함수에 있어서도 단순히 <code>any</code>를 사용해서는 안 됩니다. 최소한으로나마 구체화할 수 있는 아래의 세가지 방법이 있습니다.</p>
<pre><code class="language-ts">type Fn0 = () =&gt; any;
type Fn1 = (arg: any) =&gt; any;
type FnN = (...args: any[]) =&gt; any;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="함수-안으로-타입-단언문-감추기"><a class="header" href="#함수-안으로-타입-단언문-감추기">함수 안으로 타입 단언문 감추기</a></h1>
<p>함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이긴 하지만, 불필요한 예외 상황까지 전부 고려해가며 타입 정보를 힘들게 구성할 필요는 없습니다.
<strong>함수 내부에는 유연하게 타입 단언을 사용하고, 함수 외부로 드러나는 타입 정의를 명확히 명시하는 정도로 끝내는 것이 낫습니다.</strong></p>
<p>프로젝트 전반에 걸쳐 위험한 타입 단언이 드러나 있는 것보다는, 제대로 타입이 정의된 함수 안으로 타입 단언문이 감추어지는 쪽이 더 좋은 설계입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="any의-진화를-이해하기"><a class="header" href="#any의-진화를-이해하기">any의 진화를 이해하기</a></h1>
<p>TS 상에서 일반적인 타입들은 모두 정제되기만 하는 반면,
<code>noImplicitAny</code>가 설정된 상태에서 암시적으로 <code>any</code> 또는 <code>any[]</code> 타입으로 추정되는 변수는 <strong>진화</strong>(evolve)합니다.
다시 말해, 이는 문맥에 따라 다른 타입으로 확장해나갑니다.</p>
<pre><code class="language-ts">const result = []; // any[]
result.push('a'); // string[]
result.push(1); // (string | number)[]

let val = null; // any -&gt; null인 경우도 암시적 any입니다.
if (Math.random() &lt; 0.5) {
val = /hello/; // RegExp
} else {
val = 12; // number
}
val // number | RegExp
</code></pre>
<h2 id="명시적인-any에서는-진화하지-않습니다"><a class="header" href="#명시적인-any에서는-진화하지-않습니다">명시적인 any에서는 진화하지 않습니다</a></h2>
<p>다만, 명시적으로 직접 <code>any</code> 타입으로 선언한 경우에는 진화가 일어나지 않습니다.</p>
<pre><code class="language-ts">let val: any;
if (Math.random() &lt; 0.5) {
val = /hello/; // any
} else {
val = 12; // any
}
val // any
</code></pre>
<h3 id="any를-진화시키기-보다는-명시적-타입-구문을-사용하세요"><a class="header" href="#any를-진화시키기-보다는-명시적-타입-구문을-사용하세요">any를 진화시키기 보다는, 명시적 타입 구문을 사용하세요</a></h3>
<p>원래 <code>number[]</code> 타입이어야 하는 변수에 실수로 <code>string</code>이 섞여 잘못 진화했을 경우에도 타입 상 문제가 없습니다.
하지만 타입을 안전하게 지키기 위해서는 암시적인 <code>any</code>를 진화시켜나가는 방식보다 명시적인 타입 구문을 사용하는 것이 더 좋은 설계입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="모르는-타입의-값에는-any-대신-unknown을-사용하기"><a class="header" href="#모르는-타입의-값에는-any-대신-unknown을-사용하기">모르는 타입의 값에는 any 대신 unknown을 사용하기</a></h1>
<p><code>any</code>, <code>unknown</code>, <code>never</code> 타입은 각각 다음의 특징을 갖고 있습니다.</p>
<ul>
<li><code>any</code>는
<ul>
<li>어떠한 타입이든 <code>any</code> 타입에 할당 가능하고</li>
<li><code>any</code> 타입 본인도 어떤 타입에든 할당 가능합니다.</li>
</ul>
</li>
<li><code>unknown</code>은
<ul>
<li>어떠한 타입이든 <code>unknown</code> 타입에 할당 가능하지만</li>
<li><code>unknown</code> 타입은 오직 <code>any</code>와 <code>unknown</code>에만 할당 가능합니다.</li>
</ul>
</li>
<li><code>never</code>는
<ul>
<li>어떠한 타입도 <code>never</code> 타입에 할당할 수 없지만</li>
<li><code>never</code> 타입은 어디에든 할당할 수 있습니다.</li>
</ul>
</li>
</ul>
<p>이를 코드로 간단하게 살펴보면 다음과 같습니다.</p>
<pre><code class="language-ts">let anyVal: any;
let unknownVal: unknown;
let neverVal: never;

anyVal = '123'; // 무엇이든 할당 가능하고
const stringVal: string = anyVal; // 어디에든 할당 가능합니다.

unknownVal = 123; // 무엇이든 할당 가능하지만
const numVal: number = unknownVal; // 어디든 할당할 수는 없습니다. (any와 unknown에만 가능)
// ERROR: Type 'unknown' is not assignable to type 'number'.(2322)

// ERROR: Type 'string' is not assignable to type 'never'.(2322)
neverVal = '123'; // 어떤 타입도 할당할 수 없지만
const stringVal2: string = neverVal; // 어디든 할당할 수는 있습니다.
</code></pre>
<h2 id="unknown-타입으로-타입-변환을-강제하세요"><a class="header" href="#unknown-타입으로-타입-변환을-강제하세요">unknown 타입으로 타입 변환을 강제하세요</a></h2>
<p>기본적으로 <code>unknown</code> 타입은 그대로 사용할 수가 없는 상태이기 때문에, 별도의 <strong>타입 단언</strong>이나 <strong>타입 좁히기</strong>가 이루어져야 합니다.</p>
<pre><code class="language-ts">// 타입 단언
interface Book {
  name: string;
  author: string;
}

function safeParseYAML(yaml: string): unknown {
  return parseYAML(yaml);
}

const book = safeParseYAML(`
  name: Villette
  author: Charlotte Brontë
`) as Book; // 이제 이건 Book 타입입니다.

// 타입 좁히기
function isBook(val: unknown): val is Book {
  return (
      typeof(val) === 'object' &amp;&amp; val !== null &amp;&amp;
      'name' in val &amp;&amp; 'author' in val
  );
}

function processValue(val: unknown) {
  if (isBook(val)) {
    val;  // Type is Book
  }
}
</code></pre>
<h2 id="제너릭-대신에-unknown을-이용할-수-있는-경우-unknown이-낫습니다"><a class="header" href="#제너릭-대신에-unknown을-이용할-수-있는-경우-unknown이-낫습니다">제너릭 대신에 <code>unknown</code>을 이용할 수 있는 경우, <code>unknown</code>이 낫습니다</a></h2>
<p>제너릭을 사용한 스타일은 타입 단언문과 달라 보이지만, 기능은 동일합니다.
제너릭보다는 <code>unknown</code>을 반환하고 사용자가 직접 단언문을 사용하거나 원하는 대로 타입을 좁히도록 강제하는 것이 좋습니다.</p>
<pre><code class="language-ts">// 이것보다는
function safeParseYAML&lt;T&gt;(yaml: string): T {
  return parseYAML(yaml);
}

safeParseYAML&lt;Book&gt;(`
  name: Villette
  author: Charlotte Brontë`
);

// unknown이 낫습니다.
function safeParseYAML(yaml: string): unknown {
  return parseYAML(yaml);
}

const book = safeParseYAML(`
  name: Villette
  author: Charlotte Brontë
`) as Book;
</code></pre>
<h2 id="단언의-경우에도-any보다는-unknown을-사용하세요"><a class="header" href="#단언의-경우에도-any보다는-unknown을-사용하세요">단언의 경우에도 any보다는 unknown을 사용하세요</a></h2>
<pre><code class="language-ts">declare const foo: Foo;
let barAny = foo as any as Bar;
let barUnk = foo as unknown as Bar;
</code></pre>
<p>기능적으로 위의 <code>barAny</code>와 <code>barUnk</code>는 동일하지만, 추후 리팩토링을 염두한다면 <code>unknown</code>을 사용하는 쪽이 더 안전합니다.
<code>any</code>의 경우 분리되는 순간 그 영향력이 널리 퍼지게되지만, <code>unknown</code>의 경우 그 시점에 즉시 에러를 발생시키므로 더 안전합니다.</p>
<h2 id="와-object"><a class="header" href="#와-object">{}와 object</a></h2>
<p><code>unknown</code> 타입과 유사한 두 가지 타입이 있습니다.</p>
<ul>
<li><code>{}</code> 타입은 <code>null</code>과 <code>undefined</code>를 제외한 모든 값이 될 수 있습니다.</li>
<li><code>object</code> 타입은 모든 비기본형(non-primitive) 타입으로 이루어집니다.</li>
</ul>
<p><code>unknown</code> 타입이 생겨나기 전에는 <code>{}</code>가 일반적으로 사용되었으나, 최근에는 이를 이용하는 경우가 드뭅니다.
정말로 <code>null</code>과 <code>undefined</code>가 불가능하다고 판단되는 경우에만 <code>unknown</code> 대신 <code>{}</code>를 사용하면 됩니다.</p>
<pre><code class="language-ts">let bracket: {};
bracket = [];
bracket = {
    a: 1,
    b: 2,
}
bracket = 1;
bracket = undefined;
bracket = null;

let obj: object;
obj = [];
obj = {
    a: 1,
    b: 2,
}
obj = 1;
obj = 'a';
obj = undefined;
obj = null;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="몽키-패치보다는-안전한-타입을-사용하기"><a class="header" href="#몽키-패치보다는-안전한-타입을-사용하기">몽키 패치보다는 안전한 타입을 사용하기</a></h1>
<p>JS는 이미 생성된 객체와 클래스에 임의의 속성을 추가할 수 있습니다.
이러한 패턴을 통해 <code>window</code>나 <code>document</code>에 값을 할당하여 전역 변수를 만드는데 사용할 수 있죠.
이렇듯 런타임 시점에서 사용되는 프로토타입이나 글로벌 객체 등에 직접 변경을 가하는 것을 <strong>몽키 패치</strong>라고 합니다.
그러나 이는 일반적으로 좋은 생각이 아닙니다.</p>
<ul>
<li>서로 멀리 떨어진 부분들 간에 의존성이 생기고, 예상치 못한 사이드 이펙트를 유발합니다.</li>
<li>TS의 경우, 기본적으로 이렇게 임의로 추가된 속성에 대해서는 알 방법이 없습니다.</li>
</ul>
<p>이 중 두번째 문제의 경우, 해결하기 위한 가장 쉬운 방법은 해당 객체를 <code>any</code>로 두는 것입니다.
하지만, 이 때는 타입 안정성을 상실하고, 언어 서비스를 사용할 수 없게 됩니다.</p>
<pre><code class="language-ts">(document as any).monky = 'Tamarin';
(document as any).monkey = /Tamarin/;
</code></pre>
<p>가장 좋은 해결책은 애초에 글로벌 객체로부터 데이터를 분리하는 것입니다.
하지만, 분리할 수 없는 상황인 경우 두 가지 차선책이 존재합니다.</p>
<h2 id="1-인터페이스의-보강augmentation-기능을-사용"><a class="header" href="#1-인터페이스의-보강augmentation-기능을-사용">1. 인터페이스의 보강(augmentation) 기능을 사용</a></h2>
<pre><code class="language-ts">export {};

// 모듈 관점에서 제대로 동작하려면 `global` 선언이 필요합니다.
declare global {
  interface Document {
    monkey: string;
  }
}

document.monkey = 'Tamarin';  // OK
</code></pre>
<p>이 방법은 <code>any</code>보다 타입 안전성 측면에서도 더 안전하고, 에디터 상에서 제대로 된 피드백도 전달 받을 수 있습니다.
하지만, 보강은 전역적으로 적용되기 떄문에, 코드의 다른 부분이나 라이브러리로부터 분리할 수 없다는 단점이 있습니다.
또, 런타임 시점에서 이러한 보강을 적용할 방법이 없습니다. (런타임 도중에 프로퍼티가 추가되는 경우)
이러한 문제 때문에 프로퍼티를 optional하게 두게 되는데, 이 경우 더 정확할 수는 있으나 다루기에는 더 어려워집니다.</p>
<h2 id="2-더-구체적인-타입-단언문을-사용"><a class="header" href="#2-더-구체적인-타입-단언문을-사용">2. 더 구체적인 타입 단언문을 사용</a></h2>
<pre><code class="language-ts">interface MonkeyDocument extends Document {
  monkey: string;
}

(document as MonkeyDocument).monkey = 'Macaque';
</code></pre>
<p>이 방법은 직접적으로 <code>Document</code> 타입을 건드리지 않고 새로운 타입을 도입했기 때문에 앞선 방법에서의 모듈 영역의 문제를 해결할 수 있습니다.
이 경우 몽키 패치된 프로퍼티를 참조하는 경우에만 해당 단언을 사용하거나, 새로운 변수를 도입하면 됩니다.</p>
<p>하지만, 기본적으로 몽키 패치는 남용해서는 안 되며, 궁극적으로 더 잘 설계된 구조로 리팩토링하는 것이 올바른 방향입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-커버리지를-추적하여-타입-안정성-유지하기"><a class="header" href="#타입-커버리지를-추적하여-타입-안정성-유지하기">타입 커버리지를 추적하여 타입 안정성 유지하기</a></h1>
<p><code>noImplicitAny</code>를 설정하더라도, 여전히 <code>any</code> 타입은 프로그램 내에 존재할 수 있습니다.</p>
<ul>
<li>명시적 <code>any</code> 타입</li>
<li>서드파티 타입 선언 (<code>@types</code>)</li>
</ul>
<p><code>any</code> 타입은 프로그램 전반에 부정적 영향을 끼칠 수 있으므로 개수를 추적하는 것이 좋습니다.
다음의 <code>type-coverage</code> 패키지를 활용하면 <code>any</code>를 추적할 수 있습니다.</p>
<pre><code class="language-zsh">npx type-coverage
</code></pre>
<p><code>--detail</code> 플래그를 붙이면, <code>any</code> 타입이 있는 곳을 전부 출력해줍니다.</p>
<pre><code class="language-zsh">npx type-coverage --detail
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-선언과-types"><a class="header" href="#타입-선언과-types">타입 선언과 @types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="devdependencies에-typescript와-types-추가하기"><a class="header" href="#devdependencies에-typescript와-types-추가하기">devDependencies에 typescript와 @types 추가하기</a></h1>
<p>npm은 3가지 종류의 의존성을 구분해서 관리하며, 각각의 의존성은 <code>package.json</code> 파일 내의 별도 영역에 들어 있습니다.</p>
<ul>
<li>dependencies: 현재 프로젝트 실행에 필수적인 라이브러리</li>
<li>devDependencies: 현재 프로젝트의 개발/테스트에 사용되지만, 런타임에 필요없는 라이브러리</li>
<li>peerDependencies: 런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리</li>
</ul>
<p>TS와 관련된 대부분의 라이브러리는 일반적으로 런타임에는 영향을 미치지 않기 때문에 devDependencies에 속합니다.</p>
<p>모든 타입스크립트 프로젝트에서 공통적으로 고려해야 할 의존성 두 가지를 살펴보겠습니다.</p>
<h2 id="1-타입스크립트-자체-의존성을-고려해야-합니다"><a class="header" href="#1-타입스크립트-자체-의존성을-고려해야-합니다">1. 타입스크립트 자체 의존성을 고려해야 합니다</a></h2>
<p>TS를 시스템 레벨로 설치할 수도 있지만, 다음의 두 이유 때문에 추천하지 않습니다.</p>
<ul>
<li>팀원들 모두가 동일한 버전을 설치한다는 보장이 없습니다.</li>
<li>프로젝트 셋업 시 별도의 단계가 추가됩니다.</li>
</ul>
<p>결국, 따로 시스템 레벨로 설치를 하기 보다는, devDependencies에 포함시켜 단순히 <code>npm install</code> 명령만으로 모두 동일한 버전의 타입스크립트를 쉽게 설치하도록 하는 편이 좋습니다.</p>
<h2 id="2-타입-의존성types를-고려해야-합니다"><a class="header" href="#2-타입-의존성types를-고려해야-합니다">2. 타입 의존성(@types)를 고려해야 합니다</a></h2>
<p>사용하는 라이브러리 자체적으로 <code>@types</code>가 포함되어 있지 않더라도, <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTypes</a>에서 타입 정보를 얻을 수 있습니다.
이 경우, 원본 라이브러리 자체는 dependencies에 있더라도 <code>@types</code> 의존성은 devDependencies에 위치해야 합니다.</p>
<p>예를 들어, React의 경우에는 다음과 같습니다.</p>
<pre><code class="language-zsh">npm install react
npm install --save-dev @types/react
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입-선언과-관련된-세-가지-버전-이해하기"><a class="header" href="#타입-선언과-관련된-세-가지-버전-이해하기">타입 선언과 관련된 세 가지 버전 이해하기</a></h1>
<p>TS를 사용하게 되면 의존성 관리가 더 복잡해집니다. 왜냐하면 다음 세 가지 사항을 추가로 고려해야 하기 때문입니다.</p>
<ul>
<li>라이브러리의 버전</li>
<li>타입 선언(<code>@types</code>)의 버전</li>
<li>타입스크립트의 버전</li>
</ul>
<p>이 셋 중 하나라도 맞지 않으면, 의존성과 상관없어 보이는 곳에서 엉뚱한 오류가 발생할 수 있습니다.</p>
<h2 id="라이브러리와-타입-정보의-버전이-별도로-관리되는-경우"><a class="header" href="#라이브러리와-타입-정보의-버전이-별도로-관리되는-경우">라이브러리와 타입 정보의 버전이 별도로 관리되는 경우</a></h2>
<p>일반적으로는 특정 라이브러리를 dependencies로 설치하고, 타입 정보를 devDependencies로 설치하게 됩니다.</p>
<pre><code class="language-zsh">npm install react
+ react16.8.6

npm install --save-dev @types/react
+ @types/react@16.8.19
</code></pre>
<p>이 때, 메이저 버전과 마이너 버전이 일치하지만 패치 버전이 일치하지 않는다는 점에 주목합시다.
<code>@types/react</code>의 <code>16.8.19</code>는 타입 선언들이 React 16.8 버전의 API를 나타냄을 의미합니다.</p>
<p>React 모듈이 시맨틱 버전 규칙을 제대로 지킨다고 가정하면 패치 버전들은 공개 API의 사양을 변경하지 않습니다.
여기서 패치(patch) 버전인 <code>.19</code>의 경우는 타입 선언 자체의 버그나 누락에 따른 수정과 추가에 따른 것입니다.
앞서 React와 해당 타입 선언의 버전에 차이가 생긴 것은 라이브러리 자체보다 타입 선언에 더 많은 업데이트가 있었기 떄문입니다. (<code>19</code> vs. <code>6</code>)</p>
<p>다만, 별도로 버전을 관리하는 경우 다음의 네 가지 문제점이 있습니다.</p>
<ol>
<li>라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않는 경우
<ul>
<li>타입 선언도 업데이트하여 버전을 맞추어줘야 합니다. </li>
<li>단, 해당 버전이 준비되지 않은 경우, 임시적으로 보강을 활용할 수 있습니다.</li>
</ul>
</li>
<li>라이브러리보다 타입 선언의 버전이 최신인 경우
<ul>
<li>라이브러리를 업데이트하거나, 타입 버전을 낮추어야 합니다.</li>
</ul>
</li>
<li>프로젝트에서 사용하는 TS 버전보다 라이브러리에서 필요로 하는 TS 버전이 최신인 경우
<ul>
<li>프로젝트의 타입스크립트의 버전을 업데이트하거나</li>
<li>라이브러리의 타입 선언 버전을 낮추거나</li>
<li><code>declare module</code> 선언으로 라이브러리의 타입 정보를 없애 버릴 수 있습니다.</li>
<li>라이브러리에서 <code>typesVersions</code>를 통해 TS 버전 별로 다른 타입 선언을 제공하는 방법도 있으나, 실제로 이 경우는 매우 드뭅니다.</li>
<li>특정 버전에 대한 타입 정보를 설치하려면 <code>npm install --save-dev @types/lodash@ts.31</code>와 같이 실행하면 됩니다.</li>
</ul>
</li>
<li>라이브러리 간 <code>@types</code> 의존성이 중복되는 경우
<ul>
<li><code>npm ls @types/foo</code>와 같은 실행으로 타입 선언 중복이 어디서 발생했는지 추적합니다.</li>
<li>해당 라이브러리들을 업데이트하여 서로 버전이 호환되게끔 합니다.</li>
<li>단, 애초에 <code>@types</code>가 전이(transitive) 의존성을 갖지 않도록 설계되는 것이 좋습니다. 이에 대해서는 아이템 51에서 다룰 예정입니다.</li>
</ul>
</li>
</ol>
<h2 id="타입-정보가-라이브러리-자체적으로-관리되는-경우"><a class="header" href="#타입-정보가-라이브러리-자체적으로-관리되는-경우">타입 정보가 라이브러리 자체적으로 관리되는 경우</a></h2>
<p>일부 라이브러리, 특히 TS로 작성된 라이브러리들은 자체적으로 타입 선언을 포함(bundling)하게 됩니다.
자체 타입 선언은 보통 <code>package.json</code>의 <code>types</code>필드에서 <code>.d.ts</code> 파일을 가리키도록 되어 있습니다.</p>
<pre><code class="language-json">{
  // ...
  &quot;types&quot;: &quot;index.d.ts&quot;,
  // ...
}
</code></pre>
<p>타입 정보를 라이브러리 자체적으로 관리하는 경우 라이브러리와 타입 선언 간의 버전 불일치 문제를 해결하긴 합니다.
그러나 번들링 방식은 부수적인 네 가지 문제점을 갖고 있습니다.</p>
<ol>
<li>번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했으나 TS 버전이 올라가며 오류가 발생하는 경우
<ul>
<li>번들된 타입에서는 별도로 <code>@types</code>의 버전 선택이 불가능하다는 문제점이 있습니다.</li>
</ul>
</li>
<li>프로젝트 내 타입 선언이 다른 라이브러리의 타입 선언에 의존하는 경우
<ul>
<li>해당 프로젝트를 다른 이용자가 설치하여 사용하게 되는 경우 별도로 <code>devDependencies</code>가 설치되지 않으므로 타입 에러가 발생합니다.</li>
<li>또, JS 사용자 입장에서는 <code>@types</code>를 설치할 이유가 없기 때문에 dependencies에 포함하고 싶지 않을 것입니다.</li>
<li>이러한 상황에 대한 해결책에 대해서는 아이템 51에서 다룰 예정입니다.</li>
</ul>
</li>
<li>프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우
<ul>
<li>라이브러리 자체의 과거 버전으로 돌아가서 패치 업데이트를 해야합니다.</li>
</ul>
</li>
<li>타입 선언의 패치 업데이트를 자주 하기가 어렵습니다.
<ul>
<li>라이브러리 자체보다 타입 선언에 대한 패치 업데이트가 훨씬 많을 수 있는데, @types의 경우 커뮤니티에서 관리되기 때문에 이러한 작업량이 감당될 수 있으나, 직접 프로젝트를 처리하려면 시간이 많이 소요되는 작업입니다.</li>
</ul>
</li>
</ol>
<h2 id="어느-쪽을-선택해야-할까요"><a class="header" href="#어느-쪽을-선택해야-할까요">어느 쪽을 선택해야 할까요?</a></h2>
<p>공식적인 권장 사항은 <strong>라이브러리가 TS로 작성된 경우에만 타입 선언을 라이브러리에 포함하는 것입니다.</strong>
실제로 TS 컴파일러가 타입 선언을 대신 생성해 주기 때문에, TS로 작성된 라이브러리에 타입 선언을 포함하는 방식은 잘 동작합니다.</p>
<p>JS로 작성된 라이브러리라면 손수 작성한 타입 선언은 오류가 있을 가능성이 높고, 잦은 업데이트가 필요하게 됩니다.
이 경우에는 타입 선언을 DefinitelyTyped에 공개하여 커뮤니티에서 관리하고 유지보수하도록 맡기는 것이 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="공개-api에-등장하는-모든-타입을-export하기"><a class="header" href="#공개-api에-등장하는-모든-타입을-export하기">공개 API에 등장하는 모든 타입을 export하기</a></h1>
<p>공개된 메서드에 등장한 어떤 형태의 타입이든 익스포트를 하는 것이 좋습니다.
어차피 메서드 자체가 공개된 이상, 라이브러리 사용자가 추출이 가능하므로, 애초에 익스포트하여 이용하기 쉬운 형태로 만드는 편이 좋습니다.</p>
<pre><code class="language-ts">interface SecretName {
  first: string;
  last: string;
}

interface SecretSanta {
  name: SecretName;
  gift: string;
}

export function getGift(name: SecretName, gift: string): SecretSanta {
  // COMPRESS
  return {
    name: {
      first: 'Dan',
      last: 'Van',
    },
    gift: 'MacBook Pro',
  };
  // END
}
</code></pre>
<p>이를테면, 위의 경우에 타입을 숨기기 위해서 일부러 각 인터페이스에 대해 <code>export</code>를 하지 않았다고 하더라도, 어차피 사용자는 해당 인터페이스의 타입을 추출할 수 있습니다.</p>
<pre><code class="language-ts">type MySanta = ReturnType&lt;typeof getGift&gt;;  // type SecretSanta
type MyName = Parameters&lt;typeof getGift&gt;[0];  // type SecretName
</code></pre>
<p>다시 말해, 공개 API에 해당 타입들이 이용되는 순간, 어차피 해당 타입들은 노출된 상태이기 때문에 굳이 숨기려 하지 말고 라이브러리 이용자들을 위해 명시적으로 export하는 것이 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="api-주석에-tsdoc-사용하기"><a class="header" href="#api-주석에-tsdoc-사용하기">API 주석에 TSDoc 사용하기</a></h1>
<p>공개 API 이용자를 위한 주석을 덧붙이는 경우 JSDoc 형태로 작성해야 합니다.
TS 언어 서비스는 JSDoc 스타일을 지원하기 때문에 적극적으로 활용하는 것이 좋습니다.
이는 타입스크립트 관점에서 TSDoc이라 부르기도 합니다.</p>
<p><code>@param</code>와 <code>@returns</code>를 추가하면 함수를 호출하는 부분에서 각 매개변수와 관련된 설명을 보여줍니다.</p>
<pre><code class="language-ts">/**
 * Generate a greeting.
 * @param name Name of the person to greet
 * @param salutation The person's title
 * @returns A greeting formatted for human consumption.
 */
function greetFullTSDoc(name: string, title: string) {
  return `Hello &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{name}`;
}
</code></pre>
<p>타입 정의에 TSDoc을 사용할 수도 있습니다.
이 경우 객체의 각 필드에 커서를 올려보면 필드 별로 설명을 볼 수 있게 됩니다.</p>
<pre><code class="language-ts">interface Vector3D {}

/** A measurement performed at a time and place. */
interface Measurement {
  /** Where was the measurement made? */
  position: Vector3D;
  /** When was the measurement made? In seconds since epoch. */
  time: number;
  /** Observed momentum */
  momentum: Vector3D;
}

</code></pre>
<p>또, TSDoc 주석은 마크다운 형식으로 꾸며지므로 마크다운 문법을 사용할 수 있습니다.</p>
<pre><code class="language-ts">/**
 * This _interface_ has **three** properties:
 * 1. x
 * 2. y
 * 3. z
 */
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
</code></pre>
<p>주의해야 할 점으로, JSDoc의 경우 타입 정보를 명시하는 규칙(<code>@param {string} name</code>이 있지만, TS에서는 타입 정보를 코드를 통해 확인할 수 있으므로 이를 TSDoc 상에서 명시해선 안 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="콜백에서-this에-대한-타입-제공하기"><a class="header" href="#콜백에서-this에-대한-타입-제공하기">콜백에서 this에 대한 타입 제공하기</a></h1>
<p>JS에서의 <code>this</code> 키워드는 매우 혼란스러운 기능입니다.
<code>let</code>이나 <code>const</code>로 선언된 변수가 렉시컬 스코프(Lexical Scope)인 반면, <code>this</code>는 다이나믹 스코프(Dynamic Scope)입니다.
이는 정의된 방식이 아니라, 호출된 방식에 따라 가리키는 값이 달라집니다.</p>
<p><code>this</code>는 전형적으로 객체의 현재 인스턴스를 참조하는 클래스에서 가장 많이 쓰입니다.</p>
<pre><code class="language-js">class C {
  vals = [1, 2, 3];
  logSquares() {
    for (const val of this.vals) {
      console.log(val * val);
    }
  }
}

const c = new C();
c.logSquares();

// 1
// 4
// 9
</code></pre>
<p>위 상황에서 <code>logSquares</code>에서 사용된 <code>this</code>는 변수 <code>c</code>를 가리키게 됩니다.
한편, 이것을 외부 변수에 넣고 호출하면 어떻게 되는지 살펴봅시다.</p>
<pre><code class="language-js">const c = new C();
const method = c.logSquares; // losing this
method(); // ERROR
</code></pre>
<p>이러한 에러가 발생하는 이유는, 사실 <code>c.logSquares</code>의 호출이 실제로는 두 가지 작업을 수행하기 떄문입니다.</p>
<ul>
<li><code>this</code>의 값을 바인딩합니다.</li>
<li><code>C.prototype.logSquares</code>를 호출합니다.</li>
</ul>
<p>이를 JS 상에서 온전히 제어하기 위해서는 명시적으로 <code>this</code>를 바인딩해주어야 하는데, 이를 위해 <code>call</code>, <code>apply</code>, <code>bind</code>와 같은 메서드들이 존재합니다.</p>
<p>이러한 <code>this</code> 바인딩은 종종 콜백함수에서 쓰입니다. React의 예시를 봅시다.
다음 예시에서 바인딩을 하지 않는다면 <code>render</code> 메서드 실행 시 <code>this</code>가 <code>undefined</code>가 되는 문제가 생깁니다.</p>
<pre><code class="language-ts">class ResetButton {
  constructor() {
    this.onClick = this.onClick.bind(this);
  }
  render() {
    return makeButton({text: 'Reset', onClick: this.onClick});
  }
  onClick() {
    alert(`Reset {this}`);
  
}
</code></pre>
<p>화살표 함수를 사용하면 더 쉽게 이를 해결할 수 있습니다.
화살표 함수로 메서드를 변경하면 해당 클래스의 인스턴스의 생성할 때마다 제대로 바인딩된 <code>this</code>를 가진 새 함수를 생성합니다.</p>
<pre><code class="language-ts">class ResetButton {
  render() {
    return makeButton({text: 'Reset', onClick: this.onClick});
  }
  onClick = () =&gt; {
    alert(`Reset {this}`);  // &quot;this&quot;가 항상 인스턴스를 참조합니다.
  }
}
</code></pre>
<p>이는 실제로는 다음과 같이 동작합니다.</p>
<pre><code class="language-ts">class ResetButton {
  constructor() {
    var _this = this;
    this.onClick = function () { // 인스턴스의 생성 시점에 `onClick` 함수를 선언합니다.
      alert(&quot;Reset &quot; + _this);
    };
  }
  render() {
    return makeButton({text: 'Reset', onClick: this.onClick});
  }
}
</code></pre>
<h2 id="ts에서-this가-사용되는-콜백-함수를-다루기"><a class="header" href="#ts에서-this가-사용되는-콜백-함수를-다루기">TS에서 <code>this</code>가 사용되는 콜백 함수를 다루기</a></h2>
<p>콜백 함수 상에서 <code>this</code>가 사용된다면 그 자체가 API의 일부가 되는 것이기 때문에 반드시 타입 선언에 포함되어야 합니다.</p>
<pre><code class="language-ts">// 콜백함수인 `fn` 내부에서 `this`를 사용한다고 가정합시다.
function addKeyListener(
  el: HTMLElement,
  fn: (this: HTMLElement, e: KeyboardEvent) =&gt; void
) {
  el.addEventListener('keydown', e =&gt; {
    fn.call(el, e);
  });
}
</code></pre>
<p>이 때 해당 콜백 함수 타입의 첫 번째 매개변수에 있는 <code>this</code>는 실제론 사용 시점에는 매개변수로 여겨지지 않으며, 특별하게 처리됩니다.
만약 해당 콜백 함수를 <code>this</code> 바인딩 없이 그냥 실행하려고 하는 경우에 에러를 출력하게끔 하여, 바인딩을 강제하도록 합니다.</p>
<pre><code class="language-ts">function addKeyListener(
  el: HTMLElement,
  fn: (this: HTMLElement, e: KeyboardEvent) =&gt; void
) {
  el.addEventListener('keydown', e =&gt; {
    fn(e); // The 'this' context of type 'void' is not assignable to method's 'this' of type 'HTMLElement'.(2684)
    fn(el, e); // Expected 1 arguments, but got 2.(2554)
    fn.call(el, e); // OK.
  });
}
</code></pre>
<p>또, <code>this</code>를 사용하는 해당 콜백함수를 작성하는 시점에 <code>this</code>에 대한 타입이 명확하게 추론되기 때문에 타입 안정성을 확보할 수 있습니다.</p>
<pre><code class="language-ts">const el = document.getElementById('div')!;
addKeyListener(el, function(e) {
  // 앞선 타입 선언에 덕분에 알아서 `this`에 대한 타입을 추론합니다.
  this.innerHTML; // this는 HTMLElement 입니다.
});
</code></pre>
<p>만약 화살표 함수를 사용하여 <code>this</code>를 참조하려고 하는 경우, 해당 <code>this</code>는 다른 것을 가리킬 것이기 때문에 적절히 에러를 출력해냅니다.</p>
<pre><code class="language-ts">class Foo {
  registerHandler(el: HTMLElement) {
    addKeyListener(el, e =&gt; {
      // 여기서의 `this`는 Foo의 인스턴스가 됩니다.
      this.innerHTML;
        // ~~~~~~~~~ Property 'innerHTML' does not exist on type 'Foo'
    });
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="오버로딩-타입보다는-조건부-타입을-사용하기"><a class="header" href="#오버로딩-타입보다는-조건부-타입을-사용하기">오버로딩 타입보다는 조건부 타입을 사용하기</a></h1>
<p>오버로딩 타입을 사용하면 하나의 함수가 여러 타입에 대해 동작하는 경우에 대한 타입을 명시할 수 있습니다. (아이템 3)
허나 경우에 따라 해결하기가 까다로운 타입 선언 문제가 있을 수 있습니다.</p>
<pre><code class="language-ts">function double(x: any) { return x + x; }

// 1. 유니온 타입으로 한번에 선언하는 방법
// 선언이 모호합니다. string =&gt; number 또는 number =&gt; string의 경우도 인정합니다.
function double(x: number | string): number | string;
const num = double(12);  // string | number
const str = double('x');  // string | number

// 2. 제너릭을 사용하는 방법
// 타입이 구체적이긴 하나, 틀린 타입 선언입니다.
function double&lt;T extends number | string&gt;(x: T): T;
const num = double(12);  // Type is 12 =&gt; WRONG: 144여야 합니다.
const str = double('x');  // Type is &quot;x&quot; =&gt; WRONG: &quot;xx&quot;여야 합니다.

// 3. 여러 번에 걸쳐 타입 선언을 하는 방법
// 타입이 비교적 명확하나, 유니온 타입과 관련해서 문제가 발생합니다.
function double(x: number): number;
function double(x: string): string;
const num = double(12);  // Type is number
const str = double('x');  // Type is string
const f = (x: number | string) =&gt; double(x); // ERROR: Argument of type 'string | number' is not assignable to parameter of type 'string'.
</code></pre>
<p>이를 해결하기 위한 가장 좋은 해결책은 <b>조건부 타입(Conditional Type)</b>을 사용하는 것입니다.
조건부 타입은 타입 공간의 <code>if</code> 구문과 같습니다.
이 경우, 이전에 문제가 발생했던 모든 경우들에 대해 정상적으로 동작합니다.</p>
<pre><code class="language-ts">
function double&lt;T extends number | string&gt;(
  x: T
): T extends string ? string : number;

const num = double(12);  // Type is number
const str = double('x');  // Type is string
const f = (x: number | string) =&gt; double(x); // Type is (x: string | number) =&gt; string | number;
</code></pre>
<p>조건부 타입은 개별 타입의 유니온으로 일반화하는 과정을 거치기 때문에 타입이 보다 정확해집니다.
각각의 오버로딩 타입이 독립적으로 처리되는 반면, 조건부 타입은 타입 체커가 단일 표현식으로 받아들이기 때문에 유니온 문제를 해결할 수 있습니다.</p>
<p>이러한 장점으로 인해, 오버로딩 타입을 작성 중이라면, 조건부 타입을 사용해서 개선할 수 있을지 검토해 보는 것이 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="의존성-분리를-위해-미러-타입-사용하기"><a class="header" href="#의존성-분리를-위해-미러-타입-사용하기">의존성 분리를 위해 미러 타입 사용하기</a></h1>
<p>직접 TS로 라이브러리를 작성하여 공개할 때는 필요 이상으로 의존성을 갖는 것을 피해야 합니다.
이를테면, 아래처럼 CSV 파일을 파싱하는 함수를 만든다고 할 때, NodeJS 사용자를 위해 매개변수에 Buffer 타입을 허용하였다고 가정합시다.</p>
<pre><code class="language-ts">function parseCSV(contents: string | Buffer): {[column: string]: string}[]  {
  if (typeof contents === 'object') {
    // It's a buffer
    return parseCSV(contents.toString('utf8'));
  }
  // ...
}
</code></pre>
<p>여기서 쓰인 <code>Buffer</code> 타입은 NodeJS에 대한 타입 선언을 설치하여 얻을 수 있는데, 이 경우 작성한 라이브러리에 대한 타입 선언도 포함됩니다.
이는 <code>@types/node</code>에 의존하기 때문에, 결국 <code>devDependencies</code>로 포함하게 됩니다.
결국 이에 따라 <code>@types</code>와 무관한 JS 개발자나, NodeJS를 프로젝트에 이용하지 않는 TS 개발자의 경우 사용하지 않는 모듈을 포함해야 하는 문제가 생겨납니다.</p>
<h2 id="구조적-타이핑을-활용하세요"><a class="header" href="#구조적-타이핑을-활용하세요">구조적 타이핑을 활용하세요</a></h2>
<p>이 경우에 저희가 초기에 다루었던 구조적 타이핑을 적용할 수 있습니다.
사용할 타입을 완전히 가져다 쓰는 대신, 필요한 메서드와 속성에 대해서만 별도로 타입을 작성하는 방법을 이용할 수 있습니다.</p>
<p>예를 들어, 위의 예시에서 <code>Buffer</code>의 경우는 다음과 같이 간략하게 타입을 선언하여 대체할 수 있습니다.</p>
<pre><code class="language-ts">interface CsvBuffer {
  // parseCSV에서 쓰이는 함수에 대해서만 타입 선언을 합니다.
  toString(encoding: string): string;
}
</code></pre>
<p>구조적 타이핑의 관점에 따라, 해당 타입은 <code>Buffer</code>와도 호환되기 때문에 실제로 NodeJS 프로젝트에서 <code>Buffer</code> 인스턴스로도 <code>parseCSV</code>를 호출할 수 있습니다.</p>
<p>한편 다른 라이브러리에서의 타입 선언 대부분을 추출해야 하는 상황이라면, 차라리 명시적으로 <code>@types</code> 의존성을 추가하는 게 낫습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="테스팅-타입의-함정에-주의하기"><a class="header" href="#테스팅-타입의-함정에-주의하기">테스팅 타입의 함정에 주의하기</a></h1>
<p>프로젝트를 공개하려면 테스트 코드를 작성하는 것이 필수적이며, 타입 선언 역시 이러한 테스트를 거쳐야 합니다.
그러나 타입 선언을 테스트하는 것은 실제로 상당히 어렵습니다.</p>
<p>다음과 같은 함수가 있다고 가정합시다.</p>
<pre><code class="language-ts">const square = (x: number) =&gt; x * x;
</code></pre>
<p>이를 테스트하는 가장 쉬운 방법은 이를 단순히 실행해보는 것입니다.</p>
<pre><code class="language-ts">test('square a number', () =&gt; {
  square(1);
  square(2);
});
</code></pre>
<p>이러한 테스트의 문제점은, 오직 &quot;실행&quot;에 대해서 오류가 발생하는지 아닌지에 대해서만 체크를 한다는 것입니다.
반환값에 대해서는 체크하지 않기 때문에, 그 결과에 대해서는 관심이 없는 셈입니다.</p>
<p>이러한 문제를 해결하고자 반환 결과를 체크하기 위해 별도의 변수를 둘 수도 있습니다.</p>
<pre><code class="language-ts">declare function map&lt;U, V&gt;(array: U[], fn: (u: U) =&gt; V): V[];

const lengths: number[] = map(['john', 'paul'], name =&gt; name.length);
</code></pre>
<p>다만 이 경우 두 가지 문제가 발생합니다.</p>
<ul>
<li><strong>불필요한 변수</strong>(ex. <code>lengths</code>)를 만듭니다. 이는 린팅과 관련한 경고를 유발할 수 있습니다.</li>
<li>타입이 <strong>동일한지</strong>가 아니라, <strong>할당가능한지</strong>에 대해서만 체크가 이루어집니다.</li>
</ul>
<h2 id="헬퍼-함수와-유틸-타입을-활용하세요"><a class="header" href="#헬퍼-함수와-유틸-타입을-활용하세요">헬퍼 함수와 유틸 타입을 활용하세요</a></h2>
<p>이 문제들을 해결하기 위한 일반적인 선택은 헬퍼 함수를 정의한 후, 유틸 타입과 함께 사용하여 Input과 Output에 대한 체크를 수행하는 것입니다.</p>
<pre><code class="language-ts">// Helper func.
function assertType&lt;T&gt;(x: T) {}

type CustomMap&lt;U, V&gt; = (array: U[], fn: (u: U) =&gt; V) =&gt; V[];

// 매개변수 타입에 대한 테스트
const params: [number[], (n: number) =&gt; number] = null!;
assertType&lt;Parameters&lt;CustomMap&lt;number, number&gt;&gt;&gt;(params);

// 반환 타입에 대한 테스트
const result: number[] = null!;
assertType&lt;ReturnType&lt;CustomMap&lt;number, number&gt;&gt;&gt;(result);
</code></pre>
<h2 id="콜백에서의-this-역시-고려되어야-합니다"><a class="header" href="#콜백에서의-this-역시-고려되어야-합니다">콜백에서의 this 역시 고려되어야 합니다</a></h2>
<p>콜백 함수에서 <code>this</code>를 사용하는 경우 역시 타입을 가질 수 있으므로, 이 역시 테스트 시에 체크해주어야 합니다.</p>
<pre><code class="language-ts">declare function map&lt;U, V&gt;(
  array: U[],
  fn: (u: U, i: number, array: U[]) =&gt; V
): V[];

const beatles = ['john', 'paul', 'george', 'ringo'];

// ma
assertType&lt;number[]&gt;(map(
  beatles,
  function(name, i, array) {
    assertType&lt;string&gt;(name);
    assertType&lt;number&gt;(i);
    assertType&lt;string[]&gt;(array);
    assertType&lt;string[]&gt;(this); // this에 대해서도 타입을 체크합니다.
    return name.length;
  }
));
</code></pre>
<h2 id="테스트에서-any를-주의하세요"><a class="header" href="#테스트에서-any를-주의하세요">테스트에서 any를 주의하세요</a></h2>
<p>테스트에서도 <code>any</code>는 여전히 나쁜 영향을 끼칩니다.
<code>any</code> 타입을 사용하는 경우 테스트는 전부 통과하겠지만, 타입 안정성을 포기하게 됩니다.
<code>noImplicitAny</code>를 설정하더라도, 타입 선언을 통해 여전히 <code>any</code> 타입은 생겨나게 되며, 테스트를 하는 것이 매우 어려워집니다.</p>
<p>이러한 어려움 때문에 타입 체커와 독립적으로 동작하는 도구를 사용해 타입 선언을 테스트하는 방법이 권장되는데, <a href="https://github.com/microsoft/dtslint">dtslint</a>가 좋은 예시가 됩니다.</p>
<pre><code class="language-ts">map(beatles, function(
  name,  // $ExpectType string
  i,     // $ExpectType number
  array  // $ExpectType string[]
) {
  this   // $ExpectType string[]
  return name.length;
});  // $ExpectType number[]
</code></pre>
<p>dtslint는 특별한 형태의 주석을 통해 동작하며, 이는 할당 가능성 체크가 아닌, 각 심벌의 타입을 추출하여 글자가 일치하는지를 비교합니다.
우리가 에디터 상에서 변수에 커서를 올려 타입을 확인하는 과정을 자동화하는 것과 유사합니다.
물론 이 경우 미묘한 단점은 있는데, <code>string | number</code>와 <code>number | string</code>과 같은 경우 사실 상 같은 타입이지만 다른 타입으로 인식해버립니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="코드를-작성하고-실행하기"><a class="header" href="#코드를-작성하고-실행하기">코드를 작성하고 실행하기</a></h1>
<p>7장에서는 타입과 관계는 없지만 코드를 작성하고 실행하면서 실제로 겪을 수 있는 문제들을 다룹니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트-기능보다는-ecmascript-기능을-사용하기"><a class="header" href="#타입스크립트-기능보다는-ecmascript-기능을-사용하기">타입스크립트 기능보다는 ECMASCript 기능을 사용하기</a></h1>
<p>JS는 본래 결함이 많고 개선해야 할 부분이 많은 언어였습니다.
이 때문에 각종 기능들을 프레임워크나 트랜스파일러로 보완하는 것이 일반적인 모습이었고, TS 또한 초기 버전에는 독립적으로 개발한 시스템을 포함한 형태였습니다.</p>
<p>하지만 시간이 지남에 따라 JS는 부족했던 부분들을 내장 기능으로 추가해나갔고, 기존에 독립적으로 개발된 기능들과 호환성 문제를 일으켰습니다.
현재 TS는 런타임 기능을 배제하고 오직 타입 기능만 발전시킨다는 명확한 원칙을 세우고 이에 따라 개발해나가고 있습니다.</p>
<p>헌데, 이러한 원칙 이전에, 기존에 존재하던 몇 가지 기능들이 있었으며, 이러한 기능들은 타입 공간과 값 공간 간의 경계를 혼란스럽게 만드므로 사용하지 않는 것이 좋습니다.</p>
<h2 id="열거형-enum"><a class="header" href="#열거형-enum">열거형 (enum)</a></h2>
<pre><code class="language-ts">enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}

let flavor = Flavor.CHOCOLATE;  // Type is Flavor

Flavor  // Autocomplete shows: VANILLA, CHOCOLATE, STRAWBERRY
Flavor[0]  // Value is &quot;VANILLA&quot;
</code></pre>
<p>TS에서의 enum은 JS와 TS 간의 동작이 다르기 때문에 사용하지 않는 것이 좋습니다.
대신에 리터럴 타입의 유니온을 사용하면 됩니다.</p>
<pre><code class="language-ts">type Flavor = 'vanilla' | 'chocolate' | 'strawberry';
</code></pre>
<h2 id="매개변수-속성-parameter-properties"><a class="header" href="#매개변수-속성-parameter-properties">매개변수 속성 (Parameter Properties)</a></h2>
<p>TS의 <a href="https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties">매개변수 속성</a>을 사용하면, 일반적으로 클래스를 초기화할 때 사용하는 경우의 문법을 보다 간결하게 작성할 수 있습니다.</p>
<pre><code class="language-ts">// 일반적인 경우
class Person {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}

// 매개변수 속성을 사용하는 경우
class Person {
  constructor(public name: string) {}
}
</code></pre>
<p>매개변수 속성의 사용이 좋은지 나쁜지에 대해서는 찬반이 갈리는 문제입니다.
다만 기존 JS 문법과는 이질적이고 생소하다는 점과, 일반 속성과 같이 사용하는 경우 설계가 혼란스러울 수 있습니다.</p>
<h2 id="네임스페이스와-트리플-슬래시-임포트"><a class="header" href="#네임스페이스와-트리플-슬래시-임포트">네임스페이스와 트리플 슬래시 임포트(<code>///</code>)</a></h2>
<p>기존의 JS에는 모듈 시스템이 존재하지 않았고, 이 때문에 TS 역시 독자적인 모듈 시스템의 마련이 필요했습니다.
그 결과가 트리플 슬래시 임포트와 <code>namespace</code> 키워드이며, 이는 호환성을 유지하기 위해 남아 있을 뿐, 이제는 ES6+ 스타일의 모듈을 사용하는 것이 좋습니다.</p>
<pre><code class="language-ts">namespace foo {
  function bar() {}
}

/// &lt;reference path=&quot;other.ts&quot;&gt;
foo.bar();
</code></pre>
<h2 id="데코레이터-1"><a class="header" href="#데코레이터-1">데코레이터</a></h2>
<p>데코레이터는 클래스, 메서드, 속성에 애너테이션(annotation)을 붙이거나 기능을 추가하는데 사용할 수 있습니다.
아래 예시는 클래스의 메서드 호출 시마다 <code>logged</code> 함수를 실행하는 경우입니다.</p>
<pre><code class="language-ts">class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  @logged
  greet() {
    return &quot;Hello, &quot; + this.greeting;
  }
}

function logged(target: any, name: string, descriptor: PropertyDescriptor) {
  const fn = target[name];
  descriptor.value = function() {
    console.log(`Calling {name}`);
    return fn.apply(this, arguments);
  };
}

console.log(new Greeter('Dave').greet());
// Logs:
// Calling greet
// Hello, Dave
</code></pre>
<p>이는 처음에 앵귤러 프레임워크를 지원하기 위해 추가되었으며, 실제로도 <code>experimentalDecorators</code> 속성을 설정하고 사용해야 합니다.
현재까지도 표준화가 완료되지 않은 기능이기 때문에, 호환성이 깨질 가능성이 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="객체를-순회하는-노하우"><a class="header" href="#객체를-순회하는-노하우">객체를 순회하는 노하우</a></h1>
<p>TS는 특정 타입에 <strong>할당 가능한</strong> 모든 경우에 대해 고려되기 때문에, 이 때 단순히 <code>for</code> 키워드를 통해 객체 타입을 순회하려고 하면 타입이 예상치 못하게 추론되는 경우가 있을 수 있습니다.</p>
<pre><code class="language-ts">interface ABC {
  a: string;
  b: string;
  c: number;
}

function foo(abc: ABC) {
  for (const k in abc) {  // const k: string 
                          // 'a' | 'b' | 'c' 가 아닙니다.
    const v = abc[k];
           // ~~~~~~ Element implicitly has an 'any' type
           //        because type 'ABC' has no index signature
  }
}
</code></pre>
<p>가령, 위의 매개변수 <code>abc</code>에는 인터페이스 <code>ABC</code>의 타입만 충족한다면 그 외에 추가적으로 어떤 속성을 갖더라도 타입 상으로 문제가 없기 때문에, 이는 정상적인 오류의 출력입니다.</p>
<p>만약, 이러한 타입을 좁히려면 <code>keyof</code> 키워드를 사용하면 됩니다.
단, 이 경우 실제로 해당 객체가 추가적인 키와 값을 가질 가능성이 없는지 판단해야할 필요가 있습니다.</p>
<pre><code class="language-ts">function foo(abc: ABC) {
  let k: keyof ABC;
  for (k in abc) {  // let k: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;
    const v = abc[k];  // Type is string | number
  }
}
</code></pre>
<p>타입에 신경쓰지 않고 단순히 객체의 키와 값을 순회하고자 한다면 <code>Object.entries</code>의 사용이 보다 일반적입니다.
물론 이 경우 키와 값의 타입이 추상적이기 때문에, 타입을 다루기에 까다롭습니다.</p>
<pre><code class="language-ts">function foo(abc: ABC) {
  for (const [k, v] of Object.entries(abc)) {
    k  // Type is string
    v  // Type is any
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="dom-계층-구조-이해하기"><a class="header" href="#dom-계층-구조-이해하기">DOM 계층 구조 이해하기</a></h1>
<p>TS에서는 이벤트를 다룰 때, <code>EventTarget</code>에 달린 <code>Node</code>의 구체적인 타입을 안다면 개발 및 디버깅이 용이하며, 언제 타입 단언을 사용해야 하는지 판단하기 쉽습니다.</p>
<p><img src="https://javascript.info/article/basic-dom-node-properties/dom-class-hierarchy.svg" alt="img1" /></p>
<p>한편, <code>Event</code> 역시 <code>MouseEvent</code>, <code>UIEvent</code> 등 보다 구체적인 타입들이 존재합니다.</p>
<p>실제 개발 중에 이벤트 핸들러를 다룰 때에 <code>Event</code> 및 <code>EventTarget</code> 보다는 <code>HTMLDivElement</code>, <code>PointerEvent</code> 등 구체적인 타입을 선언 및 단언하여 개발을 해나가는 것이 좋습니다.</p>
<pre><code class="language-ts">function addDragHandler(el: HTMLElement) {
  el.addEventListener('mousedown', eDown =&gt; {
    const dragStart = [eDown.clientX, eDown.clientY];
    const handleUp = (eUp: MouseEvent) =&gt; {
      el.classList.remove('dragging');
      el.removeEventListener('mouseup', handleUp);
      const dragEnd = [eUp.clientX, eUp.clientY];
      console.log('dx, dy = ', [0, 1].map(i =&gt; dragEnd[i] - dragStart[i]));
    }
    el.addEventListener('mouseup', handleUp);
  });
}

const div = document.getElementById('surface');

if (div) {
  addDragHandler(div);
}
</code></pre>
<p>특히 DOM을 다룰 때에는 TS 타입 체커보다 개발자인 우리가 더 타입에 대해 정확히 알고 있는 경우가 많으므로 타입 단언을 사용해도 좋습니다.</p>
<pre><code class="language-ts">document.getElementById('my-div') as HTMLDivElement;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="정보를-감추는-목적으로-private-사용하지-않기"><a class="header" href="#정보를-감추는-목적으로-private-사용하지-않기">정보를 감추는 목적으로 private 사용하지 않기</a></h1>
<p>JS는 클래스에 비공개 속성을 만들 수 없습니다. 비공개 속성임을 나타내기 위해 언더스코어(<code>_</code>)로 접두사를 붙이는 것이 관례로 인정될 뿐, 실제로는 일반적인 속성일 뿐입니다.</p>
<p>헌데 TS에는 <code>public</code>, <code>protected</code>, <code>private</code> 접근 제어자가 있기 때문에, 이를 통해 공개 규칙을 강제할 수 있는 것으로 오해할 수 있습니다.</p>
<pre><code class="language-ts">class Diary {
  private secret = 'cheated on my English test';
}

const diary = new Diary();
diary.secret
   // ~~~~~~ Property 'secret' is private and only
   //        accessible within class 'Diary'
</code></pre>
<p>헌데 이러한 접근 제어자들은 TS 키워드일 뿐, 컴파일 이후에는 제거되며, 그 결과 다음처럼 일반적인 JS 속성이 됩니다.</p>
<pre><code class="language-js">class Diary {
  constructor() {
    this.secret = 'cheated on my English test';
  }
}

const diary = new Diary();
diary.secret;
</code></pre>
<p>TS 접근 제어자들은 단지 컴파일 시점에만 오류를 표시해줄 뿐, 언더스코어 관례와 마찬가지로 런타임에는 아무런 효력이 없습니다.</p>
<p>JS 및 TS에서 정보를 숨기기 위해 가장 효과적인 방법은 <strong>클로저</strong>를 사용하는 것입니다. 해당 챕터에서 클로저에 대해 깊게 다루기엔 범주를 벗어나므로, <a href="https://ko.javascript.info/closure">여기</a>를 참조하도록 합시다.</p>
<p>또 다른 선택지로는 <strong>비공개 필드 기능</strong>을 사용할 수 있습니다. 비공개 필드는 접두사로 <code>#</code>를 붙여서 타입 체크와 런타임 모두에서 비공개로 만드는 역할을 합니다.</p>
<pre><code class="language-ts">class PasswordChecker {
  #passwordHash: number;

  constructor(passwordHash: number) {
    this.#passwordHash = passwordHash;
  }

  checkPassword(password: string) {
    return hash(password) === this.#passwordHash;
  }
}
</code></pre>
<p>해당 기능은 기존에(해당 책이 작성될 시점에도) 표준화가 진행 중인 단계였으나, ES2022에 접어들면서 <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md">공식적인 스펙이 되었습니다</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="소스맵을-사용하여-타입스크립트-디버깅하기"><a class="header" href="#소스맵을-사용하여-타입스크립트-디버깅하기">소스맵을 사용하여 타입스크립트 디버깅하기</a></h1>
<p>TS는 런타임에서 직접 실행되지 않습니다. 엄밀히 말하면 TS 뿐 아니라 여러 압축 및 전처리 도구들 모두에 해당하는 내용입니다.
디버거는 런타임 시점에 동작하며, 현재 런타임에 실행 중인 코드가 어떤 과정을 거쳐 만들어졌는지 알지 못합니다.
이렇게 변환된 자바스크립트 코드는 복잡해서 디버깅하기 매우 어렵습니다.</p>
<h2 id="소스맵-source-map"><a class="header" href="#소스맵-source-map">소스맵 (source map)</a></h2>
<p>소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑합니다.
대부분의 브라우저와 많은 IDE가 소스맵을 지원합니다.</p>
<p>TS 역시 이러한 소스맵에 대한 옵션이 존재합니다.</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;sourceMap&quot;: true
  }
}
</code></pre>
<p>이후 컴파일을 실행하면 각 <code>.ts</code> 파일에 대해 <code>.js</code>와 <code>.js.map</code> 두 개의 파일을 생성하며, 이 중 <code>.js.map</code>이 바로 소스맵에 해당합니다.
소스맵이 <code>.js</code> 파일과 함께 있으면 디버거에서 기존에 작성한 <code>.ts</code> 파일이 나타납니다.</p>
<p>이제 원하는 대로 브레이크포인트를 설정할 수 있고, 변수를 조사할 수 있습니다.</p>
<p><img src="https://mblogthumb-phinf.pstatic.net/MjAyMDAxMDhfMjE2/MDAxNTc4NDM3OTk1MjEx.DUvBZyim0r6VYxtC6Gt44gzKMbJaEdOewY70DSRyBwQg.YX9FsTW1bPHqWKxCfnP1zEVVUPr_oyPlbIcmrTEUNJ4g.PNG.bunggl/%EC%BA%A1%EC%B2%98.PNG?type=w800" alt="sourceMapImg" /></p>
<p>디버거 좌측의 <code>app.ts</code>가 이탤릭 글꼴로 나오는 것은 곧 이것이 웹페이지에 포함된 (컴파일 된) <strong>실제 파일이 아니라는 것</strong>을 의미합니다. 컴파일된 내용이 소스맵을 통해 TS처럼 보이는 것 뿐입니다.</p>
<p>TS 타입체커는 코드 실행 전에 많은 오류를 잡을 수 있지만, 디버거를 대체할 수는 없습니다. 소스맵을 통해 제대로 된 TS 디버깅 환경을 구축하는 것이 필요합니다.</p>
<h3 id="주의사항"><a class="header" href="#주의사항">주의사항</a></h3>
<ul>
<li>TS와 함께 여러 번들러 및 압축기를 사용하고 있다면, 이것이 각자의 소스맵을 생성하게 됩니다. 이상적인 디버깅 환경을 위해선 이들이 원본 TS 소스로 매핑되도록 해야하며, 번들러가 기본적으로 TS를 지원한다면 문제 없겠지만, 그렇지 않다면 번들러가 소스맵을 인식할 수 있도록 추가적인 설정이 필요합니다.</li>
<li>프로덕션 환경에 소스맵이 유출되고 있지는 않은지 확인해야 합니다. 소스맵을 통해 공개해서는 안될 내용이 들어 있을 수 있습니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트로-마이그레이션하기"><a class="header" href="#타입스크립트로-마이그레이션하기">타입스크립트로 마이그레이션하기</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="모던-자바스크립트로-작성하기"><a class="header" href="#모던-자바스크립트로-작성하기">모던 자바스크립트로 작성하기</a></h1>
<p>TS는 타입 체크 기능 이외에 TS 코드를 특정 버전의 JS로 컴파일하는 기능도 갖고 있습니다.
예를 들어, 최신 TS 및 JS 코드를 ES3 스펙의 JS 코드로 컴파일할 수도 있습니다.</p>
<p>다시 말해, TS 컴파일러를 JS 트랜스파일러로써 사용할 수 있습니다.</p>
<p>만약, 기존에 JS로 작성된 프로젝트를 TS 기반으로 마이그레이션 하고자 한다면, 먼저 최신 버전의 JS로 코드를 수정해나가는 작업부터 해나가는 것이 좋습니다.</p>
<p>모던 JS에 대한 내용들은 다른 부분에서 더욱 알차게 다루고 있으니, 여기에서는 굳이 깊게 언급하지 않도록 하겠습니다.</p>
<ul>
<li>ES6 모듈 (<code>import</code>, <code>export</code>)</li>
<li>Class</li>
<li><code>let</code> / <code>const</code></li>
<li><code>for-of</code> 또는 <code>forEach</code> 등 배열 메서드</li>
<li>화살표 함수</li>
<li>단축 객체 표현(Compact object literal) / 구조 분해 할당(Object destructuring)</li>
<li>매개변수 기본값</li>
<li><code>async</code> / <code>await</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="타입스크립트-도입-전에-ts-check와-jsdoc으로-시험해-보기"><a class="header" href="#타입스크립트-도입-전에-ts-check와-jsdoc으로-시험해-보기">타입스크립트 도입 전에 @ts-check와 JsDoc으로 시험해 보기</a></h1>
<h2 id="ts-check"><a class="header" href="#ts-check">@ts-check</a></h2>
<p>TS로 전환하기에 앞서, <code>@ts-check</code> 지시자를 사용하면 TS 전환 시에 어떤 문제가 발생하는지 JS 상에서 미리 시험해 볼 수 있습니다.
<code>@ts-check</code> 지시자를 통해 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시합니다.</p>
<pre><code class="language-js">// @ts-check
const person = {first: 'Grace', last: 'Hopper'};
2 * person.first
 // ~~~~~~~~~~~~ The right-hand side of an arithmetic operation must be of type
 //              'any', 'number', 'bigint', or an enum type
</code></pre>
<p>그러나 <code>@ts-check</code> 지시자는 매우 느슨한 수준의 타입 체크를 수행합니다. 심지어는 <code>noImplicitAny</code> 설정을 해제한 것보다 느슨하므로 이에 주의해야 합니다.</p>
<p>만약 기존에 JSDoc 스타일의 주석을 사용 중이었다면, <code>@ts-check</code> 지시자 설정 시 기존 주석에 대한 타입 체크가 동작합니다.</p>
<pre><code class="language-js">// @ts-check
/**
 * Gets the size (in pixels) of an element.
 * @param {Node} el The element
 * @return {{w: number, h: number}} The size
 */
function getSize(el) {
  const bounds = el.getBoundingClientRect();
                 // ~~~~~~~~~~~~~~~~~~~~~ Property 'getBoundingClientRect'
                 //                       does not exist on type 'Node'
  return {width: bounds.width, height: bounds.height};
       // ~~~~~~~~~~~~~~~~~~~ Type '{ width: any; height: any; }' is not
       //                     assignable to type '{ w: number; h: number; }'
}
</code></pre>
<p><code>@ts-check</code> 지시자와 <code>JsDoc</code> 주석을 통해 JS 환경에서도 TS와 유사한 경험으로 개발이 가능하기 때문에 마이그레이션 과정에 도움이 됩니다.
하지만, 장기적인 관점에서는 주석의 양이 늘어나 로직의 해석을 방해한다는 문제가 있습니다. 때문에 궁극적으로는 모든 코드가 TS 기반으로 전환될 수 있는 것을 목표로 삼아야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="allowjs로-타입스크립트와-자바스크립트-같이-사용하기"><a class="header" href="#allowjs로-타입스크립트와-자바스크립트-같이-사용하기">allowJs로 타입스크립트와 자바스크립트 같이 사용하기</a></h1>
<p>프로젝트의 규모가 큰 경우, 한꺼번에 모든 JS 코드를 TS로 전환하는 것이 불가능하므로, 점진적인 전환 과정이 필요합니다.
그러러면 마이그레이션 기간 중에 TS와 JS가 동시에 동작할 수 있도록 하는 것이 필요합니다.</p>
<p>이것의 핵심은 <code>allowJs</code> 컴파일러 옵션인데, 이는 TS와 JS 파일을 서로 임포트할 수 있게 해줍니다.</p>
<p>번들러에 TS가 통합되어 있거나, 플러그인 방식으로 통합이 가능하다면 이를 쉽게 적용할 수 있습니다.</p>
<p>예를 들어, <code>tsify</code>는 TS를 컴파일하기 위한 <code>browserify</code> 플러그인이며, 이를 다음과 같은 형태로 사용할 수 있습니다.</p>
<pre><code class="language-bash">browserify index.ts -p [ tsify --allowJs ] &gt; bundle.js
</code></pre>
<p>대부분의 유닛 테스트 도구 역시 동일한 역할을 하는 옵션이 있습니다.
예를 들어 <code>jest</code>를 사용할 때 <code>ts-jest</code>를 설치하고 <code>jest.config.js</code>에 전달할 TS 소스를 지정할 수 있습니다.</p>
<pre><code class="language-js">module.exports = {
  transform: {
    '^.+\\.tsx?': 'ts-jest',
  },
};
</code></pre>
<p>만약, 프레임워크 없이 빌드 체인을 직접 구성했다면, 다소 복잡하긴 하더라도 TS 컴파일링 후 <code>outDir</code>에 지정한 디렉토리를 기반으로 기존의 빌드 체인을 실행하면 됩니다.
이 경우, TS가 생성한 코드가 기존의 JS 룰을 따르도록 출력 옵션을 조정해야 할 필요는 있습니다. (ex. target, module)</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="의존성-관계에-따라-모듈-단위로-전환하기"><a class="header" href="#의존성-관계에-따라-모듈-단위로-전환하기">의존성 관계에 따라 모듈 단위로 전환하기</a></h1>
<p>점진적으로 마이그레이션을 할 때는 모듈 단위로 해나가는 것이 이상적입니다.
허나 어떤 모듈을 골라 타입 정보를 추가하면, 해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류가 발생하게 됩니다.
그렇기 떄문에, 의존성 관련 오류 없이 작업하기 위해서는 다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해 최상단에 있는 모듈을 마지막에 완성할 수 있도록 해야합니다.</p>
<h2 id="서드파티-라이브러리"><a class="header" href="#서드파티-라이브러리">서드파티 라이브러리</a></h2>
<p>프로젝트 내 모듈들이 서드파티 라이브러리를 의존할 수 있어도, 그 역은 그렇지 않기 때문에 우선 서드파티 라이브러리의 타입 정보를 해결해야 합니다.
일반적으로 <code>@types</code> 모듈을 설치하면 됩니다. </p>
<pre><code class="language-bash">npm install --save-dev @types/lodash
</code></pre>
<h2 id="외부-api"><a class="header" href="#외부-api">외부 API</a></h2>
<p>외부 API를 호출하는 경우도 있기 때문에, 외부 API의 타입 정보도 추가해야 합니다.
서드파티 라이브러리와 마찬가지로, 프로젝트 내 모듈은 API에 의존하지만 API는 해당 모듈에 의존하지 않기 때문에 먼저 해결하는 것이 좋습니다.</p>
<p>특히, 외부 API에 대한 타입 정보는 특별한 문맥이 없어 TS가 추론하기 어렵습니다.
그렇기 때문에 API 사양을 기반으로 타입 정보를 생성해나가야 합니다.</p>
<h2 id="리팩터링은-미루세요"><a class="header" href="#리팩터링은-미루세요">리팩터링은 미루세요</a></h2>
<p>TS로의 마이그레이션 작업을 하던 도중, 설계 상으로 이상한 점을 발견하더라도 당장에 리팩터링을 하기보다는 마이그레이션 작업에 집중하는 것이 좋습니다.
개선할 부분을 기록해 두고, 리팩터링은 TS 전환 작업이 완료된 이후에 생각해야 합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="마이그레이션의-완성을-위해-noimplicitany-설정하기"><a class="header" href="#마이그레이션의-완성을-위해-noimplicitany-설정하기">마이그레이션의 완성을 위해 noImplicitAny 설정하기</a></h1>
<p>프로젝트 전체를 <code>.ts</code>로 전환했다면 매우 큰 진척을 이룬 것이지만, 마지막 단계로 <code>noImplicitAny</code>를 설정하는 것이 필요합니다.
<code>noImplicitAny</code>가 설정되지 않은 상태에서는 타입 선언에서 비롯된 실제 오류가 숨어있기 때문에 마이그레이션이 완료되었다고 할 수 없습니다.</p>
<p>예를 들어, 아래와 같이 <code>indices</code>라는 속성을 가진 클래스 <code>Chart</code>가 있다고 했을 때, <code>noImplicitAny</code>가 설정되어 있지 않다면 다음과 같이 작성되더라도 문제가 없습니다.</p>
<pre><code class="language-ts">class Chart {
  indices: number[];
  // ...
  getRanges() {
    for (const r of this.indices) {
      const low = r[0];  // Type is any
      const high = r[1];  // Type is any
      // 에러가 출력되지 않습니다.
      // ...
    }
  }
}
</code></pre>
<p>만약, <code>noImplicitAny</code>가 설정되어 있다면 다음과 같이 <code>any</code>에 대한 에러가 제대로 발생합니다.</p>
<pre><code class="language-ts">class Chart {
  indices: number[];
  // ...
  getRanges() {
    for (const r of this.indices) {
      const low = r[0];
              // ~~~~ Element implicitly has an 'any' type because
              //      type 'Number' has no index signature
      const high = r[1];
                // ~~~~ Element implicitly has an 'any' type because
                //      type 'Number' has no index signature
      // ...
    }
  }
}
</code></pre>
<p>처음에는 <code>noImplicitAny</code>를 로컬에만 설정하고 작업하는 것이 좋습니다.
원격 상에서는 설정에 변화가 없어 빌드에 실패하지 않을 것이기 때문입니다.</p>
<p>그 외에도 타입 체크의 강도를 높이는 설정에는 여러 가지가 있습니다.
지금껏 이야기한 <code>noImplicitAny</code>는 상당히 엄격한 설정이며, <code>strictNullChecks</code> 같은 설정을 적용하지 않더라도 대부분의 타입 체크를 적용한 것으로 볼 수 있습니다.</p>
<p>최종적으로 강력한 설정은 <code>&quot;strict&quot;: true</code>이며, 타입 체크의 강도는 팀 내의 모든 사람이 TS에 익숙해진 다음에 조금씩 높여가는 것이 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="왜-react인가"><a class="header" href="#왜-react인가">왜 React인가?</a></h1>
<blockquote>
<p><a href="https://medium.com/javascript-scene/the-missing-introduction-to-react-62837cb2fd76">여기</a>의 내용을 의역 및 일부 편집한 내용입니다.</p>
</blockquote>
<p><strong><em>컴포넌트는 비즈니스 로직, 애플리케이션 상태, 네트워크와 무관하게 있을 때 가장 이상적입니다. 동일한 props가 있다면, 동일한 형태로 렌더링되어야 하죠.</em></strong></p>
<p>다른 프레임워크들이 MVC, MVVM 과 같은 패턴을 따를 때, React는 View에 대한 렌더링을 Model과 완전히 떼어놓으려는 시도를 했습니다. 그 노력이 바로 Flux 패턴입니다.</p>
<p>그렇다면 왜 이것이 MVC보다도 낫다고 여겨졌을까요?</p>
<p>2013년에 페이스북은 채팅 기능을 통합하기 위해 많은 노력을 기울였습니다. 애플리케이션 환경 전반에 걸쳐 라이브가 가능하고, 사이트의 모든 페이지에 통합된 기능이었죠. 이미 복잡한 애플리케이션 내에서의 새로운 복잡한 앱이었고, DOM의 비제어(uncontrolled) 변경과 더불어 수많은 이용자들의 병렬적이고 비동기적인 I/O도 페이스북 팀에게 어려운 과제였습니다.</p>
<p>예를 들어, 그 무엇이든지 간에 DOM을 멋대로 조작하고, 그것을 마음대로 변형할 수 있다면, 과연 적절한 화면이 렌더링된 것인지 어떻게 알 방도가 없습니다.</p>
<p>React 이전에는 이러한 &quot;올바른 화면&quot;에 대한 보장을 그 어떤 프레임워크도 할 수 없었습니다. DOM의 경쟁 상태는 이전 웹 애플리케이션의 가장 흔한 버그 중 하나였습니다.</p>
<h2 id="비결정적--병행-처리--변형가능한-상태"><a class="header" href="#비결정적--병행-처리--변형가능한-상태">비결정적 = 병행 처리 + 변형가능한 상태</a></h2>
<p>React 팀이 가장 먼저 하고자 했던 것은 이러한 문제를 고치는 것이었고, 그러기 위해 두 가지 혁신이 필요했습니다.</p>
<ol>
<li>Flux 구조를 이용한 단방향 데이터 바인딩</li>
<li>Immutable한 컴포넌트 상태 : 일단 설정 되고 나면, 컴포넌트의 상태는 변하지 않습니다. 상태의 변화는 현재 View의 상태를 변경하는 것이 아니라, <strong>새로운 상태에 대한 새로운 View 렌더링을 유발합니다.</strong></li>
</ol>
<p>Flux 패턴을 통해, React는 통제 불가능한 변형의 문제를 다룰 수 있었습니다. 수많은 DOM의 업데이트를 위해 수많은 이벤트 리스너를 추가하는 대신에, React는 컴포넌트의 상태 조작을 위해서 유일한 방법을 사용합니다. 바로 액션을 <strong>Dispatch</strong>하는 것입니다. 이를 통해 Store의 상태가 변경되면, Store는 해당 컴포넌트를 리렌더링합니다.</p>
<img src="https://miro.medium.com/max/700/1*lNLcKqywLkrHadcA-zhgBA.png" />
<p>그래서, &quot;React를 왜 써야 하나요?&quot;에 대한 대답은 심플합니다. 바로 <strong>결정론적인(deterministic) View를 손쉽게 렌더링할 수 있기 때문</strong>입니다.</p>
<blockquote>
<p><em>주의</em> : 따라서, 우리가 VanillaJS를 다루는 것 처럼, DOM에 데이터를 보관하거나 조작하는 것은 안티패턴입니다. 이 경우 React를 쓰는 의미가 없어집니다.</p>
</blockquote>
<p>결정론적인 렌더링 방식은 React의 유일한 트릭이었음에도, 이는 이미 엄청난 혁신이었습니다. 그럼에도 불구하고, React는 계속해서 더 뛰어난 기능들을 선보이고 있습니다.</p>
<h2 id="jsx"><a class="header" href="#jsx">JSX</a></h2>
<p>JSX는 선언적인 형태로 커스텀 UI 컴포넌트를 생성할 수 있는 JS의 확장입니다. JSX는 다음과 같은 장점을 갖습니다.</p>
<ul>
<li>쉽고, 선언적인 마크업</li>
<li>컴포넌트와 함께 배치</li>
<li>관심사를 구분할 수 있음 (ex. UI vs 상태 로직 vs 사이드이펙트)</li>
<li>DOM의 차이를 추상화</li>
<li>내부적인 기술에 대한 추상화</li>
</ul>
<p>단, JSX에서는 명심해야할 부분이 몇가지 있습니다.</p>
<ul>
<li><code>class</code> 어트리뷰트는 JSX에서 <code>className</code>이 됩니다.</li>
<li>List item 형태의 요소들은 반드시 <code>key</code> 어트리뷰트를 가져야 합니다. (여기에 대해서는 이 <a href="https://ko.reactjs.org/docs/reconciliation.html#recursing-on-children">문서</a>를 읽어보세요!)</li>
</ul>
<h2 id="synthetic-events-합성-이벤트"><a class="header" href="#synthetic-events-합성-이벤트">Synthetic Events (합성 이벤트)</a></h2>
<p>React에서는 DOM 이벤트에 대한 래퍼를 제공하는데, 이는 Synthetic Events라고 합니다. 이는 다음과 같은 장점을 갖습니다.</p>
<ol>
<li>이벤트 핸들링 시에 플랫폼 간의 차이를 완화해줍니다.</li>
<li>자체적으로 메모리 관리가 자동으로 이루어집니다. 이를테면, 무한 스크롤 리스트를 만들 때, 메모리 누수를 방지하기 위해 이벤트 위임이 필요할 것입니다. 한편, Synthetic Event는 자동으로 최상단 부모 노드에 이벤트 위임을 적용하기 때문에, 이벤트 메모리 관리에 신경쓰지 않아도 됩니다.</li>
</ol>
<h2 id="컴포넌트-생명주기-component-lifecycle"><a class="header" href="#컴포넌트-생명주기-component-lifecycle">컴포넌트 생명주기 (Component Lifecycle)</a></h2>
<p>React의 컴포넌트 생명주기는 컴포넌트의 상태를 보호하기 위해 존재합니다. 컴포넌트 상태는 React가 컴포넌트를 그려내는 동안에는 변경되지 않아야 하기 때문입니다.</p>
<p>생명주기에 대한 이해는 곧 React가 동작하는 방식에 대한 이해입니다.</p>
<p>React의 컴포넌트 생명주기는 다음과 같이 나누어 볼 수 있습니다.</p>
<img src="https://miro.medium.com/max/336/1*xRzCfozCPTWXp8wgnZrXiA.png" />
<p>그리고, Update 시점은 다음과 같은 형태로 이루어집니다.</p>
<img src="https://miro.medium.com/max/360/1*9wk48udC9l884fOZydImiw.png"/>
<ul>
<li>
<p><strong>Render</strong> - <code>render</code> 함수는 결정론적이며, 사이드이펙트를 포함해서는 안됩니다. 이것을 props를 가져와 JSX를 반환하는 순수 함수로 이해할 수 있습니다.</p>
</li>
<li>
<p><strong>Pre-Commit</strong> - <code>getSnapShotBeforeUpdate</code> 생명주기 메서드를 이용해 DOM으로부터 데이터를 가져올 수 있습니다. 만약 스크롤 위치나 렌더링된 요소의 크기를 파악하고자 할 때 유용합니다.</p>
</li>
<li>
<p><strong>Commit</strong> - DOM과 ref들에 대한 갱신을 수행합니다. <code>componentDidUpdate</code> 또는 <code>useEffect</code> 훅을 통해 이를 이용할 수 있습니다. 여기에서는 사이드 이펙트를 유발하거나 DOM을 조작해도 괜찮습니다.</p>
</li>
</ul>
<p>다음 그림이 React 컴포넌트의 전반적인 흐름을 파악할 수 있게끔 도와 줄 겁니다.</p>
<img src="https://miro.medium.com/max/700/1*cEWErpe-oY-_S1dOaT1NtA.jpeg" />
<p>말했다시피, React에서의 컴포넌트는, &quot;변형&quot;을 가하는 것이 아니라, 상태의 변화에 따라 리렌더링 단계를 거쳐 새롭게 &quot;대체&quot;를 한다고 보는 것이 맞습니다. 이러한 단계를 통해 React의 &quot;결정론적인 View 렌더링&quot;을 쉽게 해줍니다.</p>
<p>다시 말해, React 컴포넌트의 대부분은 앞서 말한 것 처럼, props를 받아 JSX를 반환하는 순수함수로 생각될 수 있습니다.</p>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>React Hooks는 클래스형 컴포넌트가 아닌 경우에도 React 컴포넌트 생명주기를 활용하기 위한 함수들입니다. Hooks의 사용은 일반적으로 사이드 이펙트의 유발을 일으킵니다. 여기서 사이드 이펙트란 함수의 반환값 외에 발생하는 함수 외부 값의 상태 변화를 의미힙니다.</p>
<p>Hooks는 결국 다음과 같은 것들을 가능하게 합니다.</p>
<ul>
<li>클래스형 컴포넌트가 아니더라도 함수형 컴포넌트에서 생명주기 로직을 처리할 수 있습니다.</li>
<li>코드를 더 잘 정리할 수 있습니다.</li>
<li>다른 컴포넌트 간에 재사용할 수 있는 로직을 공유할 수 있습니다.</li>
<li>스스로 임의의 커스텀 훅을 만들 수 있습니다.</li>
</ul>
<h2 id="컨테이너-vs-프레젠테이션-컴포넌트"><a class="header" href="#컨테이너-vs-프레젠테이션-컴포넌트">컨테이너 vs 프레젠테이션 컴포넌트</a></h2>
<p>컴포넌트의 모듈화와 더 나은 재사용성을 위해 대체로 다음의 두 형태로 컴포넌트를 구분지을 수 있습니다.</p>
<ul>
<li><strong>컨테이너 컴포넌트</strong>는 데이터 스토어와 연결되어, 여러 사이드이펙트를 유발할 수 있습니다.</li>
<li><strong>프레젠테이션 컴포넌트</strong>는 <em>대부분</em> 순수 컴포넌트이며, 동일한 컨텍스트 내 동일한 props에 대해서는 항상 동일한 JSX를 반환합니다.</li>
</ul>
<p>프레젠테이션 컴포넌트는 다음과 같은 특징을 지닙니다.</p>
<ul>
<li>네트워크와 접촉하지 않습니다.</li>
<li>로컬 스토리지에 저장 또는 불러오지 않습니다.</li>
<li>랜덤 데이터를 생성하지 않습니다.</li>
<li>현재 시스템 시간을 가져오지 않습니다.(<code>Date.now()</code>)</li>
<li>데이터 스토어에 직접 접근하지 않습니다.</li>
<li>한편, form input과 같은 로컬 컴포넌트 상태를 사용할 수는 있습니다. 물론 이 경우, 최초 상태에서부터 결정론적인 유닛 테스트가 이루어져야 합니다.</li>
</ul>
<p>컨테이너 컴포넌트는 다음과 같은 특징을 지닙니다.</p>
<ul>
<li>상태 관리, I/O, 그 외의 사이드 이펙트를 유발합니다.</li>
<li>스스로에 대한 마크업을 렌더링하지 않아야 합니다.</li>
<li>프레젠테이션 컴포넌트의 래퍼로서 사용됩니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="왜-reducer는-순수해야-하는가"><a class="header" href="#왜-reducer는-순수해야-하는가">왜 Reducer는 순수해야 하는가?</a></h1>
<p><a href="https://medium.com/free-code-camp/why-redux-needs-reducers-to-be-pure-functions-d438c58ae468">여기</a>의 글을 참조했습니다.</p>
<p>Redux는 상태의 변경에 있어서 Reducer를 사용합니다. 그런데 이 Reducer는 아시다시피 기본적으로 <strong>순수함수</strong>입니다. 동일한 Input이 있다면, 항상 동일한 Output을 반환해야 합니다. 이는 다시 말해, 해당 함수가 항상 Immutable하게 동작해야 한다는 뜻이죠.</p>
<img src="https://miro.medium.com/max/700/1*BojNgnfwqAXdqJSsuNf0Sg.png" />
<p>다만, 단순히 생각해볼 때, 얼핏 이는 비효율적으로 보이기도 하죠. 왜 해당 상태를 직접 변경하지 않는 걸까요? 훨씬 더 간편할텐데요.</p>
<p>이는 기본적으로, Redux가 상태의 변경을 감지할 때, &quot;<strong>얕은 비교</strong>&quot;를 하기 때문입니다. 만약에 어떤 변화가 생겼다면, 해당 리듀서로부터 아예 새로운 객체를 반환받을 것이라 생각하는 것이죠.</p>
<p>그래서, Redux는 왜 이런 식으로 구현되어 있을까요?</p>
<p>사실, 답은 간단합니다. 이는 객체의 변화를 깊은 비교를 통해 감지하는 것보다 <strong>훨씬 빠르기 때문입니다.</strong> 만약 JS의 두 객체가 같은 프로퍼티를 가졌는지에 대해 판단하기 위해서는, 깊은 비교를 통해서 각각의 프로퍼티를 일일이 비교해나가야 합니다. 그런데 이 과정은 실제 애플리케이션에서는 굉장히 비용이 많이 드는 과정이죠. 이는 특히 애플리케이션의 규모가 커져 관리해야할 상태가 늘어나게 되면 더더욱 두드러집니다.</p>
<p>그래서 이를 대체하기 위한 방법으로, **개발자는 상태 변화가 생기면 매번 새로운 객체를 만들어 반환해줘야 한다.**라는 하나의 규칙이 Redux에 생겨난 것입니다. 만약 변화가 없다면, 기존의 객체를 반환하면 되는 것이죠. 다시 말해, 새로운 객체는 곧 새로운 상태를 의미합니다.</p>
<p>이러한 규칙이 존재한다면, Redux가 상태의 변화를 감지하는 것이 굉장히 쉬워집니다. 아시다시피 객체의 참조에 대한 비교는 직접 새로운 비교 알고리즘을 구현하지 않더라도 <code>!==</code> 만으로 쉽게 처리할 수 있거든요.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<h2 id="svelte란"><a class="header" href="#svelte란">Svelte란?</a></h2>
<p>Svelte는 React, Vue와 같이 유연하게 상호작용 가능한 UI를 구성하기 위한 JS 프레임워크다.</p>
<p>단, 한가지 중요한 차이가 있는데, Svelte가 런타임 시점에 코드를 해석하는 것이 아니라 <strong>빌드 과정</strong>을 거친다는 점이다. 즉, 프레임워크의 추상화에 따른 성능적인 비용이 없고, 최초 로딩에 있어 부담이 덜하다.</p>
<p>Svelte에서 애플리케이션은 하나 이상의 컴포넌트들로 구성된다. 컴포넌트는 HTML / CSS / JS를 하나로 재사용 가능하게 묶은 코드 블럭이며, 이는 <code>.svelte</code> 확장자 파일로 관리된다.</p>
<h2 id="data-추가"><a class="header" href="#data-추가">Data 추가</a></h2>
<pre><code class="language-svelte">&lt;script&gt;
  let name = 'world';
&lt;/script&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>
<h2 id="동적-어트리뷰트"><a class="header" href="#동적-어트리뷰트">동적 어트리뷰트</a></h2>
<pre><code class="language-svelte">&lt;script&gt;
  let src = 'some-image.png';
&lt;/script&gt;

&lt;img src={src} alt=&quot;A man dances.&quot;&gt;
</code></pre>
<h2 id="스타일링"><a class="header" href="#스타일링">스타일링</a></h2>
<pre><code class="language-svelte">&lt;style&gt;
  p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
&lt;/style&gt;

&lt;p&gt;This is a paragraph.&lt;/p&gt;
</code></pre>
<h2 id="중첩-nested-컴포넌트"><a class="header" href="#중첩-nested-컴포넌트">중첩 (Nested) 컴포넌트</a></h2>
<pre><code class="language-svelte">&lt;script&gt;
	import Nested from './Nested.svelte';
&lt;/script&gt;

&lt;p&gt;This is a paragraph.&lt;/p&gt;
&lt;Nested/&gt;
</code></pre>
<h2 id="html-태그"><a class="header" href="#html-태그">HTML 태그</a></h2>
<p>JS에서 일반적인 string을 HTML 태그로서 삽입하고자 할 때 사용한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let string = `this string contains some &lt;strong&gt;HTML!!!&lt;/strong&gt;`;
&lt;/script&gt;

&lt;p&gt;{@html string}&lt;/p&gt;
</code></pre>
<h3 id="주의-1"><a class="header" href="#주의-1"><strong>주의!</strong></a></h3>
<blockquote>
<p>Svelte는 <code>{@html ...}</code> 내에 작성된 내용을 DOM에 추가하기 전에 그 어떤 처리도 하지 않는다. 다시 말해, 신뢰할 수 없는 출처를 통해 해당 기능을 적용하고자 하는 경우, 이에 대한 이스케이프를 직접 처리해주는 것이 매우 중요하다. 그렇지 않은 경우 XSS 공격의 위험이 있다.</p>
</blockquote>
<h2 id="프로젝트-세팅"><a class="header" href="#프로젝트-세팅">프로젝트 세팅</a></h2>
<p>Svelte는 Rollup이나 Webpack과 같은 빌드 툴과 함께 사용할 수 있다.</p>
<p>또, VS Code 상에서 Svelte 익스텐션을 설치하여 IDE 상의 피드백을 받을 수 있다.</p>
<p>Webpack을 통한 세팅이 완료가 되면, <code>svelte-loader</code>가 각각의 컴포넌트들을 JS 클래스로 변환한다. 해당 컴포넌트들은 <code>new</code> 키워드로 아래와 같이 사용할 수 있다.</p>
<pre><code class="language-js">import App from './App.svelte';

const app = new App({
  target: document.body,
  props: {
    // we'll learn about props later
    answer: 42,
  },
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="reactivity"><a class="header" href="#reactivity">Reactivity</a></h1>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>기본적인 이벤트 핸들링은 다음과 같이 할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let count = 0;

	function handleClick() {
		count += 1;
	}
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
	Clicked {count} {count === 1 ? 'time' : 'times'}
&lt;/button&gt;
</code></pre>
<h2 id="declarations"><a class="header" href="#declarations">Declarations</a></h2>
<p>Svelte는 컴포넌트의 상태가 변하면 자동으로 DOM을 업데이트한다. 종종 일부 상황에서, 특정 상태에 의존적인 다른 상태가 존재할 수 있는데, 이 경우 <strong>Reactive Declaration</strong> 기능을 통해 이를 처리할 수 있다. 정확한 원리는 JS의 [Label]을 참조하자. 다시 말해, 아래와 같이 `<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">‘</span><span class="mord hangul_fallback">를통해이를적용하는경우</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord hangul_fallback">참조하는다른값이변하는경우해당코드를다시실행하라</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∗</span><span class="mord hangul_fallback">는의미를전달할수있다</span><span class="mord">.‘‘‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">lt</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">i</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">co</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">;</span></span></span></span>: doubled = count * 2;</p>
<pre><code>function handleClick() {
	count += 1;
}
</code></pre>
</script>
<button on:click={handleClick}>
	Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
<p>{count} doubled is {doubled}</p>
```
<p>물론, 단순히 <code>doubled</code>를 새로 선언하지 않고 <code>{count * 2}</code>와 같이 사용해도 된다.</p>
<h2 id="statements"><a class="header" href="#statements">Statements</a></h2>
<p>Declaration 뿐 아니라 Statement를 처리할 수도 있다.</p>
<pre><code class="language-svelte">: {
	console.log(`the count is {count}`);
	alert(`I SAID THE COUNT IS {count}`);
}
</code></pre>
<p>if 문을 적용할 수도 있다.</p>
<pre><code class="language-svelte">: if (count &gt;= 10) {
	alert(`count is dangerously high!`);
	count = 9;
}
</code></pre>
<h2 id="updating-arrays-and-objects"><a class="header" href="#updating-arrays-and-objects">Updating arrays and objects</a></h2>
<p>React와 마찬가지로, 상태가 array 및 objects인 경우 <code>push</code>나 <code>splice</code> 같은 메서드들은 업데이트를 유발하지 않는다. 이를 해결하기 위한 방안 역시 동일하다.</p>
<pre><code class="language-js">let numbers = [1, 2, 3, 4];

function addNumber() {
  numbers = [...numbers, numbers.length + 1];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="props"><a class="header" href="#props">Props</a></h1>
<h2 id="declaring-props"><a class="header" href="#declaring-props">Declaring props</a></h2>
<p>특정 컴포넌트에서 하위 컴포넌트로 데이터를 전달해야할 때, 프로퍼티(props)를 지정해줄 필요가 있다.</p>
<p>Svelte에서는 해당 작업이 <code>export</code> 키워드를 통해서 이루어질 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	export let answer;
&lt;/script&gt;
</code></pre>
<p>이를 상위 컴포넌트에서 사용하려면, 아래와 같은 식이다.</p>
<pre><code class="language-svelte">&lt;Nested answer={42}/&gt;
</code></pre>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<p>아래와 같이 props가 전달되지 않은 경우에 대한 기본값을 지정해줄 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	export let answer = 'a mystery';
&lt;/script&gt;
</code></pre>
<h2 id="spread-props"><a class="header" href="#spread-props">Spread Props</a></h2>
<p>별도로 objects로 props들을 전달하려는 경우, spread 연산자로 이를 처리할 수 있다. React랑 똑같다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import Info from './Info.svelte';

	const pkg = {
		name: 'svelte',
		version: 3,
		speed: 'blazing',
		website: 'https://svelte.dev'
	};
&lt;/script&gt;

&lt;Info {...pkg}/&gt;
</code></pre>
<p>만약, 별도로 <code>export</code> 키워드를 통해 props를 지정하지 않았음에도, 전달받는 값을 사용해야 하는 경우, `<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord hangul_fallback">를통해컴포넌트에서접근할수있다</span><span class="mord">.</span></span></span></span></span></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="logic"><a class="header" href="#logic">Logic</a></h1>
<p>Svelte는 조건 혹은 루프와 같은 로직을 처리할 수 있다.</p>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p>조건에 따라 특정 컴포넌트를 렌더링하고자 하는 경우, 아래와 같이 <code>if</code>를 통해 감싸주자.</p>
<pre><code class="language-svelte">{#if user.loggedIn}
	&lt;button on:click={toggle}&gt;
		Log out
	&lt;/button&gt;
{/if}

{#if !user.loggedIn}
	&lt;button on:click={toggle}&gt;
		Log in
	&lt;/button&gt;
{/if}
</code></pre>
<h2 id="else"><a class="header" href="#else">else</a></h2>
<p>else에 대해서는 아래와 같이 처리할 수 있다.</p>
<pre><code class="language-svelte">{#if user.loggedIn}
	&lt;button on:click={toggle}&gt;
		Log out
	&lt;/button&gt;
{:else}
	&lt;button on:click={toggle}&gt;
		Log in
	&lt;/button&gt;
{/if}
</code></pre>
<ul>
<li><code>#</code> : 블럭을 여는 태그</li>
<li><code>/</code> : 블럭을 닫는 태그</li>
<li><code>:</code> : 블럭 내에서 사용되는 태그</li>
</ul>
<h2 id="else-if"><a class="header" href="#else-if">else-if</a></h2>
<pre><code class="language-svelte">{#if x &gt; 10}
	&lt;p&gt;{x} is greater than 10&lt;/p&gt;
{:else if 5 &gt; x}
	&lt;p&gt;{x} is less than 5&lt;/p&gt;
{:else}
	&lt;p&gt;{x} is between 5 and 10&lt;/p&gt;
{/if}
</code></pre>
<h2 id="each"><a class="header" href="#each">each</a></h2>
<p>여러 개의 데이터가 Array 형태로 있는 경우, <code>each</code> 를 사용해 각각에 대한 순회 로직을 처리할 수 있다.</p>
<p>여기서의 Array는 배열 혹은 유사배열 객체라면 뭐든 가능하다.</p>
<p>또한, 두번째 인자로 <code>index</code>가 전달되기 때문에, 추가적으로 이를 이용할 수 있다.</p>
<pre><code>{#each cats as cat, i}
	&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.youtube.com/watch?v={cat.id}&quot;&gt;
		{i + 1}: {cat.name}
	&lt;/a&gt;&lt;/li&gt;
{/each}
</code></pre>
<h2 id="keyed-each"><a class="header" href="#keyed-each">Keyed each</a></h2>
<p>기본으로, <code>each</code>의 값에 대한 수정이 이루어지는 경우, 이들은 아예 처음부터 리렌더링 된다.</p>
<p>이 경우, 성능 상으로도 우려가 있을 뿐더러, 의도대로 동작하지 않을 가능성이 다분하다.</p>
<p>때문에, <code>each</code> 블럭에 별도의 고유 <code>id</code>를 지정해줌으로써 변경되지 않는 item에 대해서는 리렌더링을 방지해줄 수 있다.</p>
<pre><code class="language-svelte">{#each things as thing (thing.id)}
	&lt;Thing current={thing.color}/&gt;
{/each}
</code></pre>
<p>사실 Svelte는 내부적으로 key 관리에 <code>Map</code>을 사용하기 때문에, 무엇이든지 <code>key</code>로써 사용할 수 있다. 다시말해, 위의 경우에는 굳이 <code>thing.id</code>가 아닌 <code>thing</code>을 사용해도 된다. <strong>하지만, 일반적으로는 string 혹은 number를 사용하는 것이 안전하다.</strong> key 변경 감지에 단순히 참조에 대한 동일성을 확인하기 때문.</p>
<h2 id="await"><a class="header" href="#await">Await</a></h2>
<p>대부분의 웹 애플리케이션은 비동기적으로 데이터를 다루어야만 하는 경우가 발생한다. Svelte는 마크업 내에서 직접적으로 promise를 다룰 수 있게끔 한다.</p>
<pre><code class="language-svelte">{#await promise}
	&lt;p&gt;...waiting&lt;/p&gt;
{:then number}
	&lt;p&gt;The number is {number}&lt;/p&gt;
{:catch error}
	&lt;p style=&quot;color: red&quot;&gt;{error.message}&lt;/p&gt;
{/await}
</code></pre>
<p>오직 가장 최신의 promise에 대해서만 고려되며, 다시 말해 race condition에 대해 신경 쓸 필요가 없다.</p>
<p>사용되는 promise가 rejected 상태가 될 염려가 없는 경우에는, <code>catch</code> 블럭을 제거할 수도 있으며, 심지어 resolved 상태 이전에 별도로 보여주고자 하는 내용이 없는 경우에는 이조차 없애도 상관없다.</p>
<pre><code class="language-svelte">{#await promise then value}
	&lt;p&gt;the value is {value}&lt;/p&gt;
{/await}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="events-1"><a class="header" href="#events-1">Events</a></h1>
<h2 id="dom-events"><a class="header" href="#dom-events">DOM events</a></h2>
<p>이미 앞서 살펴본 것 처럼, <code>on:</code> 명령어를 통해 특정 요소에 이벤트 핸들러를 부여할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
&lt;/script&gt;

&lt;div on:mousemove={handleMousemove}&gt;
	The mouse position is {m.x} x {m.y}
&lt;/div&gt;

&lt;style&gt;
	div { width: 100%; height: 100%; }
&lt;/style&gt;
</code></pre>
<h2 id="inline-handler"><a class="header" href="#inline-handler">Inline handler</a></h2>
<p>인라인으로 직접 부여할 수도 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
&lt;/script&gt;

&lt;div on:mousemove=&quot;{e =&gt; m = { x: e.clientX, y: e.clientY }}&quot;&gt;
	The mouse position is {m.x} x {m.y}
&lt;/div&gt;

&lt;style&gt;
	div { width: 100%; height: 100%; }
&lt;/style&gt;
</code></pre>
<p><code>&quot;</code> 따옴표는 선택사항이다. 없어도 상관 없다.</p>
<p>일부 프레임워크에서는 이러한 인라인 이벤트 핸들러를 사용하는 것을 지양하지만, Svelte의 경우 컴파일링 단계에서 성능 상의 최적화가 진행되므로 문제가 없다.</p>
<h2 id="event-modifiers"><a class="header" href="#event-modifiers">Event modifiers</a></h2>
<p>DOM 이벤트 핸들러들은 그들 동작을 변경해주는 Event modifier를 가질 수 있다. 이를테면, 아래처럼 <code>once</code>를 이벤트 핸들러에 덧붙인 경우 해당 이벤트 핸들러는 딱 한번만 동작한다.</p>
<pre><code class="language-svelte">&lt;button on:click|once={handleClick}&gt;
	Click me
&lt;/button&gt;
</code></pre>
<p>아래는 Event modifier의 전체 목록이다.</p>
<ul>
<li><code>preventDefault</code> - 핸들러를 동작시키기 전에 <code>event.preventDefault()</code>를 먼저 수행한다.</li>
<li><code>stopPropagation</code> - <code>event.stopPropagation()</code>을 호출한다. 다시 말해, 이벤트 버블링/캡처링을 막는다.</li>
<li><code>passive</code> - 터치 및 마우스 휠 이벤트에 대한 스크롤 성능을 향상시킨다. [<a href="https://ko.javascript.info/default-browser-action#ref-2368">참조</a>]</li>
<li><code>nonpassive</code> - <code>passive: false</code>를 의미한다.</li>
<li><code>capture</code> - 이벤트 핸들러의 동작에 있어 버블링이 아닌 캡처링 단계를 사용한다.</li>
<li><code>once</code> - 이벤트 핸들러를 딱 한번만 동작시키고 제거한다.</li>
<li><code>self</code> - 오직 해당 요소 본인에서 이벤트가 발생했을 때만 이벤트 핸들러를 동작시킨다. (event.target === currentTarget)</li>
</ul>
<p>이러한 Event modifier들은 <code>on:click|once|capture={...}</code>와 같이 여러 개를 한번에 체이닝할 수 있다.</p>
<h2 id="component-events"><a class="header" href="#component-events">Component events</a></h2>
<p>컴포넌트 역시 이벤트를 디스패치할 수 있다. 이를 위해서는 이벤트 디스패쳐를 만들어야한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();

	function sayHello() {
		dispatch('message', {
			text: 'Hello!'
		});
	}
&lt;/script&gt;
</code></pre>
<p>위에서의 <code>text</code>는 <code>event.detail.text</code>를 통해 접근할 수 있다.</p>
<h2 id="event-forwarding"><a class="header" href="#event-forwarding">Event forwarding</a></h2>
<p>DOM 이벤트와 다르게, 컴포넌트 이벤트는 버블링되지 않는다. 따라서, 상위 컴포넌트에서 이벤트를 전달받기 위해선 각 층의 컴포넌트마다 이벤트를 디스패치 해주어야 한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import Inner from './Inner.svelte';
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();

	function forward(event) {
		dispatch('message', event.detail);
	}
&lt;/script&gt;

&lt;Inner on:message={forward}/&gt;
</code></pre>
<p>단, 이러한 과정 자체가 너무 많은 코드를 작성하게 만드므로, Svelte에서는 이러한 내용을 다음과 같이 짧게 처리할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import Inner from './Inner.svelte';
&lt;/script&gt;

&lt;Inner on:message/&gt;
</code></pre>
<h2 id="dom-event-forwarding"><a class="header" href="#dom-event-forwarding">DOM event forwarding</a></h2>
<p>DOM 이벤트 역시 이벤트 포워딩을 처리할 수 있다. 해당 요소 본인이 처리할 이벤트 핸들러가 존재하지 않더라도, 상위 컴포넌트로 이를 전달해주는 역할을 한다.</p>
<pre><code class="language-svelte">&lt;button on:click&gt;
	Click me
&lt;/button&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="bindings"><a class="header" href="#bindings">Bindings</a></h1>
<h2 id="text-inputs"><a class="header" href="#text-inputs">Text inputs</a></h2>
<p>일반적으로, Svelte에서의 데이터 흐름은 탑-다운 형식이다. 부모 컴포넌트에서 자식 컴포넌트에 props를 전달할 수 있고, 컴포넌트는 보유한 요소들에 대해 어트리뷰트를 설정할 수 있다.</p>
<p>가끔, 이러한 규칙을 깨야하는 경우가 있는데, 대표적인 경우가 컴포넌트 내에 <code>&lt;input&gt;</code> 태그를 보유한 경우다. 우리는 <code>on:input</code>에 대한 이벤트 핸들러를 추가하여 <code>event.target.name</code>에 따라 별도의 상태값을 변경하도록 구성할 수 있다. 다만, 이러한 과정 자체를 매번 반복하게 되면 너무 번거롭다.</p>
<p>대신에, 이러한 상황에 <code>bind:value</code> 명령을 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let name = 'world';
&lt;/script&gt;

&lt;input bind:value={name}&gt;

&lt;h1&gt;Hello {name}!&lt;/h1&gt;
</code></pre>
<p><code>bind</code>를 사용하는 경우, <code>input</code>의 <code>value</code>값 변경에 따라 <code>name</code>의 값을 변경할 뿐만 아니라, <code>name</code>의 값이 변경됨에 따라 <code>value</code>값 역시 변경된다.</p>
<h2 id="numeric-inputs"><a class="header" href="#numeric-inputs">Numeric inputs</a></h2>
<p>DOM 상에서, 모든 값들은 string 으로 다루어진다. 이런 경우, <code>type=&quot;number&quot;</code> 혹은 <code>type=&quot;range&quot;</code>인 상황에서, 값을 다루기에 다소 까다로워지며, 별도로 데이터 타입을 변환해주어야 한다.</p>
<p>Svelte에서는 <code>bind:value</code>를 사용하면, 알아서 이러한 과정을 처리해준다.</p>
<pre><code class="language-svelte">&lt;input type=number bind:value={a} min=0 max=10&gt;
&lt;input type=range bind:value={a} min=0 max=10&gt;
</code></pre>
<h2 id="checkbox-inputs"><a class="header" href="#checkbox-inputs">Checkbox inputs</a></h2>
<p>체크박스들은 상태 값들을 토글링(toggling)하기 위해 사용된다. 이 경우, 이들의 상태값은 <code>value</code>가 아닌 <code>checked</code>가 되므로, 다음과 같이 사용해야 한다.</p>
<pre><code class="language-svelte">&lt;input type=checkbox bind:checked={yes}&gt;
</code></pre>
<h2 id="group-inputs"><a class="header" href="#group-inputs">Group inputs</a></h2>
<p>동일한 값에 대한 여러 input들이 존재한다면, <code>bind:group</code>을 사용할 수 있다. 대표적으로 <code>radio</code> 혹은 <code>checkbox</code> 태그가 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let scoops = 1;
	let flavours = ['Mint choc chip'];

	let menu = [
		'Cookies and cream',
		'Mint choc chip',
		'Raspberry ripple'
	];

	function join(flavours) {
		if (flavours.length === 1) return flavours[0];
		return `&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.001892em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ce&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05724em;&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.751892em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.751892em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{flavours[flavours.length - 1]}`;
	}
&lt;/script&gt;

&lt;h2&gt;Size&lt;/h2&gt;

&lt;label&gt;
	&lt;input type=radio bind:group={scoops} value={1}&gt;
	One scoop
&lt;/label&gt;

&lt;label&gt;
	&lt;input type=radio bind:group={scoops} value={2}&gt;
	Two scoops
&lt;/label&gt;

&lt;label&gt;
	&lt;input type=radio bind:group={scoops} value={3}&gt;
	Three scoops
&lt;/label&gt;

&lt;h2&gt;Flavours&lt;/h2&gt;

{#each menu as flavour}
	&lt;label&gt;
		&lt;input type=checkbox bind:group={flavours} value={flavour}&gt;
		{flavour}
	&lt;/label&gt;
{/each}

{#if flavours.length === 0}
	&lt;p&gt;Please select at least one flavour&lt;/p&gt;
{:else if flavours.length &gt; scoops}
	&lt;p&gt;Can't order more flavours than scoops!&lt;/p&gt;
{:else}
	&lt;p&gt;
		You ordered {scoops} {scoops === 1 ? 'scoop' : 'scoops'}
		of {join(flavours)}
	&lt;/p&gt;
{/if}
</code></pre>
<h2 id="textarea-inputs"><a class="header" href="#textarea-inputs">Textarea inputs</a></h2>
<p><code>&lt;textarea&gt;</code> 요소는 <code>&lt;text&gt;</code>와 거의 동일하게 동작하며, <code>bind:value</code>를 사용하면 된다.</p>
<pre><code class="language-svelte">&lt;textarea bind:value={value}&gt;&lt;/textarea&gt;
</code></pre>
<p>만약, 변경할 상태의 변수명이 똑같이 <code>value</code>로 일치한다면, 아래와 같이 약식으로 작성할 수 있다.</p>
<pre><code class="language-svelte">&lt;textarea bind:value&gt;&lt;/textarea&gt;
</code></pre>
<h2 id="select-bindings"><a class="header" href="#select-bindings">Select bindings</a></h2>
<p><code>&lt;select&gt;</code> 요소에도 <code>bind:value</code>를 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;select bind:value={selected} on:change=&quot;{() =&gt; answer = ''}&quot;&gt;
</code></pre>
<p><code>&lt;select&gt;</code> 하위에 있는 <code>&lt;option&gt;</code> 값들이 string이 아닌 object임을 주의하자.</p>
<p><code>selected</code>에 대한 기본값을 설정하지 않았기 때문에, binding 시에 기본적으로 <code>select</code>는 리스트의 첫번째 값을 <code>selected</code>로 설정해준다.</p>
<h2 id="select-multiple"><a class="header" href="#select-multiple">Select multiple</a></h2>
<p><code>&lt;select&gt;</code>는 <code>multiple</code> 어트리뷰트를 사용할 수 있으며, 이 경우 하나 이상의 값들을 <strong>Array 형태로 받아올 수 있게 된다.</strong></p>
<pre><code class="language-svelte">&lt;h2&gt;Flavours&lt;/h2&gt;

&lt;select multiple bind:value={flavours}&gt;
	{#each menu as flavour}
		&lt;option value={flavour}&gt;
			{flavour}
		&lt;/option&gt;
	{/each}
&lt;/select&gt;
</code></pre>
<h2 id="contenteditable-bindings"><a class="header" href="#contenteditable-bindings">Contenteditable bindings</a></h2>
<p><code>contenteditable=&quot;true&quot;</code> 어트리뷰트를 보유한 요소들은 <code>textContent</code>와 <code>innerHTML</code>에 대해서도 바인딩을 할 수 있다.</p>
<pre><code class="language-svelte">&lt;div
	contenteditable=&quot;true&quot;
	bind:innerHTML={html}
&gt;&lt;/div&gt;
</code></pre>
<h2 id="each-block-bindings"><a class="header" href="#each-block-bindings">Each block bindings</a></h2>
<p><code>each</code> 문 내에서도 바인딩을 할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let todos = [
		{ done: false, text: 'finish Svelte tutorial' },
		{ done: false, text: 'build an app' },
		{ done: false, text: 'world domination' }
	];

	function add() {
		todos = todos.concat({ done: false, text: '' });
	}

	function clear() {
		todos = todos.filter(t =&gt; !t.done);
	}

	: remaining = todos.filter(t =&gt; !t.done).length;
&lt;/script&gt;

&lt;h1&gt;Todos&lt;/h1&gt;

{#each todos as todo}
	&lt;div class:done={todo.done}&gt;
		&lt;input
			type=checkbox
			bind:checked={todo.done}
		&gt;

		&lt;input
			placeholder=&quot;What needs to be done?&quot;
			bind:value={todo.text}
		&gt;
	&lt;/div&gt;
{/each}

&lt;p&gt;{remaining} remaining&lt;/p&gt;

&lt;button on:click={add}&gt;
	Add new
&lt;/button&gt;

&lt;button on:click={clear}&gt;
	Clear completed
&lt;/button&gt;

&lt;style&gt;
	.done {
		opacity: 0.4;
	}
&lt;/style&gt;
</code></pre>
<p>이 경우 바인딩은 <code>todos</code> Array를 직접 변경하게 된다. 본인이 불변성을 유지하는 형태를 선호한다면, 이 경우엔 바인딩을 사용하지 말고 이벤트 핸들러를 직접 작성하는 편이 좋다.</p>
<h2 id="media-elements"><a class="header" href="#media-elements">Media elements</a></h2>
<p><code>&lt;audio&gt;</code>와 <code>&lt;video&gt;</code> 요소는 바인딩 할 수 있는 수많은 프로퍼티들이 존재한다.</p>
<p>아래는 바인딩 가능한 읽기 전용 프로퍼티다.</p>
<ul>
<li><code>duration</code> (readonly) — 비디오 및 오디오의 전체 시간, 초 단위</li>
<li><code>buffered</code> (readonly) — {start, end} 객체 Array</li>
<li><code>seekable</code> (readonly) — {start, end} 객체 Array</li>
<li><code>played</code> (readonly) — {start, end} 객체 Array</li>
<li><code>seeking</code> (readonly) — boolean</li>
<li><code>ended</code> (readonly) — boolean</li>
</ul>
<p>비디오의 경우는 <code>videoWidth</code> 및 <code>videoHeight</code> 읽기 전용 속성이 추가적으로 존재한다.</p>
<p>아래는 쌍방향으로 바인딩 가능한 프로퍼티들이다.</p>
<ul>
<li><code>currentTime</code> - 비디오 및 오디오의 현재 위치</li>
<li><code>playbackRate</code> - 비디오 및 오디오의 재생 속도, <code>1</code>이 기본.</li>
<li><code>paused</code> - 정지 여부</li>
<li><code>volume</code> - <code>0</code>부터 <code>1</code> 사이의 값</li>
<li><code>muted</code> - 음소거 여부, boolean</li>
</ul>
<h2 id="dimensions"><a class="header" href="#dimensions">Dimensions</a></h2>
<p>모든 블록 요소들은 <code>clientWidth</code>, <code>clientHeight</code>, <code>offsetWidth</code>, 그리고 <code>offsetHeight</code>에 대한 바인딩을 할 수 있다.</p>
<pre><code>&lt;div bind:clientWidth={w} bind:clientHeight={h}&gt;
	&lt;span style=&quot;font-size: {size}px&quot;&gt;{text}&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>이들 바인딩은 읽기 전용이며, 이들 값을 직접 변경하는 것은 아무 의미가 없다.</p>
<blockquote>
<p><strong>주의</strong> :
요소의 크기 등을 측정하기 위해서는 내부적으로 <a href="http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/">이런 테크닉</a>을 사용한다. 이 경우, 오버헤드에 대한 우려 때문에 너무 많은 수에 대해 해당 바인딩을 사용하지 않는 것을 추천한다.</p>
</blockquote>
<h2 id="this"><a class="header" href="#this">This</a></h2>
<p><code>this</code>에 대한 바인딩은 읽기 전용이며, 모든 요소 및 컴포넌트에 사용할 수 있다.</p>
<p>이는 React에서의 Ref와 유사하며, 요소 및 컴포넌트에 대한 참조값을 얻을 수 있다.</p>
<pre><code class="language-svelte">&lt;canvas
	bind:this={canvas}
	width={32}
	height={32}
&gt;&lt;/canvas&gt;
</code></pre>
<p>위 예시에서 <code>canvas</code>는 컴포넌트가 마운트되기 전까지는 <code>undefined</code>임에 유의하자. 때문에, 마운트 시에 해당 컴포넌트 및 요소에 특정 로직을 적용하려면 <code>onMount</code> 등의 라이프사이클 메서드를 사용해야 한다. 이에 대해선 추후 살펴본다.</p>
<h2 id="component-bindings"><a class="header" href="#component-bindings">Component bindings</a></h2>
<p>DOM 요소들의 프로퍼티에 대해 바인딩을 할 수 있는 것처럼, 컴포넌트의 props에 대해서도 바인딩을 할 수 있다.</p>
<pre><code class="language-svelte">&lt;Keypad bind:value={pin} on:submit={handleSubmit}/&gt;
</code></pre>
<p>이 경우, 하위 컴포넌트에서 상태 변화가 일어나면, 바인딩을 적용한 부모 요소에 대해서도 이에 따른 변경이 일어난다.</p>
<blockquote>
<p><strong>주의</strong> : 가능하다면 컴포넌트 바인딩은 사용하지 않는 편이 좋다. 애플리케이션 규모가 커지면서, 데이터 흐름이 너무 많아지는 경우 이에 대한 추적이 어려울 수 있다. 이러한 문제는 single souce of truth가 없는 경우에 더욱 심각해진다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h1>
<h2 id="onmount"><a class="header" href="#onmount">onMount</a></h2>
<p>모든 컴포넌트는 생성되는 시점에서부터 사라질 때까지 생명주기가 존재한다. Svelte 역시 이를 다루기 위한 몇가지 함수들을 제공한다.</p>
<p><code>onMount</code>는 그중 가장 자주 사용하게 될 생명주기 함수로, 최초로 DOM에 렌더링된 이후에 실행된다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { onMount } from 'svelte';

	let photos = [];

	onMount(async () =&gt; {
		const res = await fetch(`https://jsonplaceholder.typicode.com/photos?_limit=20`);
		photos = await res.json();
	});
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>주의</strong> : SSR에 의해, <code>fetch</code> 메서드는 <code>script</code> 태그의 최상위 보다 <code>onMount</code>에 위치하는 것이 좋다. <code>onDestroy</code>를 제외하면, SSR 중에는 생명주기 함수가 실행되지 않으며, 다시말해 DOM에 마운트 된 이후에야 실행되어야 하는 데이터를 페칭하는 경우를 방지할 수 있다.</p>
</blockquote>
<p><code>onMount</code>의 콜백함수에서 함수를 반환할 수 있는데, 이 경우 해당 함수는 컴포넌트가 사라질 때 호출된다. (clean up)</p>
<h2 id="ondestroy"><a class="header" href="#ondestroy">onDestroy</a></h2>
<p>함수에 사라질 때 특정 로직을 처리하고자 할 때 <code>onDestroy</code> 함수를 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { onDestroy } from 'svelte';

	let seconds = 0;
	const interval = setInterval(() =&gt; seconds += 1, 1000);

	onDestroy(() =&gt; clearInterval(interval));
&lt;/script&gt;
</code></pre>
<p>이러한 생명주기 함수들을 React의 커스텀 Hook 처럼 사용할 수도 있다.</p>
<pre><code class="language-svelte">import { onDestroy } from 'svelte';

export function onInterval(callback, milliseconds) {
	const interval = setInterval(callback, milliseconds);

	onDestroy(() =&gt; {
		clearInterval(interval);
	});
}
</code></pre>
<h2 id="beforeupdate--afterupdate"><a class="header" href="#beforeupdate--afterupdate">beforeUpdate &amp; afterUpdate</a></h2>
<p><code>beforeUpdate</code> 함수는 컴포넌트의 상태에 따라 DOM이 업데이트 되기 전마다 실행되며, 반대로 <code>afterUpdate</code>는 DOM이 업데이트 된 이후에 실행된다.</p>
<p>단순히 상태 중심적인 방식으로는 처리하기 어려운 로직을 처리하기 위한 경우에 종종 유용하다. (ex. 스크롤 위치 변경 등)</p>
<pre><code class="language-svelte">let div;
let autoscroll;

beforeUpdate(() =&gt; {
	autoscroll = div &amp;&amp; (div.offsetHeight + div.scrollTop) &gt; (div.scrollHeight - 20);
});

afterUpdate(() =&gt; {
	if (autoscroll) div.scrollTo(0, div.scrollHeight);
});
</code></pre>
<h2 id="tick"><a class="header" href="#tick">tick</a></h2>
<p><code>tick</code> 함수는 다른 생명주기 함수들과 다르게, 최초에 함수가 초기화되는 시점이 아닌, 어디서는 호출할 수 있다. 해당 함수는 보류 중인 상태 변경 사항이 DOM에 적용된 이후 즉시 resolved 되는 promise를 반환한다.</p>
<p>Svelte는 컴포넌트의 상태가 업데이트될 때, DOM을 바로 업데이트하지 않고, 적용할 다른 변경 사항이 없는지를 판단하기 위해 다음 마이크로태스트까지 대기한다. 이렇게 함으로써 불필요한 동작을 피하고, 브라우저가 더 효율적으로 작업을 일괄 처리할 수 있도록 도와준다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { tick } from 'svelte';

	let text = `Select some text and hit the tab key to toggle uppercase`;

	async function handleKeydown(event) {
		if (event.key !== 'Tab') return;

		event.preventDefault();

		const { selectionStart, selectionEnd, value } = this;
		const selection = value.slice(selectionStart, selectionEnd);

		const replacement = /[a-z]/.test(selection)
			? selection.toUpperCase()
			: selection.toLowerCase();

		text = (
			value.slice(0, selectionStart) +
			replacement +
			value.slice(selectionEnd)
		);

		await tick();
		this.selectionStart = selectionStart;
		this.selectionEnd = selectionEnd;
	}
&lt;/script&gt;

&lt;style&gt;
	textarea {
		width: 100%;
		height: 200px;
	}
&lt;/style&gt;

&lt;textarea value={text} on:keydown={handleKeydown}&gt;&lt;/textarea&gt;
</code></pre>
<p>위와 같이 사용하는 경우, <code>await tick();</code>의 이전까지의 내용들이 모두 적용되고, DOM이 업데이트 된 이후, 그 다음의 로직들이 처리된다. 즉, DOM이 업데이트되고 나서야 <code>await tick()</code> 이후의 코드가 실행된다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="stores"><a class="header" href="#stores">Stores</a></h1>
<h2 id="writable-stores"><a class="header" href="#writable-stores">Writable stores</a></h2>
<p>Svelte에서는 <em>store</em>를 통해 상태 로직을 컴포넌트와 분리할 수 있다. store는 상태값이 변경되었을 때 관련 컴포넌트들에게 알려주는 <code>subscribe</code> 메서드를 가진 단순한 객체다.</p>
<p>store 중에는 <strong>writable store</strong>가 있으며, 이는 <code>set</code>과 <code>update</code>메서드를 갖는다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { count } from './stores.js';
	import Incrementer from './Incrementer.svelte';
	import Decrementer from './Decrementer.svelte';
	import Resetter from './Resetter.svelte';

	let count_value;

	const unsubscribe = count.subscribe(value =&gt; {
		count_value = value;
	});
&lt;/script&gt;
</code></pre>
<p><code>update</code>는 인수를 콜백함수로 받으며, <code>set</code>는 직접적인 값을 받는다.</p>
<pre><code class="language-svelte">function increment() {
	count.update(n =&gt; n + 1);
}
</code></pre>
<pre><code class="language-svelte">function reset() {
	count.set(0);
}
</code></pre>
<h2 id="auto-subscriptions"><a class="header" href="#auto-subscriptions">Auto-subscriptions</a></h2>
<p>만약, 컴포넌트가 초기화와 제거를 여러번 반복하게 되는 경우, <code>unsubscribe</code> 함수를 실행하지 않게되면 메모리 누수의 위험이 있다.</p>
<p>따라서, 이를 방지하기 위해선 <code>onDestroy</code> 생명주기 메서드에서 이를 호출해주어야 한다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { onDestroy } from 'svelte';
	import { count } from './stores.js';
	import Incrementer from './Incrementer.svelte';
	import Decrementer from './Decrementer.svelte';
	import Resetter from './Resetter.svelte';

	let count_value;

	const unsubscribe = count.subscribe(value =&gt; {
		count_value = value;
	});

	onDestroy(unsubscribe);
&lt;/script&gt;

&lt;h1&gt;The count is {count_value}&lt;/h1&gt;
</code></pre>
<p>헌데, 여러 컴포넌트에 대해 동일한 작업을 해주어야 하는 상황이라면 이런 방법이 다소 번거롭게 느껴질 수 있다.(boilerplatey) Svelte는 ``만 덧붙이면 store 값에 대해 앞선 작업들을 알아서 처리해준다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { count } from './stores.js';
	import Incrementer from './Incrementer.svelte';
	import Decrementer from './Decrementer.svelte';
	import Resetter from './Resetter.svelte';
&lt;/script&gt;

&lt;h1&gt;The count is {count}&lt;/h1&gt;
</code></pre>
<p>이러한 Auto-subscription은 store의 변수들이 컴포넌트 최상위 스코프에서 선언 및 import 되었을 때만 제대로 동작한다.</p>
<p><code>&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;로변수명을시작하는것은&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ore&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;값을참조하겠다는것으로간주되며&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;그렇지않은경우에대해&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05764em;&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;는&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code>로 임의의 변수를 선언하는 것을 방지한다.</p>
<h2 id="readable-stores"><a class="header" href="#readable-stores">Readable stores</a></h2>
<p>모든 경우에 store를 참조하는 컴포넌트들에게 쓰기 권한을 부여할 필요는 없다. 이를테면, 시간, 마우스 위치, 지리적 위치 등을 다루는 경우가 그렇다.</p>
<p>이러한 경우에 readable store를 사용할 수 있다.</p>
<pre><code class="language-svelte">export const time = readable(new Date(), function start(set) {
	const interval = setInterval(() =&gt; {
		set(new Date());
	}, 1000);

	return function stop() {
		clearInterval(interval);
	};
});
</code></pre>
<p><code>readable</code>의 첫번째 인수는 초기값이며, 설정할 필요가 없다면 <code>null</code> 혹은 <code>undefined</code>로 두면 된다.</p>
<p>두번째 인수는 <code>start</code> 콜백함수이며, 이는 <code>set</code> 콜백함수를 파라미터로 받고 <code>stop</code> 함수를 반환하는 함수다. <code>start</code> 함수는 최초의 subscriber에 의해 상태값이 참조되는 경우에 호출되며, <code>stop</code>은 마지막 subscriber가 unscribe를 했을 때에 실행되는 cleanup 함수다.</p>
<h2 id="derived-stores"><a class="header" href="#derived-stores">Derived stores</a></h2>
<p>특정 store의 값에 의존하는 다른 값이 있는 경우, <code>derived</code>를 통해 새로운 store를 만들어 줄 수 있다. 아래는 특정 페이지가 열리고 나서의 시간을 측정한 상태값을 보유한 derived store다.</p>
<pre><code class="language-svelte">export const elapsed = derived(
	time,
	&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69862em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ro&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;((&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;time - start) / 1000)
);
</code></pre>
<p>여러 inputs들로부터 derive store를 갖추고, 값을 반환하는 대신 명시적으로 <code>set</code>를 통해 값을 변경해줄 수도 있다. 이에 대해서는 <a href="https://svelte.dev/docs#derived">여기</a>를 참조하자.</p>
<h2 id="custom-stores"><a class="header" href="#custom-stores">Custom stores</a></h2>
<p>어떤 객체든 <code>subscribe</code> 메서드가 적절하게 실행되기만 하면, 이는 store로 취급된다. 이를 통해 유저가 임의로 커스텀 store를 만들어 로직을 처리할 수 있다.</p>
<p>해당 문서의 앞쪽에서 <code>writable</code>을 통해 store를 다루었던 내용을 커스텀 store를 통해 리팩토링해보자.</p>
<pre><code class="language-svelte">function createCount() {
	const { subscribe, set, update } = writable(0);

	return {
		subscribe,
		increment: () =&gt; update(n =&gt; n + 1),
		decrement: () =&gt; update(n =&gt; n - 1),
		reset: () =&gt; set(0)
	};
}
</code></pre>
<h2 id="store-bindings"><a class="header" href="#store-bindings">Store bindings</a></h2>
<p>writable store를 사용하는 경우, 로컬 컴포넌트의 상태값과 store의 값을 binding 해줄 수 있다.</p>
<p>아래 예시에서는 <code>name</code> store 값을 <code>input</code>의 <code>value</code>값에 바인딩을 해주는 예시다.</p>
<pre><code class="language-svelte">&lt;input bind:value={name}&gt;
</code></pre>
<p>이후, input의 <code>value</code>에 변경이 있다면 <code>name</code> store값 역시 자동으로 업데이트된다.</p>
<p>컴포넌트 내부에서 값을 직접 할당해줄 수도 있다.</p>
<pre><code class="language-svelte">&lt;button on:click=&quot;{() =&gt; name += '!'}&quot;&gt;
	Add exclamation mark!
&lt;/button&gt;
</code></pre>
<p>위에서의 <code>name += '!'</code>은 `name.set(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mord"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">!</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">‘</span><span class="mord hangul_fallback">의호출과동일하다</span><span class="mord">.</span></span></span></span></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="motion"><a class="header" href="#motion">Motion</a></h1>
<h2 id="tweened"><a class="header" href="#tweened">Tweened</a></h2>
<p>Svelte는 상호작용에 따른 매끄러운 UI 애니메이션을 구성하기 위한 툴을 제공한다.</p>
<p><code>tweened</code>를 통해 <code>progress</code> store를 변경해보자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { tweened } from 'svelte/motion';
	import { cubicOut } from 'svelte/easing';

	const progress = tweened(0, {
		duration: 400,
		easing: cubicOut
	});
&lt;/script&gt;
</code></pre>
<p><code>tweened</code>의 첫번째 인수에는 초기값이, 두번째 인수에는 <code>options</code>가 전달된다. 가능한 <code>option</code>에는 다음과 같은 것들이 있다.</p>
<ul>
<li><code>delay</code> - tween이 시작되기 전의 딜레이. <code>ms</code>단위.</li>
<li><code>duration</code> - tween의 동작 시간, <code>ms</code>단위 혹은 <code>(from, to) =&gt; ms</code> 함수</li>
<li><code>easing</code> - <code>p =&gt; t</code> 함수</li>
<li><code>interplate</code> - 커스텀 <code>(from, to) =&gt; t =&gt; value</code> 함수. 기본적으로 Svelte는 number, date, 동일한 모양의 object, array에 대해서만 지원하기 때문에, 컬러스트링 등에 대해 적용하기 위해서는 별도로 커스텀 interpolator를 전달해야한다.</li>
</ul>
<p>해당 옵션들을 <code>progress.set</code> 혹은 <code>progress.update</code>의 두번째 인수로 전달할 수 있으며, 이 경우 기본 옵션에 오버라이딩된다. <code>set</code>와 <code>update</code> 메서드는 tween이 완료될 때 resolved 되는 프라미스를 반환한다.</p>
<h2 id="spring"><a class="header" href="#spring">Spring</a></h2>
<p><code>spring</code> 함수는 <code>tweened</code>보다 좀 더 자주 변경되는 값에 더 최적화된 함수이다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { spring } from 'svelte/motion';

	let coords = spring({ x: 50, y: 50 });
	let size = spring(10);
&lt;/script&gt;
</code></pre>
<p>추가적으로 각각 <code>0</code>과 <code>1</code> 사이의 <code>{stiffness, damping}</code> 옵션을 넘겨줄 수 있다.</p>
<pre><code class="language-svelte">let coords = spring({ x: 50, y: 50 }, {
	stiffness: 0.1,
	damping: 0.25
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="transitions"><a class="header" href="#transitions">Transitions</a></h1>
<h2 id="the-transition-directive"><a class="header" href="#the-transition-directive">The transition directive</a></h2>
<p>Svelte는 <code>transition</code> 선언을 통해 트랜지션을 매우 쉽게 구현할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { fade } from 'svelte/transition';
	let visible = true;
&lt;/script&gt;

&lt;label&gt;
	&lt;input type=&quot;checkbox&quot; bind:checked={visible}&gt;
	visible
&lt;/label&gt;

&lt;p transition:fade&gt;Fades in and out&lt;/p&gt;
</code></pre>
<h2 id="adding-parameters"><a class="header" href="#adding-parameters">Adding parameters</a></h2>
<p>트랜지션 함수들은 추가적으로 매개변수를 가질 수도 있다. 이번엔 <code>fade</code>가 아닌 <code>fly</code>의 예를 보자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { fly } from 'svelte/transition';
	let visible = true;
&lt;/script&gt;

&lt;p transition:fly=&quot;{{ y: 200, duration: 2000 }}&quot;&gt;
	Flies in and out
&lt;/p&gt;
</code></pre>
<p>트랜지션이 <strong>reversible</strong>하다는 점을 눈여겨보자. Svelte에서 제공하는 함수를 통해 구현된 트랜지션은 진행되는 도중에도 다시 되돌아올 수 있다.</p>
<h2 id="in-and-out"><a class="header" href="#in-and-out">In and out</a></h2>
<p>요소가 나타날 때와, 없어질 때 각각의 Transition을 다르게 구현하고자 하는 경우, <code>transition</code> 명령 대신, 요소에 <code>in</code>과 <code>out</code> 명령을 따로 지정할 수 있다.</p>
<pre><code class="language-svelte">import { fade, fly } from 'svelte/transition';

&lt;p in:fly=&quot;{{ y: 200, duration: 2000 }}&quot; out:fade&gt;
	Flies in, fades out
&lt;/p&gt;
</code></pre>
<h2 id="custom-css-transitions"><a class="header" href="#custom-css-transitions">Custom CSS transitions</a></h2>
<p><code>svelte/transition</code> 모듈에는 자체적으로 유용한 빌트인 트랜지션들이 많이 있으나, 직접 트랜지션을 구성하는 것도 쉽다.</p>
<p>아래는 <code>fade</code> 함수의 소스코드다.</p>
<pre><code class="language-js">function fade(node, { delay = 0, duration = 400 }) {
  const o = +getComputedStyle(node).opacity;

  return {
    delay,
    duration,
    css: (t) =&gt; `opacity: {t * o}`,
  };
}
</code></pre>
<p>이 함수는 두 개의 매개변수를 받는다. 하나는 트랜지션이 적용될 노트이고, 다른 하나는 아래의 옵션들이다.</p>
<ul>
<li><code>delay</code> - 트랜지션이 시작되기 전의 딜레이, ms 단위</li>
<li><code>duration</code> - 트랜지션의 전체 길이, ms 단위</li>
<li><code>easing</code> - <code>p =&gt; t</code> easing 함수</li>
<li><code>css</code> - <code>(t, u) =&gt; css</code>함수, 여기서 <code>u === 1 - t</code> 이다.</li>
<li><code>tick</code> - 노드에 효과를 적용하는 <code>(t, u) =&gt; {...}</code> 함수</li>
</ul>
<p><code>t</code>는 인트로의 시작 또는 아웃트로의 끝에서 0이고, 인트로의 끝 또는 아웃트로의 시작에서 1이다.</p>
<p>가능하다면 대부분은 <code>tick</code> 프로퍼티가 아닌 <code>css</code> 프로퍼티를 반환해야 하는데, CSS 애니메이션은 가능하다면 브라우저의 버벅거림을 방지하기 위해 메인 스레드에서 실행되지 않기 때문이다. Svelte는 트랜지션을 시뮬레이션하고, CSS 애니메이션을 구성한 뒤 이를 실행한다.</p>
<p>이를테면, <code>fade</code> 트랜지션은 아래와 같은 CSS 애니메이션을 생성한다.</p>
<pre><code class="language-css">0% {
  opacity: 0;
}
10% {
  opacity: 0.1;
}
20% {
  opacity: 0.2;
}
/* ... */
100% {
  opacity: 1;
}
</code></pre>
<p>좀 더 창의적이고 쓸데없는 애니메이션을 하나 만들어보자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { fade } from 'svelte/transition';
	import { elasticOut } from 'svelte/easing';

	let visible = true;

	function spin(node, { duration }) {
		return {
			duration,
			css: t =&gt; {
				const eased = elasticOut(t);

				return `
					transform: scale({eased}) rotate(&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;se&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1080&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{~~(t * 360)},
						&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{Math.min(50, 500 - 500 * t)}%
					);`
			}
		};
	}
&lt;/script&gt;
</code></pre>
<h2 id="custom-js-transitions"><a class="header" href="#custom-js-transitions">Custom JS transitions</a></h2>
<p>일반적으로는 가능하다면 CSS를 이용한 트랜지션을 사용하는 것이 좋지만, 일부 경우에는 JS 없이 구현하기 어려운 효과가 있을 수 있다. 대표적인 것이 타자기 효과다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	let visible = false;

	function typewriter(node, { speed = 50 }) {
		const valid = (
			node.childNodes.length === 1 &amp;&amp;
			node.childNodes[0].nodeType === Node.TEXT_NODE
		);

		if (!valid) {
			throw new Error(`This transition only works on elements with a single text node child`);
		}

		const text = node.textContent;
		const duration = text.length * speed;

		return {
			duration,
			tick: t =&gt; {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
		};
	}
&lt;/script&gt;

&lt;label&gt;
	&lt;input type=&quot;checkbox&quot; bind:checked={visible}&gt;
	visible
&lt;/label&gt;

{#if visible}
	&lt;p in:typewriter&gt;
		The quick brown fox jumps over the lazy dog
	&lt;/p&gt;
{/if}

</code></pre>
<h2 id="transition-events"><a class="header" href="#transition-events">Transition events</a></h2>
<p>트랜지션의 시작과 끝이 언제인지를 아는 것이 유용할 때가 있다. Svelte는 다른 DOM 이벤트들과 마찬가지로 해당 시점에 이벤트를 디스패치해준다.</p>
<pre><code class="language-svelte">&lt;p
	transition:fly=&quot;{{ y: 200, duration: 2000 }}&quot;
	on:introstart=&quot;{() =&gt; status = 'intro started'}&quot;
	on:outrostart=&quot;{() =&gt; status = 'outro started'}&quot;
	on:introend=&quot;{() =&gt; status = 'intro ended'}&quot;
	on:outroend=&quot;{() =&gt; status = 'outro ended'}&quot;
&gt;
	Flies in and out
&lt;/p&gt;
</code></pre>
<h2 id="local-transitions"><a class="header" href="#local-transitions">Local transitions</a></h2>
<p>일반적으로 트랜지션은 컨테이너 블록이 추가되거나 없어지는 모든 경우에 실행된다.</p>
<p>만약, 모든 경우가 아니라, 요소 본인에 대한 직접적인 추가/삭제에 대해서만 트랜지션 효과를 주고자 한다면, local transition을 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;div transition:slide|local&gt;
	{item}
&lt;/div&gt;
</code></pre>
<h2 id="deferred-transitions"><a class="header" href="#deferred-transitions">Deferred transitions</a></h2>
<p>Svelte의 트랜지션 엔진이 갖는 강력한 특징은 트랜지션을 지연시킬 수 있다는 점이다. 따라서, 여러 개의 요소 간에도 이를 조정할 수 있다.</p>
<p><code>crossfade</code> 함수는 <code>send</code>와 <code>receive</code>라는 두 쌍의 트랜지션을 만들어낸다. 어떤 요소가 <code>send</code>될 때, 해당 요소는 여기에 상응하는 <code>received</code> 요소를 찾고나서, 찾아낸 요소의 위치로 이동하며 트랜지션 효과를 실행한다.</p>
<pre><code class="language-svelte">  &lt;script&gt;
	import { quintOut } from 'svelte/easing';
	import { crossfade } from 'svelte/transition';

	const [send, receive] = crossfade({
		duration: d =&gt; Math.sqrt(d * 200),

		fallback(node, params) {
			const style = getComputedStyle(node);
			const transform = style.transform === 'none' ? '' : style.transform;

			return {
				duration: 600,
				easing: quintOut,
				css: t =&gt; `
					transform: &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{t});
					opacity: {t}
				`
			};
		}
	});

  // ...
  &lt;script&gt;
</code></pre>
<p>이후 아래와 주고 받게 될 각각의 요소에서 사용한다.</p>
<pre><code class="language-svelte">&lt;label
	in:receive=&quot;{{key: todo.id}}&quot;
	out:send=&quot;{{key: todo.id}}&quot;
&gt;

&lt;label
	class=&quot;done&quot;
	in:receive=&quot;{{key: todo.id}}&quot;
	out:send=&quot;{{key: todo.id}}&quot;
&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<h2 id="the-animate-directive"><a class="header" href="#the-animate-directive">The animate directive</a></h2>
<p>트랜지션이 적용되지 않는 컴포넌트들에 대해서도 애니메이션을 적용해야하는 경우가 있다. 이를테면, 리스트의 아이템 하나가 삭제됨에 따라 다른 아이템들을 서서히 이동하는 것을 구현해야 하는 경우다.</p>
<p>이를 위해서는 <code>flip</code> 함수를 사용한다. 이는 '<a href="https://aerotwist.com/blog/flip-your-animations/">First, Last, Invert, Play</a>'의 준말이다.</p>
<pre><code class="language-svelte">import { flip } from 'svelte/animate';
</code></pre>
<p>이후, 트랜지션 외에 애니메이션이 적용되어야 하는 컴포넌트 및 요소에 animation을 추가해준다.</p>
<pre><code class="language-svelte">&lt;label
	in:receive=&quot;{{key: todo.id}}&quot;
	out:send=&quot;{{key: todo.id}}&quot;
	animate:flip=&quot;{{duration: 200}}&quot;
&gt;
</code></pre>
<p>위에서의 <code>duration</code>은 <code>d =&gt; ms</code> 형태의 함수일수도 있다. 여기서의 <code>d</code>는 요소가 움직여야 할 픽셀의 갯수에 해당한다.</p>
<p>다시 한번, 모든 트랜지션과 애니메이션은 JS보다는 CSS 상에서 구현되어야 한다는 점을 기억하자. 이는 메인 스레드의 진행을 막는 것을 방지하기 위해서다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="actions"><a class="header" href="#actions">Actions</a></h1>
<h2 id="the-use-directive"><a class="header" href="#the-use-directive">The use directive</a></h2>
<p>Action은 기본적으로 요소 수준의 생명주기 함수다. 다음과 같은 내용들을 구현할 때 유용하다.</p>
<ul>
<li>서드파티 라이브러리를 사용할 때</li>
<li>이미지에 대한 레이지 로딩</li>
<li>툴팁</li>
<li>커스텀 이벤트 핸들러 추가</li>
</ul>
<p>여러 컴포넌트에 다양하게 사용될 로직들을 미리 모듈화 시켜놓고, <code>use</code>를 통해 사용하는 방식이라고 이해하면 편하다.</p>
<pre><code class="language-svelte">export function pannable(node) {
	// setup work goes here...

	return {
		destroy() {
			// ...cleanup goes here
		}
	};
}
</code></pre>
<pre><code class="language-svelte">import { pannable } from './pannable.js';

&lt;div class=&quot;box&quot;
	use:pannable
	on:panstart={handlePanStart}
	on:panmove={handlePanMove}
	on:panend={handlePanEnd}
	style=&quot;transform:
		translate({coords.x}px,{coords.y}px)
		rotate({coords.x * 0.2}deg)&quot;
&gt;&lt;/div&gt;
</code></pre>
<h2 id="adding-parameters-1"><a class="header" href="#adding-parameters-1">Adding parameters</a></h2>
<p>트랜지션 및 애니메이션처럼, 액션 역시 인자를 전달받아서 로직 구성에 활용할 수 있다. 해당 매개변수는 <code>node</code> 다음의 두번째 매개변수로 전달받는다.</p>
<p>만약, 전달받는 매개변수가 변경될 수 있는 경우라면, <code>destroy</code> 외에도 <code>update</code>함수를 추가적으로 반환해주어야 한다.</p>
<pre><code class="language-svelte">export function longpress(node, duration) {
	// ...

	const handleMousedown = () =&gt; {
		timer = setTimeout(() =&gt; {
			node.dispatchEvent(
				new CustomEvent('longpress')
			);
		}, duration);
	};

	// ...

  return {
    update(newDuration) {
      duration = newDuration;
    },
    destroy() {
      // ...
    }
  };
}
</code></pre>
<p>이 후, 아래와 같이 인수를 전달한다.</p>
<pre><code class="language-svelte">&lt;button use:longpress={duration}&gt;
</code></pre>
<p>만약 여러개의 인자를 전달해야 하는 상황이라면, object를 전달하면 된다.</p>
<pre><code class="language-svelte">&lt;button use:longpress={{duration, spiciness}}&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<h2 id="the-class-directive"><a class="header" href="#the-class-directive">The class directive</a></h2>
<p>다른 어트리뷰트와 마찬가지로, JS 어트리뷰트를 통해 class를 지정할 수 있다.</p>
<pre><code class="language-svelte">&lt;button
	class=&quot;{current === 'foo' ? 'selected' : ''}&quot;
	on:click=&quot;{() =&gt; current = 'foo'}&quot;
&gt;foo&lt;/button&gt;
</code></pre>
<p>위와 같은 것은 UI 개발 상에서 일반적인 패턴으로, Svelte에서는 이를 단순화하기 위한 특별한 명령어를 갖고 있다. 아래 코드는 위와 동일하다.</p>
<pre><code class="language-svelte">&lt;button
	class:selected=&quot;{current === 'foo'}&quot;
	on:click=&quot;{() =&gt; current = 'foo'}&quot;
&gt;foo&lt;/button&gt;
</code></pre>
<h2 id="shorthand-class-directive"><a class="header" href="#shorthand-class-directive">Shorthand class directive</a></h2>
<p>종종, 클래스 이름은 그것이 의존하는 변수명과 동일한 경우가 많다.</p>
<pre><code class="language-svelte">&lt;div class:big={big}&gt;
	&lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<p>이 경우, 아래와 같이 짧게 작성할 수 있다.</p>
<pre><code class="language-svelte">&lt;div class:big&gt;
	&lt;!-- ... --&gt;
&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="component-composition"><a class="header" href="#component-composition">Component composition</a></h1>
<h2 id="slot"><a class="header" href="#slot">Slot</a></h2>
<p>일반적으로 요소가 자식 요소들을 가질 수 있는 것처럼, 컴포넌트 역시 똑같이 적용될 수 있다.</p>
<p>이는 <code>&lt;slot&gt;</code> 요소를 통해 구현할 수 있는데, React에서의 <code>{children}</code>과 매우 유사하다.</p>
<pre><code class="language-svelte">&lt;div class=&quot;box&quot;&gt;
	&lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<h2 id="slot-fallbacks"><a class="header" href="#slot-fallbacks">Slot fallbacks</a></h2>
<p>컴포넌트는 slot이 비어있을 경우에 제공할 fallback을 지정할 수 있다.</p>
<pre><code class="language-svelte">&lt;div class=&quot;box&quot;&gt;
	&lt;slot&gt;
		&lt;em&gt;no content was provided&lt;/em&gt;
	&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<h2 id="named-slots-1"><a class="header" href="#named-slots-1">Named slots</a></h2>
<p>앞선 예시들은 모두 default slot을 사용했으나, 좀 더 구체적으로 어떤 slot에 위치해야 하는지에 대해 지정해주어야 하는 경우가 있을 수 있다.</p>
<p>이러한 경우에 named slot을 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;article class=&quot;contact-card&quot;&gt;
	&lt;h2&gt;
		&lt;slot name=&quot;name&quot;&gt;
			&lt;span class=&quot;missing&quot;&gt;Unknown name&lt;/span&gt;
		&lt;/slot&gt;
	&lt;/h2&gt;

	&lt;div class=&quot;address&quot;&gt;
		&lt;slot name=&quot;address&quot;&gt;
			&lt;span class=&quot;missing&quot;&gt;Unknown address&lt;/span&gt;
		&lt;/slot&gt;
	&lt;/div&gt;

	&lt;div class=&quot;email&quot;&gt;
		&lt;slot name=&quot;email&quot;&gt;
			&lt;span class=&quot;missing&quot;&gt;Unknown email&lt;/span&gt;
		&lt;/slot&gt;
	&lt;/div&gt;
&lt;/article&gt;
</code></pre>
<p>이후, 각각의 slot에 요소를 추가하기 위해서는 <code>slot</code> 어트리뷰트를 추가적으로 작성해야 한다.</p>
<pre><code class="language-svelte">&lt;ContactCard&gt;
	&lt;span slot=&quot;name&quot;&gt;
		P. Sherman
	&lt;/span&gt;

	&lt;span slot=&quot;address&quot;&gt;
		42 Wallaby Way&lt;br&gt;
		Sydney
	&lt;/span&gt;
&lt;/ContactCard&gt;
</code></pre>
<h2 id="checking-for-slot-content"><a class="header" href="#checking-for-slot-content">Checking for slot content</a></h2>
<p>`<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">‘</span><span class="mord hangul_fallback">를통해</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">컴포넌트측에서전달받은</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">들에어떤것들이있는지파악할수있다</span><span class="mord">.</span><span class="mord hangul_fallback">이는아래와같은형태다</span><span class="mord">.‘‘‘</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">lt</span><span class="mord mathnormal">e</span></span></span></span></span>slots = {
default: false,
comments: true
}</p>
<pre><code>
따라서, 컴포넌트에서는 이를 통해 다음과 같이 조건부로 UI를 구성할 수 있다.

```svelte
&lt;article class:has-discussion={slots.comments}&gt;
</code></pre>
<pre><code class="language-svelte">{#if slots.comments}
	&lt;div class=&quot;discussion&quot;&gt;
		&lt;h3&gt;Comments&lt;/h3&gt;
		&lt;slot name=&quot;comments&quot;&gt;&lt;/slot&gt;
	&lt;/div&gt;
{/if}
</code></pre>
<h2 id="slot-props"><a class="header" href="#slot-props">Slot props</a></h2>
<p>일부 상황에서는, 하위 컴포넌트에서 부모 컴포넌트로 데이터를 전달하여, 이에 따라 slot으로 전달할 내용을 변경해주어야 하는 경우가 생긴다.</p>
<p>이러한 상황에서 slot props를 활용할 수 있다. 가령, 아래의 <code>Hoverable</code> 컴포넌트는, slot에 <code>hovering</code> 값을 전달한다.</p>
<pre><code class="language-svelte">&lt;div on:mouseenter={enter} on:mouseleave={leave}&gt;
	&lt;slot hovering={hovering}&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p>이후, <code>hovering</code>을 <code>&lt;Hoverable&gt;</code> 컴포넌트의 내용에 전달하기 위해, <code>let</code> 명령어를 사용한다.</p>
<pre><code class="language-svelte">&lt;Hoverable let:hovering={hovering}&gt;
	&lt;div class:active={hovering}&gt;
		{#if hovering}
			&lt;p&gt;I am being hovered upon.&lt;/p&gt;
		{:else}
			&lt;p&gt;Hover over me!&lt;/p&gt;
		{/if}
	&lt;/div&gt;
&lt;/Hoverable&gt;
</code></pre>
<p>별도로 변수명을 다시 지어도 된다. 아래의 경우에는 <code>hovering</code>을 <code>active</code>라는 이름으로 부모 컴포넌트 측에서 다시 이름지었다.</p>
<pre><code class="language-svelte">&lt;Hoverable let:hovering={active}&gt;
	&lt;div class:active&gt;
		{#if active}
			&lt;p&gt;I am being hovered upon.&lt;/p&gt;
		{:else}
			&lt;p&gt;Hover over me!&lt;/p&gt;
		{/if}
	&lt;/div&gt;
&lt;/Hoverable&gt;
</code></pre>
<p>Named slot에서도 props를 가질 수 있는데, 이 경우 컴포넌트 자체보다는 <code>slot=&quot;...&quot;</code> 어트리뷰트를 보유한 요소에서 <code>let</code> 명령어를 사용하자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="context-api"><a class="header" href="#context-api">Context API</a></h1>
<h2 id="setcontext-and-getcontext"><a class="header" href="#setcontext-and-getcontext">setContext and getContext</a></h2>
<p>context API는 데이터를 props로 전달하거나, store를 통해 디스패칭하지 않고도 컴포넌트 간에 소통할 수 있는 매커니즘이다.</p>
<p>이는 React에서의 context와도 흡사하게 이해해도 좋다.</p>
<p>한 컴포넌트에서 <code>setContext(key, context)</code>를 호출하면, 컴포넌트 본인을 포함한 하위 컴포넌트 모두에서 <code>const context = getContext(key)</code>로 해당 값을 가져올 수 있다.</p>
<pre><code class="language-svelte">import { onMount, setContext } from 'svelte';
import { mapbox, key } from './mapbox.js';

setContext(key, {
	getMap: () =&gt; map
});
</code></pre>
<p>context는 어떤 타입이든지 가능하며, 생명주기 함수와 마찬가지로 <code>setContext</code>와 <code>getContext</code>는 반드시 컴포넌트 초기화 시점에 호출되어야 한다. 컴포넌트가 마운트되기 전까지 위에서 반환하는 <code>map</code>은 <code>undefined</code>가 되므로, <code>getMap</code> 함수를 통해 우회적으로 가져오는 방법을 사용한다.</p>
<p>이제, 하위 컴포넌트에서는 아래와 같이 <code>map</code>을 가져올 수 있다.</p>
<pre><code class="language-svelte">import { getContext } from 'svelte';
import { mapbox, key } from './mapbox.js';

const { getMap } = getContext(key);
const map = getMap();
</code></pre>
<h3 id="context-keys"><a class="header" href="#context-keys">Context keys</a></h3>
<p>사실, 위에서의 <code>key</code>는 아래와 같다.</p>
<pre><code class="language-js">const key = {};
</code></pre>
<p><code>key</code>로는 어떤 것이든 사용 가능하며, 그냥 <code>setContext('mapbox', ...)</code>와 같이 string을 전달해도 된다.</p>
<p>단, <code>key</code>로 string을 사용할 경우, 여러 컴포넌트 라이브러리들 간에 서로 충돌되는 <code>key</code>를 사용할지도 모른다는 문제가 발생한다. 이를 방지하기 위해 위와 같이 객체 리터럴을 사용하면, 해당 key가 고유함을 보장받을 수 있다.</p>
<h3 id="context-vs-stores"><a class="header" href="#context-vs-stores">Context vs. Stores</a></h3>
<p>Context는 store와 비슷해 보일 수 있다. 둘 사이의 차이점은, store가 애플리케이션의 전역에서 접근할 수 있는 반면, context는 해당 컴포넌트와 그 하위 컴포넌트들에서만 접근할 수 있다는 것이다.</p>
<p>상황에 따라 둘을 적절히 사용할 수도 있다. context는 반응적이지(reactive) 않으므로, 실시간으로 값이 변화하는 값들에 대해서는 아래와 같은 형태로 store를 사용하는 것이 더 적합하다.</p>
<pre><code class="language-svelte">const { these, are, stores } = getContext(...);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="special-elements"><a class="header" href="#special-elements">Special elements</a></h1>
<h2 id="svelteself"><a class="header" href="#svelteself"><a href="svelte:self">svelte:self</a></a></h2>
<p>Svelte는 여러 빌트인 요소들을 제공한다. 먼저, <code>&lt;svelte:self&gt;</code>는 컴포넌트를 재귀적으로 활용할 수 있게 해준다. 기본적으로 모듈은 스스로를 import 하는 것이 불가능하기 때문에, <code>&lt;svelte:self&gt;</code>가 필요하다.</p>
<p>이는 폴더 안에 다른 폴더가 포함될 수 있는 폴더 트리 뷰와 같은 것들을 구성할 때 유용하다.</p>
<pre><code class="language-svelte">{#if file.type === 'folder'}
	&lt;svelte:self {...file}/&gt;
{:else}
	&lt;File {...file}/&gt;
{/if}
</code></pre>
<h2 id="sveltecomponent"><a class="header" href="#sveltecomponent"><a href="svelte:component">svelte:component</a></a></h2>
<p><code>&lt;svelte:component&gt;</code>는 동적으로 특정 컴포넌트가 해당 요소의 위치가 올 수 있을 경우에 활용할 수 있다.</p>
<p>이를테면, 아래처럼 조건부로 컴포넌트를 렌더링하고자 할 때, <code>&lt;svelte:component&gt;</code>를 통해 하나의 동적 컴포넌트로 처리해줄 수 있다.</p>
<pre><code class="language-svelte">{#if selected.color === 'red'}
	&lt;RedThing/&gt;
{:else if selected.color === 'green'}
	&lt;GreenThing/&gt;
{:else if selected.color === 'blue'}
	&lt;BlueThing/&gt;
{/if}
</code></pre>
<p>위의 코드는 아래의 한줄로 대체될 수 있다.</p>
<pre><code class="language-svelte">&lt;svelte:component this={selected.component}/&gt;
</code></pre>
<h2 id="sveltewindow"><a class="header" href="#sveltewindow"><a href="svelte:window">svelte:window</a></a></h2>
<p>바닐라 JS 상에서 어떤 DOM 요소에든 이벤트 리스너를 추가할 수 있듯, Svelte에서 <code>window</code> 오브젝트에 이벤트 리스너를 추가하고자 한다면 <code>&lt;svelte:window&gt;</code>를 이용하면 된다.</p>
<pre><code class="language-svelte">&lt;svelte:window on:keydown={handleKeydown}/&gt;
</code></pre>
<h2 id="sveltewindow-bindings"><a class="header" href="#sveltewindow-bindings"><a href="svelte:window">svelte:window</a> bindings</a></h2>
<p><code>window</code>의 특정 프로퍼티에 바인딩을 해줄 수도 있다.</p>
<pre><code class="language-svelte">&lt;svelte:window bind:scrollY={y}/&gt;
</code></pre>
<p>아래는 바인딩 가능한 프로퍼티의 리스트다.</p>
<ul>
<li><code>innerWidth</code></li>
<li><code>innerHeight</code></li>
<li><code>outerWidth</code></li>
<li><code>outerHeight</code></li>
<li><code>scrollX</code></li>
<li><code>scrollY</code></li>
<li><code>online</code> - <code>window.navigator.onLine</code>과 동일</li>
</ul>
<p><code>scrollX</code>와 <code>scrollY</code>을 제외한 모두는 읽기 전용 프로퍼티다.</p>
<h2 id="sveltebody"><a class="header" href="#sveltebody"><a href="svelte:body">svelte:body</a></a></h2>
<p><code>&lt;svelte:window&gt;</code>와 비슷하게, <code>&lt;svelte:body&gt;</code> 요소 역시 <code>document.body</code>에 직접적으로 이벤트 리스너를 추가해야 하는 경우에 사용할 수 있다.</p>
<p><code>window</code>에서는 발생하지 않는 <code>mouseenter</code> 혹은 <code>mouseleave</code> 이벤트를 사용해야 하는 경우에 유용하다.</p>
<pre><code class="language-svelte">&lt;svelte:body
	on:mouseenter={handleMouseenter}
	on:mouseleave={handleMouseleave}
/&gt;
</code></pre>
<h2 id="sveltehead"><a class="header" href="#sveltehead"><a href="svelte:head">svelte:head</a></a></h2>
<p><code>&lt;svelte:head&gt;</code> 요소는 문서의 <code>&lt;head&gt;</code> 내에 요소를 추가해야할 때 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;svelte:head&gt;
	&lt;link rel=&quot;stylesheet&quot; href=&quot;tutorial/dark-theme.css&quot;&gt;
&lt;/svelte:head&gt;
</code></pre>
<p>SSR 모드의 경우, <code>&lt;svelte:head&gt;</code>의 내용은 HTML의 나머지와 별도로 반환된다.</p>
<h2 id="svelteoptions"><a class="header" href="#svelteoptions"><a href="svelte:options">svelte:options</a></a></h2>
<p><code>&lt;svelte:options&gt;</code>는 컴파일링 옵션을 설정할 수 있게 해준다.</p>
<p>예를 들어, 해당 컴포넌트에서 설정할 수 있는 <code>immutable</code> 옵션이 존재하는데, 이는 해당 컴포넌트가 immutable 데이터를 기반으로 동작함을 의미한다.</p>
<p>이를테면, 아래와 같이 <code>Todo</code> 컴포넌트가 존재한다고 하자.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import { afterUpdate } from 'svelte';
	import flash from './flash.js';

	export let todo;

	let div;

	afterUpdate(() =&gt; {
    // 아래의 flash는 애니메이션 효과.
		flash(div);
	});
&lt;/script&gt;

&lt;!-- the text will flash red whenever
     the `todo` object changes --&gt;
&lt;div bind:this={div} on:click&gt;
	{todo.done ? '👍': ''} {todo.text}
&lt;/div&gt;

&lt;style&gt;
	div {
		cursor: pointer;
		line-height: 1.5;
	}
&lt;/style&gt;
</code></pre>
<p>헌데, 아래처럼 여러 개의 <code>Todo</code>를 갖는 리스트를 구현하려고 하는 상황을 생각해보자.</p>
<p><code>toggle</code>이 실행될 때, <code>map</code> 메서드에 의해서 새로운 <code>todos</code>가 반환되며, 이에 따라 하위의 일부 <code>Todo</code>에 대해서는 결론적으로는 변경된 데이터가 없어 굳이 새로 리렌더링할 필요가 없음에도 모든 <code>Todo</code> 컴포넌트가 리렌더링 과정을 거치게 된다.</p>
<pre><code class="language-js">let todos = [
  { id: 1, done: true, text: 'wash the car' },
  { id: 2, done: false, text: 'take the dog for a walk' },
  { id: 3, done: false, text: 'mow the lawn' },
];

function toggle(toggled) {
  todos = todos.map((todo) =&gt; {
    if (todo === toggled) {
      // return a new object
      return {
        id: todo.id,
        text: todo.text,
        done: !todo.done,
      };
    }

    // return the same object
    return todo;
  });
}
</code></pre>
<p>이러한 상황을 방지하기 위해서, immutable 옵션을 통해 props 값의 참조가 유지된다면 리렌더링을 수행하지 않도록 한다.</p>
<pre><code class="language-svelte">// &lt;svelte:options immutable/&gt;을 써도 된다.

&lt;svelte:options immutable={true}/&gt;
</code></pre>
<p>아래는 <code>&lt;svelte:options&gt;</code>에서 설정할 수 있는 옵션들이다.</p>
<ul>
<li><code>immutable={true}</code> - mutable 데이터를 사용하지 않겠다는 뜻으로, 컴포넌트는 값의 변경 여부를 확인하기 위해 단순 참조 비교(simple referential quality check)를 거친다.</li>
<li><code>immutable={false}</code> - 기본값. 값이 변경되었는지의 여부에 대해 더 엄격하게 체크한다.</li>
<li><code>accessors={true}</code> - 컴포넌트의 props에 대한 getter와 setter를 추가한다.</li>
<li><code>accessors={false}</code> - 기본값.</li>
<li><code>namespace=&quot;...&quot;</code> - 컴포넌트가 사용될 네임스페이스. 일반적으로 <code>svg</code>에서 사용된다.</li>
<li><code>tag=&quot;...&quot;</code> - 컴포넌트를 커스텀 요소로 컴파일링할 때 사용할 이름.</li>
</ul>
<h2 id="sveltefragment"><a class="header" href="#sveltefragment"><a href="svelte:fragment">svelte:fragment</a></a></h2>
<p><code>&lt;svelte:fragment&gt;</code> 요소는 named slot에 요소를 전달하고자 할 때, 굳이 별도의 컨테이너(ex. <code>div</code>)를 통해 요소를 묶어주지 않아도 곧바로 전달할 수 있게끔 해준다. React에서의 Fragment와 동일하다.(<code>&lt;&gt;&lt;/&gt;</code>)</p>
<pre><code class="language-svelte">&lt;svelte:fragment slot=&quot;footer&quot;&gt;
	&lt;p&gt;All rights reserved.&lt;/p&gt;
	&lt;p&gt;Copyright (c) 2019 Svelte Industries&lt;/p&gt;
&lt;/svelte:fragment&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="module-context"><a class="header" href="#module-context">Module context</a></h1>
<h2 id="sharing-code"><a class="header" href="#sharing-code">Sharing code</a></h2>
<p>지금껏 사용한 것 처럼, <code>&lt;script&gt;</code> 블록은 컴포넌트 초기화 시 각각의 컴포넌트 내에서 실행되는 로직들을 담고 있다. 그리고 대부분의 경우에는 이것으로 충분하다.</p>
<p>헌데, 아주 가끔 컴포넌트 외부에서 로직을 처리하여, 여러 컴포넌트에 해당 코드를 &quot;공유&quot;해야하는 경우가 생긴다. 이를테면, 음악 플레이어 컴포넌트를 만든 이후, 한 플레이어가 재생 중일 때 다른 플레이어를 중지시키는 로직을 구현하고자 하는 경우가 그렇다.</p>
<p>이 경우, <code>&lt;script context=&quot;module&quot;&gt;</code> 블록을 통해 처리할 수 있다. 해당 블록 내에서 실행되는 코드는 컴포넌트의 초기화 시점이 아닌, 최초로 evaluate되는 시점에 딱 한번만 실행된다.</p>
<pre><code class="language-svelte">&lt;script context=&quot;module&quot;&gt;
	let current;
&lt;/script&gt;
</code></pre>
<p>이제, 별도로 부모 컴포넌트에서 상태를 관리하지 않더라도, 동일한 컴포넌트의 인스턴스들끼리 소통하여 로직을 처리할 수 있다.</p>
<pre><code class="language-svelte">function stopOthers() {
	if (current &amp;&amp; current !== audio) current.pause();
	current = audio;
}
</code></pre>
<h2 id="exports"><a class="header" href="#exports">Exports</a></h2>
<p><code>context=&quot;module&quot;</code> 블록 내에서 <code>export</code>되는 변수들은 실제 모듈 자체에서 export한 것처럼 다루어진다.</p>
<p>다시 말해, 아래와 같이 <code>stopAll</code> 함수를 <code>export</code>한 경우,</p>
<pre><code class="language-svelte">// AudioPlayer.svelte
&lt;script context=&quot;module&quot;&gt;
	const elements = new Set();

	export function stopAll() {
		elements.forEach(element =&gt; {
			element.pause();
		});
	}
&lt;/script&gt;
</code></pre>
<p>이는 일반적인 JS 모듈처럼 <code>import</code>해서 사용할 수 있다.</p>
<pre><code class="language-svelte">&lt;script&gt;
	import AudioPlayer, { stopAll } from './AudioPlayer.svelte';
&lt;/script&gt;

&lt;button on:click={stopAll}&gt;
	stop all audio
&lt;/button&gt;

// ...
</code></pre>
<p>Svelte에서는 컴포넌트가 default export로 다루어지기 때문에, <code>default export</code>를 사용할 수 없음에 주의하자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="the-debug-tag"><a class="header" href="#the-debug-tag">The @debug tag</a></h2>
<p>때때로, 애플리케이션을 이용하는 중에 데이터 흐름을 체크하는 과정이 필요하다.</p>
<p>일반적으로 이는 <code>console.log(...)</code>을 통해 처리되곤 하는데, 만약 실행을 멈추고 해당 값을 확인하고자 한다면, <code>{@debug value1, value2, ...}</code> 태그를 사용할 수 있다.</p>
<pre><code class="language-svelte">{@debug user}

&lt;h1&gt;Hello {user.firstname}!&lt;/h1&gt;
</code></pre>
<p>이제 <code>user</code>의 값이 변경될 떄마다 debugger가 동작할 것이다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="introspection"><a class="header" href="#introspection">Introspection</a></h1>
<p><a href="https://graphql-kr.github.io/learn/introspection/">여기</a>의 내용을 Github Graphql API로 따라가보자.</p>
<p>타입 시스템을 사용하기 때문에, 우리는 현재 유효한 타입이 무엇인지 알 수 있으나, 그렇지 않은 경우 Query의 루트에서 사용할 수 있는 <code>__schema</code> 필드를 쿼리하여 GraphQL에 요청할 수 있다.</p>
<pre><code class="language-graphql"># query
{
  __schema {
    types {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__schema&quot;: {
      &quot;types&quot;: [
        {
          &quot;name&quot;: &quot;AcceptEnterpriseAdministratorInvitationInput&quot;
        },
        {
          &quot;name&quot;: &quot;AcceptEnterpriseAdministratorInvitationPayload&quot;
        },
        {
          &quot;name&quot;: &quot;AcceptTopicSuggestionInput&quot;
        },
        // ...
        {
          &quot;name&quot;: &quot;__Schema&quot;
        },
        {
          &quot;name&quot;: &quot;__Type&quot;
        },
        {
          &quot;name&quot;: &quot;__TypeKind&quot;
        }
      ]
    }
  }
}
</code></pre>
<p>직접 해보면 알겠지만, 엄청 많이 뜬다. 이를 몇개로 그룹화해볼 수 있다.</p>
<ul>
<li><code>Query</code>, <code>User</code> 등 : 타입 시스템을 통해 정의한 것</li>
<li><code>String</code>, <code>Boolean</code> 등 : 타입 시스템이 제공하는 내장 스칼라</li>
<li><code>__Schema</code>, <code>__Type</code> 등 : 이들 앞에는 <code>__</code>가 붙어있는데, 이는 이것이 Introspection 시스템의 일부임을 나타낸다.</li>
</ul>
<pre><code class="language-graphql"># query
query {
  __schema {
    queryType {
      name
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__schema&quot;: {
      &quot;queryType&quot;: {
        &quot;name&quot;: &quot;Query&quot;
      }
    }
  }
}
</code></pre>
<p>최상단의 <code>Query</code> 타입에서 위와 같이 요청하면, 다음과 같이 <code>queryType</code>을 통해 우리가 <code>__schema</code>를 요청한 지점이 <code>Query</code> 타입에 해당함을 확인할 수 있다.</p>
<p>보통은 특정 타입 내에서 검사하는 작업이 유용한 경우가 많으며, 아래에서 <code>User</code> 타입에 대해 살펴보자.</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;User&quot;) {
    name
    description
    kind
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__type&quot;: {
      &quot;name&quot;: &quot;User&quot;,
      &quot;description&quot;: &quot;A user is an individual's account on GitHub that owns repositories and can make new content.&quot;,
      &quot;kind&quot;: &quot;OBJECT&quot;
    }
  }
}
</code></pre>
<p>위와 같은 식으로 특정 타입(위에서는 <code>User</code>)에 대한 상세한 정보를 얻을 수 있다. 여기에 더 나아가 해당 타입이 보유한 필드들에 어떤 것들이 있는지 찾아보자.</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;User&quot;) {
    name
    description
    kind
    fields {
      name
      type {
        name
        kind
        ofType {
          name
          kind
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;__type&quot;: {
      &quot;name&quot;: &quot;User&quot;,
      &quot;description&quot;: &quot;A user is an individual's account on GitHub that owns repositories and can make new content.&quot;,
      &quot;kind&quot;: &quot;OBJECT&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;anyPinnableItems&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;,
            &quot;ofType&quot;: {
              &quot;name&quot;: &quot;Boolean&quot;,
              &quot;kind&quot;: &quot;SCALAR&quot;
            }
          }
        },
        {
          &quot;name&quot;: &quot;avatarUrl&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;,
            &quot;ofType&quot;: {
              &quot;name&quot;: &quot;URI&quot;,
              &quot;kind&quot;: &quot;SCALAR&quot;
            }
          }
        },
        {
          &quot;name&quot;: &quot;bio&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: &quot;String&quot;,
            &quot;kind&quot;: &quot;SCALAR&quot;,
            &quot;ofType&quot;: null
          }
        },
        // ...
        {
          &quot;name&quot;: &quot;watching&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;,
            &quot;ofType&quot;: {
              &quot;name&quot;: &quot;RepositoryConnection&quot;,
              &quot;kind&quot;: &quot;OBJECT&quot;
            }
          }
        },
        {
          &quot;name&quot;: &quot;websiteUrl&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: &quot;URI&quot;,
            &quot;kind&quot;: &quot;SCALAR&quot;,
            &quot;ofType&quot;: null
          }
        }
      ]
    }
  }
}
</code></pre>
<p>(어지럽다..)</p>
<p>유의할만한 내용으로는 위에서 볼수 있는 <code>anyPinnableItems</code> 와 같은 필드의 경우에는 <code>NON_NULL wrapper</code> 타입에 해당하기 때문에, 타입에 대한 이름(<code>name</code>)이 존재하지 않는다.</p>
<p>이 경우, 해당 필드에서 <code>ofType</code>을 쿼리해 추가로 정보를 얻어보면, 해당 타입이 <code>Boolean!</code>에 해당함을 확인할 수 있다. (아래 일부)</p>
<pre><code class="language-json">// fields에 반환되는 내용 중 일부
{
  &quot;name&quot;: &quot;anyPinnableItems&quot;,
  &quot;type&quot;: {
    &quot;name&quot;: null,
    &quot;kind&quot;: &quot;NON_NULL&quot;,
    &quot;ofType&quot;: {
      &quot;name&quot;: &quot;Boolean&quot;,
      &quot;kind&quot;: &quot;SCALAR&quot;
    }
  }
},
</code></pre>
<p>이는 <code>LIST wrapper</code> 타입의 경우도 마찬가지이며, 아래와 같이 깊숙한 정보를 요구할 수도 있다.</p>
<pre><code class="language-graphql">query {
  __type(name: &quot;Repository&quot;) {
    name
    description
    kind
    fields {
      name
      type {
        name
        kind
        ofType {
          name
          kind
          ofType {
            name
            kind
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// fields에 반환되는 내용 일부
{
  &quot;name&quot;: &quot;viewerPossibleCommitEmails&quot;,
  &quot;type&quot;: {
    &quot;name&quot;: null,
    &quot;kind&quot;: &quot;LIST&quot;,
    &quot;ofType&quot;: {
      &quot;name&quot;: null,
      &quot;kind&quot;: &quot;NON_NULL&quot;,
      &quot;ofType&quot;: {
        &quot;name&quot;: &quot;String&quot;,
        &quot;kind&quot;: &quot;SCALAR&quot;
      }
    }
  }
}
</code></pre>
<p>위의 <code>viewerPossibleCommitEmails</code>는 <code>[String!]</code>에 해당함을 확인할 수 있다.</p>
<p>앞서 봤듯이, Introspection 기능을 통해 타입 시스템의 문서에 접근할 수 있고, 문서 탐색기 및 풍부한 IDE 환경을 만들 수 있다.</p>
<p>이는 Introspection 시스템의 극히 일부에 해당하며, <a href="https://github.com/graphql/graphql-js/blob/main/src/type/introspection.js">여기</a>에 GraphQL의 Introspection 시스템을 구현하는 코드가 있으니 추후에 따로 확인해보자.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>이 <a href="https://graphql-kr.github.io/learn/execution/">문서</a>의 내용을 실습하며 따라가보려고 한다. (TypeScript를 사용)</p>
<p>GraphQL 쿼리의 각 필드는 특정한 타입의 값을 반환하는 함수로 생각할 수 있으며, 이는 사실 실제 GraphQL의 작동방식이기도 하다.</p>
<p>타입의 각 필드는 GraphQL 서버 측의 <code>resolver</code> 함수에 대응되며, 해당 필드가 <code>string</code>이나 <code>number</code> 같은 스칼라 값을 반환하게 되면 실행이 완료된다.</p>
<p>반면, 필드가 객체를 반환하는 경우, 쿼리는 해당 객체에 적용되는 다른 필드들을 포함하게 되며, 이는 스칼라 값에 도달할 때까지 반복된다.</p>
<p>즉, GraphQL 쿼리의 끝은 항상 스칼라 값이어야 한다.</p>
<h2 id="root-fields--resolvers"><a class="header" href="#root-fields--resolvers">Root fields &amp; resolvers</a></h2>
<p>모든 GraphQL 서버의 최상위 레벨은 GraphQL API에서 사용 가능한 모든 진입점을 나타내는 타입이며, 이는 <code>Root</code> 타입 혹은 <code>Query</code> 타입으로 불린다.</p>
<pre><code class="language-js">// resolver
const resolvers = {
  Query: {
    game: (obj: any, { id }: GameArgs, context: Context) =&gt; {
      return context.db.games.find(({ id: gameId }) =&gt; id === gameId);
    },
    // ...
  },
  // ...
};
</code></pre>
<p>각 필드의 <code>resolver</code> 함수는 네 개의 매개변수를 받는데, 다음과 같다.</p>
<ul>
<li><code>obj</code> : <strong>부모 객체</strong>, 위에서는 이것이 <code>Query</code> Type에 해당하므로 거의 쓰일 일이 없다.</li>
<li><code>args</code> : GraphQL 쿼리의 필드에 제공된 인수. 이를테면 <code>game(id: '1') {...}</code> 과 같은 경우에는 args가 <code>{ id: '1' }</code>이 된다.</li>
<li><code>context</code> : 모든 <code>resolver</code> 함수들에 동일하게 전달되며, 데이터베이스 접근이나 로그인 세션 등에 활용될 수 있다.</li>
<li><code>info</code> : 현재의 쿼리, 스키마 정보와 관련된 필드별 정보를 보유하며, 자세한 내용은 <a href="https://graphql.org/graphql-js/type/#graphqlobjecttype">여기</a>를 참조하자.</li>
</ul>
<h2 id="async-resolvers"><a class="header" href="#async-resolvers">Async Resolvers</a></h2>
<pre><code class="language-js">// 임의로 작성됨
const resolver = async (obj, args, context) {
  const result = await context.db.gameInfo(args.id);
  return result.data;
};
</code></pre>
<p>위와 같이 임의로 작성된 비동기 resolver의 경우에도 정상적으로 동작한다.</p>
<p>하지만, 여기서는 실제 DB에 접근하지 않고 임의의 객체로 만든 Mocking DB를 활용할 것이므로, 편의상 일반적인 함수를 통해 resolver를 구현하겠다.</p>
<h2 id="trivial-resolvers"><a class="header" href="#trivial-resolvers">Trivial resolvers</a></h2>
<p>앞서 <code>Game</code> 객체에 대해 접근하는 resolver를 작성했으므로, 이제 이 <code>Game</code> 객체 내 각 필드를 구체화해보자.</p>
<pre><code class="language-js">const resolvers = {
  Query: {
    game: (obj: any, { id }: GameArgs, context: Context) =&gt; {
      return context.db.games.find(({ id: gameId }) =&gt; id === gameId);
    },
  },
  Game: {
    // id의 resolver 첫번째 파라미터는 이제 Game 객체가 된다.
    id: (game: Game) =&gt; game.id,
    // ...
  },
};
</code></pre>
<p>아래와 같은 구성으로 타입을 지정했다고 하자.</p>
<pre><code class="language-graphql">const typeDefs = gql`
  enum Score {
    good
    normal
    bad
  }

  type Query {
    game(id: ID!): Game
    developer(id: ID!): Developer
  }

  type Game {
    id: ID!
    title: String!
    developer: Developer!
    score: Score!
  }

  type Developer {
    id: ID!
    name: String!
    games: [Game]!
  }
`;
</code></pre>
<p>이에 대해 객체 타입에 대한 resolver 작성을 한꺼번에 해보면 이런 식이다.</p>
<pre><code class="language-js">const resolvers = {
  Query: {
    game: (_: any, { id }: GameArgs, context: Context) =&gt; {
      return context.db.games.find(({ id: gameId }) =&gt; id === gameId);
    },
    developer: (_: any, { id }: DeveloperArgs, context: Context) =&gt; {
      return context.db.developers.find(
        ({ id: developerId }) =&gt; id === developerId,
      );
    },
  },
  Game: {
    id: (game: Game) =&gt; game.id,
    title: (game: Game) =&gt; game.title,
    developer: ({ developer: id }: Game, _: any, context: Context) =&gt; {
      return context.db.developers.find(
        ({ id: developerId }) =&gt; id === developerId,
      );
    },
    score: (game: Game) =&gt; {
      return game.score;
    },
  },
  Developer: {
    id: (developer: Developer) =&gt; developer.id,
    name: (developer: Developer) =&gt; developer.name,
    games: ({ games }: Developer, _: any, context: Context) =&gt; {
      return games.map((gameId) =&gt;
        context.db.games.find(({ id }) =&gt; id === gameId),
      );
    },
  },
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://graphql-kr.github.io/learn/queries/">여기</a> 문서에 따라, GraphQL의 쿼리를 직접 실습해보려고 한다.</p>
<p>여기서는 실습을 위해 Github의 <a href="https://docs.github.com/en/graphql/overview/explorer">GraphQL API</a>를 활용했다.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>GraphQL의 핵심은 쿼리와 결과가 거의 동일한 형태를 보인다는 것이다. 덕분에 항상 클라이언트가 기대한 결과값을 얻을 수 있다.</p>
<pre><code class="language-graphql"># query
{
  viewer {
    email
    interactionAbility {
      origin
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;viewer&quot;: {
      &quot;email&quot;: &quot;&quot;,
      &quot;interactionAbility&quot;: {
        &quot;origin&quot;: &quot;USER&quot;
      }
    }
  }
}
</code></pre>
<p>아래 예제에서 <code>licenses</code>는 배열을 반환하며, 배열 안 각각의 Item에 대해 <code>name</code>만을 가져온다.</p>
<p>쿼리문 자체는 모두 동일해보이지만, GraphQL 스키마를 기반으로 예상되는 결과를 알 수 있다.</p>
<pre><code class="language-graphql"># query
{
  licenses {
    name
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;licenses&quot;: [
      {
        &quot;name&quot;: &quot;GNU Affero General Public License v3.0&quot;
      },
      {
        &quot;name&quot;: &quot;Apache License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;BSD 2-Clause \&quot;Simplified\&quot; License&quot;
      },
      ...
    ]
  }
}
</code></pre>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p>필드에 인자를 전달할 수도 있다.</p>
<pre><code class="language-graphql"># query
{
  user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    }
  }
}
</code></pre>
<h2 id="aliases"><a class="header" href="#aliases">Aliases</a></h2>
<p>만약, 여러 결과 객체 필드가 동일한 이름을 갖는 경우(위에서는 <code>user</code>), 충돌이 일어난다. 아래는 닉네임을 통해 여러 유저의 정보를 가져오는 예시인데, 아래대로라면 에러가 발생한다.</p>
<pre><code class="language-graphql"># query
{
  user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
  user(login: &quot;adam-p&quot;) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// result
// 에러 발생!
{
  &quot;errors&quot;: [
    {
      &quot;path&quot;: [],
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;fieldConflict&quot;,
        &quot;fieldName&quot;: &quot;user&quot;,
        &quot;conflicts&quot;: &quot;{login:\&quot;\\\&quot;Shubidumdu\\\&quot;\&quot;} or {login:\&quot;\\\&quot;adam-p\\\&quot;\&quot;}&quot;
      },
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 2,
          &quot;column&quot;: 2
        },
        {
          &quot;line&quot;: 6,
          &quot;column&quot;: 3
        }
      ],
      &quot;message&quot;: &quot;Field 'user' has an argument conflict: {login:\&quot;\\\&quot;Shubidumdu\\\&quot;\&quot;} or {login:\&quot;\\\&quot;adam-p\\\&quot;\&quot;}?&quot;
    }
  ]
}
</code></pre>
<p>이러한 상황에서 Alias를 사용할 수 있다. 각각의 <code>user</code> 결과에 대해 이름을 지정해주자.</p>
<pre><code class="language-graphql"># query
{
  me: user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
  not_me: user(login: &quot;adam-p&quot;) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;me&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    },
    &quot;not_me&quot;: {
      &quot;name&quot;: &quot;Adam Pritchard&quot;,
      &quot;location&quot;: &quot;Toronto, Canada&quot;
    }
  }
}
</code></pre>
<h2 id="fragments"><a class="header" href="#fragments">Fragments</a></h2>
<p>상대적으로 복잡한 페이지의 경우, Fragment라는 <strong>재사용 가능한 단위</strong>가 사용될 수 있다. 이를 사용하면 미리 필드셋을 구성한 다음 쿼리에 포함시킬 수 있다.</p>
<p>앞서 여러 유저들의 정보를 가져오는 쿼리를 Fragment를 통해 다시 만들어보면 아래와 같아진다.</p>
<pre><code class="language-graphql"># query
{
  me: user(login: &quot;Shubidumdu&quot;) {
    ...userInfo
  }
  not_me: user(login: &quot;adam-p&quot;) {
    ...userInfo
  }
}

fragment userInfo on User {
  name
  location
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;me&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    },
    &quot;not_me&quot;: {
      &quot;name&quot;: &quot;Adam Pritchard&quot;,
      &quot;location&quot;: &quot;Toronto, Canada&quot;
    }
  }
}
</code></pre>
<p>결과는 동일하지만, 쿼리 시에 일일이 객체 필드를 작성해줄 필요가 없게 되었다.</p>
<h3 id="fragment-안에서-매개변수variables-사용하기"><a class="header" href="#fragment-안에서-매개변수variables-사용하기">Fragment 안에서 매개변수(variables) 사용하기</a></h3>
<p>쿼리 및 뮤테이션에다 선언한 변수는 Fragment를 통해서도 접근할 수 있다.</p>
<p>아래는 기존의 <code>userInfo</code>에서 <code>avatarSize</code> 변수를 통해 임의의 사이즈를 가진 avatar 이미지를 추가로 쿼리한 것이다.</p>
<pre><code class="language-graphql"># query
query UserInfos(avatarSize: Int = 100) {
  me: user(login: &quot;Shubidumdu&quot;) {
    ...userInfo
  }
  not_me: user(login: &quot;adam-p&quot;) {
    ...userInfo
  }
}

fragment userInfo on User {
  name
  location
  avatarUrl(size: avatarSize)
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;me&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;,
      &quot;avatarUrl&quot;: &quot;https://avatars.githubusercontent.com/u/54790378?s=100&amp;u=9fa9c08aa2c952a873633a1baf3ea342a4c45855&amp;v=4&quot;
    },
    &quot;not_me&quot;: {
      &quot;name&quot;: &quot;Adam Pritchard&quot;,
      &quot;location&quot;: &quot;Toronto, Canada&quot;,
      &quot;avatarUrl&quot;: &quot;https://avatars.githubusercontent.com/u/425687?s=100&amp;v=4&quot;
    }
  }
}
</code></pre>
<h2 id="operation-name-작업명"><a class="header" href="#operation-name-작업명">Operation name (작업명)</a></h2>
<p>지금껏 <code>query</code> 키워드와 이름을 모두 생략한 채 <code>{ ... }</code>와 같은 형태로 쿼리를 요청했다.</p>
<p>하지만 실제로 애플리케이션에 GraphQL을 적용하고자 할 때는 코드를 최대한 덜 헷갈리게 만드는 편이 좋다.</p>
<p>바로 위의 쿼리에서는 <code>UserInfos</code>와 같은 식으로 이름을 지정했다.</p>
<p>작업 타입은 <code>query</code>, <code>mutation</code>, <code>subscription</code>이 될 수 있으며, 해당 작업이 어떤 형태의 작업인지를 나타낸다.</p>
<p>작업명은 명시적인 작업의 <strong>이름</strong>인데, 디버깅 및 로깅에 있어 매우 유용하다. 임의의 쿼리 결과를 찾아내는 것보다, 직접 쿼리명을 찾아내는 것이 훨씬 쉽기 때문이다.</p>
<h2 id="variables-변수"><a class="header" href="#variables-변수">Variables (변수)</a></h2>
<p>지금껏 앞의 모든 예시에서 인자들은 쿼리 문자열에 함께 작성되었다. 허나, 대부분 필드에 대한 인자는 동적이다.</p>
<p>클라이언트 측에서는 쿼리 문자열을 런타임 시점에 동적으로 조작하고, 이를 GraphQL의 특정 포맷으로 Serialize해야 한다.</p>
<p>그렇기 때문에 동적 인자들을 쿼리 문자열에 직접 전달하는 것은 좋은 방법이 아니다. 그래서 GraphQL은 동적 값을 쿼리에서 없애고 이를 별도로 전달하는 방법을 제공하는데 이를 Variables(변수)라고 한다.</p>
<pre><code class="language-graphql">{
  user(login: &quot;Shubidumdu&quot;) {
    name
    location
  }
}
</code></pre>
<p>위의 쿼리를 Variables를 활용한 형태로 바꾸려면 다음과 같은 작업들이 필요하다.</p>
<ol>
<li>쿼리 내의 정적인 값을 <code>variableName</code> 형태로 변경한다.</li>
<li><code>variableName</code>를 쿼리에서 받아오는 변수의 타입으로 선언한다.</li>
<li>별도의 전송규약(일반적으로 JSON) 변수에 <code>variableName: value</code>를 전달한다.</li>
</ol>
<p>변수를 이용해 위의 쿼리를 재작성하면 아래와 같은 형태가 된다.</p>
<pre><code class="language-graphql"># query
query MyInfo(nickname: String!) {
  user(login: nickname) {
    name
    location
  }
}
</code></pre>
<pre><code class="language-json">// variables
{ &quot;nickname&quot;: &quot;Shubidumdu&quot; }
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;
    }
  }
}
</code></pre>
<p>이제, 클라이언트 측에서는 완전히 새로운 쿼리를 작성하지 않고 손쉽게 다른 변수를 전달할 수 있다.</p>
<p>한편, 이런 방식은 쿼리의 어떤 Argument가 동적인 형태를 띠는지 나타내는 좋은 방법이기도 하다.</p>
<h3 id="변수-정의"><a class="header" href="#변수-정의">변수 정의</a></h3>
<p>변수 정의는 위 예시 쿼리에서 <code>(nickname: String!)</code>에 해당하는 부분이다. 정적타입 언어의 함수에 대한 인자 정의와 동일하다.</p>
<p><strong>모든 변수는 scalars, enum, 또는 input object type 이어야 한다.</strong> 복잡한 객체를 필드에 전달하려면 서버에서 일치하는 입력 타입을 알아야 하며, 이에 대해서는 문서를 통해 더 알아보자.</p>
<p>변수 정의는 required 혹은 optional일 수 있다. 위에서는 <code>String!</code>으로 <code>!</code>가 붙었으므로 required scalar type에 해당한다. 반대로, <code>!</code>가 붙지 않았다면 이는 optional한 값이 된다.</p>
<h3 id="변수-기본값"><a class="header" href="#변수-기본값">변수 기본값</a></h3>
<p>타입 선언 다음에 기본값을 할당할 수도 있다.
이 경우에는 별도로 Variable을 전달하지 않더라도 올바르게 동작한다.</p>
<pre><code class="language-graphql"># query
query MyInfo(nickname: String = &quot;Shubidumdu&quot;) {
  user(login: nickname) {
    name
    location
  }
}
</code></pre>
<p><strong>여기에, <code>nickname: String!</code>과 같이 required 변수를 요구하는 경우에는 기본값을 가질 수 없다는 점을 유의하자.</strong></p>
<h2 id="directives-지시어"><a class="header" href="#directives-지시어">Directives (지시어)</a></h2>
<p>Directives는 GraphQL의 기능으로, 필드나 프래그먼트 안에 삽입되어, 쿼리 실행에 영향을 줄 수 있다.</p>
<ul>
<li><code>@include(if: Boolean)</code>: 인자가 <code>true</code>인 경우에만 이 필드를 결과에 포함한다.</li>
<li><code>@skip(if: Boolean)</code>: 인자가 <code>true</code>인 경우에만 이 필드를 건너뛴다.</li>
</ul>
<p>이를 이용해 앞서 작성한 유저 정보 쿼리에서 <code>withAvatar</code> 변수가 <code>true</code>인 경우에만 이미지를 함께 가져오게끔 해보자.</p>
<pre><code class="language-graphql"># query
query MyInfo(&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ni&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;knam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;St&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;withAvatar: Boolean = false) {
  user(login: nickname) {
    name
    location
    avatarUrl @include(if: withAvatar)
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;nickname&quot;: &quot;Shubidumdu&quot;,
  &quot;withAvatar&quot;: true
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;,
      &quot;avatarUrl&quot;: &quot;https://avatars.githubusercontent.com/u/54790378?u=9fa9c08aa2c952a873633a1baf3ea342a4c45855&amp;v=4&quot;
    }
  }
}
</code></pre>
<p>물론, 필드가 객체를 참조하는 경우에도 활용할 수 있다.</p>
<pre><code class="language-graphql"># query
query MyInfo(
  &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ni&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;knam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8777699999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;St&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05764em;&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;bi&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;withItemShowcase: Boolean = false
) {
  user(login: nickname) {
    name
    location
    company
    itemShowcase @include(if: withItemShowcase) {
      items {
        totalCount
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;withItemShowcase&quot;: true
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;Won Gyo Seo&quot;,
      &quot;location&quot;: &quot;Seoul, South Korea&quot;,
      &quot;company&quot;: &quot;The Mong, Inc.&quot;,
      &quot;itemShowcase&quot;: {
        &quot;items&quot;: {
          &quot;totalCount&quot;: 6
        }
      }
    }
  }
}
</code></pre>
<h2 id="mutation"><a class="header" href="#mutation">Mutation</a></h2>
<p>지금까지는 전부 데이터 가져오기(<code>fetch</code>)에만 초점을 뒀다.</p>
<p>REST의 경우, 사실 상 모든 요청이 사이드 이펙트를 일으킬 수 있지만, 데이터 수정에 있어서는 <code>GET</code>을 사용하지 않는다는 규칙이 정해져 있다.</p>
<p>이는 GraphQL 역시 마찬가지다. 기술적으로는 어떤 형태의 쿼리든 데이터에 수정을 가할 수 있으나, 사이드 이펙트를 유발하는 작업의 경우에는 Mutation을 통해 전송되어야 한다는 규칙이 있다.</p>
<p>아래는 내 <code>shubi-docs</code> repo에 star를 추가하는 예시 Mutation이다.</p>
<pre><code class="language-graphql"># mutation
mutation MyMutation(repoId: ID!) {
  __typename
  addStar(input: { starrableId: repoId, clientMutationId: &quot;Star added!&quot; }) {
    clientMutationId
  }
}
</code></pre>
<pre><code class="language-json">// variables
{ &quot;repoId&quot;: &quot;MDEwOlJlcG9zaXRvcnkzMDYzNjgwMDY&quot; }
</code></pre>
<pre><code class="language-json">// result
// 실제로 repo에 star가 추가된다.
{
  &quot;data&quot;: {
    &quot;__typename&quot;: &quot;Mutation&quot;,
    &quot;addStar&quot;: {
      &quot;clientMutationId&quot;: &quot;Star added!&quot;
    }
  }
}
</code></pre>
<h3 id="다중-필드-mutation"><a class="header" href="#다중-필드-mutation">다중 필드 Mutation</a></h3>
<p>Mutation은 쿼리와 마찬가지로 여러 필드를 포함할 수 있는데, 둘 사이에 중요한 차이점이 있다.</p>
<p><strong>쿼리 필드는 병렬로 실행되지만 뮤테이션 필드는 하나씩 차례대로 실행된다</strong>는 점이다.</p>
<p>덕분에, 아래와 같이 여러 개의 뮤테이션을 요청하면, 순서가 보장되기 때문에 결국 추가한 star는 다시 사라진다.</p>
<pre><code class="language-graphql">mutation MyMutation(repoId: ID!) {
  __typename
  addStar(input: { starrableId: repoId, clientMutationId: &quot;Star added!&quot; }) {
    clientMutationId
  }
  removeStar(
    input: { starrableId: repoId, clientMutationId: &quot;Star removed!&quot; }
  ) {
    clientMutationId
  }
}
</code></pre>
<pre><code class="language-json">// variables
{ &quot;repoId&quot;: &quot;MDEwOlJlcG9zaXRvcnkzMDYzNjgwMDY&quot; }
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;__typename&quot;: &quot;Mutation&quot;,
    &quot;addStar&quot;: {
      &quot;clientMutationId&quot;: &quot;Star added!&quot;
    },
    &quot;removeStar&quot;: {
      &quot;clientMutationId&quot;: &quot;Star removed!&quot;
    }
  }
}
</code></pre>
<h2 id="inline-fragments"><a class="header" href="#inline-fragments">Inline Fragments</a></h2>
<p>다른 여러 타입과 마찬가지로 GraphQL 스키마에는 인터페이스와 유니온 타입을 정의하는 기능이 포함되어 있다.</p>
<p>만약, 인터페이스나 유니언 타입을 반환하는 필드를 쿼리하는 경우, Inline Fragement를 사용할 수 있는데, 다음과 같은 형태다.</p>
<pre><code class="language-graphql"># query
{
  node(id: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;) {
    id
    ... on User {
      name
    }
    ... on Organization {
      email
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;node&quot;: {
      &quot;id&quot;: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;,
      &quot;name&quot;: &quot;Won Gyo Seo&quot;
    }
  }
}
</code></pre>
<p>위의 인자로 입력한 <code>id</code>를 통해 반환되는 값은 Node이자 User 타입이다.</p>
<p>User를 반환받는 경우, <code>id</code>와 <code>name</code> 필드를 가져오도록 Inline Fragment (<code>... on User</code>)를 활용했기 때문에, <code>... on Organization {...}</code>은 완전히 무시된다.</p>
<h3 id="meta-fields"><a class="header" href="#meta-fields">Meta fields</a></h3>
<p>만약, GraphQL 상에서 리턴될 타입을 모르는 상황인 경우, 클라이언트에서 해당 데이터를 처리할 방법을 결정하기 위해 타입이 요구되는 경우가 있다.</p>
<p>GraphQL은 쿼리의 어느 지점에서건 메타 필드인 <code>__typename</code>을 요청해 그 시점에서의 객체 타입의 이름을 가져올 수 있다.</p>
<pre><code class="language-graphql"># query
{
  node(id: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;) {
    __typename
    id
    ... on User {
      name
    }
    ... on Organization {
      email
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;node&quot;: {
      &quot;__typename&quot;: &quot;User&quot;,
      &quot;id&quot;: &quot;MDQ6VXNlcjU0NzkwMzc4&quot;,
      &quot;name&quot;: &quot;Won Gyo Seo&quot;
    }
  }
}
</code></pre>
<p>위 쿼리에서 <code>__typename</code>을 추가해 클라이언트 측에서 타입을 구분할 수 있게끔 해주었다.</p>
<p>GraphQL은 이 외에도 몇 가지 메타필드를 제공하며, 이들은 <strong>introspection</strong>의 일부다. 이에 대해서는 다른 문서를 통해 설명하겠다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://graphql-kr.github.io/learn/schema/">여기</a> 문서에 따라, GraphQL 스키마 및 타입에 관해 직접 실습해보려고 한다.</p>
<p>실습을 위해 Typescript 기반으로 Apollo를 이용한 임의의 GraphQL 서버를 생성했다.</p>
<h1 id="schema--type"><a class="header" href="#schema--type">Schema &amp; Type</a></h1>
<p>다음과 같은 쿼리를 받았다고 생각해보자.</p>
<pre><code class="language-graphql"># query
{
  game {
    title
    genre
    tags
  }
}
</code></pre>
<pre><code class="language-json">// result
// 임의로 작성됨
{
  &quot;data&quot;: {
    &quot;title&quot;: &quot;Super Mario Bros&quot;,
    &quot;genre&quot;: &quot;adventure&quot;,
    &quot;developer&quot;: &quot;Nintendo&quot;,
    &quot;publisher&quot;: &quot;Nintendo&quot;,
    &quot;tags&quot;: [&quot;2d&quot;, &quot;famicom&quot;]
  }
}
</code></pre>
<p>기본적으로 GraphQL 쿼리의 형태가 결과와 거의 일치하기 때문에, 서버에 대해 모르는 상태에서도 쿼리가 어떤 형태의 값을 반활할지에 대해 어느 정도 예측할 수 있다.</p>
<p>하지만, 어떤 필드를 선택할 수 있는지, 어떤 종류의 객체를 반환할 수 있는지, 하위 객체에서 사용할 수 있는 필드가 무엇인지 등에 대한 정보를 얻기 위해 스키마가 필요하다.</p>
<p>모든 GraphQL 서비스는 해당 서비스에서 쿼리 가능한 데이터들을 완벽하게 설명하는 타입들을 정의하고, 쿼리가 들어오면 해당 스키마에 대한 유효성이 검사된 후에 실행된다.</p>
<h2 id="type-language"><a class="header" href="#type-language">Type language</a></h2>
<p>GraphQL은 어떤 언어로든 작성될 수 있으며, 해당 문서에서는 TypeScript에 기반하여 내용을 따라갈 예정이다.</p>
<h2 id="object-types-and-fields"><a class="header" href="#object-types-and-fields">Object types and fields</a></h2>
<p>GraphQL 스키마의 가장 기본적인 구성 요소는 객체 타입으로, 이는 서비스에서 가져올 수 있는 객체 종류와 그 객체의 필드를 나타낸다.</p>
<pre><code class="language-graphql">type Game {
  title: String!
  developer: Developer!
  tags: [Tag]!
}

type Developer {
  name: String!
  games: [Game]!
}
</code></pre>
<ul>
<li><code>Game</code>, <code>Developer</code> 등은 <strong>GraphQL Object 타입</strong>이다. 다시 말해, 필드가 존재하는 타입이란 의미이며, 스키마에서 대부분의 타입은 여기에 해당한다.</li>
<li><code>title</code>, <code>name</code> 등은 <code>Character</code> 타입 내에 존재하는 <strong>Field</strong>이다. 즉, 쿼리에서 <code>title</code>는 <code>Game</code> 타입 내에서, <code>name</code>은 <code>Developer</code> 타입 내에서 어디서든 사용할 수 있는 필드이다.</li>
<li><code>String</code>은 내장된 스칼라(scalar) 타입 중 하나다. 이는 단일 스칼라 객체로 해석된다.</li>
<li><code>String!</code>은 필드가 non-nullable함을 의미한다. 즉, 해당 필드를 쿼리하는 경우 항상 GraphQL 서비스는 해당 값을 반환한다는 것을 의미한다.</li>
<li><code>[Game]!</code>은 <code>Game</code> 객체의 배열을 나타내는데, 이 또한 non-nullable하여 무조건 배열을 반환함을 의미한다. (배열 자체는 길이가 0이어도 상관이 없다.)</li>
</ul>
<h2 id="arguments인자"><a class="header" href="#arguments인자">Arguments(인자)</a></h2>
<p>GraphQL 객체 타입의 모든 필드는 0개 이상의 인수를 가질 수 있다.</p>
<pre><code class="language-graphql">type Game {
  title(language: Language = KOREAN): String!
  developer: Developer!
  tags: [Tag]!
}
</code></pre>
<p>모든 인자에는 이름이 있다. 위의 예시에서는 <code>title</code> 필드가 <code>language</code>라는 매개변수를 갖는다.</p>
<p>인자는 required일수도, optional할수도 있다. 인자가 optional인 경우 기본값을 정의할 수 있으며, 이에 대해서는 쿼리에 관한 문서에서도 설명한 바가 있다.</p>
<h2 id="query-type--mutation-type"><a class="header" href="#query-type--mutation-type">Query Type &amp; Mutation Type</a></h2>
<p>스키마 대부분의 타입은 일반 객체 타입이지만, 두 가지 특수한 타입이 존재한다.</p>
<pre><code>schema {
  query: Query
  mutation: Mutation
}
</code></pre>
<p>모든 GraphQL 서비스는 <code>query</code> 타입을 가지며, <code>mutation</code> 타입은 가질 수도, 가지지 않을 수도 있다. 전반적인 취급은 동일하지만, 모든 GraphQL 쿼리의 진입점(<strong>Entry Point</strong>)를 정의하는 것이므로 이는 특별하다.</p>
<h2 id="scalar-type"><a class="header" href="#scalar-type">Scalar Type</a></h2>
<p>GraphQL 객체 타입은 이름과 필드를 가지지만, 결국 그 끝에는 구체적인 데이터로 해석되어야 하는데, 이것이 스칼라 타입이 필요한 이유다.</p>
<p>쿼리를 요청할 때, 필드에 하위 필드가 존재하지 않는 경우 그것이 스칼라 타입임을 알 수 있다. 기본적으로 존재하는 스칼라 타입에는 다음과 같은 것들이 있다.</p>
<ul>
<li><code>Int</code> : 부호가 있는(Signed) 32비트 정수</li>
<li><code>Float</code> : 부호가 있는 부동소수점(double-precision floating-point) 값</li>
<li><code>String</code> : UTF-8 문자열</li>
<li><code>Boolean</code> : <code>true</code> 또는 <code>false</code></li>
<li><code>ID</code> : ID 스칼라 타입은 객체를 다시 요청하거나 캐시 키로써 종종 사용되는 고유 식별자다. String과 같은 형태로 Serialized 되지만, <code>ID</code>로 정의하는 것은 사람들이 읽기 위한 용도가 아님을 의미한다.</li>
</ul>
<p>별도로 커스텀 스칼라 타입을 지정할 수도 있는데, 이는 어떤 언어와 라이브러리를 활용하느냐에 따라 조금씩 다른 형태가 될 것이다. 아래는 JS와 apollo를 활용한 기준.</p>
<pre><code class="language-js">const { ApolloServer, gql } = require('apollo-server');
const { GraphQLScalarType, Kind } = require('graphql');

const typeDefs = gql`
  scalar Date

  type Event {
    id: ID!
    date: Date!
  }

  type Query {
    events: [Event!]
  }
`;

const dateScalar = new GraphQLScalarType({
  name: 'Date',
  description: 'Date custom scalar type',
  serialize(value) {
    return value.getTime(); // Convert outgoing Date to integer for JSON
  },
  parseValue(value) {
    return new Date(value); // Convert incoming integer to Date
  },
  parseLiteral(ast) {
    if (ast.kind === Kind.INT) {
      return new Date(parseInt(ast.value, 10)); // Convert hard-coded AST string to integer and then to Date
    }
    return null; // Invalid hard-coded value (not an integer)
  },
});

const resolvers = {
  Date: dateScalar,
  // ...other resolver definitions...
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
});
</code></pre>
<h2 id="enum-type"><a class="header" href="#enum-type">Enum Type</a></h2>
<p>Enum 타입은 특정 값들로 제한되는 특별한 종류의 스칼라다.</p>
<pre><code class="language-graphql">enum Genre {
  action
  puzzle
  adventure
}
</code></pre>
<p>위의 예시에서 <code>Genre</code> 타입을 사용하면, 이는 정확히 <code>action</code>, <code>puzzle</code>, <code>adventure</code> 중에 하나일 것임을 보장한다.</p>
<h2 id="lists--non-null"><a class="header" href="#lists--non-null">Lists &amp; Non-Null</a></h2>
<p>object, scalar, enum 타입은 GraphQL에서 정의할 수 있는 타입의 전부다.</p>
<p>하지만, 스키마의 다른 부분이나 쿼리 변수 선언에서 타입을 사용해 해당 값의 유효성 검사를 할 수 있는 타입 수정자를 적용할 수 있다.</p>
<pre><code class="language-graphql">type Game {
  title: String!
  tags: [String]!
}
</code></pre>
<p><code>String</code>타입의 뒤에 느낌표 <code>!</code>를 추가해 Non-Null임을 나타냈다. 이제 서버는 해당 필드에 대해 항상 <code>null</code>이 아닐 것이라 기대하며, 만약 <code>null</code>이 반환되면 오류를 발생시킨다.</p>
<p>Non-null 타입 수정자는 매개 변수를 정의할 때도 사용할 수 있는데, 이를 쿼리 시에 충족시키지 않는 경우 유효성 검사 오류를 반환하게끔 한다.</p>
<pre><code class="language-graphql"># query
query GameInfo(id: ID!) {
  game(id: id) {
    title
    tags
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  // 아무것도 넘기지 않는다.
}
</code></pre>
<pre><code class="language-json">// result
// variables에 아무것도 넘기지 않아 에러가 발생.
{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Variable \&quot;id\&quot; of required type \&quot;ID!\&quot; was not provided.&quot;,
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 1,
          &quot;column&quot;: 17
        }
      ]
    }
  ]
}
</code></pre>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>여러가지 타입 시스템과 마찬가지로 GraphQL 역시 인터페이스를 지원한다.</p>
<p>예를 들면, 다음과 같은 식으로 작성할 수 있다.</p>
<pre><code class="language-graphql">interface Game {
  id: ID!
  title: String!
  tags: [Tag]!
}

type ActionGame implements Game {
  id: ID!
  title: String!
  tags: [Tag]!
  genre: ActionGenre!
}

enum ActionGenre {
  Fighting
  Platformer
  ARPG
}
</code></pre>
<p>이런 식으로 <code>Game</code>을 implement하는 모든 타입이 해당 인자와 리턴 타입을 가진 정확한 필드를 가져야함을 명시해줄 수 있다.</p>
<p>만약, 앞선 쿼리의 형태에서 특정 타입에만 존재하는 필드를 가져오고자 하는 경우, 단순히 아래와 같은 형태는 에러가 발생한다.</p>
<pre><code class="language-graphql">query GameInfo(id: ID!) {
  game(id: id) {
    title
    genre # ActionGame 타입에만 존재
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;id1234&quot;
}
</code></pre>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Cannot query field \&quot;genre\&quot; on type \&quot;Game\&quot;. Did you mean to use an inline fragment on \&quot;ActionGame\&quot;?&quot;,
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 4,
          &quot;column&quot;: 5
        }
      ]
    }
  ]
}
</code></pre>
<p>이러한 경우에 아래와 같은 형태로 인라인 프래그먼트를 사용하여 특정 객체 타입일 경우의 필드를 요청할 수 있다.</p>
<pre><code class="language-graphql">query GameInfo(id: ID!) {
  game(id: id) {
    title
    ... on ActionGame {
      genre
    }
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;id&quot;: &quot;id1234&quot;
}
</code></pre>
<pre><code class="language-json">// result
// 임의로 작성됨
{
  &quot;data&quot;: {
    &quot;title&quot;: &quot;Super Mario Bros&quot;,
    &quot;genre&quot;: &quot;Platformer&quot;
  }
}
</code></pre>
<h2 id="union-type"><a class="header" href="#union-type">Union Type</a></h2>
<p>유니온 타입은 인터페이스와 유사하지만, 타입 간의 공통 필드를 정의하지 않는다는 차이점이 있다.</p>
<pre><code class="language-graphql">union SearchResult = ActionGame | PuzzleGame
</code></pre>
<p>이런 경우, SearchResult의 결과가 어떤 타입이더라도 쿼리할 수 있도록 조건부 프래그먼트를 사용해야 한다.</p>
<pre><code class="language-graphql">search(text: &quot;ma&quot;) {
  ... on ActionGame {
    # ActionGame 타입에서 존재하는 필드
  }
  ... on PuzzleGame {
    # PuzzleGame 타입에서 존재하는 필드
  }
}
</code></pre>
<h2 id="input-type"><a class="header" href="#input-type">Input Type</a></h2>
<p>지금껏 매개변수에 전달하는 인자가 간단한 스칼라 값인 경우에 대해서만 나타냈는데, 좀 더 복잡한 객체도 쉽게 전달할 수 있다. 이는 뮤테이션 타입에서 특히 유용하다.</p>
<p>이 때 활용하는 타입이 <strong>Input Type</strong>이며, 일반 객체 타입과 완전히 동일하지만, <code>type</code> 대신에 <code>input</code>을 사용한다는 차이점이 있다.</p>
<pre><code class="language-graphql">input ReviewInput {
  stars: Int!
  comment: String
}
</code></pre>
<pre><code class="language-graphql"># mutation
mutation CreateReviewForGame(gameId: ID!, review: ReviewInput!) {
  createReview(gameId: gameId, review: review) {
    stars
    commentary
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;gameId&quot;: &quot;mario1234&quot;,
  &quot;review&quot;: {
    &quot;stars&quot;: 5,
    &quot;comment&quot;: &quot;The begin of legend. :)&quot;
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;createReview&quot;: {
      &quot;stars&quot;: 5,
      &quot;commentary&quot;: &quot;The begin of legend. :)&quot;
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://graphql-kr.github.io/learn/pagination/">여기</a>의 내용을 Github GraphQL API로 따라가보자.</p>
<h1 id="pagination"><a class="header" href="#pagination">Pagination</a></h1>
<h2 id="plurals"><a class="header" href="#plurals">Plurals</a></h2>
<p>여러 개의 객체를 가져오기 위한 가장 간단한 방법은 Plurals(복수형) 타입을 반환하는 필드를 사용하는 것이다.</p>
<pre><code class="language-graphql">licenses {
  name
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;licenses&quot;: [
      {
        &quot;name&quot;: &quot;GNU Affero General Public License v3.0&quot;
      },
      {
        &quot;name&quot;: &quot;Apache License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;BSD 2-Clause \&quot;Simplified\&quot; License&quot;
      },
      {
        &quot;name&quot;: &quot;BSD 3-Clause \&quot;New\&quot; or \&quot;Revised\&quot; License&quot;
      },
      {
        &quot;name&quot;: &quot;Boost Software License 1.0&quot;
      },
      {
        &quot;name&quot;: &quot;Creative Commons Zero v1.0 Universal&quot;
      },
      {
        &quot;name&quot;: &quot;Eclipse Public License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;GNU General Public License v2.0&quot;
      },
      {
        &quot;name&quot;: &quot;GNU General Public License v3.0&quot;
      },
      {
        &quot;name&quot;: &quot;GNU Lesser General Public License v2.1&quot;
      },
      {
        &quot;name&quot;: &quot;MIT License&quot;
      },
      {
        &quot;name&quot;: &quot;Mozilla Public License 2.0&quot;
      },
      {
        &quot;name&quot;: &quot;The Unlicense&quot;
      }
    ]
  }
}
</code></pre>
<h2 id="slicing"><a class="header" href="#slicing">Slicing</a></h2>
<p>헌데, 여기에 클라이언트가 가장 앞의 둘, 혹은 가장 뒤의 둘과 같은 식으로 Slicing을 원한다면, 아래와 같은 형태가 이루어질 수 있다.</p>
<pre><code class="language-graphql">{
  search(query: &quot;react&quot;, type: REPOSITORY, first: 2) {
    nodes {
      ... on Repository {
        name
        owner {
          ... on User {
            name
          }
          ... on Organization {
            name
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;search&quot;: {
      &quot;nodes&quot;: [
        {
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;name&quot;: &quot;Facebook&quot;
          }
        },
        {
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;name&quot;: &quot;TypeScript Cheatsheets&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<h2 id="pagination-and-edges"><a class="header" href="#pagination-and-edges">Pagination and Edges</a></h2>
<p>페이지네이션을 할 수 있는 방법은 여러 가지가 있다.</p>
<ul>
<li>
<p><code>field(first: 2, offset: 2)</code> : 리스트로 다음 두 개를 요청</p>
</li>
<li>
<p><code>field(first: 2, after: &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.77777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;앞서가져온마지막&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;의&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;값을통해그다음두개를요청&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;fieldCursor)</code> : 마지막 항목으로부터 커서를 가져와 사용</p>
</li>
</ul>
<p>이 중 가장 기능이 강력한 것은 마지막의 **커서 기반 페이지네이션(cursor-based pagination)**이며, 커서를 사용하면 향후 페이지네이션 모델이 변경될 경우에 추가적인 유연성이 제공된다.</p>
<p>다만, 또 여기서 문제가 발생하는데, 객체에서 어떻게 커서를 가져오느냐 하는 것이다.</p>
<p>기본적으로, 커서는 연결(<code>connection</code>)을 위한 필드이므로 이것이 객체 속성에 포함되는 것은 부적절해보인다.</p>
<p>때문에 <code>edge</code>라고 하는 별도의 필드를 가지며, 이는 객체와 관련된 정보가 아닌 엣지와 관련된 자체 정보가 있는 경우에 유용하다.</p>
<pre><code class="language-graphql"># query
{
  search(query: &quot;react&quot;, type: REPOSITORY, first: 3) {
    edges {
      cursor
    }
    nodes {
      ... on Repository {
        id
        name
        owner {
          id
          ... on User {
            name
          }
          ... on Organization {
            name
          }
        }
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;search&quot;: {
      &quot;edges&quot;: [
        {
          &quot;cursor&quot;: &quot;Y3Vyc29yOjE=&quot;
        },
        {
          &quot;cursor&quot;: &quot;Y3Vyc29yOjI=&quot;
        },
        {
          &quot;cursor&quot;: &quot;Y3Vyc29yOjM=&quot;
        }
      ],
      &quot;nodes&quot;: [
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMDI3MDI1MA==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;,
            &quot;name&quot;: &quot;Facebook&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMzU3ODYwOTM=&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjUwMTg4MjY0&quot;,
            &quot;name&quot;: &quot;TypeScript Cheatsheets&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnk3NTM5NjU3NQ==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDQ6VXNlcjMyNDk2NTM=&quot;,
            &quot;name&quot;: &quot;肚皮&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<h2 id="end-of-list-counts-and-connections"><a class="header" href="#end-of-list-counts-and-connections">End-of-list, counts, and Connections</a></h2>
<p>그렇다면 이런 식으로 pagination을 반복하다가 언제 <code>connection</code>이 끝났는지를 알 수 있을까?? 또한, 총 몇 개의 item이 존재하는지 어떻게 알 수 있을까??</p>
<p>이를 위해 필드는 <code>connection</code> 객체를 반환할 수 있다.</p>
<p><code>connection</code> 객체에는 엣지에 대한 필드 뿐만 아니라 다른 정보(ex. item 갯수, 다음 페이지 존재 여부)등을 담고 있다.</p>
<p>이를 활용한다면, 다음과 같은 형태로 이용할 수 있다.</p>
<pre><code class="language-graphql">{
  search(query: &quot;react&quot;, type: REPOSITORY, first: 3) {
    nodes {
      ... on Repository {
        id
        name
        owner {
          id
          ... on User {
            name
          }
          ... on Organization {
            name
          }
        }
      }
    }
    repositoryCount
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;search&quot;: {
      &quot;nodes&quot;: [
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMDI3MDI1MA==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjY5NjMx&quot;,
            &quot;name&quot;: &quot;Facebook&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnkxMzU3ODYwOTM=&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDEyOk9yZ2FuaXphdGlvbjUwMTg4MjY0&quot;,
            &quot;name&quot;: &quot;TypeScript Cheatsheets&quot;
          }
        },
        {
          &quot;id&quot;: &quot;MDEwOlJlcG9zaXRvcnk3NTM5NjU3NQ==&quot;,
          &quot;name&quot;: &quot;react&quot;,
          &quot;owner&quot;: {
            &quot;id&quot;: &quot;MDQ6VXNlcjMyNDk2NTM=&quot;,
            &quot;name&quot;: &quot;肚皮&quot;
          }
        }
      ],
      &quot;repositoryCount&quot;: 1979845,
      &quot;pageInfo&quot;: {
        &quot;startCursor&quot;: &quot;Y3Vyc29yOjE=&quot;,
        &quot;endCursor&quot;: &quot;Y3Vyc29yOjM=&quot;,
        &quot;hasPreviousPage&quot;: false,
        &quot;hasNextPage&quot;: true
      }
    }
  }
}
</code></pre>
<p><code>pageInfo</code>내의 <code>startCursor</code>, <code>endCursor</code>를 통해 페이지네이션에 필요한 커서를 얻을 수 있으며, 더 이상 <code>edge</code>를 쿼리할 필요가 없어졌다.</p>
<h2 id="complete-connection-model"><a class="header" href="#complete-connection-model">Complete Connection Model</a></h2>
<p>이는 별도로 <code>~Connection</code>과 같은 필드를 추가하는 방식이다.</p>
<p>단순히 복수 타입을 갖도록 하는 형태보다 훨씬 더 복잡하지만, 이러한 디자인을 채택함으로써 클라이언트를 위한 다양한 기능을 사용할 수 있게 된다.</p>
<ul>
<li>리스트의 페이지네이션 기능</li>
<li><code>totalCount</code> 또는 <code>pageInfo</code>와 같은 연결 자체에 대한 정보를 요청하는 기능</li>
<li><code>cursor</code> 등 엣지 자체에 대한 정보를 요청하는 기능</li>
<li>백엔드 측에서 페이지네이션 방식 변경이 가능 (사용자가 불투명(<code>opaque</code>) 커서만을 사용하기 때문에)</li>
</ul>
<p>아래는 예시.</p>
<pre><code class="language-graphql">{
  hero {
    name
    friends {
      name
    }
    friendsConnection(first: 3) {
      totalCount
      edges {
        cursor
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;hero&quot;: {
      &quot;name&quot;: &quot;R2-D2&quot;,
      &quot;friends&quot;: [
        {
          &quot;name&quot;: &quot;Luke Skywalker&quot;
        },
        {
          &quot;name&quot;: &quot;Han Solo&quot;
        },
        {
          &quot;name&quot;: &quot;Leia Organa&quot;
        }
      ],
      &quot;friendsConnection&quot;: {
        &quot;totalCount&quot;: 3,
        &quot;edges&quot;: [
          {
            &quot;cursor&quot;: &quot;Y3Vyc29yMQ==&quot;
          },
          {
            &quot;cursor&quot;: &quot;Y3Vyc29yMg==&quot;
          },
          {
            &quot;cursor&quot;: &quot;Y3Vyc29yMw==&quot;
          }
        ],
        &quot;pageInfo&quot;: {
          &quot;endCursor&quot;: &quot;Y3Vyc29yMw==&quot;,
          &quot;hasNextPage&quot;: false
        }
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="serving-over-http"><a class="header" href="#serving-over-http">Serving Over HTTP</a></h1>
<p><a href="https://graphql-kr.github.io/learn/serving-over-http/">여기</a>의 내용을 따라가보자.</p>
<h2 id="uris-routes"><a class="header" href="#uris-routes">URIs, Routes</a></h2>
<p>HTTP는 일반적으로 리소스를 핵심 개념으로 여기는 REST와 관련이 있다.</p>
<p>이와 반대로, GraphQL의 개념 모델은 엔티티 그래프로, 이는 URL로 식별되지 않는다.</p>
<p>GraphQL 서버는 단일 엔드포인트(일반적으로 <code>/graphql</code>)에서 작동하며, 주어진 서비스에 대한 모든 요청은 해당 엔드포인트에서 수행된다.</p>
<h2 id="http-methods-headers-and-body"><a class="header" href="#http-methods-headers-and-body">HTTP Methods, Headers, and Body</a></h2>
<p>GraphQL HTTP 서버는 HTTP GET / POST 메서드를 처리해야 한다.</p>
<h3 id="get-요청"><a class="header" href="#get-요청">GET 요청</a></h3>
<p>만약 다음과 같은 GraphQL 쿼리를 실행하려고 한다면,</p>
<pre><code class="language-graphql">{
  me {
    name
  }
}
</code></pre>
<p>다음과 같이 HTTP GET을 통해 전송할 수 있다.</p>
<pre><code>/graphql?query={me{name}}
</code></pre>
<p>여기에 더해 다음과 같은 추가 쿼리 파라미터를 가질 수 있다.</p>
<ul>
<li><code>variables</code> : 쿼리 변수들을 넘기는 객체를 JSON Stringified 처리한 문자열</li>
<li><code>operationName</code> : 쿼리에 여러 개의 명명된 작업이 포함된 경우에, 어떤 쿼리를 실행하는지 제어</li>
</ul>
<p>즉, <code>variables</code>과 함께 좀 더 복잡한 쿼리를 전달해보자면, 가령 아래와 같은 쿼리가 있다고 할 때,</p>
<pre><code class="language-graphql">query gameInfo(id: ID!) {
  game(id: id) {
    title
  }
}
</code></pre>
<pre><code class="language-json">// variables
{
  &quot;id&quot;: &quot;1&quot;
}
</code></pre>
<pre><code class="language-json">// result
{
  &quot;data&quot;: {
    &quot;game&quot;: {
      &quot;title&quot;: &quot;Super Mario Bros&quot;
    }
  }
}
</code></pre>
<p>이를 (굳이) HTTP GET 메서드로 요청해보겠다고 하면 아래와 같아진다. 만약 나머지 특수문자들도 인코딩한다면 훨씬 지저분해질 것이다.</p>
<pre><code>/graphql?variables={&quot;id&quot;:&quot;1&quot;}&amp;query=query%20gameInfo(id:ID!){game(id:id){title}}
</code></pre>
<p><code>operationName</code>의 경우, 앞서 말했듯 여러 개의 쿼리 작업을 보유한 경우, 실행하길 원하는 작업명을 의미한다.</p>
<p>이를테면 아래와 같이 사용한다. 다음과 같은 쿼리가 있다고 하자.</p>
<pre><code class="language-graphql">query query1 {
  game(id: &quot;1&quot;) {
    title
  }
}

query query2 {
  game(id: &quot;2&quot;) {
    title
  }
}
</code></pre>
<p>여기서, (굳이 또) HTTP GET 메서드로 <code>query2</code>에 해당하는 작업을 요구하려는 경우에는 다음과 같이 할 수 있다.</p>
<pre><code>/graphql?operationName=query2&amp;query=query%20query1{game(id:&quot;1&quot;){title}}%20query%20query2{game(id:&quot;2&quot;){title}}
</code></pre>
<h3 id="post-요청"><a class="header" href="#post-요청">POST 요청</a></h3>
<p>표준 GraphQL POST 요청은 <code>application/json</code> content-type을 사용해야하며, 아래 형식의 JSON 인코딩 처리된 Body를 포함해야한다.</p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;...&quot;,
  &quot;operationName&quot;: &quot;...&quot;,
  &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }
}
</code></pre>
<p><code>operationName</code>과 <code>variables</code>는 앞선 GET 메서드의 경우와 똑같은 역할을 한다.</p>
<p>위 내용 외에도 추가로 다음 두 가지 경우에 대해 지원하는 것이 좋다.</p>
<ul>
<li>위의 GET 요청과 같은 방식으로 쿼리스트링 파라미터가 존재하는 경우, HTTP GET의 경우와 동일한 형식으로 처리</li>
<li><code>application/graphql</code> Content-Type header가 있는 경우, HTTP POST body의 내용을 GraphQL 쿼리스트링으로 처리 (Body에 넘겨진 텍스트 자체를 쿼리문으로 여겨야 한다는 듯)</li>
</ul>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>쿼리와 변수가 전송된 방식과는 관계없이, 응답은 Body에 JSON 형태로 반환되어야 한다.
쿼리는 데이터 뿐만 아니라 오류 또한 유발할 수 있기 때문에, 다음과 같은 형태로 반환되어야 한다.</p>
<pre><code>{
  &quot;data&quot;: { ... },
  &quot;errors&quot;: [ ... ]
}
</code></pre>
<p>오류가 없는 경우에는 <code>errors</code> 필드가 없어야 한다.
반면 데이터가 반환되지 않는 경우에는 실행 도중에 에러가 발생한 경우에 대해서만 <code>data</code> 필드가 포함된다.</p>
<h3 id="graphiql"><a class="header" href="#graphiql">GraphiQL</a></h3>
<p>GraphiQL이나 GraphQL Playground는 테스트 및 개발 중에 유용하게 쓰일 수 있지만, 기본적으로 프로덕션 환경에서는 사용하지 않도록 되어야 한다.</p>
<p><code>express-graphql</code>의 경우는 다음과 같이 이를 구현할 수 있다.</p>
<pre><code class="language-js">app.use(
  '/graphql',
  graphqlHTTP({
    schema: MySessionAwareGraphQLSchema,
    graphiql: process.env.NODE_ENV === 'development',
  }),
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h2>
<pre><code class="language-bash">docker run -d -p 80:80 docker/getting-started
</code></pre>
<ul>
<li><code>-d</code> : 컨테이너를 <code>detached</code> 모드로 실행한다. (백그라운드에서)</li>
<li><code>-p 80:80</code> : 호스트의 <code>80</code> 포트를 컨테이너의 <code>80</code> 포트로 연결시킨다.</li>
<li><code>docker/getting-started</code> : 사용할 이미지</li>
</ul>
<p>위의 단일 문자 플래그들은 합쳐서 사용할 수 있다. 이를테면 아래와 같이 작성할 수 있다.</p>
<pre><code class="language-bash">docker run -dp 80:80 docker/getting-started
</code></pre>
<h2 id="대쉬보드"><a class="header" href="#대쉬보드">대쉬보드</a></h2>
<p>컨테이너를 실행하고나면 이를 대쉬보드 상에서 확인할 수 있다.</p>
<img src="https://docs.docker.com/get-started/images/tutorial-in-dashboard.png" />
<h2 id="컨테이너란"><a class="header" href="#컨테이너란">컨테이너란?</a></h2>
<p>컨테이너란 호스트 머신의 다른 프로세스로부터 격리된 또 하나의 프로세스다. 이러한 분리는 Linux에서 오랫동안 사용되어 온 기능인 <a href="https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504">kernel namespaces와 cgroups</a>를 활용한다. 그리고 Docker는 이런 기능들은 접근 가능하고 사용하기 쉽게 만들고자 한 것이다.</p>
<h2 id="컨테이너-이미지란"><a class="header" href="#컨테이너-이미지란">컨테이너 이미지란?</a></h2>
<p>컨테이너가 실행될 때, 해당 컨테이너는 격리된 파일시스템을 사용한다. 이 격리된 파일시스템이 바로 <strong>컨테이너 이미지</strong>로부터 제공된다. 각 이미지들은 컨테이너의 파일시스템을 내포하고 있으며, 애플리케이션의 실행에 필요한 모든 것들을 담고 있어야 한다. (dependencies / configurations / scripts / binaries / etc.) 또한 환경변수, 기초 실행 명령 / 그 외의 메타 데이터 등 컨테이너에 대한 다른 설정들 또한 갖고있다.</p>
<p>이미지에 대해서는 Layering, Best practices 등 추후 더 깊게 다루어보도록 하겠다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="애플리케이션-구성"><a class="header" href="#애플리케이션-구성">애플리케이션 구성</a></h2>
<img src="https://docs.docker.com/get-started/images/ide-screenshot.png" />
<p>위와 같은 애플리케이션이 있다고 하자.</p>
<h2 id="컨테이너-이미지-빌드"><a class="header" href="#컨테이너-이미지-빌드">컨테이너 이미지 빌드</a></h2>
<p>애플리케이션을 빌드하기 위해서는 <code>Dockerfile</code>을 사용해야 한다. <code>Dockerfile</code>은 컨테이너 이미지를 생성하기 위해 사용되는 간단한 텍스트 스크립트다.</p>
<ol>
<li>먼저 <code>Dockerfile</code>을 <code>package.json</code>이 위치한 폴더와 같은 곳에 생성한다.</li>
</ol>
<pre><code class="language-dockerfile"> # syntax=docker/dockerfile:1
 FROM node:12-alpine
 RUN apk add --no-cache python g++ make
 WORKDIR /app
 COPY . .
 RUN yarn install --production
 CMD [&quot;node&quot;, &quot;src/index.js&quot;]
</code></pre>
<p><code>Dockerfile</code>에는 별도로 <code>.txt</code>와 같은 확장자가 붙어있지 않음을 유의하자.</p>
<ol start="2">
<li><code>Dockerfile</code>이 위치한 디렉토리로 이동하여 <code>docker build</code> 명령을 통해 컨테이너 이미지를 빌드한다.</li>
</ol>
<pre><code class="language-bash">docker build -t getting-started .
</code></pre>
<p>빌드 과정에서, 수많은 <strong>layer</strong>들이 다운로드되는 것을 확인할 수 있는데, 이는 <code>Dockerfile</code>의 처음에 <code>node:12-alpine</code> 이미지에서부터 시작된다고 빌더에게 명령했기 때문이다. 현재의 호스트 머신에는 이 이미지가 존재하지 않고, 따라서 해당 이미지를 다운로드하는 과정이 필요한 것이다.</p>
<p>해당 이미지가 다운로드되면, 애플리케이션을 복사하고 <code>yarn</code>으로 애플리케이션의 dependencies를 설치한다. <code>CMD</code> 명령에는 이미지로부터 컨테이너를 가동할 때 실행할 기본 명령어를 지정한다.</p>
<p>마지막으로, <code>-t</code> 플래그는 이미지에 대한 태그를 의미한다. 생성한 이미지에 대한 읽기 쉬운 이름이라고 이해하면 된다. <code>getting-started</code> 라는 이름으로 이미지를 이름지었기 때문에, 컨테이너를 실행할 때마다 해당 이름을 참조할 수 있다.</p>
<p><code>docker build</code>의 마지막에 있는 <code>.</code>은 Docker에게 <strong>현재 디렉토리</strong>에서 <code>Dockerfile</code>을 찾아야한다고 명령하는 것이다.</p>
<h2 id="앱-컨테이너-실행"><a class="header" href="#앱-컨테이너-실행">앱 컨테이너 실행</a></h2>
<p>자, 이제 이미지를 만들었으니, 이를 실행해보자. <code>docker run</code> 명령을 사용하면 된다.</p>
<ol>
<li>앞서 만든 이미지를 <code>docker run</code> 명령을 통해 컨테이너로 실행한다.</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 getting-started
</code></pre>
<p>앞선 챕터에서 <code>-d</code>와 <code>-p</code> 플래그에 대해 설명했던 것이 기억나는가? <code>-dp</code> 플래그를 통해, 호스트의 3000 포트를 컨테이너의 3000 포트와 매핑하고, 컨테이너를 &quot;detached&quot; 모드(백그라운드에서) 실행했다. 만약 별도로 포트를 지정해주지 않는다면, 애플리케이션에 접근할 수 없다.</p>
<ol start="2">
<li>잠시 후, <code>http://localhost:3000</code>에 접근하면, 애플리케이션을 확인할 수 있다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="애플리케이션-업데이트"><a class="header" href="#애플리케이션-업데이트">애플리케이션 업데이트</a></h2>
<pre><code class="language-bash">docker build -t getting-started .
docker run -dp 3000:3000 getting-started
</code></pre>
<p>애플리케이션에 어떤 변경사항이 생겼을 때, 이를 적용하고 이전 챕터에서 했던 것과 동일하게 빌드 / 실행하게되면 아래와 같은 에러가 발생한다.</p>
<pre><code class="language-bash">docker: Error response from daemon: driver failed programming external connectivity on endpoint laughing_burnell
(bb242b2ca4d67eba76e79474fb36bb5125708ebdabd7f45c8eaf16caaabde9dd): Bind for 0.0.0.0:3000 failed: port is already allocated.
</code></pre>
<p>해당 문제는 컨테이너가 호스트의 3000 포트를 사용하고 있고, 호스트 머신에서는 하나의 프로세스만이 특정 포트를 수신할 수 있기 때문이다. 따라서, 이를 해결하려면 실행 중인 이전의 컨테이너를 제거해야 한다.</p>
<h2 id="컨테이너-교체"><a class="header" href="#컨테이너-교체">컨테이너 교체</a></h2>
<p>컨테이너를 제거하려면, 먼저 컨테이너를 멈추어야 한다. 두 가지 방법이 있는데, 어느 쪽을 사용해도 상관없다.</p>
<h3 id="1-cli로-컨테이너-제거"><a class="header" href="#1-cli로-컨테이너-제거">1. CLI로 컨테이너 제거</a></h3>
<ol>
<li><code>docker ps</code> 명령으로 컨테이너의 ID를 가져온다.</li>
</ol>
<pre><code class="language-bash">docker ps
</code></pre>
<ol start="2">
<li><code>docker stop</code> 명령으로 컨테이너를 멈춘다.</li>
</ol>
<pre><code class="language-bash"># &lt;the-container-id&gt;를 앞선 과정에서 얻은 ID로 교체
docker stop &lt;the-container-id&gt;
</code></pre>
<ol start="3">
<li>컨테이너가 멈추고 난 후, <code>docker rm</code> 명령으로 제거한다.</li>
</ol>
<pre><code class="language-bash">docker rm &lt;the-container-id&gt;
</code></pre>
<p>만약 &quot;force&quot; 플래그를 추가한다면 <code>docker rm</code> 명령 하나만으로 컨테이너를 정지하고 삭제할 수 있다.</p>
<pre><code class="language-bash">docker rm -f &lt;the-container-id&gt;
</code></pre>
<h3 id="2-docker-대쉬보드를-통해-컨테이너-삭제"><a class="header" href="#2-docker-대쉬보드를-통해-컨테이너-삭제">2. Docker 대쉬보드를 통해 컨테이너 삭제</a></h3>
<img src="https://docs.docker.com/get-started/images/dashboard-removing-container.png" />
<p>Docker 대쉬보드를 이용한다면 몇 번의 클릭을 통해 앞선 과정을 해결할 수 있다.</p>
<h2 id="컨테이너-재실행"><a class="header" href="#컨테이너-재실행">컨테이너 재실행</a></h2>
<p>이제, 다시 업데이트된 컨테이너를 실행해보자.</p>
<pre><code class="language-bash">docker run -dp 3000:3000 getting-started
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="저장소repository-생성"><a class="header" href="#저장소repository-생성">저장소(Repository) 생성</a></h2>
<p>이미지를 푸쉬하기 위해서는 먼저 DockerHub에 저장소를 생성해야 한다.</p>
<ol>
<li>Docker Hub에 가입하고, 로그인</li>
<li><strong>Create Repository</strong> 버튼을 클릭</li>
<li>저장소 이름을 설정하고, Visibility를 <code>Public</code>으로 지정
<blockquote>
<p>기본적으로 Private 저장소는 개인 당 1개만 주어진다. 추가로 이용하거나 팀 별로 이용하고자 하는 경우엔 <a href="https://www.docker.com/pricing?utm_source=docker&amp;utm_medium=webreferral&amp;utm_campaign=docs_driven_upgrade">Pricing</a>을 참조하자.</p>
</blockquote>
</li>
<li><strong>Create</strong> 버튼을 클릭</li>
</ol>
<p>해당 과정을 마쳤으면, 아래와 같이 <strong>Docker commands</strong>가 나타난다. 이는 현재 저장소에 푸쉬하기 위한 예시 명령이다.</p>
<img src="https://docs.docker.com/get-started/images/push-command.png" />
<h2 id="이미지-푸쉬"><a class="header" href="#이미지-푸쉬">이미지 푸쉬</a></h2>
<ol>
<li>다음과 같이 푸쉬 명령을 작성한다. <code>docker</code>가 아니라, 본인의 네임 스페이스로 작성해주어야 함을 주의하자.</li>
</ol>
<pre><code class="language-bash">  docker push docker/getting-started
 The push refers to repository [docker.io/docker/getting-started]
 An image does not exist locally with the tag: docker/getting-started
</code></pre>
<p>뭐가 문제일까? 푸쉬 명령이 <code>docker/getting-started</code>라는 이름의 이미지를 찾아봤지만, 알 수 없었다. <code>docker image ls</code>를 실행해보면 알겠지만, 아무 것도 존재하지 않는다.</p>
<ol start="2">
<li>
<p>먼저, <code>docker login -u &lt;USER-NAME&gt;</code> 명령으로 Docker Hub에 로그인한다.</p>
</li>
<li>
<p><code>docker tag</code> 명령으로 <code>getting-started</code> 이미지에 새로운 이름을 부여한다.</p>
</li>
</ol>
<pre><code class="language-bash">docker tag getting-started &lt;USER-NAME&gt;/getting-started
</code></pre>
<ol start="4">
<li>이제, 앞선 과정을 다시 해보자. 현재 따로 태그네임을 추가하지 않았으므로 <code>:tagname</code> 부분은 없어도 된다. 별도로 태그를 지정하지 않는 경우, Docker는 <code>latest</code>라는 이름의 태그를 사용한다.</li>
</ol>
<pre><code class="language-bash">docker push YOUR-USER-NAME/getting-started
</code></pre>
<h2 id="새-인스턴스에-이미지-실행"><a class="header" href="#새-인스턴스에-이미지-실행">새 인스턴스에 이미지 실행</a></h2>
<p>이제, 우리가 빌드한 컨테이너 이미지를 전혀 다른 새로운 환경에서 사용해보자. 여기서는 <strong>Play with Docker</strong>를 사용한다.</p>
<ol>
<li>
<p>브라우저로 <a href="https://labs.play-with-docker.com/">Play with Docker</a>에 접속한다.</p>
</li>
<li>
<p><strong>Login</strong>을 클릭하고, <strong>docker</strong>를 선택한다.</p>
</li>
<li>
<p>본인의 Docker Hub 계정으로 접속한다.</p>
</li>
<li>
<p>로그인 한 후, <strong>ADD NEW INSTANCE</strong> 옵션을 클릭한다. 이 후, 브라우저 상에서 터미널을 확인할 수 있다.</p>
</li>
</ol>
<img src="https://docs.docker.com/get-started/images/pwd-add-new-instance.png" />
<ol start="5">
<li>해당 터미널에서 우리가 푸쉬했던 애플리케이션을 실행하자.</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 YOUR-USER-NAME/getting-started
</code></pre>
<ol start="6">
<li>위쪽에 <code>3000</code> 포트를 클릭하면, 실행한 애플리케이션을 확인할 수 있다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="컨테이너-파일시스템"><a class="header" href="#컨테이너-파일시스템">컨테이너 파일시스템</a></h2>
<p>컨테이너가 실행될 때, 파일시스템을 구축하기 위해 이미지로부터 여러 개의 레이어를 사용한다. 각각의 컨테이너는 파일을 생성/업데이트/제거하기 위한 &quot;Scratch space&quot;를 갖는다. 한 컨테이너 내의 어떤 변화는 다른 컨테이너에 영향을 주지 않으며, 심지어 그것이 같은 이미지로부터 만들어진 컨테이너라도 마찬가지다.</p>
<h2 id="실전"><a class="header" href="#실전">실전</a></h2>
<p>직접 두 개의 컨테이너를 실행시키고 각각 하나의 파일을 만들게끔 해보자. 이로부터 하나의 컨테이너에서 생긴 파일은 다른 컨테이너에서 활용할 수 없음을 확인할 수 있을 것이다.</p>
<ol>
<li><code>ubuntu</code> 컨테이너를 실행하고 1에서 10000 사이의 난수를 갖는 <code>/data.txt</code>라는 이름의 파일을 만든다.</li>
</ol>
<pre><code class="language-bash">docker run -d ubuntu bash -c &quot;shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null&quot;
</code></pre>
<p>위에서는 <code>&amp;&amp;</code>를 통해 두 가지 명령을 실행했는데, 첫번째는 무작위 번호를 추출하여 <code>/data.txt</code>라는 파일로 작성한 것이고, 두번째는 컨테이너를 실행 상태로 유지하기 위해 파일을 확인하는 것이다.</p>
<ol start="2">
<li>컨테이너에 <code>exec</code>을 해줌으로써 결과를 확인할 수 있다. 그렇게 하기 위해서, 대쉬보드를 열고 실행 중인 <code>ubuntu</code> 이미지가 실행 중인 컨테이너를 클릭하자.</li>
</ol>
<img src="https://docs.docker.com/get-started/images/dashboard-open-cli-ubuntu.png"/>
<p>그러면 현재 실행 중인 <code>ubuntu</code> 컨테이너 내에서 동작하고 있는 터미널을 확인할 수 있다. 작성한 <code>/data.txt</code> 파일을 확인하기 위해 아래의 명령을 실행하고, 터미널을 다시 종료하자.</p>
<pre><code class="language-bash">cat /data.txt
</code></pre>
<p>만약, 대쉬보드보다 CLI 방식을 더 선호한다면, 아래와 같이 <code>docker exec</code> 명령을 실행하여 똑같이 진행할 수 있다. 이 경우 컨테이너의 ID를 알고 있어야 한다.(<code>docker ps</code>를 사용하자.)</p>
<pre><code class="language-bash">docker exec &lt;container-id&gt; cat /data.txt
</code></pre>
<p>그러면 <code>/data.txt</code>에 작성된 난수를 확인할 수 있을 것이다!</p>
<ol start="3">
<li>이제, 똑같은 이미지를 통해 다른 <code>ubuntu</code> 컨테이너를 실행시켜보자. 동일한 파일이 존재하지 않음을 알 수 있다.</li>
</ol>
<pre><code class="language-bash">docker run -it ubuntu ls /
</code></pre>
<p>보시다시피 <code>data.txt</code>가 존재하지 않는다. 말했다시피 해당 파일은 첫번째 컨테이너에 대한 &quot;scratch space&quot;에 작성되었기 때문이다.</p>
<h2 id="컨테이너-볼륨"><a class="header" href="#컨테이너-볼륨">컨테이너 볼륨</a></h2>
<p>앞선 실험에서, 동일한 이미지에서 실행한 각각의 컨테이너는 매번 새롭게 실행되는 것임을 확인했다. 각각의 컨테이너 내에서 일어나는 일련의 CRUD 작업들은 해당 컨테이너 내에서만 영향을 준다. 단, **볼륨(Volume)**을 사용한다면, 이를 바꿀 수 있다.</p>
<p><a href="https://docs.docker.com/storage/volumes/">볼륨</a>은 컨테이너의 특정 파일 시스템 경로를 호스트 머신에 연결시켜줄 수 있게 해준다. 컨테이너의 디렉토리가 마운트되면, 디렉토리 내의 변경사항들은 호스트 머신에도 적용된다. 덕분에, 컨테이너가 여러번 재실행되더라도, 동일한 디렉토리를 마운트하게 되면 매번 동일한 파일을 유지할 수 있다.</p>
<p>볼륨에는 두 가지 종류가 있는데, 하나는 <strong>Named volumes</strong>이다.</p>
<h2 id="데이터-유지하기"><a class="header" href="#데이터-유지하기">데이터 유지하기</a></h2>
<p>앞선 챕터에서, 기본적으로 우리의 TODO 앱은 <a href="https://www.sqlite.org/index.html">SQLite</a>를 통해 <code>/etc/todos/todo.db</code>에 데이터를 저장한다. SQLite는 하나의 파일에 데이터를 저장하는 간단한 형태의 관계형 DB다. 이는 대규모의 애플리케이션에 적합하진 않지만, 작은 데모에서는 잘 동작한다. DB 엔진을 변경하는 방법에 대해서는 추후에 따로 다루어보자.</p>
<p>DB가 하나의 파일이기 때문에, 해당 파일을 유지하기만 하면 다음 컨테이너의 실행에서도 DB에 저장된 내용을 유지할 수 있다. 볼륨을 만들고, 디렉토리에 첨부(일반적으로, <strong>mouting</strong>이라고 함)하면, 데이터가 저장, 유지된다. 현재 컨테이너는 <code>todo.db</code> 파일을 작성하기 때문에, 볼륨을 통해 해당 파일이 호스트에 지속될 것이다.</p>
<p>앞서 말했듯, 먼저 <strong>named volume</strong>을 사용해보겠다. named volume은 간단한 데이터 버킷이다. Docker가 디스크의 물리적인 로케이션을 유지하고, 우리는 해당 볼륨의 이름을 기억하기만 하면 된다. 해당 볼륨을 사용할 때마다, Docker가 적절한 데이터가 제공됨을 보장해줄 것이다.</p>
<ol>
<li><code>docker volume create</code> 명령으로 볼륨을 만든다.</li>
</ol>
<pre><code class="language-bash">docker volume create todo-db
</code></pre>
<ol start="2">
<li>
<p>작동 중인 TODO 앱 컨테이너를 멈추고, 삭제한다. (대쉬보드, 혹은 <code>docker rm -f &lt;id&gt;</code>)</p>
</li>
<li>
<p>새로 컨테이너를 실행하되, <code>-v</code> 플래그를 통해 마운트할 볼륨을 지정해준다. 여기선 named volume을 사용하고, 이를 <code>/etc/todos</code>에 마운트 해주었다. 이를 통해 해당 경로에 있는 모든 파일들이 캡처된다.</p>
</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
</code></pre>
<ol start="4">
<li>애플리케이션을 실행하여 적절히 데이터가 생성 / 변경 / 유지되는지 확인한다.</li>
</ol>
<img src="https://docs.docker.com/get-started/images/items-added.png"/>
<ol start="5">
<li>2 ~ 4번을 다시 수행하면서, 컨테이너를 재실행시키더라도 데이터가 여전히 유지되는지 확인한다.</li>
</ol>
<blockquote>
<p><strong>참고</strong> : Docker에서는 기본적으로 named volume과 bind mounts(추후 설명)를 볼륨으로 제공하지만, NFS, SFTP, NetApp 등 수많은 볼륨 드라이버 플러그인들이 존재한다. 이는 Swarm, Kubernetes 등의 클러스터 환경을 통해 여러 호스트에서 컨테이너를 실행한다면 특히 중요하다.</p>
</blockquote>
<h2 id="볼륨-파헤치기"><a class="header" href="#볼륨-파헤치기">볼륨 파헤치기</a></h2>
<p>종종, &quot;<em>Named volume을 사용할 때, Docker는 실제로 어디에 데이터를 저장하는 걸까?</em>&quot;하는 물음이 들 수 있다. 이를 확인하고 싶다면, <code>docker volume inspect</code> 명령을 사용해보자.</p>
<pre><code class="language-bash">docker volume inspect todo-db
[
    {
        &quot;CreatedAt&quot;: &quot;2019-09-26T02:18:36Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;,
        &quot;Name&quot;: &quot;todo-db&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<p><code>Mountpoint</code>가 바로 데이터가 저장되는 디스크의 실제 위치다. 대부분의 머신에서는 해당 디렉토리에 접근하기 위해 루트 엑세스 권한이 요구된다.</p>
<blockquote>
<p><strong>Docker Desktop의 경우</strong> : Docker Desktop을 실행하는 동안, Docker 명령은 실제로는 호스트 머신 내의 작은 VM 내에서 실행된다. 이 경우 <code>Mountpoint</code> 디렉토리 내의 실제 파일들을 확인하려고 한다면, 먼저 VM 내부로 들어가야 한다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>이전 챕터에서, DB 내의 데이터를 보존하기 위한 <strong>named volume</strong>에 대해서 이야기했다. Named volume은 어디에 데이터를 저장하는지에 대해서는 신경쓰지 않기 때문에, 단순히 데이터를 저장하기 위한 용도로는 충분하다.</p>
<p><strong>Bind mounts</strong>를 사용한다면, 우리가 직접 호스트의 정확한 &quot;mountpoint&quot;를 조작할 수 있다. Bind Mounts는 데이터를 보존하기 위해 사용할 수도 있지만, 컨테이너에 추가적인 데이터를 제공해야 하는 경우에 쓰이는 경우가 많다. 애플리케이션 개발 단계에서 Bind Mounts를 사용하면 소스 코드를 컨테이너에 마운트하여 코드 변경 사항을 확인하고, 즉각적인 변경 사항을 확인할 수 있다.</p>
<p><a href="https://npmjs.com/package/nodemon">nodemon</a>은 NodeJS 애플리케이션에서 변경 사항을 파악하고, 재실행 시켜주는 툴이다. NodeJS 외의 언어 및 프레임워크에서는 다른 적합한 툴들이 존재할 것이다.</p>
<h2 id="볼륨-타입-비교"><a class="header" href="#볼륨-타입-비교">볼륨 타입 비교</a></h2>
<p>Bind mounts 와 Named volumes는 Docker 엔진에서 제공되는 두가지 타입의 볼륨이다. 다른 경우에 제공되는 추가적인 볼륨 드라이버를 사용할 수도 있다.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Named Volumes</th><th>Bind Mounts</th></tr></thead><tbody>
<tr><td>호스트 위치</td><td>Docker가 정함</td><td>직접 정함</td></tr>
<tr><td>마운트 예시 (<code>-v</code> 플래그)</td><td><code>my-volume:/usr/local/data</code></td><td><code>/path/to/data:/usr/local/data</code></td></tr>
<tr><td>새 볼륨을 컨테이너 컨텐츠로 채움</td><td>예</td><td>아니오</td></tr>
<tr><td>볼륨 드라이버 지원</td><td>예</td><td>아니오</td></tr>
</tbody></table>
</div>
<h2 id="dev-모드-컨테이너-실행"><a class="header" href="#dev-모드-컨테이너-실행">Dev 모드 컨테이너 실행</a></h2>
<p>컨테이너가 개발 워크플로우를 지원하도록 하기 위해서, 아래의 사항을 수행해야 한다.</p>
<ul>
<li>컨테이너에 소스 코드를 마운트시킨다.</li>
<li>모든 종속성을 설치한다. (<code>dev</code> 종속성 포함)</li>
<li><code>nodemon</code>을 실행하여 파일시스템 변경을 감시한다.</li>
</ul>
<ol>
<li>이전에 실행했던 <code>getting-started</code> 컨테이너를 종료, 제거한다.</li>
<li>아래 명령을 입력한다. 아래쪽에서 해당 명령에 대해 상세히 설명하겠다.</li>
</ol>
<pre><code class="language-bash">docker run -dp 3000:3000 \
    -w /app -v &quot;(pwd):/app&quot; \
    node:12-alpine \
    sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<p>PowerShell을 사용한다면 아래 명령을 사용해야 한다.</p>
<pre><code class="language-shell">docker run -dp 3000:3000 `
    -w /app -v &quot;(pwd):/app&quot; `
    node:12-alpine `
    sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ul>
<li><code>-dp 3000:3000</code> - 포트 매핑 및 백그라운드 모드 (이전에 언급한 것과 같다.)</li>
<li><code>-w /app</code> - 작업 디렉토리, 혹은 명령이 실행될 디렉토리를 지정</li>
<li><code>-v &quot;(pwd):/app&quot;</code> - 호스트의 현재 디렉토리(<code>pwd</code>)를 컨테이너의 <code>/app</code> 디렉토리와 <strong>bind mount</strong>시킴</li>
<li><code>node:12-alpine</code> - 사용할 이미지. Dockerfile 내의 Base 이미지를 사용.</li>
<li><code>sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;</code> - 명령어. <code>sh</code>를 통해서 셸을 실행하고(alpine은 <code>bash</code>를 갖고있지 않다.) <code>yarn install</code>을 실행하여 모든 종속성을 설치한 뒤 <code>yarn run dev</code>로 개발 모드로 실행한다.</li>
</ul>
<ol start="3">
<li><code>docker logs -f &lt;container-id&gt;</code>를 통해 로그를 확인할 수 있다.</li>
</ol>
<pre><code class="language-bash"> docker logs -f &lt;container-id&gt;
  nodemon src/index.js
 [nodemon] 1.19.2
 [nodemon] to restart at any time, enter `rs`
 [nodemon] watching dir(s): *.*
 [nodemon] starting `node src/index.js`
 Using sqlite database at /etc/todos/todo.db
 Listening on port 3000
</code></pre>
<ol start="4">
<li>이제, 애플리케이션에 변경을 적용해보자. <code>src/static/js/app.js</code> 파일에서 텍스트를 간단하게 변경해보겠다.</li>
</ol>
<pre><code> -                         {submitting ? 'Adding...' : 'Add Item'}
 +                         {submitting ? 'Adding...' : 'Add'}
</code></pre>
<ol start="5">
<li>브라우저가 변경을 감지하고 페이지를 새로고침하는 것을 확인할 수 있다.</li>
</ol>
<img src="https://docs.docker.com/get-started/images/updated-add-button.png" />
<ol start="6">
<li>모든 작업이 끝났다면, 컨테이너를 정지시키고 <code>docker build -t getting-started .</code> 명령을 통해 새로운 이미지를 빌드한다.</li>
</ol>
<p>bind mounts의 이용은 로컬 개발 환경에서 매우 일반적으로 사용된다. 호스트 머신에서 별도로 빌드 툴과 환경을 설치하지 않아도 된다는 장점이 있다. 덕분에 단순히 <code>docker run</code> 커맨드를 실행함으로써 개발 환경이 구축되고, 곧바로 개발에 돌입할 수 있다.</p>
<p>추후에 <strong>Docker Compose</strong>에 대해 이야기할텐데, 이를 사용하면 앞서 사용했던 명령들을 훨씬 간단하게 처리할 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p>이전 챕터까지는 모두 단일 컨테이너 애플리케이션을 다루었다. 자, 이제 MySQL과 같이 별도의 애플리케이션 스택을 추가하려고 한다. 종종 다음과 같은 물음이 생긴다. - &quot;어디서 MySQL을 구동해야 할까? 똑같은 컨테이너 내에서 설치되어야 하나, 아니면 따로 실행되어야 하나?&quot; 일반적으로, <strong>각각의 컨테이너는 한 가지 일만을 수행하고, 그것이 잘 이루어져야 한다.</strong> 이유는 다음과 같다.</p>
<ul>
<li>DB 외에 API 및 프론트엔드를 확장해야 할 가능성이 높다.</li>
<li>별도의 컨테이너를 통한 버저닝이 수월하다.</li>
<li>로컬에서 데이터베이스에 대한 컨테이너를 사용할 수도 있는 한편, 프로덕션 상에 운영 중인 데이터베이스에 대해 관리되는 서비스를 사용하고 싶을수도 있다.</li>
<li>여러 프로세스를 실행하려면 별도의 프로세스 매니저가 요구된다. (컨테이너는 하나의 프로세스만을 실행한다.) 따라서 컨테이너의 시작 / 종료에 복잡성을 가중시킨다.</li>
</ul>
<p>그 외에도 여러 이유가 있으며, 결국 우리는 아래와 같은 형태로 애플리케이션을 업데이트하려고 한다.</p>
<img src="https://docs.docker.com/get-started/images/multi-app-architecture.png"/>
<h2 id="컨테이너-네트워킹"><a class="header" href="#컨테이너-네트워킹">컨테이너 네트워킹</a></h2>
<p>기본적으로, 컨테이너는 격리된 환경에서 실행되며, 동일한 머신 내의 다른 프로세스나 컨테이너에 대해서는 아무것도 알지 못한다는 점을 기억하라. 그렇다면, 어떻게 컨테이너 상호 간의 소통을 주도할 수 있을까? 정답은 <strong>Networking</strong>이다. <strong>두 컨테이너가 같은 네트워크 상에 있다면, 컨테이너 간에 상호작용을 할 수 있다. 그렇지 않다면, 불가능하다.</strong></p>
<h2 id="mysql-실행"><a class="header" href="#mysql-실행">MySQL 실행</a></h2>
<p>컨테이너를 네트워크에 포함시키기 위한 두가지 방법이 있다. <strong>1) 실행 시점에 할당시키거나</strong>, <strong>2) 기존 컨테이너에 연결한다.</strong> 먼저, 네트워크를 생성하고 MySQL 컨테이너를 해당 네트워크에 첨부해보자.</p>
<ol>
<li>네트워크를 생성한다.</li>
</ol>
<pre><code class="language-bash">docker network create todo-app
</code></pre>
<ol start="2">
<li>MySQL 컨테이너를 실행하고 네트워크에 첨부한다. 데이터베이스를 초기화하기 위해서 환경 변수를 지정해주어야 한다.</li>
</ol>
<pre><code class="language-bash"> docker run -d \
     --network todo-app --network-alias mysql \
     -v todo-mysql-data:/var/lib/mysql \
     -e MYSQL_ROOT_PASSWORD=secret \
     -e MYSQL_DATABASE=todos \
     mysql:5.7
</code></pre>
<p>PowerShell을 이용한다면 아래 명령을 사용하자.</p>
<pre><code class="language-shell"> docker run -d `
     --network todo-app --network-alias mysql `
     -v todo-mysql-data:/var/lib/mysql `
     -e MYSQL_ROOT_PASSWORD=secret `
     -e MYSQL_DATABASE=todos `
     mysql:5.7
</code></pre>
<p>위에서 <code>--network-alias</code> 플래그를 지정한 것을 볼 수 있는데, 이에 대해서는 아래쪽에서 다루도록 하자.</p>
<blockquote>
<p><strong>유의</strong> : 위에서 <code>todo-mysql-data</code>로 볼륨명을 지정하고, <code>/var/lib/mysql</code>에 마운트한 것을 확인할 수 있는데, 이는 MySQL이 데이터를 저장하는 디렉토리이다. 헌데, 이 후 <code>docker volume create</code> 명령을 수행하지는 않는다. Docker가 Named volume의 사용을 인지하고 자동으로 볼륨을 생성해주기 때문이다.</p>
</blockquote>
<ol start="3">
<li>이후 데이터베이스를 실행하고, 연결한 후에 제대로 연결되었는지를 확인해보자.</li>
</ol>
<pre><code class="language-bash">docker exec -it &lt;mysql-container-id&gt; mysql -u root -p
</code></pre>
<p>패스워드 프롬프트가 뜨면, 패스워드를 입력한다. 이후 MySQL 셸에서 데이터베이스를 리스트하고 <code>todos</code> 데이터베이스를 확인하자.</p>
<pre><code class="language-bash">mysql&gt; SHOW DATABASES;
</code></pre>
<p>이제 아래와 같은 결과가 보일 것이다.</p>
<pre><code class="language-bash"> +--------------------+
 | Database           |
 +--------------------+
 | information_schema |
 | mysql              |
 | performance_schema |
 | sys                |
 | todos              |
 +--------------------+
 5 rows in set (0.00 sec)
</code></pre>
<p>여기까지가 <code>todos</code> 데이터베이스를 만드는 과정이었다.</p>
<h2 id="mysql에-연결"><a class="header" href="#mysql에-연결">MySQL에 연결</a></h2>
<p>이제 MySQL에 DB를 구성했고, 이제 사용하기만 하면 된다. 문제는 이를 어떻게 사용하느냐인데, 동일한 네트워크에서 다른 컨테이너들을 어떻게 찾아낼 수 있을까?</p>
<p>이를 확인하기 위해서 <a href="https://github.com/nicolaka/netshoot">nicolaka/netshoot</a> 컨테이너를 사용한다. 해당 컨테이너는 네트워킹 이슈에 대한 트러블 슈팅 혹은 디버깅에 유용한 수많은 툴을 제공한다.</p>
<ol>
<li>nicolaka/netshoot 이미지를 사용하여 새로운 컨테이너를 실행한다. 기존에 생성한 것과 동일한 네트워크에 연결하는 것임을 확인하자.</li>
</ol>
<pre><code class="language-bash">docker run -it --network todo-app nicolaka/netshoot
</code></pre>
<ol start="2">
<li>컨테이너 내에서 <code>dig</code> 명령을 사용하는데, 이는 유용한 DNS 툴이다. 아래 명령으로 <code>mysql</code>이라는 호스트네임에 대한 IP 주소를 찾을 수 있다.</li>
</ol>
<pre><code class="language-bash">dig mysql
</code></pre>
<p>그리고 그 결과는 아래처럼 나타난다.</p>
<pre><code class="language-bash"> ; &lt;&lt;&gt;&gt; DiG 9.14.1 &lt;&lt;&gt;&gt; mysql
 ;; global options: +cmd
 ;; Got answer:
 ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32162
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;mysql.				IN	A

 ;; ANSWER SECTION:
 mysql.			600	IN	A	172.23.0.2

 ;; Query time: 0 msec
 ;; SERVER: 127.0.0.11#53(127.0.0.11)
 ;; WHEN: Tue Oct 01 23:47:24 UTC 2019
 ;; MSG SIZE  rcvd: 44
</code></pre>
<p><code>ANSWER SECTION</code> 부분에서 <code>mysql</code>의 <code>A</code> 레코드가 <code>172.23.0.2</code>로 지정되어 있음을 확인할 수 있다. (환경에 따라 IP 주소는 달라질 수 있다.) <code>mysql</code>은 일반적으로 타당한 호스트네임이 아니지만, Docker는 network alias를 보유한 컨테이너의 IP 주소를 사용함으로써 이를 처리했다. (앞서 <code>--network-alias</code> 플래그를 사용했던 것을 기억하자.)</p>
<p>그 결과, 이제 애플리케이션은 <code>mysql</code>이라는 이름의 호스트에 연결하기만 하면, 데이터베이스와 상호작용할 수 있게 된다.</p>
<h2 id="mysql과-함께-애플리케이션-구동"><a class="header" href="#mysql과-함께-애플리케이션-구동">MySQL과 함께 애플리케이션 구동</a></h2>
<p>이제 TODO 앱은 MySQL과 연결하기 위해 몇가지 환경 변수 설정이 필요하다.</p>
<ul>
<li><code>MYSQL_HOST</code></li>
<li><code>MYSQL_USER</code></li>
<li><code>MYSQL_PASSWORD</code></li>
<li><code>MYSQL_DDB</code></li>
</ul>
<blockquote>
<p><strong>환경 변수에 대해</strong> : 개발 단계에서 환경 변수를 사용하는 것은 괜찮지만, 애플리케이션이 프로덕션 단계에서 실행되는 경우 환경 변수는 <strong>대부분의 경우 사용하지 말아야 한다.</strong> 그 이유에 대해서는 Docker의 보안 리드 Diogo Monica의 <a href="https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/">블로그 포스트</a>를 참조하자.</p>
<p>보다 안전한 방법은, 컨테이너 오케스트레이션 프레임워크에서 제공하는 Secret Support 기능을 사용하는 것이다. 대부분의 경우 이러한 Secret들은 실행 중인 컨테이너에 파일로 마운트된다. 많은 애플리케이션들이 이를 위해 <code>_FILE</code> 접미사가 붙은 변수들을 지원하는 것을 확인할 수 있다.</p>
<p>예를 들어, 우리가 사용하는 예시 애플리케이션에서는 <code>MYSQL_PASSWORD_FILE</code> 변수를 설정하여 DB를 연결하기 위한 환경변수가 담긴 파일을 참조하도록 할 수 있다. Docker 자체는 별도로 환경 변수를 지원하지 않는다. 애플리케이션 자체적으로 사용할 환경 변수에 대한 파일을 찾아서 사용하도록 구현해야 한다.</p>
</blockquote>
<p>당장에는 환경 변수를 통해서 애플리케이션을 DB에 연결해보자.</p>
<ol>
<li>각각의 환경 변수들을 작성해주고, 컨테이너를 네트워크에 연결해준다.</li>
</ol>
<pre><code class="language-bash"> docker run -dp 3000:3000 \
   -w /app -v &quot;(pwd):/app&quot; \
   --network todo-app \
   -e MYSQL_HOST=mysql \
   -e MYSQL_USER=root \
   -e MYSQL_PASSWORD=secret \
   -e MYSQL_DB=todos \
   node:12-alpine \
   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<p>PowerShell을 사용한다면 아래와 같이 작성한다.</p>
<pre><code class="language-sh"> docker run -dp 3000:3000 `
   -w /app -v &quot;(pwd):/app&quot; `
   --network todo-app `
   -e MYSQL_HOST=mysql `
   -e MYSQL_USER=root `
   -e MYSQL_PASSWORD=secret `
   -e MYSQL_DB=todos `
   node:12-alpine `
   sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ol start="2">
<li>컨테이너 로그를 살펴보면(<code>docker logs &lt;container-id&gt;</code>), 다음과 같이 DB 연결에 성공했음을 나타내는 메시지를 확인할 수 있다.</li>
</ol>
<pre><code class="language-bash"> # Previous log messages omitted
 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05724em;&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1.19.2&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ores&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;an&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02691em;&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hin&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.46528em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;esrc&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05724em;&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.07153em;&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ec&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ba&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nin&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;or&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;3000‘‘‘3.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;브라우저에서애플리케이션을실행하고&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;TO&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;앱을테스트해본다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.4.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;아래명령을통해&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;데이터베이스에연결하고&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;데이터가적절하게저장되었는지를확인하자&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.‘‘‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ba&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;oc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ere&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ec&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69862em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.74285em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ain&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.73354em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;pt&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘‘‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;셸상에서아래와같이작성하고&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;결과를확인한다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.‘‘‘&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ba&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hm&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ys&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;ql&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;se&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ec&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ro&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.31166399999999994em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathnormal mtight&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;nam&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.01968em;&quot;&gt;pl&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;906&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;ff&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;08&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;44&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;49&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;0853&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;85∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ama&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.04398em;&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hin&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣0∣∣2912&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;79&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;8486&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.77777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;460793&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;575&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.05017em;&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02691em;&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;eso&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣0∣&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.66666em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;‘‘‘&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;현재&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;Doc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;대쉬보드를확인해본다면&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;두개의앱컨테이너가작동하고있음을확인할수있다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;하지만&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;두컨테이너가하나의애플리케이션을위해그룹화되어있음을확인할수는없다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord hangul_fallback&quot;&gt;이를개선할방법에에대해서는이후챕터에서알아보겠다&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.85396em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ttp&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ocs&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;oc&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03148em;&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ima&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;es&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;hb&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.77777em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;lt&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.74285em;vertical-align:-0.08333em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;co&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;ain&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.02778em;&quot;&gt;er&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&amp;quot;/&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<p><a href="https://docs.docker.com/compose/">Docker Compose</a>는 멀티 컨테이너 애플리케이션을 정의하고 공유하는 것을 돕고자 개발된 툴이다. Compose를 사용하면, YAML 파일을 생성하여 서비스를 정의한 후, 단일 명령을 통해 애플리케이션을 구축하거나 분해할 수 있다.</p>
<p>Compose를 사용할 경우의 큰 이점은 바로 애플리케이션 스택을 하나의 파일로 정의할 수 있다는 점이다. 해당 파일은 프로젝트 저장소의 루트에 저장되며, 다른 이들이 이를 보고 프로젝트에 쉽게 기여할 수 있게 해준다. 그런 경우가 아니더라도, 단순히 repo를 클론하여 애플리케이션을 실행하기만 하면 된다는 점에서 편리하다. 이는 Github/GitLab 등에서 이루어지는 것과 유사하다.</p>
<h2 id="docker-compose-설치"><a class="header" href="#docker-compose-설치">Docker Compose 설치</a></h2>
<p>Windows나 Mac에서 Docker Desktop/Toolbox를 설치했다면, 이미 Docker Compose가 포함되어 있다. &quot;Play-with-Docker&quot; 인스턴스 역시 Docker Compose가 설치되어 있으며, Linux 머신을 사용하는 상황이라면, 별도로 <a href="https://docs.docker.com/compose/install/">설치</a>해주어야 한다.</p>
<p>설치 이후, 아래 명령을 통해 버전 정보를 확인해보자.</p>
<pre><code>docker-compose version
</code></pre>
<h2 id="compose-파일-생성"><a class="header" href="#compose-파일-생성">Compose 파일 생성</a></h2>
<ol>
<li>
<p>프로젝트 루트에서, <code>docker-compose.yml</code> 이라는 이름의 파일을 생성한다.</p>
</li>
<li>
<p>해당 파일에서, 우선 schema 버전을 정의하는 것부터 시작하자. 대부분의 경우에는 최신 지원 버전을 사용하는 것이 좋다. 현재 schema 버전에서 가능한 Compose file의 <a href="https://docs.docker.com/compose/compose-file/">레퍼런스</a>에 대해 확인하자.</p>
</li>
</ol>
<pre><code class="language-yaml">version: '3.7'
</code></pre>
<ol start="3">
<li>이후, 애플리케이션에 사용할 각각의 서비스(컨테이너)를 정의해준다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
</code></pre>
<h2 id="앱-서비스-정의"><a class="header" href="#앱-서비스-정의">앱 서비스 정의</a></h2>
<p>이전 챕터에서 우리는 앱 컨테이너를 정의하기 위해 아래와 같은 명령을 실행했다.</p>
<pre><code class="language-bash">docker run -dp 3000:3000 \
  -w /app -v &quot;(pwd):/app&quot; \
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:12-alpine \
  sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<p>PowerShell의 경우</p>
<pre><code class="language-sh">docker run -dp 3000:3000 `
  -w /app -v &quot;(pwd):/app&quot; `
  --network todo-app `
  -e MYSQL_HOST=mysql `
  -e MYSQL_USER=root `
  -e MYSQL_PASSWORD=secret `
  -e MYSQL_DB=todos `
  node:12-alpine `
  sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ol>
<li>먼저, 컨테이너에 사용할 서비스 엔트리와 이미지를 정의한다. 서비스에는 어떤 이름이든 쓰여도 된다(여기에서는 <code>app</code>). 여기서의 이름은 자동으로 network alias가 되며, 이후 다른 서비스에서 해당 서비스를 활용할 때 유용하다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
</code></pre>
<ol start="2">
<li>일반적으로 <code>command</code> 항목을 <code>image</code> 가까이에 정의하긴 하지만, 별도로 순서에 대한 요구 사항은 없다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
</code></pre>
<ol start="3">
<li>서비스의 <code>ports</code>를 정의해준다. (<code>-p 3000:3000</code>) 이 부분에서는 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-1">짧게</a> 작성할 수도 있고, 좀 더 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#long-syntax-1">길게</a> 구체적으로 작성할 수도 있다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
</code></pre>
<ol start="4">
<li>이제 <code>working_dir</code>과 <code>volumes</code> 항목을 통해 작업 디렉토리(<code>-w /app</code>)와 볼륨 매핑(<code>-v &quot;(pwd):/app&quot;</code>)를 정의한다. 볼륨 역시 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#short-syntax-3">짧게</a> 혹은 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#long-syntax-3">길게</a> 작성될 수 있다.</li>
</ol>
<p>Docker Compose를 통해 볼륨을 정의하는 경우, 현재 디렉토리에서의 상대 경로를 사용할 수 있다는 장점이 있다.</p>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
</code></pre>
<ol start="5">
<li>마지막으로, 사용하는 환경 변수를 <code>environment</code> 항목에서 지정해준다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos
</code></pre>
<h2 id="mysql-서비스-정의"><a class="header" href="#mysql-서비스-정의">MySQL 서비스 정의</a></h2>
<p>자, 이제 MySQL 서비스에 대해 정의해보자. 앞서 아래와 같은 명령을 통해 MySQL 컨테이너를 실행했다.</p>
<pre><code class="language-bash">docker run -d \
  --network todo-app --network-alias mysql \
  -v todo-mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  -e MYSQL_DATABASE=todos \
  mysql:5.7
</code></pre>
<p>PowerShell을 사용한다면</p>
<pre><code class="language-sh">docker run -d `
  --network todo-app --network-alias mysql `
  -v todo-mysql-data:/var/lib/mysql `
  -e MYSQL_ROOT_PASSWORD=secret `
  -e MYSQL_DATABASE=todos `
  mysql:5.7
</code></pre>
<ol>
<li>먼저 새로운 서비스를 정의하고 <code>mysql</code>로 이름짓는다. 이를 통해 자동으로 network alias를 갖게 된다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    # The app service definition
  mysql:
    image: mysql:5.7
</code></pre>
<ol start="2">
<li>다음으로, 볼륨 매핑을 정의한다. 기존에는 <code>docker run</code>을 통해 컨테이너를 실행하게 되면, named volume이 알아서 생성되었지만, Compose를 사용하는 경우에는 그렇지 않다. 최상단의 <code>volumes:</code> 항목에서 직접 볼륨을 정의하고, <code>services:</code> 의 각 항목 내에서 mountpoint를 지정해주어야 한다. 단순히 볼륨 네임만을 정의한다면 기본 옵션값들이 사용된다. 추가 옵션들에 대해서는 <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#volume-configuration-reference">여기</a>를 참조하자.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    # The app service definition
  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql

volumes:
  todo-mysql-data:
</code></pre>
<ol start="3">
<li>마지막으로, 환경 변수들을 정의해준다.</li>
</ol>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    # The app service definition
  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
</code></pre>
<p>최종적으로, 작성한 <code>docker-compose.yml</code>파일은 아래와 같은 형태가 된다.</p>
<pre><code class="language-yaml">version: '3.7'

services:
  app:
    image: node:12-alpine
    command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot;
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
</code></pre>
<h2 id="애플리케이션-스택-실행"><a class="header" href="#애플리케이션-스택-실행">애플리케이션 스택 실행</a></h2>
<p><code>docker-compose.yml</code> 파일을 갖고 있다면, 이제 애플리케이션들을 실행할 수 있다.</p>
<ol>
<li>
<p>기존에 실행 중인 app 혹은 db가 없는지 확인한다. (<code>docker ps</code>와 <code>docker rm -f &lt;ids&gt;</code> 사용)</p>
</li>
<li>
<p><code>docker-compose up</code>을 통해 애플리케이션 스택을 실행한다. <code>-d</code> 플래그를 통해 모든 스택들을 백그라운드 모드에서 실행한다.</p>
</li>
</ol>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<p>명령 이후 아래와 같은 진행사항들이 출력된다.</p>
<pre><code class="language-bash">Creating network &quot;app_default&quot; with the default driver
Creating volume &quot;app_todo-mysql-data&quot; with default driver
Creating app_app_1   ... done
Creating app_mysql_1 ... done
</code></pre>
<p>네트워크와 볼륨들이 생성되는 것을 확인할 수 있다. 기본적으로, Docker Compose는 애플리케이션 스택 상에 정의된 네트워크를 생성한다. (별도로 compose 파일 내에서 네트워크를 정의하지 않은 이유다.)</p>
<ol start="3">
<li><code>docker-compose logs -f</code> 명령을 통해 로그를 확인할 수 있다. 각각의 서비스에서의 로그가 단일 스트림으로 인터리빙된것을 볼 수 있다. 이는 타이밍 관련 이슈들을 탐지하고자 하는 경우에 굉장히 유용하다. <code>-f</code> 플래그는 로그를 &quot;팔로우&quot;할 것을 의미하며, 실시간으로 재생되는 로그들을 제공받는다.</li>
</ol>
<pre><code>mysql_1  | 2019-10-03T03:07:16.083639Z 0 [Note] mysqld: ready for connections.
mysql_1  | Version: '5.7.27'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server (GPL)
app_1    | Connected to mysql db at host mysql
app_1    | Listening on port 3000
</code></pre>
<p>서비스 네임이 각 줄의 <code>|</code> 좌측에 출력되며, 만약 특정 서비스에 대한 로그만을 확인하고자 한다면, 로그 명령 끝에 원하는 서비스네임을 추가해주면 된다.</p>
<pre><code>docker-compose logs -f app
</code></pre>
<blockquote>
<p><strong>DB 실행 이후 App이 실행되도록 하기</strong> : Docker는 다른 컴포넌트가 완전히 구동되고 준비될 때까지 기다리도록 하는 내장 지원 기능이 별도로 없다. Node 기반의 프로젝트에서는 이를 위해 <a href="https://github.com/dwmkerr/wait-port">wait-port</a> 라이브러리를 사용할 수 있다. 다른 프레임워크 및 언어에 대해서도 유사한 것들이 존재한다.</p>
</blockquote>
<ol start="4">
<li>이제 애플리케이션을 직접 열어 확인해보자.</li>
</ol>
<h2 id="대쉬보드에서-애플리케이션-스택-확인"><a class="header" href="#대쉬보드에서-애플리케이션-스택-확인">대쉬보드에서 애플리케이션 스택 확인</a></h2>
<p>Docker 대쉬보드를 살펴보면 <code>app</code>이라는 이름으로 그룹이 생성되었음을 확인할 수 있다. 이는 Docker Compose에서 작성된 프로젝트 네임으로, 기본값으로 <code>docker-compose.yml</code>이 위치한 디렉토리의 이름이 사용된다.</p>
<img src="https://docs.docker.com/get-started/images/dashboard-app-project-collapsed.png" />
<p>애플리케이션 스택을 살펴보면, 앞서 compose 파일을 통해 정의한 두 컨테이너를 확인할 수 있다. 이들은 <code>&lt;project-name&gt;_&lt;service-name&gt;_&lt;replica-number&gt;</code>의 패턴을 따른다.</p>
<img src="https://docs.docker.com/get-started/images/dashboard-app-project-expanded.png" />
<h2 id="종료-및-제거"><a class="header" href="#종료-및-제거">종료 및 제거</a></h2>
<p><code>docker-compose down</code>을 명령하거나 대쉬보드 상에서 휴지통 아이콘을 클릭하면 앱 스택을 종료할 수 있다. 관련된 모든 컨테이너들이 중지되고, 네트워크는 삭제된다.</p>
<blockquote>
<p><strong>주의</strong> : 기본적으로 compose 파일에서 정의된 named volume들은 <code>docker-compose down</code> 명령으로 제거되지 않는다. 볼륨들도 제거하고자 하는 경우, <code>--volumes</code> 플래그를 추가해주어야 한다.</p>
<p>Docker 대쉬보드에서도 마찬가지로 애플리케이션 스택을 제거할 때 볼륨은 제거하지 않는다.</p>
</blockquote>
<p>앱 스택을 제거 한 이후, 다른 프로젝트를 작업할 때도 단순히 <code>docker-compose up</code>를 실행하기만 하면 된다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h2 id="보안-스캐닝"><a class="header" href="#보안-스캐닝">보안 스캐닝</a></h2>
<p>이미지를 빌드하고 나서, <code>docker scan</code> 명령으로 보안 취약점을 탐색하는 것이 좋다. Docker는 <a href="http://snyk.io/">Snyk</a>과 파트너쉽을 보유하여 취약점 탐색 서비스를 제공한다.</p>
<p>예를 들어, <code>getting-started</code> 이미지에 대한 스캐닝을 진행해보자.</p>
<pre><code class="language-bash">docker scan getting-started
</code></pre>
<p>스캔은 지속적으로 업데이트되는 취약점 데이터베이스를 활용하기 때문에, 아래와 같이 표시되는 출력은 상황에 따라 달라질 수 있다.</p>
<pre><code>✗ Low severity vulnerability found in freetype/freetype
  Description: CVE-2020-15999
  Info: https://snyk.io/vuln/SNYK-ALPINE310-FREETYPE-1019641
  Introduced through: freetype/freetype@2.10.0-r0, gd/libgd@2.2.5-r2
  From: freetype/freetype@2.10.0-r0
  From: gd/libgd@2.2.5-r2 &gt; freetype/freetype@2.10.0-r0
  Fixed in: 2.10.0-r1

✗ Medium severity vulnerability found in libxml2/libxml2
  Description: Out-of-bounds Read
  Info: https://snyk.io/vuln/SNYK-ALPINE310-LIBXML2-674791
  Introduced through: libxml2/libxml2@2.9.9-r3, libxslt/libxslt@1.1.33-r3, nginx-module-xslt/nginx-module-xslt@1.17.9-r1
  From: libxml2/libxml2@2.9.9-r3
  From: libxslt/libxslt@1.1.33-r3 &gt; libxml2/libxml2@2.9.9-r3
  From: nginx-module-xslt/nginx-module-xslt@1.17.9-r1 &gt; libxml2/libxml2@2.9.9-r3
  Fixed in: 2.9.9-r4
</code></pre>
<p>출력에는 취약점의 타입을 나열하고, 이와 관련된 URL을 보여주며, 취약점을 고치기 위한 최근 라이브러리 버전 등을 제공해준다.</p>
<p><a href="https://docs.docker.com/engine/scan/">Docker scan 문서</a>에서 더 많은 옵션들에 대한 사항을 살펴볼 수 있다.</p>
<p>CLI 외에도, Docker Hub 설정을 통해 새롭게 푸쉬된 이미지들에 대해서 스캐닝을 진행할 수도 있다.</p>
<img src="https://docs.docker.com/get-started/images/hvs.png" />
<h2 id="이미지-레이어링"><a class="header" href="#이미지-레이어링">이미지 레이어링</a></h2>
<p>한 이미지가 어떻게 구성되어 있는지 확인하려면 어떻게 해야할까? <code>docker image history</code> 명령을 사용하면, 하나의 이미지를 구성하기 위해 생성된 여러 레이어들에 대한 명령어들을 확인할 수 있다.</p>
<ol>
<li><code>docker image history</code> 명령을 사용하면 이전 챕터에서 만들었던 <code>getting-started</code> 이미지에 대한 레이어들을 확인할 수 있다.</li>
</ol>
<pre><code>docker image history getting-started
</code></pre>
<p>결과는 아래와 같은 형태일 것이다.</p>
<pre><code> IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
 a78a40cbf866        18 seconds ago      /bin/sh -c #(nop)  CMD [&quot;node&quot; &quot;src/index.j…    0B
 f1d1808565d6        19 seconds ago      /bin/sh -c yarn install --production            85.4MB
 a2c054d14948        36 seconds ago      /bin/sh -c #(nop) COPY dir:5dc710ad87c789593…   198kB
 9577ae713121        37 seconds ago      /bin/sh -c #(nop) WORKDIR /app                  0B
 b95baba1cfdb        13 days ago         /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;docker-entry…   0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B
 &lt;missing&gt;           13 days ago         /bin/sh -c apk add --no-cache --virtual .bui…   5.35MB
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.21.1      0B
 &lt;missing&gt;           13 days ago         /bin/sh -c addgroup -g 1000 node     &amp;&amp; addu…   74.3MB
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV NODE_VERSION=12.14.1     0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B
 &lt;missing&gt;           13 days ago         /bin/sh -c #(nop) ADD file:e69d441d729412d24…   5.59MB
</code></pre>
<p>각각의 한줄은 이미지 내 하나의 레이어들을 나타낸다. 최근의 레이어일수록 상단에 위치한다. 이를 통해, 각각의 레이어 사이즈를 찾아볼 수 있고, 큰 이미지들을 진단하는데에 도움이 된다.</p>
<ol start="2">
<li>위에서, 여러 줄들이 결과 출력에서 잘린 것을 볼 수 있는데, <code>--no-trunc</code> 플래그를 추가해서 전체 출력을 표시할 수 있다.</li>
</ol>
<pre><code class="language-bash">docker image history --no-trunc getting-started
</code></pre>
<h2 id="레이어-캐싱"><a class="header" href="#레이어-캐싱">레이어 캐싱</a></h2>
<p>레이어가 동작하는 방식을 살펴봤으니, 이제 컨테이너 이미지를 빌드하는데에 걸리는 시간을 줄이기 위한 방법에 대해 살펴보자.</p>
<p><strong><em>일단 하나의 레이어가 변경된다면, 해당 레이어의 다운스트림 레이어들도 모두 재생성되어야 한다.</em></strong></p>
<p>기존에 작성했던 Dockerfile을 다시 살펴보자.</p>
<pre><code># syntax=docker/dockerfile:1
FROM node:12-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD [&quot;node&quot;, &quot;src/index.js&quot;]
</code></pre>
<p>이미지 히스토리에서 살펴본 것처럼, Dockerfile 내의 각각의 명령어들이 이미지 내 레이어가 되는 것을 볼 수 있다. 아마, 이미지에 어떤 변화가 발생하면 모든 yarn 종속성들이 전부 새로 설치되는 것을 확인할 수 있을 것이다. 빌드할 때마다 매번 동일한 종속성들을 설치하는게 적절해보이진 않는다. 이를 보완하려면 어떻게 해야할까?</p>
<p>이를 보완하기 위해서는, Dockerfile이 종속성 캐싱을 지원하도록 수정해야한다. Node 기반의 애플리케이션의 경우, 종속성들은 <code>package.json</code> 파일에 정의된다. 만약 우리가 처음 한번만 <code>package.json</code> 파일을 복사하고, 종속성을 설치한 후, 그 다음에 다른 것들을 복사하는 형태로 진행한다면 어떨까? 그렇다면 <code>package.json</code>에 변경이 있을 때에만 yarn 종속성이 재설치되도록 할 수 있을 것이다.</p>
<ol>
<li>Dockerfile에 가장 먼저 <code>package.json</code>을 복사하도록 수정한다. 이후 종속성을 설치하고, 그 다음에 나머지 모두를 복사한다.</li>
</ol>
<pre><code class="language-dockerfile"> # syntax=docker/dockerfile:1
 FROM node:12-alpine
 WORKDIR /app
 COPY package.json yarn.lock ./
 RUN yarn install --production
 COPY . .
 CMD [&quot;node&quot;, &quot;src/index.js&quot;]
</code></pre>
<ol start="2">
<li>동일한 폴더에 <code>.dockerignore</code> 라는 이름의 파일을 생성하고 아래의 내용을 작성한다.</li>
</ol>
<pre><code>node_modules
</code></pre>
<p><code>.dockerignore</code> 파일은 이미지와 관련된 파일만을 선택적으로 복사하기 위한 쉬운 방법이다. <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">여기</a>에서 더 많은 정보를 찾아볼 수 있다. 위 경우에서는, <code>node_modules</code> 폴더가 이미지에 추가될 필요가 없으므로 제외시켰다. 어차피 <code>RUN</code> 명령 단계를 통해 종속성이 설치되기 때문이다. <a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/">여기 문서</a>를 통해 NodeJS 애플리케이션을 도커라이징하는데 있어서 추천되는 디테일 사항에 대해 살펴볼 수 있다.</p>
<ol start="3">
<li><code>docker build</code>를 통해 새로운 이미지를 빌드한다.</li>
</ol>
<pre><code>docker build -t getting-started .
</code></pre>
<p>그러면 아래와 같은 결과가 나타날 것이다.</p>
<pre><code>Sending build context to Docker daemon  219.1kB
Step 1/6 : FROM node:12-alpine
---&gt; b0dc3a5e5e9e
Step 2/6 : WORKDIR /app
---&gt; Using cache
---&gt; 9577ae713121
Step 3/6 : COPY package.json yarn.lock ./
---&gt; bd5306f49fc8
Step 4/6 : RUN yarn install --production
---&gt; Running in d53a06c9e4c2
yarn install v1.17.3
[1/4] Resolving packages...
[2/4] Fetching packages...
info fsevents@1.2.9: The platform &quot;linux&quot; is incompatible with this module.
info &quot;fsevents@1.2.9&quot; is an optional dependency and failed compatibility check. Excluding it from installation.
[3/4] Linking dependencies...
[4/4] Building fresh packages...
Done in 10.89s.
Removing intermediate container d53a06c9e4c2
---&gt; 4e68fbc2d704
Step 5/6 : COPY . .
---&gt; a239a11f68d8
Step 6/6 : CMD [&quot;node&quot;, &quot;src/index.js&quot;]
---&gt; Running in 49999f68df8f
Removing intermediate container 49999f68df8f
---&gt; e709c03bc597
Successfully built e709c03bc597
Successfully tagged getting-started:latest
</code></pre>
<p>Dockerfile을 수정했으므로 모든 레이어들이 다시 빌드됨을 확인할 수 있다.</p>
<ol start="4">
<li>
<p>이제, <code>src/static/index.html</code> 상에서 약간의 변경을 해보자.</p>
</li>
<li>
<p>다시 <code>docker build -t getting-started .</code>를 통해 도커 이미지를 빌드한다. 이번에는 결과가 조금 다르게 출력될 것이다.</p>
</li>
</ol>
<pre><code> Sending build context to Docker daemon  219.1kB
 Step 1/6 : FROM node:12-alpine
 ---&gt; b0dc3a5e5e9e
 Step 2/6 : WORKDIR /app
 ---&gt; Using cache
 ---&gt; 9577ae713121
 Step 3/6 : COPY package.json yarn.lock ./
 ---&gt; Using cache
 ---&gt; bd5306f49fc8
 Step 4/6 : RUN yarn install --production
 ---&gt; Using cache
 ---&gt; 4e68fbc2d704
 Step 5/6 : COPY . .
 ---&gt; cccde25a3d9a
 Step 6/6 : CMD [&quot;node&quot;, &quot;src/index.js&quot;]
 ---&gt; Running in 2be75662c150
 Removing intermediate container 2be75662c150
 ---&gt; 458e5c6f080c
 Successfully built 458e5c6f080c
 Successfully tagged getting-started:latest
</code></pre>
<p>빌드 타임이 훨씬 짧아졌음을 확인할 수 있을 것이다. 그리고 위의 1 ~ 4 단계들이 전부 <code>Using cache</code>로 처리된 것을 볼 수 있다.</p>
<h2 id="멀티스테이지-빌드"><a class="header" href="#멀티스테이지-빌드">멀티스테이지 빌드</a></h2>
<p>현재 튜토리얼에서 너무 깊은 내용을 다루진 않겠지만, 멀티스테이지 빌드는 한 이미지를 생성하기 위해 여러 스테이지를 사용하도록 도와주는 유용한 툴이다. 이는 다음과 같은 이점을 제공한다.</p>
<ul>
<li>런타임 종속성과 빌드타임 종속성을 분리한다.</li>
<li>애플리케이션 구동에 오직 필요한 내용만 빌드하여 전반적인 이미지 사이즈를 줄인다.</li>
</ul>
<h3 id="react-예시"><a class="header" href="#react-예시">React 예시</a></h3>
<p>React 애플리케이션을 빌드할 때, JS 코드, SASS, 그 외 정적 파일들을 컴파일하기 위한 Node 환경이 필요하다. (특히 JSX) 만약 SSR을 적용하는 것이 아니라면, 프로덕션 빌드 상에는 굳이 Node 환경이 필요하지 않다. 때문에 아래 예시에서는 정적인 nginx 컨테이너에 정적 리소스들만을 복사해준다.</p>
<pre><code class="language-dockerfile"># syntax=docker/dockerfile:1
FROM node:12 AS build
WORKDIR /app
COPY package* yarn.lock ./
RUN yarn install
COPY public ./public
COPY src ./src
RUN yarn run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
</code></pre>
<p>위에서는 <code>node:12</code> 이미지를 사용해 빌드를 수행한 후, nginx 컨테이너에 그 결과를 복사해넣게끔 해주었다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ssh--secure-shell--secure-socket-shell"><a class="header" href="#ssh--secure-shell--secure-socket-shell">SSH : Secure Shell / Secure Socket Shell</a></h1>
<ul>
<li>참고문서 : <a href="https://medium.com/@Magical_Mudit/understanding-ssh-workflow-66a0e8d4bf65">Understanding SSH workflow</a></li>
</ul>
<h2 id="ssh란-"><a class="header" href="#ssh란-">SSH란 ?</a></h2>
<p>SSH는 관리자들이 원격 컴퓨터에 안전한 방법으로 접근할 수 있게끔 해주는 네트워크 프로토콜이다. SSH는 클라이언트와 서버 간에 보안된 연결을 형성하며, 서로 간에 증명하며 명령어를 전달할 수 있다.</p>
<h2 id="ssh는-어떻게-동작하는가"><a class="header" href="#ssh는-어떻게-동작하는가">SSH는 어떻게 동작하는가?</a></h2>
<p><img src="https://www.hostinger.com/tutorials/wp-content/uploads/sites/2/2017/07/symmetric-encryption-ssh-tutorial.jpg" alt="ssh_architecture" /></p>
<p>SSH 프로토콜은 정보의 전송을 안전하게 하기 위해 대칭 / 비대칭 암호화와 해싱을 사용한다. 클라이언트와 서버 간의 SSH 연결은 다음의 세 단계를 거친다.</p>
<ol>
<li>클라이언트에 의한 서버의 증명</li>
<li>모든 통신을 암호화하기 위한 세션 키 생성</li>
<li>클라이언트의 인증</li>
</ol>
<p>위의 세 단계에 대해서는 아래에서 살펴보자.</p>
<h3 id="1-서버의-증명"><a class="header" href="#1-서버의-증명">1. 서버의 증명</a></h3>
<p>클라이언트가 처음 서버와 SSH 연결을 실행한다. 서버는 기본적으로는 SSH 연결에 대해서 22번 포트(바뀔 수 있다)를 수신한다. 이 시점에서, 서버의 신원이 확인되는데, 두 가지 경우가 있다.</p>
<p><img src="https://miro.medium.com/max/1134/1*gnKOi4J8qq21gBdj99EXsg.png" alt="known_hosts" /></p>
<ol>
<li>만약 클라이언트가 서버에 처음으로 접속하는 것이라면, 클라이언트는 서버의 공개 키(퍼블릭 키 : Public key)를 검증함으로써 직접 인증해야 한다. 서버의 퍼블릭 키는 <strong><code>ssh-keyscan</code></strong> 커맨드를 통해서 확인하거나, 구글 등을 통해 살펴볼 수 있다. 일단 키가 증명되면, 클라이언트 측의 <code>~/.ssh</code> 디렉토리에 <code>known_hosts</code> 파일에 해당 서버를 추가한다. 이 <code>known_hosts</code>파일은 클라이언트에 의해 검증된 서버들에 대한 정보들을 담고 있다.</li>
<li>만약 클라이언트가 처음으로 서버에 접속하는 게 아니라면, 앞서 생성한 <code>known_hosts</code>파일에 기록된 정보들로 서버의 신원을 확인하며, 이를 인증에 사용한다.</li>
</ol>
<h3 id="2-세션-키-생성"><a class="header" href="#2-세션-키-생성">2. 세션 키 생성</a></h3>
<p>일단 서버가 인증되고 나면, 클라이언트와 서버 양측에서 <strong>Diffie-Hellman</strong> 알고리즘이라는 버전을 사용하여 세션 키를 협상한다. 해당 알고리즘은 세션 키 생성 시에 양측이 동등하게 기여할 수 있는 방식으로 설계된다. 생성된 세션키는 공유 대칭 키(Shared symmetirc key)이며, 다시 말해 동일한 키가 암호화와 복호화에 같이 사용된다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="tdd--test-driven-development"><a class="header" href="#tdd--test-driven-development">TDD : Test Driven Development</a></h1>
<h4 id="참고문서"><a class="header" href="#참고문서">참고문서</a></h4>
<ul>
<li><a href="https://medium.com/javascript-scene/tdd-changed-my-life-5af0ce099f80">TDD Changed My Life</a></li>
<li><a href="https://medium.com/javascript-scene/5-common-misconceptions-about-tdd-unit-tests-863d5beb3ce9">5 Common Misconceptions About TDD &amp; Unit Tests
</a></li>
</ul>
<h2 id="tdd-"><a class="header" href="#tdd-">TDD ?</a></h2>
<p><img src="https://cdn.shortpixel.ai/client/q_glossy,ret_img,w_1024/https://marsner.com/wp-content/uploads/test-driven-development-TDD.png" alt="tdd_process" />
프로세스 자체는 굉장히 심플하다.</p>
<ol>
<li>
<p>직접 코딩하기 전에, <strong>실패하는</strong> 테스트 코드를 작성해둔다. 이는 '정답'이 나오는 테스트들을 '양산하는' 것을 방지하기 위해서다.</p>
</li>
<li>
<p>코드를 작성하고, 테스트 코드를 통과하는지 확인한다.</p>
</li>
<li>
<p>필요하다면 리팩토링한다. 든든한 테스트코드를 작성했다면, '어디가 망가졌는지'를 파악할 수 있으므로, 리팩토링에 자신감을 갖자.</p>
</li>
</ol>
<h2 id="비효율적"><a class="header" href="#비효율적">비효율적?</a></h2>
<p><img src="https://miro.medium.com/max/875/1*9ZbCv6O3Sr7x6d3lt3uNRA.png" alt="two_states_of_programmer" /></p>
<p>나도 최근에 테스트 코드를 직접 작성해보면서, 이상과의 괴리감을 좀 느꼈다. 생각만큼 그 '테스트 코드'를 작성하는 것이 쉽지 않았다.</p>
<p>표면 상으로도, 이 또한 코드를 작성하는 것이기 때문에, 추가적인 코드를 위한, 추가적인 시간 소요가 필요하다. 코드를 테스트하기 위한 테스트 코드를 테스트 하기 위한 테스트... 같은 느낌으로 코드를 만들고 있는 내 모습을 볼 수 있었다.</p>
<p><strong>틀린 말은 아니다.</strong> 처음 테스트 코드를 작성할 때, 몇가지 노고를 겪는다.</p>
<ul>
<li>테스트 코드를 작성하는 법 자체</li>
<li>어떤 테스트를 추가해야 하는지</li>
</ul>
<p>결국, <strong>TDD도 러닝커브가 있다</strong>. 위 그림처럼 이상적인 프로세스로 보이는 것도, 실제로 해보려면 익숙해지기 위한 시간이 제법 되는 것이다. 한 작성자는 대략 15%-35% 정도 시간이 더 늘어난다고 말했다.</p>
<p>다만, 이것에 익숙해지기 시작하면, 마법같은 일이 일어나는데, 유닛테스트에 익숙해지면서 이전과는 비교가 안될 속도로 코드를 작성하는 것이다.</p>
<h2 id="수동-테스트"><a class="header" href="#수동-테스트">수동 테스트</a></h2>
<p>TDD라는 개념이고 뭐고, 테스트 코드란게 있는지 조차 몰랐을 적의 내 모습을 떠올려보자.</p>
<p>HTML/CSS, JS를 작성하면서, 제대로 됐는지 확인을 해야한다. 당시에 내가 할 수 있는 유일한 '테스트'는 새로고침을 하고, 직접 버튼을 눌러보고, <code>console.log</code>로 직접 상태를 확인하는 것이었다.</p>
<blockquote>
<p>코드 바꾸고, 저장하고, 새로고침하고, 클릭하고, 기다렸다가, 어 안되네, <code>console.log</code>달고, 바꾸고, 저장하고, 아 이것도 안되네.... 콤보</p>
</blockquote>
<p>내가 건들고 있는 부분이 비록 한 두 페이지에 불과하고, 변경과 컴파일에 얼마 걸리지 않는다면, 이는 전혀 문제될 게 없다. 근데, 앞으로 우리가 건드리게 될 것들이 그렇게 쉬운 문제들일까?? 버튼 한두개 만들고, 아이콘 한두개 띄우고...??</p>
<p>결국, 이런 테스트의 대상이 많아지면 많아질수록, 저런 식의 테스트는 비효율 그 자체가 되어버리고, 심지어는 리팩토링을 하거나 기능을 추가하는 과정에서 기존에 됐던 것이 안되거나 하는 일이 일어나도 전혀 인지하지 못하는 일이 생긴다.</p>
<h2 id="테스트코드의-마법"><a class="header" href="#테스트코드의-마법">테스트코드의 마법</a></h2>
<pre><code class="language-js">describe('clipReducer/setClipStopTime', async (assert) =&gt; {
  const stopTime = 5;
  const clipState = {
    startTime: 2,
    stopTime: Infinity,
  };
  assert({
    given: 'clip stop time',
    should: 'set clip stop time in state',
    actual: clipReducer(clipState, setClipStopTime(stopTime)),
    expected: { ...clipState, stopTime },
  });
});
</code></pre>
<p>이 코드를 보면 무슨 생각이 드는가? <strong>테스트 한번 하겠다고 너무 코드를 길게 써야하는 것 아닌가??</strong> 싶을 수도 있겠다. 근데 그게 바로 요점이다. 이 테스트 코드는 일종의 <strong>명세서</strong>같은 개념이다. 이렇게 문서화되어있는 대로 코드를 동작시키겠다는 일종의 증명이고, 그것이 있는 한, <strong>내가 제대로 테스트했는지</strong>에 대한 염려 자체를 할 필요가 없어진다.</p>
<p>결국 테스트 코드를 쓰는데 얼마나 오래걸렸는지가 중요한 것이 아니다. <strong>뭔가 잘못되었을때, 그것을 디버깅하기 위해 얼마나 걸리는지</strong>가 중요한 것이지. 위 코드가 제대로 동작하지 않으면, 그 테스트 자체가 훌륭한 버그 리포트가 된다. 테스트 코드를 살펴보는 것만으로 어디가 문제인지를 알 수 있게 된다.</p>
<h2 id="tdd는-더-나은-코드-작성법을-알려준다"><a class="header" href="#tdd는-더-나은-코드-작성법을-알려준다">TDD는 더 나은 코드 작성법을 알려준다</a></h2>
<p>유닛테스트를 작성할 때 중요한 것은, 테스트하고자 하는 부분 이외의 것들과는 완전히 독립적이어야한다는 점이다. 예를 들어, 상태 관리에 대해 테스트를 하고자 한다면 별도로 스크린을 띄우거나 데이터베이스에 어떤 동작을 하지 않고 테스트를 할 수 있어야 한다. UI를 테스트한다면 브라우저에 페이지를 로딩하거나 네트워크를 건들지 않고도 테스트할 수 있어야 한다.</p>
<p>TDD는 가능한한 UI 컴포넌트들을 작게 유지함으로써 훨씬 간편해진다는 점을 알려준다. UI와 비즈니스 로직, 사이드이펙트들을 구분지어 생각하자. 이는 React 등의 라이브러리를 사용할 때도, 디스플레이를 담당하는 컴포넌트와 컨테이너 컴포넌트들을 구분지어 사용하기 쉽게 만들어준다.</p>
<p>모든 소프트웨어 개발은 **구성(Composition)**이다. 커다란 문제들을 작고 해결이 쉬운 많은 문제들로 분해하고, 그 문제들에 대한 해결책들을 만들어 애플리케이션을 만들어간다.</p>
<p>유닛테스트에서의 <strong>모킹</strong>은 이렇게 구성된 애플리케이션의 구성이 실제로 그렇게 범접 못할 정도로 긴밀하게 뭉쳐져있지 않다는 것을 알려주며, 어떻게 하면 그 '분리점'을 발견해낼 수 있는지를 알려준다.</p>
<h2 id="tdd에-대한-5가지-오해"><a class="header" href="#tdd에-대한-5가지-오해">TDD에 대한 5가지 오해</a></h2>
<ol>
<li>
<p>TDD는 시간 낭비다. 경영팀에서 절대 허용해줄 리가 없다.</p>
</li>
<li>
<p>디자인을 알기 전에는 테스트를 작성할 수 없다 &amp; 코드를 실행시켜보기 전까진 그 디자인을 알 수 없다.</p>
</li>
<li>
<p>코드를 실행하기 전에 모든 테스트를 작성해야만 한다.</p>
</li>
<li>
<p>Red, Green 이후 <strong>항상</strong> 리팩토링한다.</p>
</li>
<li>
<p>모든 것에 유닛테스트가 필요하다.</p>
</li>
</ol>
<h2 id="모든-유닛테스트가-갖춰야-하는-5가지-질문"><a class="header" href="#모든-유닛테스트가-갖춰야-하는-5가지-질문">모든 유닛테스트가 갖춰야 하는 5가지 질문</a></h2>
<ol>
<li>무엇을 테스트하는 중인가?(모듈 / 함수 / 클래스 / 뭐든)</li>
<li>그것이 무엇을 해야 하는가? (설명: description)</li>
<li>실제로 나온 결과가 무엇인가?</li>
<li>예상했던 결과는 무엇인가?</li>
<li>어떻게 '실패'를 만들어 낼 수 있는가?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h1>
<p>함수형 프로그래밍(Functional Programming)은 예전부터 들어왔지만, 그 자체로 되게 애매한 지식으로 내게 자리잡고 있었다.</p>
<p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">여기</a>의 문서를 살펴보면서 함수형 프로그래밍에 대한 개념을 잡고 가려고 한다.</p>
<hr />
<p>FP는 다음과 같은 방식을 통해 소프트웨어를 만들어나가는 과정이다.</p>
<ul>
<li>순수 함수의 합성(compose) 기반</li>
<li>공유 상태 / mutable 데이터 / 사이드 이펙트를 모두 회피</li>
<li>명령형 보다는 선언형</li>
<li>웹의 측면에서 보자면 순수함수들을 통한 상태 관리를 지향</li>
</ul>
<p>이는 일반적으로 앱의 상태가 공유되고, 객체 메서드와 동일시되는 OOP와는 대조적인 성향을 띤다.</p>
<p>함수형 코드는 OOP 및 명령형 코드보다 명확하고, 예측가능하고, 테스트하기 쉽다.</p>
<p>사실, JS를 통해 프로그래밍을 해왔다면, 함수형 프로그래밍의 컨셉과 기능들을 본인도 모르는 사이에 적용해왔을 가능성이 높다.</p>
<h2 id="왜-어렵게-들릴까"><a class="header" href="#왜-어렵게-들릴까">왜 어렵게 들릴까?</a></h2>
<p><strong>함수형 프로그래밍</strong>은 뭔가 거창하게 들린다. 생소한 단어들이 여기저기 있기 때문이다.</p>
<ul>
<li>순수 함수 (Pure func.)</li>
<li>합성 함수 (Function Composition)</li>
<li>공유 상태 방지</li>
<li>Mutationg 상태 방지</li>
<li>사이드 이펙트 방지</li>
</ul>
<h2 id="순수-함수"><a class="header" href="#순수-함수">순수 함수</a></h2>
<p>동일한 입력이 있으면, 결과도 항상 동일하다</p>
<p>사이드 이펙트가 없다</p>
<h2 id="합성-함수"><a class="header" href="#합성-함수">합성 함수</a></h2>
<p>둘 이상의 함수들을 합쳐 새로운 작업을 수행하는 함수다.</p>
<h2 id="공유-상태"><a class="header" href="#공유-상태">공유 상태</a></h2>
<p>공유 상태는 공유 영역에 존재하는 변수, 객체, 메모리 공간들을 의미한다.</p>
<p>공유 상태가 갖는 문제점은, 단순히 함수의 실행 순서가 달라졌음에도 그 결과가 달라질 수 있다는 점에서 온다.</p>
<pre><code class="language-js">// With shared state, the order in which function calls are made
// changes the result of the function calls.
const x = {
  val: 2,
};

const x1 = () =&gt; (x.val += 1);

const x2 = () =&gt; (x.val *= 2);

x1();
x2();

console.log(x.val); // 6

// This example is exactly equivalent to the above, except...
const y = {
  val: 2,
};

const y1 = () =&gt; (y.val += 1);

const y2 = () =&gt; (y.val *= 2);

// ...the order of the function calls is reversed...
y2();
y1();

// ... which changes the resulting value:
console.log(y.val); // 5
</code></pre>
<p>이를 회피하기 위해, 앞서 나온 개념들인 순수함수, 합성함수들을 활용함과 더불어 공유 상태를 회피한다.</p>
<pre><code class="language-js">const x = {
  val: 2,
};

const x1 = (x) =&gt; Object.assign({}, x, { val: x.val + 1 });

const x2 = (x) =&gt; Object.assign({}, x, { val: x.val * 2 });

console.log(x1(x2(x)).val); // 5

const y = {
  val: 2,
};

// Since there are no dependencies on outside variables,
// we don't need different functions to operate on different
// variables.

// this space intentionally left blank

// Because the functions don't mutate, you can call these
// functions as many times as you want, in any order,
// without changing the result of other function calls.
x2(y);
x1(y);

console.log(x1(x2(y)).val); // 5
</code></pre>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p><strong>불변성</strong>은 일단 생성되고 난 후에는 수정될 수 없는 성질을 의미한다.</p>
<p>단순히 <code>const</code>로 변수를 선언하는 것과 헷갈리지 말아야 한다.</p>
<h2 id="side-effects"><a class="header" href="#side-effects">Side Effects</a></h2>
<p>사이드 이펙트는 함수의 실행 이후 반환되는 값이 아닌 다른 부분에서 상태 변화가 생기는 경우다.</p>
<p>사이드 이펙트를 유발하는 동작들은 소프트웨어에서 별도로 관리되어야 하며, 프로그래밍 로직에 직접적으로 관련되어선 안된다.</p>
<p>앞선 과정이 이루어지면, 소프트웨어의 확장, 리팩토링, 디버깅, 테스트 및 유지보수가 훨씬 수월해진다.</p>
<p>때문에 많은 프론트엔드 프레임워크들이 느슨하게 결합된 모듈을 통해 상태를 관리하고, 컴포넌트를 렌더링하게끔 유도한다.</p>
<h2 id="고차-함수를-통한-재사용성"><a class="header" href="#고차-함수를-통한-재사용성">고차 함수를 통한 재사용성</a></h2>
<p>함수형 프로그래밍에서는 어떤 종류의 데이터든 동일하게 취급된다.</p>
<p><code>map()</code> 메서드는 매개변수로 함수를 사용하기 때문에, 어떤 종류의 값이든 매핑을 할 수 있다.</p>
<p>JS는 1등급 함수를 갖는다. 이는 함수를 데이터로 다룰 수 있게 하며, 매개변수로 지정할 수도 있고, 인수로 전달될 수도 있고, 함수 자체가 반환될 수도 있다.</p>
<p>결국, 고차 함수란 함수를 매개변수로 받거나, 함수를 반환하는 함수로 여겨질 수 있다. 이들을 종종 다음과 같은 역할을 할 수 있다.</p>
<ul>
<li>콜백, 프로미스 등을 통해 이벤트 핸들링이나 비동기 로직을 처리한다.</li>
<li>다양한 데이터 타입에 폭넓게 적용할 수 있는 유틸 함수를 만든다</li>
<li>Partial Application 및 Currying</li>
<li>함수의 리스트를 받아 이들 함수들의 합성함수를 반환</li>
</ul>
<h2 id="선언형-vs-명령형"><a class="header" href="#선언형-vs-명령형">선언형 vs 명령형</a></h2>
<p>함수형 프로그래밍은 선언형이며, 이는 프로그램 로직이 내부적인 흐름을 설명하지 않고 표현되는 하나의 패러다임이다.</p>
<p>명령형 프로그래밍은 원하는 결과를 얻기 위한 순차적인 방법을 코드에 작성하며, <strong>어떻게 처리하는가</strong>를 주로 코드에 작성한다.</p>
<p>선언형 프로그래밍은 어떻게 이를 얻는지보다는 <strong>무엇을 하는가</strong>를 명시하는 코드를 주로 작성한다. 짧은 예시를 보자.</p>
<p>아래는 명령형 프로그래밍으로, 함수 실행을 통해 각 배열에 2를 곱한 결과를 얻고자 한다.</p>
<pre><code class="language-js">const doubleMap = (numbers) =&gt; {
  const doubled = [];
  for (let i = 0; i &lt; numbers.length; i++) {
    doubled.push(numbers[i] * 2);
  }
  return doubled;
};

console.log(doubleMap([2, 3, 4])); // [4, 6, 8]
</code></pre>
<p>아래는 선언형 프로그래밍으로, 앞의 코드와 동일한 역할을 하지만, <code>map</code> 메서드를 통해 각각의 값에 2를 곱하는 과정을 추상화하여 훨씬 데이터의 흐름을 명확하게 나타낸다.</p>
<p>결국, 명령형 프로그래밍은 Statement를 위주로 작성되는 코드에 해당한다. Statement는 일정한 액션을 수행하는 코드 조각들이며, <code>for</code>, <code>if</code>, <code>switch</code>, <code>throw</code>, 등이 이에 해당한다고 볼 수 있다.</p>
<p>반면, 선언형 프로그래밍은 Expression에 더 많이 의존한다. Expression은 어떤 값을 나타내는 코드 조각들이다. 일반적으로 결과 값을 생성하기 위해 함수 호출, 값 또는 연산자들의 조합들이다.</p>
<h2 id="결론-1"><a class="header" href="#결론-1">결론</a></h2>
<p>함수형 프로그래밍은 다음을 선호하는 패러다임이다.</p>
<ul>
<li>공유 상태 &amp; 사이드 이펙트 대신에 순수함수</li>
<li>불변(Immutable) 데이터를 활용</li>
<li>명령형 흐름보다는 합성 함수</li>
<li>고차 함수를 통해 여러 종류의 데이터 타입에 폭넓게 재사용될 수 있는 유틸함수</li>
<li>명령형보다 선언형 (어떻게 하는지보다 무엇을 하는지에 초점)</li>
<li>Statement보다 Expression</li>
<li>다형성(Polymorphism)보다는 컨테이너와 고차함수</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="reactive-programming"><a class="header" href="#reactive-programming">Reactive Programming</a></h1>
<p>해당 문서는 <a href="https://medium.com/@kevalpatel2106/what-is-reactive-programming-da37c1611382">여기</a>의 내용을 번역 및 참조한 것입니다.</p>
<h2 id="왜-우리는-비동기적인-작업을-필요로-할까요"><a class="header" href="#왜-우리는-비동기적인-작업을-필요로-할까요">왜 우리는 비동기적인 작업을 필요로 할까요?</a></h2>
<p>간단한 대답은 바로 <strong>이용자 경험을 향상시키기 위해서</strong>입니다. 우리들은 애플리케이션을 더 반응성이 뛰어나게 만들고 싶어합니다. 다시 말해 메인 쓰레드를 멈추도록 하지 않고 더 부드러운 이용자 경험을 제공하고 싶어하죠.</p>
<p>메인 쓰레드를 자유롭게 유지하기 위해서는, 비용 소모가 많은 작업들에 대해서는 백그라운드를 통해 처리하도록 할 필요가 있습니다. 또, 무겁고 연산이 복잡한 작업들에 대해서는 서버를 통해 처리해야할 필요가 있죠. 이런 경우에도 네트워크 작업을 위해서 비동기적인 처리가 요구됩니다.</p>
<h2 id="그래서-반응형-프로그래밍은-뭘까요"><a class="header" href="#그래서-반응형-프로그래밍은-뭘까요">그래서 반응형 프로그래밍은 뭘까요?</a></h2>
<p>반응형 프로그래밍은 데이터의 흐름과 변경의 전파를 중심으로 하는 프로그래밍 패러다임입니다. 이는 정적 또는 동적인 데이터 흐름을 쉽게 표현할 수 있고, 그에 따라 그 아래 놓인 실행 모델이 데이터 흐름을 통해 변경 사항을 자동으로 전파한다는 것을 의미합니다.</p>
<p>쉽게 말해서, 반응형 프로그래밍에서는 한 컴포넌트에 의해 데이터 흐름이 실행되고, 실행 모델이 해당 데이터 변화를 받게끔 등록한 다른 컴포넌트로 변경사항을 전파하도록 합니다.</p>
<p>아래에서는 Rx에서 사용되는 3가지 포인트에 대해 이야기해봅시다.</p>
<blockquote>
<p><strong>RX = OBSERVABLE + OBSERVER + SCHEDULERS</strong></p>
</blockquote>
<ul>
<li>
<p><strong>Observable</strong> : Observable은 대단할게 없는 데이터 스트림입니다. 이는 데이터를 한 쓰레드에서 다른 쓰레드로 넘겨질 수 있도록 데이터를 감쌉니다. 이들은 기본적으로 구성에 따라 주기적으로 또는 수명 주기에 한번 데이터를 내보냅니다. 당장에는, 해당 Observable을 일종의 &quot;공급자&quot;라고 생각하시면 됩니다. 이들은 데이터를 다른 컴포넌트에 처리하고 공급합니다.</p>
</li>
<li>
<p><strong>Observers</strong> : Observer는 Observable에서 내보낸 데이터 스트림을 소비합니다. Observer는 observer를 <code>subscribeOn()</code>을 통해 구독하며, Observable가 내보낸 데이터를 전달받습니다. Observable이 데이터 스트림을 내보낼 때마다, 등록된 모든 Observer가 <code>onNext()</code>콜백을 통해 데이터를 넘겨받습니다. 이 시점에서 JSON 응답을 파싱하거나, UI를 업데이트 하는 등의 다양한 작업을 수행할 수 있습니다. 반면 에러가 발생하는 경우에는 <code>onError()</code> 콜백을 통해 처리할 수 있습니다.</p>
</li>
<li>
<p><strong>Schedulers</strong> : 기본적으로 반응형 프로그래밍은 비동기적인 프로그래밍을 위한 것이고, 우리는 쓰레드 관리가 필요합니다. Rx 상에서 Scheduler란 Observable과 Observer에게 어떤 쓰레드를 실행해야 하는지에 대해 알려주는 역할을 합니다. <code>observeOn()</code> 메서드를 통해 어떤 쓰레드가 observe를 수행해야 하는지에 대해 처리해줄 수 있습니다.</p>
</li>
</ul>
<h2 id="애플리케이션에서-rx를-사용하는-간단한-3단계"><a class="header" href="#애플리케이션에서-rx를-사용하는-간단한-3단계">애플리케이션에서 Rx를 사용하는 간단한 3단계</a></h2>
<img src="https://miro.medium.com/max/1400/1*-N6sUYNrO615PQCeKtP0Kw.png" />
<ol>
<li>데이터 스트림을 내보낼 Observable을 생성</li>
<li>해당 데이터를 소비할 Observer를 생성</li>
<li>동시성 관리</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="machine-learning"><a class="header" href="#machine-learning">Machine Learning</a></h1>
<p>해당 문서는 <a href="https://developers.google.com/machine-learning/">여기</a>의 내용을 따라가기 위한 과정입니다.</p>
<p>이는 번역 작업에 중점을 둔 것이 아니라, 어디까지나 제 개인적인 학습을 위한 것으로, 중간중간에 생략 및 의역된 내용들이 다수 포함될 확률이 높습니다. 이에 참고바랍니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="problem-framing"><a class="header" href="#problem-framing">Problem Framing</a></h1>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Process.svg?hl=ko" />
<p>해당 섹션의 목표는 다음과 같습니다.</p>
<ul>
<li>일반적인 ML 용어의 정의</li>
<li>ML을 사용하는 상품과 각각에서 쓰이는 ML 문제 해결의 일반적인 방식</li>
<li>ML로 특정 문제를 해결할 수 있는지를 구분</li>
<li>다른 프로그래밍 방식과 ML의 비교 및 대조</li>
<li>ML 문제들에 대한 가설 검증과 과학적 방법</li>
<li>ML 문제 해결에 대한 이야기</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="common-ml-problems"><a class="header" href="#common-ml-problems">Common ML Problems</a></h1>
<p>일반적인 관점에서, 머신 러닝이란 <strong>모델</strong>이라 불리는 하나의 소프트웨어를 훈련시키는 과정입니다. 모델은 데이터 셋을 사용해 유용한 예측을 수행합니다.</p>
<p>종종, 사람들은 머신러닝을 <em>지도학습</em>과 <em>비지도학습</em>이라는 두가지 패러다임으로 구분합니다. 하지만, 실제로 머신러닝은 이 두가지 학습 방식이 복합적으로 어우러진다고 보는 편이 더 정확합니다. 여기서는 간단함을 위해, 좀 더 양쪽에 극단적인 케이스를 다루고자 합니다.</p>
<h2 id="지도-학습"><a class="header" href="#지도-학습">지도 학습</a></h2>
<p>지도 학습은 <strong>label</strong>처리된 트레이닝 데이터들을 제공받는 머신러닝의 유형입니다.</p>
<p>예를 들어, 아래와 같은 식물들의 데이터를 통해, 각 식물이 어떤 종에 속하는지를 맞추는 것과 같죠.</p>
<table>
<thead>
<tr>
<th>Leaf Width</th>
<th>Leaf Length</th>
<th>Species</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.7</td>
<td>4.9</td>
<td>small-leaf</td>
</tr>
<tr>
<td>3.2</td>
<td>5.5</td>
<td>big-leaf</td>
</tr>
<tr>
<td>2.9</td>
<td>5.1</td>
<td>small-leaf</td>
</tr>
<tr>
<td>3.4</td>
<td>6.8</td>
<td>big-leaf</td>
</tr>
</tbody>
</table>
<p>여기서 잎의 너비와 길이는 <strong>Features</strong>입니다. 그리고 우리가 맞추어야 하는 종(Species)는 곧 <strong>Label</strong>이 되죠. 아마 실제로는 훨씬 더 많은 Feature들이 존재할테지만, 여전히 Label은 한개일겁니다. 그리고, 이 Label이란 개념은 반드시 &quot;정답&quot;과 같은 느낌으로, 명확해야 합니다.</p>
<p>위에서는 단순히 4개의 예시만 다루었지만, 실제로는 훨씬 더 많은 데이터가 존재할 겁니다. 만약 데이터셋이 다음과 같은 그래프를 그려낸다고 생각해봅시다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph1.svg?hl=ko">
<p>지도학습에서는, 각 데이터셋의 케이스에 대한 Feature와 Label들을 알고리즘에 전달하는 <strong>Training</strong>이라 불리는 과정을 거칩니다. 이러한 과정 속에서, 알고리즘은 점차적으로 Feature들과 Label 간의 상관관계를 파악하게 되며, 이러한 상관관계가 곧 <strong>모델</strong>이 됩니다. 머신러닝에서 대부분 이러한 모델은 굉장히 복잡한 형태지만, 당장에는 다음과 같이 선 하나로 표현될 수 있는 모델이 있다고 하겠습니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph2.svg?hl=ko">
<p>이제 모델은 난생 처음보는 케이스들에 대해서 나름의 예측을 할 수 있게 됩니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph3.svg?hl=ko">
<h2 id="비지도-학습"><a class="header" href="#비지도-학습">비지도 학습</a></h2>
<p>비지도 학습에서의 목표는 데이터 내에 존재하는 <strong>의미있는 패턴</strong>을 발견하는 것입니다. 이를 위해서 기계는 별도의 Label이 존재하지 않는 데이터로부터 배워야합니다. 다시 말해, 모델은 각 데이터 조각들을 어떻게 분류해나가고, 어떻게 처리되어야 하는지에 대한 별도의 힌트를 전달받지 못합니다.</p>
<p>아래 그래프에는 별도의 Label이 없습니다. 그렇기 때문에 모두 초록색 동그라미로 표기됩니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph4.svg?hl=ko" />
<p>이처럼 Label이 없는 데이터셋에 아래와 같이 선을 긋는 것은 무의미합니다. 여전히 줄의 양쪽에는 동일한 초록 동그라미들이 있을 뿐입니다.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph5.svg?hl=ko" />
<p>한번 다르게 접근해봅시다. 여기 두 <strong>Cluster</strong>(군집)이 있습니다. 이 군집들은 무엇을 나타낼까요? 아마 대답하기는 어려울겁니다. 때때로 모델은 우리가 배우지 않기를 바라는 데이터에 대한 패턴을 찾아내기도 합니다. 스테레오타입(Stereotypes)과 편향(Bias)같은 것들이죠.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph6.svg?hl=ko" />
<p>그럼에도 부룩하고, 새로운 데이터가 나타났을 때, 그것이 현재 알고 있는 군집에 적합한 데이터라면 우리는 쉽게 이를 분류할 수 있습니다. 그런데, 만약 우리가 난생 처음 보는 군집에 해당하는 데이터라면 어떨까요?</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Graph7.svg?hl=ko" />
<blockquote>
<p>참고 : 사실, 클러스터링(군집화)는 비지도 학습의 유일한 형태가 아닙니다. 비지도 학습에는 여러 유형이 있고, 군집화는 그 중 가장 일반적인 방식일 뿐입니다.</p>
</blockquote>
<h3 id="강화-학습"><a class="header" href="#강화-학습">강화 학습</a></h3>
<p>머신 러닝의 추가적인 갈래로 강화 학습(Reinforcement Learning)이 있습니다. 이는 머신러닝의 다른 유형들과 구분됩니다. 기본적으로 이는 Label을 가진 데이터를 수집하지 않습니다. 만약 기계에게 정말 간단한 비디오게임을 플레이하게 만들고, 절대 지지 않게끔 가르치려고 한다고 해봅시다. 이는 기계에게 게임을 하되, 게임오버에 도달하지 말라고 말하는 것과 같습니다. 기계는 학습 중에 <strong>reward</strong> 함수라 불리는 것을 통하여 각 태스크에 대한 보상을 전달받습니다. 강화 학습을 거치면서, 이들은 실제로 사람을 뛰어넘는 수준으로 빠르게 학습할 수도 있습니다.</p>
<p>기본적으로 강화 학습은 수많은 데이터를 요구하지 않습니다. 그러나 좋은 reward 함수를 디자인하는 것은 어려우며, 그렇기 때문에 지도 학습보다 덜 안정적이고, 예측이 어렵습니다. 추가적으로, 기계가 게임과 같은 것들을 플레이 해나가며 상호작용을 통해 데이터를 생산해나갈 방법 자체도 고려해야합니다. 만약, 우리가 실 생활에서나, 혹은 VR 세계에서 강화학습을 적용해나가고자 한다면, 대단히 어려운 과정이 될 것입니다. 강화 학습도 머신러닝 분야에서 굉장히 활발하게 연구되고 있으나, 여기에서는 별도로 자세히 알아보지는 않도록 하겠습니다.</p>
<h2 id="머신러닝-문제의-유형"><a class="header" href="#머신러닝-문제의-유형">머신러닝 문제의 유형</a></h2>
<p>머신러닝 문제는 <em>예측이 어떤 식으로 이루어지느냐</em>에 따라 여러가지로 구분됩니다. 아래는 일반적인 지도/비지도 학습의 예시들을 다루고 있습니다.</p>
<table class="blue">
  <tbody><tr><th>Type of ML Problem</th><th>Description</th><th>Example</th></tr>
  <tr>
    <td>Classification</td>
    <td>Pick one of N labels</td>
    <td>Cat, dog, horse, or bear</td>
  </tr>
    <tr>
    <td>Regression</td>
      <td>Predict numerical values</td>
      <td>Click-through rate</td>
  </tr>
    <tr>
    <td>Clustering</td>
      <td>Group similar examples</td>
      <td>Most relevant documents (unsupervised)</td>
  </tr>
   <tr>
    <td>Association rule learning</td>
      <td>Infer likely association patterns in data</td>
      <td>If you buy hamburger buns, you're likely to buy hamburgers
        (unsupervised)</td>
  </tr>
    <tr>
    <td>Structured output</td>
      <td>Create complex output</td>
      <td>Natural language parse trees, image recognition bounding boxes</td>
  </tr>
      <tr>
    <td>Ranking</td>
      <td>Identify position on a scale or status</td>
      <td>Search result ranking</td>
  </tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="the-ml-mindset"><a class="header" href="#the-ml-mindset">The ML Mindset</a></h1>
<blockquote>
<p><em>머신러닝은 당신이 문제에 대해 생각하는 방법을 바꿉니다. 문제의 초점이 수학에서 자연과학으로 옮겨가면서 논리가 아닌, 실험과 통계에 기반하게 됩니다.</em> - Perter Norvig</p>
</blockquote>
<p>전통적인 방식의 소프트웨어 엔지니어링은 요구사항으로부터 실행가능한 디자인까지 추론해낼 수 있습니다. 그러나 머신러닝에서는, 실행가능한 모델을 찾기 위해서 실험이 필수적입니다.</p>
<p>많은 머신러닝 시스템은 인간과 다르게 신호를 해석함으로서 지식과 지능을 인코딩하는 모델을 만듭니다. Neural Network(인공신경망, 이하 NN)는 임베딩을 통해 단어를 해석할 수도 있을 겁니다. 예를들어, &quot;tree&quot;는 <code>[0.37, 0.24, 0.2]</code>, &quot;car&quot;는 <code>[0.1, 0.78, 0.9]</code>와 같은 식으로 해석될 것입니다. NN은 이러한 결과를 번역이나 감정 분석등에 사용할 수 있겠지만, 이는 사람이 봤을 때에는 도무지 이해할 수 없는 형태일 것입니다. 이러한 부분들이 기계 입장에서의 지능을 인간 입장에서 상당히 이해하고 평가하기 어렵게 만듭니다. 아예 불가능하지는 않겠지만요.</p>
<p>모델은 왜곡된 교육 데이터부터 시작해, 예상치 못한 해석에 이르기까지, 여러가지 디버깅하기 어려운 실수들을 범합니다. 게다가, 이를 실제 제품에 적용하려면, 상호작용이 훨씬 복잡해질테고, 이런 이유로 가능한 모든 상황을 예측하고 테스트하는 것이 어려울 수 있습니다. 이러한 문제들을 해결하기 위해 제품을 담당하는 팀이 머신러닝 시스템의 기능과 개선 방법을 이해하는 데에 많은 시간을 투자하는 것이 필요합니다.</p>
<h2 id="experimental-design-primer"><a class="header" href="#experimental-design-primer">Experimental Design Primer</a></h2>
<h3 id="어느-정도의-불확실성에-대해서는-익숙해지세요"><a class="header" href="#어느-정도의-불확실성에-대해서는-익숙해지세요">어느 정도의 불확실성에 대해서는 익숙해지세요.</a></h3>
<p>단순히 문제를 다르게 생각하는 것을 넘어, ML의 구현은 기존의 프로그래밍 방식과는 다릅니다. 전통적인 방식에서의 프로그래밍은 매개변수를 설정하고 모든 것이 어떻게 동작하는지에 대해 개발자가 이해할 수 있습니다. 허나 ML에서는, 일반적으로 훨씬 더 적은 양의 코드를 작성하지만, 코딩 이외의 작업이 매우 복잡할 수 있습니다.</p>
<p>사용가능한 모델만 만들고 끝내고 싶다고요? 이런 생각은 처음부터 글러먹었습니다.</p>
<h3 id="과학적-방법론"><a class="header" href="#과학적-방법론">과학적 방법론</a></h3>
<p>ML로 전환하는 문제를 해결하기 위해서, ML 프로세스는 테스트에 테스트를 거듭하여 실행 가능한 모델에 수렴해나가기 위한 실험 과정으로 이해하면 도움이 됩니다. 마치 실험과도 같이, 그 과정은 흥미롭고 도전적이고, 궁극적으로 가치있을겁니다.</p>
<table label="Steps of the Scientific Method with examples.">
  <tbody><tr><th>Step</th><th>Example</th></tr>
  <tr><td>1. 연구 목표 설정</td><td>주어진 날짜에 교통 체증이 얼마나 발생할지를 예측하고 싶다.</td></tr>
  <tr><td>2. 가설 세우기</td><td>아마 일기 예보가 좋은 정보가 될 것 같은데?</td></tr>
  <tr><td>3. 데이터 수집</td><td>각 날짜의 교통과 날씨 정보를 수집한다.</td></tr>
  <tr><td>4. 가설을 테스트한다.</td><td>수집한 데이터로 모델을 훈련시킨다.</td></tr>
  <tr><td>5. 결과를 분석한다.</td><td>지금보다 더 좋은 모델이 나올 수 있을까?</td></tr>
  <tr><td>6. 결론을 도출한다.</td><td>X, Y, Z 때문에, 이 모델을 사용해야(하지 말아야) 한다.</td></tr>
  <tr><td>7. 새로운 가설을 세우고 다시 반복한다.</td><td>1년을 기준으로 본 시간이 의미가 있을 수도 있어!</td></tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="identifying-good-problems-for-ml"><a class="header" href="#identifying-good-problems-for-ml">Identifying Good Problems for ML</a></h1>
<p>해당 섹션에서는 좋은 ML 문제들의 특징에 대해서 살펴봅니다.</p>
<h2 id="명확한-유스-케이스-use-case"><a class="header" href="#명확한-유스-케이스-use-case">명확한 유스 케이스 (Use Case)</a></h2>
<blockquote>
<p><em>해답이 아니라, 문제부터 시작하세요. ML 하나로 모든 문제들을 뚝딱 해결할거라 생각하지 마세요.</em></p>
</blockquote>
<p>전통적인 프로그래밍 방식으로 해결하기 어렵다고 생각하는 문제를 들여다봅시다. 예를 들어, <a href="https://ai.googleblog.com/2017/05/efficient-smart-reply-now-for-gmail.html">Smart Reply</a>같은 것이죠.</p>
<p>이러한 시스템들은 기존의 프로그래밍으로는 명확한 접근 방식을 생각해낼 수 없습니다. 반면에 ML을 통해서 여러 데이터들 간의 패턴을 파악하고 적용하면서 이런 문제들을 해결해낼 수 있죠. ML은 도구함 속 한가지 도구로 생각하는 것이 맞습니다. 오직 적절한 상황에서만 사용하는 그런 도구일 뿐이죠.</p>
<p>ML이 필요한지에 대해 파악하기 위해서는 다음과 같은 질문들에 대해 스스로 생각해볼 필요가 있습니다.</p>
<ol>
<li>현재 내가 무엇인가 만들던 도중 마주친 문제가 무엇인가?</li>
<li>그것이 ML로 해결하기에 적합한 문제인가?</li>
</ol>
<h2 id="데이터에-집중하기-이전에-문제부터-파악하라"><a class="header" href="#데이터에-집중하기-이전에-문제부터-파악하라">데이터에 집중하기 이전에 문제부터 파악하라</a></h2>
<blockquote>
<p><em>본인이 세운 가정이 틀릴 상황에 대해 준비하세요.</em></p>
</blockquote>
<p>어떤 문제를 명확하게 이해했다면, 최상의 모델을 만들기 위해 몇가지 잠재적인 솔루션을 세워볼 수 있을겁니다. 제대로 동작하는 모델을 만들기 전에는 몇가지 솔루션들을 시도해봐야 할 것입니다.</p>
<p>탐색적 데이터 분석(EDA)은 데이터를 이해하는 데는 도움이 될 수 있지만, 이전에 보지 못했던 데이터에 대해서도 동일한 패턴이 일반적으로 발생한다는 것을 직접 확인하기 전에는 이에 대해 확신할 수 없습니다. 이러한 부분을 정확하게 체크하지 않으면, 스테레오타입(고정관념)과 바이어스(편향)에 빠질 수 있다는 점을 주의하세요.</p>
<h2 id="본인-팀의-로그에-의존하세요"><a class="header" href="#본인-팀의-로그에-의존하세요">본인 팀의 로그에 의존하세요.</a></h2>
<blockquote>
<p><em>ML은 수많은 데이터들을 필요로 합니다.</em></p>
</blockquote>
<p>애초에 ML 작업을 위해 특별한 형태로 수집된 데이터가 가장 유용합니다. 하지만, 실제 상황에서는 이러한 형태로 이루어지기 어려울 수 있으며, 그런 경우 가깝게 위치한 모든 데이터에 의존해야 합니다. 비용과 제품 로그 등에 대해 알고 있다면, 이를 통해 더 적합할 모델을 구축할 수 있습니다.</p>
<p><em>얼마나 많이요?</em> 그것은 해결하고자 하는 문제에 따라 다릅니다. 그러나 일반적으로 모델은 더 많은 데이터를 활용할 수록 더 좋은 예측을 할 수 있습니다. 기본적인 선형 모델의 경우 적어도 수천 개의 예시를, 신경망의 경우에는 수십 만개의 예시를 갖는 것이 일반적으로 좋습니다. 이 정도의 데이터를 모을 수 없는 상황이라면, ML이 아닌 솔루션을 우선적으로 고려할 필요가 있습니다.</p>
<h2 id="예측력"><a class="header" href="#예측력">예측력</a></h2>
<blockquote>
<p><em>Feature들은 예측력을 포함하고 있습니다.</em></p>
</blockquote>
<p>경마에서 어떤 말이 좋은 성적을 보일지 예측하는 모델을 만들고 싶다고 합시다. 여기서 우리는 말의 눈 색깔을 Feature로 사용하기로 결정했다고 합시다. 우리의 가설은, &quot;눈 색깔을 통해 말이 눈병에 걸리기 쉬운지를 예측하고, 이것이 말의 신체능력에 영향이 줄 것&quot;이라는 것이죠. 이러한 가설은 틀릴지도 모르고, 추후 증거에 기초하여 가설을 기각할 수도 있습니다. 즉, 눈 색깔이 모델의 향상에 도움을 주는 Feature가 되지 않을지도 모른다는거죠.</p>
<p>그렇다고 해서 ML이 자신과 관련된 Feature가 무엇인지 찾는 어려운 작업을 수행하게 만들어서는 안됩니다. 모델에게 관련된 데이터를 모두 던져주고, 어떤 것이 유용한지 확인하려고 한다면, 우리가 만든 모델을 지나치게 복잡하고, 비싸고, 중요하지 않은 Feature들로 가득차게 될 가능성이 높습니다. 작은 데이터 셋 내에서 Feature는 샘플 데이터 내에서 우연한 상관관계를 띄게 될 가능성이 큽니다. 가설을 세우지 않고 무작정 많은 Feature를 적용하려고 하면, 그것이 모델과 관련된 신호라고 착각하게 될 가능성이 높습니다. 이러한 사실은 모형을 사용해 예측을 시도하고, 그것이 일반화되지 않았다는 것을 깨닫기 전까지는 알 수 없습니다.</p>
<h2 id="예측predictions-vs-결정decisions"><a class="header" href="#예측predictions-vs-결정decisions">예측(Predictions) vs. 결정(Decisions)</a></h2>
<blockquote>
<p><em>예측이 아닌, 결정에 초점을 맞추세요.</em></p>
</blockquote>
<p>여기서 말하는 <strong>결정</strong>이란, 모델의 출력 결과에 따라 제품이 수행하게 될 작업을 말합니다. ML은 우리에게 문제에 대한 통찰력을 제안하기 보다는, 이에 기반한 결정을 내리는 것에 더 초점이 맞추어져 있습니다. 만약, 우리가 가진 수많은 데이터에 대해 어떤 <strong>흥미로운</strong> 분석 결과에 대해 알고 싶다면 ML보다는 통계학이 더 올바른 접근 방법입니다.</p>
<p>예측이 유용한 액션을 취할 수 있도록 하는지 확신하세요. 예를 들어, 특정 동영상을 클릭할 가능성을 예측하는 모델을 통해 시스템이 클릭할 가능성이 가장 높은 동영상을 미리 가져오도록 할 수 있습니다.</p>
<p>가끔 예측과 결정은 밀집하게 연관된 경우도 있지만, 그와 다르게 관계가 명확하지 않은 경우도 많습니다. 아래의 예측/결정 간의 차이에 다룬 테이블을 확인해봅시다.</p>
<table class="cyan">
  <tbody><tr><th>Prediction</th><th>Decision</th></tr>
  <tr><td>이용자가 다음에 어떤 동영상을 보고자 할까?</td><td>추천 목록에 해당 동영상들을 띄워주자.</td></tr>
  <tr><td>누군가 검색 결과에 대해 클릭할 확률</td><td>`P(click) > 0.12` 이라면, 해당 웹페이지를 미리 가져오자.</td></tr>
  <tr><td>이용자가 시청할 비디오 광고의 비율</td><td>적은 비율이라면, 광고를 보여주지 않도록 하자.</td></tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="hard-ml-problems"><a class="header" href="#hard-ml-problems">Hard ML Problems</a></h1>
<p>해당 섹션에서는 ML에서 특히 다루기 어려운 문제들에 대해 이야기합니다.</p>
<h2 id="clustering-클러스터링--군집화"><a class="header" href="#clustering-클러스터링--군집화">Clustering (클러스터링 = 군집화)</a></h2>
<p>비지도 학습에서 각 클러스터는 무엇을 의미할까요? 예를 들어, 우리가 만든 모델이 아래의 사진에서 <em>파란 클러스터</em>내에 특정 유저가 포함된다고 이야기한다면, 결국 우리는 파란 클러스터 자체가 무엇을 의미하는지를 알아야할 필요가 있습니다.</p>
<p><img src="https://developers.google.com/machine-learning/problem-framing/images/LabeledClusters.svg?hl=ko" alt="Image of scatterplot with 4 clusters
circled" class="screenshot attempt-right"></p>
<p>종종 클러스터에 따라 액션을 취해야 할 수 있습니다. 예를 들어, Google Photo에서는 동일한 사람들이 모인 사진들을 동일한 사진 그룹에 모아놓습니다. 그 밖의 경우, 클러스터에 기반하여 어떤 액션을 수행하는 것은 도전적인 일이 될 겁니다. 클러스터에 의미를 부여하려고 할 수는 있지만, 생각보다 쉽지는 않습니다. 왜냐하면 모델이 직관적인 기준에 따라 그룹화되어 있지 않을 수도 있기 때문입니다.</p>
<p>이에 대한 한가지 대안은 클러스터링을 하기 이전에 미리 일부 표본들에 대해 label(레이블)을 수행한 다음 해당 레이블들을 전체 클러스터에 전파하는 것입니다. 예를 들어, 레이블이 X인 모든 항목이 하나의 클러스터에 모여있다면, 해당 레이블 X를 다른 예시들에도 전파시켜볼 수 있습니다.</p>
<h2 id="anomaly-detection"><a class="header" href="#anomaly-detection">Anomaly Detection</a></h2>
<p><img src="https://developers.google.com/machine-learning/problem-framing/images/Anomaly.png?hl=ko" alt="Image of a scatterplot with 2 parallel lines indicating a threshold that has
points outside of it which are to be considered anomalies."></p>
<p>종종, 사람들은 이상징후를 식별하기 위해서 ML을 사용하려고 합니다. 관건은 &quot;어떤 것이 이상치인지&quot; 어떻게 결정하느냐 입니다. 한 가지 선택지는 휴리스틱을 정의하고 이를 이상치의 레이블링에 사용하는 것입니다. 그러나, 이 휴리스틱을 정의하였을 때, 이를 학습 단계에서 사용하게 될 경우 애초에 ML은 해당 휴리스틱을 능가할 수 없는 상황에 처하기 때문에, 생산 단계에서 해당 휴리스틱을 사용하는 것이 좋습니다.</p>
<blockquote>
<p>참고 : 떄때로 고정밀 저호출 휴리스틱(High-precision Low-recall heuristic)을 정의한 다음, 준지도적인(semi-superviesed) 방식을 사용해 모델이 시드 예측 집합(seed set of predictions)에서 성장하게끔 훈련시켜 레이블이 없는 더 큰 데이터 집합을 분류할 수 있게끔 할 수도 있습니다. (아직은 뭔 소린지 모르겠다.)</p>
</blockquote>
<p>만약, 휴리스틱이 충분히 복잡하다면 ML을 통해 이를 대체하는 것을 고려해볼 수도 있습니다. 그러나 일반적으로 휴리스틱을 다시 정의하는 것만큼 모델은 쉽게 수정하기 어렵기 때문에 주의할 필요가 있습니다.</p>
<h2 id="causation"><a class="header" href="#causation">Causation</a></h2>
<p>ML은 둘 이상의 상호 관계 및 연관성에 대해 식별할 수 있습니다. 반면, <em>인과 관게</em>를 판단하는 것은 훨씬 어려운 일입니다. 다시 말해, **무슨 일들이 일어났는가?**에 대해서는 알기 쉽지만, **왜 그것이 일어났는가?**에 대해서는 훨씬 판악하기 어렵습니다.</p>
<blockquote>
<p>예를 들어, 소비자들이 어떤 책들을 구매한 것은, 바로 지난 주에 해당 책에 대한 긍정적인 리뷰가 있었기 때문일까? 아니면 그 리뷰는 전혀 상관 없는 것이었을까?</p>
</blockquote>
<p>오직 관측 데이터를 통해서는 인과 관계에 대해 파악할 수 없습니다. 위 사례처럼, 지난 일들에 대한 기록만 보고서는 지난 주의 리뷰가 구매를 유발했는지의 여부를 판단할 수 없습니다. 이를 파악하려면, 리뷰를 보지 못한 이용자와, 리뷰를 본 이용자 간을 비교하는 실험이 추가적으로 필요합니다. 결국, 일반적으로 어떤 일들의 인과 관계를 확인하려면 추가적인 실험이 필요하고, 이는 순수 관측 데이터를 통해서는 불가능한 일입니다.</p>
<h2 id="no-existing-data"><a class="header" href="#no-existing-data">No Existing Data</a></h2>
<p>앞서 언급한 것처럼, 모델을 훈련시킬 데이터가 없다면, ML은 여러분에게 아무런 도움을 줄 수가 없습니다. 데이터가 없다면, 단순한 휴리스틱 기반의 규칙 기반 시스템을 사용하세요. 많은 신규 서비스들은 휴리스틱 기반의 시스템으로 시작하여, 이용자들이 해당 서비스와 상호작용하기 시작하면서부터 새로운 훈련 데이터들을 얻습니다. 일단 훈련 데이터들이 갖추어지기 시작한다면, 그 속에서 패턴을 찾으려고 노력하세요. 패턴이 존재하지 않거나, 자질구레한 패턴만이 존재한다면, ML은 아마 별다른 쓸모가 없을 겁니다. 결국, <strong>수많은 패턴이 존재하고, 그 속에서 정확한 예측을 하는 것이 중요한 상황</strong> 속에서야 ML은 비로소 올바른 접근이 될 겁니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="deciding-on-ml"><a class="header" href="#deciding-on-ml">Deciding on ML</a></h1>
<p>데이터를 본격적으로 다루기 전에, 준비되었는지 확인해보는 과정을 거치도록 하자.
아래에서는 머신 러닝 문제들을 구성하기 전에 생각해야 할 몇가지 사항에 대해 간략하게 설명한다.</p>
<h2 id="명확하고-간단하게-시작하라"><a class="header" href="#명확하고-간단하게-시작하라">명확하고 간단하게 시작하라.</a></h2>
<p>말 그대로, ML 모델이 어떤 일을 했으면 좋겠는가?</p>
<table class="green">
  <tbody><tr><th>예시</th></tr>
  <tr>
    <td>ML 모델으로 방금 업로드된 동영상이 추후에 얼마나 인기를 끌지 예측하고 싶다.</td>
  </tr>
</tbody></table>
<p>현 시점에서, 이에 대해 답하는 것은 다소 정성적인 목표가 될 수 있으나, 간접적인 목표가 아니라, 실제 목표를 지니고 있는지 확인하라.</p>
<h2 id="어떤-결과가-이상적인가"><a class="header" href="#어떤-결과가-이상적인가">어떤 결과가 이상적인가?</a></h2>
<p>시스템에 ML 모델을 추가하는 것은 이상적인 결과를 생산해야 한다. 이는 단순히 모델과 그 품질을 평가하는 것과는 다른 의미를 갖는다.</p>
<table class="green">
  <tbody><tr><th>예시</th><th></th></tr>
  <tr>
    <td>트랜스코딩</td>
    <td>
      <div>이상적인 목표는 덜 인기있는 영상에 대해 트랜스코딩을 거쳐 이들이 잡아먹는 리소스를 줄이는 것이다.</div>
    </td>
  </tr>
    <tr>
    <td>영상 추천</td>
    <td>이상적인 목표는 사람들이 유용하고, 흥미로워하고, 가치가 있다고 판단하는 영상을 제안하는 것이다.</td>
  </tr>
</tbody></table>
<blockquote>
<p><strong>주의</strong>: 똑같은 모델로도 다른 이상적인 결과를 목표로 할 수 있다. 이것이 이상적인 결과를 명확하게 두어야 하는 이유다.</p>
</blockquote>
<p>이미 최적화를 하고 있는 서비스의 매트릭스에 갇혀있지 마라. 제품 및 서비스의 더 큰 목표에 집중해야 한다.</p>
<h2 id="성공실패-매트릭스지표"><a class="header" href="#성공실패-매트릭스지표">성공/실패 매트릭스(지표)</a></h2>
<h3 id="정량화하라"><a class="header" href="#정량화하라">정량화하라</a></h3>
<p>시스템이 성공적인지 아닌지 어떻게 판단할 수 있을까?</p>
<p>성공 및 실패 매트릭스는 정밀도, 재현율 또는 AUC와 같은 평가 매트릭스와 독립적으로 표현되어야 합니다.
대신, 예상 결과를 구체화시켜야 합니다.
시작하기 전에 미리 성공 매트릭스를 설정하세요.
이는 매몰 비용으로 우리가 평범한 모델로부터 시작하게끔 하는 것을 막기 위해서 입니다.</p>
<table class="green">
  <tbody><tr><th>예시</th><th></th></tr>
  <tr>
    <td>트랜스코딩</td>
    <td>성공 매트릭스는 CPU 리소스 사용률이다. 성공은 트랜스코딩을 위한 CPU 비용을 35% 줄이는 것을 의미한다. 반면 실패는 비용 절감이 모델 학습 및 제공을 위한 CPU 비용보다 적은 경우다.</td></tr>
    <tr>
    <td>영상 추천</td>
    <td>성공 매트릭스는 모델을 통해 적절하게 예측한 영상의 개수가 된다. 성공은 업로드된 이후 28일 이내에 시청 시간을 기반으로 가장 인기있는 동영상의 95%를 예측하는 것을 의미한다. 반면 실패는 적절하게 예측된 인기 동영상의 수가 현재의 휴리스틱을 통한 예측보다 성능이 나쁜 경우다.</td>
  </tr>
</tbody></table>
<h3 id="측정-가능한-매트릭스인가"><a class="header" href="#측정-가능한-매트릭스인가">측정 가능한 매트릭스인가?</a></h3>
<p>측정가능한 지표는 실제로 적용하였을 때의 평가에 있어 충분한 정보를 제공한다.
예를 들어, 과수원의 건강 상태를 모니터링하는 시스템은 병든 나무들의 비율을 줄이고자 한다.
한편, &quot;어떤 나무가 병든 나무인가?&quot;에 대한 측정이 불가능하다면, 그다지 유용한 지표는 아니다.</p>
<p>아래와 같은 질문들을 스스로 해보자.</p>
<ul>
<li>어떻게 지표를 측정하는가?</li>
<li>언제 지표를 측정할 수 있는가?</li>
<li>새로운 ML 시스템이 성공적인지 아닌지를 판단하는 데에 얼마나 많은 시간이 걸릴 것인가?</li>
</ul>
<p>이상적으로는, 빨리 실패하고자 할 것이다. 
데이터의 신호(Signal)가 너무 적거나, 예측할 수 없는 데이터가 있는지를 확인하여 가설이 틀릴 수 있는지에 대해 판단하라.
빠른 실패는 프로세스의 초기에 가설을 수정하고 시간 손실을 방지할 수 있다.</p>
<table class="green">
  <tbody><tr><th>예시</th></tr>
  <tr>
    <td>
      이용자의 위치에 따라 어떤 영상이 시청되었지에 대해 판단하고 싶다.
      이는 가능한 것처럼 보이지만, 막상 시도해보면, 신호가 너무 약하거나, 너무 많은 노이즈가 껴있어 제대로 이루어지기 어렵다.
      얼마나 오래 해당 가설을 고수할 것인가?
    </td>
  </tr>
</tbody></table>
<p>보다 장기적인 관점에서 엔지니어링 및 유지 비용을 고려하라.</p>
<h3 id="다른-실패-시나리오"><a class="header" href="#다른-실패-시나리오">다른 실패 시나리오</a></h3>
<p>성공 지표와 관련이 없는 실패에 대해서도 확인하라.
예를 들어, 영상 추천 시스템이 항상 &quot;어그로 영상&quot;들을 추천한다면 양질의 서비스를 제공해야한다는 관점에서 성공적이라고 할 수 없을 것이다.</p>
<h2 id="ml-모델이-어떤-형태의-결과를-만들어냈으면-하는가"><a class="header" href="#ml-모델이-어떤-형태의-결과를-만들어냈으면-하는가">ML 모델이 어떤 형태의 결과를 만들어냈으면 하는가?</a></h2>
<p>아래 테이블을 기반으로, 어떤 형태의 결과를 출력하는 것이 가장 적절할지에 대해 생각해보라.</p>
<table class="blue">
  <tbody><tr><th>Type of ML Problem</th><th>Description</th><th>Example</th></tr>
  <tr>
    <td>Classification (분류)</td>
    <td>N개의 라벨 중 하나를 선택</td>
    <td>cat, dog, horse, or bear</td>
  </tr>
    <tr>
    <td>Regression (회귀)</td>
      <td>수치에 대한 예측</td>
      <td>클릭율</td>
  </tr>
    <tr>
    <td>Clustering (군집화)</td>
      <td>유사한 예시들을 그룹화시키기</td>
      <td>가장 관련이 있는 문서 (비지도)</td>
  </tr>
   <tr>
    <td>Association rule learning (연관 규칙 학습)</td>
      <td>데이터에서 가능한 연관 패턴 추론</td>
      <td>만약 햄버거 빵을 샀으면, 햄버거도 샀을 것이다. (비지도)</td>
  </tr>
    <tr>
    <td>Structured output (구조적인 결과)</td>
      <td>복잡한 출력 생성</td>
      <td>자연어 파싱 트리, 이미지 인식 경계 박스</td>
  </tr>
</tbody></table>
<blockquote>
<p><strong>주의</strong> : 특정 ML 문제는 어떤 타입에서는 실패하지만, 어떤 타입에서는 성공적일 수 있습니다.</p>
</blockquote>
<h3 id="좋은-출력의-특징"><a class="header" href="#좋은-출력의-특징">좋은 출력의 특징</a></h3>
<h4 id="모델이-만들어낸-출력은-명확한-정의가-가능한-정량적-결과여야-합니다"><a class="header" href="#모델이-만들어낸-출력은-명확한-정의가-가능한-정량적-결과여야-합니다"><strong>모델이 만들어낸 출력은 명확한 정의가 가능한 정량적 결과여야 합니다.</strong></a></h4>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>
      이용자가 영상을 재밌게 보았는가? vs. 이용자가 영상을 공유하였는가?
    </td>
  </tr>
</tbody></table>
<p>이용자에게 직접 물어보지 않는 한, 이용자가 정말로 해당 영상을 즐겼는지에 대해 알 방도가 없다.
만약 이를 판단하려면, 별도의 **<a href="https://developers.google.com/machine-learning/glossary?hl=ko#proxy_labels">프록시 레이블</a>**이 필요할 것이다.
프록시 레이블은 실제를 대신할 대체 레이블을 의미하는데, 이용자의 공유 여부는 좋은 프록시 레이블이 된다.
물론, 공유는 이용자가 영상을 재밌게 보았는지에 대한 완벽한 측정치가 될 수 없다.
그러나, 공유는 정량적이고, 추적 가능하고, 수많은 예측 시그널을 제공한다는 점에서 더 적절하다.</p>
<h4 id="출력은-앞서-정한-이상적인-결과와-관련이-있어야-한다"><a class="header" href="#출력은-앞서-정한-이상적인-결과와-관련이-있어야-한다"><strong>출력은 앞서 정한 이상적인 결과와 관련이 있어야 한다.</strong></a></h4>
<p>모델은 출력을 올바른 방향으로 최적화해 나갈 것이다. 그러므로, 출력은 우리가 신경쓰고자 하는 실질적인 이상적인 목표와 관련이 있어야 한다.
프록시 레이블이 종종 필수적인데, 항상 이상적인 결과를 직접 측정할 수 없기 때문이다.
그러나, 레이블과 실제 결과 간의 연관성이 강할수록, 제대로 된 것을 최적화시켜 나가고 있다는 자신을 갖기도 용이하다.</p>
<table class="green">
  <tbody><tr><th>Output</th><th>Ideal Outcome</th></tr>
  <tr><td>이용자가 기사를 공유할지 아닌지에 대한 예측</td><td>이용자들이 좋아하는 기사를 보여줌</td></tr>
  <tr><td>비디오가 인기있을 것인지 아닌지에 대한 예측</td><td>이용자가 유용하고 가치있다고 판단하는 영상을 제공</td></tr>
  <tr><td>이용자들이 앱 스토어에서 어떤 앱을 설치할지 아닌지에 대한 예측</td>
    <td>이용자들이 좋아할만한 앱을 찾아줌</td></tr>
  <tr class="alt"><td colspan="3"><b>둘 사이에 강한 연관성이 있는지 확인해야 한다!</b></td></tr>
</tbody></table>
<h4 id="연습-데이터로-사용할-예시-데이터들을-얻을-수-있는가"><a class="header" href="#연습-데이터로-사용할-예시-데이터들을-얻을-수-있는가"><strong>연습 데이터로 사용할 예시 데이터들을 얻을 수 있는가?</strong></a></h4>
<p>어떻게, 어디서 데이터들을 가져올 것인가?</p>
<p>지도 학습은 레이블 처리된 데이터에 의존한다. 
만약 연습에 사용할 데이터를 얻는 것이 어려운 상황이라면, 앞선 단계를 다시 밟으면서 문제와 목표를 재정의하는 것이 필요할 것이다.
앞서 시청 시간을 퍼센트 단위로 변환한 것처럼, 출력 예시는 엔지니어링 되어야 할 수도 있다.</p>
<h2 id="출력-활용"><a class="header" href="#출력-활용">출력 활용</a></h2>
<p>모델은 다음의 두 부분에서 예측을 수행할 수 있다.</p>
<ul>
<li>실제 사례, 이용자 활동에 따른 반응 (online)</li>
<li>배치 또는 캐시로써 사용</li>
</ul>
<p>서비스에서 어떻게 예측을 활용할 것인가? 명심하라, ML은 단순히 예측을 하는 것이 아니라, 그것에 기반해 결정을 수행해야 한다.
어떻게 모델의 예측 결과를 의사 결정으로 바꿀 수 있을까?</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>모델은 새 영상이 업로드될 때 영상의 인기도를 예측할 것이다. 그 결과에 기반하여 영상에 대한 트랜스코딩 알고리즘을 결정할 것이다.</td>
  </tr>
</tbody></table>
<p>아래 예시처럼, 이용자의 클릭율을 예측하여 이를 통해 이용자에게 알림을 전달할 수도 있다.</p>
<pre><code>click_probability = call_model(user)
if click_probability &gt; 0.05:
    send_notification(user)
</code></pre>
<p>다음으로, 아키텍처의 어디에 이러한 의사 결정 코드들이 위치할 지에 대해 판단하라.
아래의 질문들이 중요한 도움이 될 것이다.</p>
<ul>
<li>모델을 호출할 때 어떤 데이터들이 필요한가?</li>
<li>대기시간(latency) 요구사항이 있는가? UX를 위해 빠르게 실행해야 하는가, 아니면 이용자가 기다리지 않아도 되는 경우인가?</li>
</ul>
<p>위의 질문들은 모델의 실제 feature를 구성하는 데에도 영향을 준다. 
모델을 호출할 때 사용할 수 있는 데이터들에 대해서만 feature를 결정하고 훈련시킬 수 있기 떄문이다.
요구 대기시간 역시 feature 구성에 영향을 줄 수 있는데, 이를테면 카메라 앱에서 현재 날씨 데이터를 feature로 사용하고자 하는 경우, 해당 데이터를 다른 api 등을 통해 가져오는 데 비용이 너무 크게 소모되기 때문이다.</p>
<p>마지막으로, 너무 오래된 데이터를 사용하지 않도록 해야한다.
훈련 데이터가 며칠이 지난 경우가 있을 수 있다.
실시간 트래픽에서 동작하는 경우, 최신 데이터에 대해 당장에 접근할 수 없는 경우가 발생할 수도 있다.</p>
<h2 id="좋지-않은-목표"><a class="header" href="#좋지-않은-목표">좋지 않은 목표</a></h2>
<p>적절하게 설정되기만 한다면, ML 시스템은 목표를 추구하기에 정말 유용하다.
반대로, 적절하지 않은 목표에 기반을 둔다면, ML 시스템은 의도치 않은 결과를 생산해낼 것이다.
그러므로, 어떤 문제를 해결하기 위하여 해당 시스템의 목표에 대해서 주의깊게 고려할 필요가 있다.</p>
<p>유튜브에서 어떤 이용자가 다음에 볼 영상을 예측하는 모델의 경우를 생각해보자.
아래는 모두 <strong>적절하지 않은 목표</strong>에 대한 예시이다.</p>
<h3 id="클릭율을-최대한-높이기"><a class="header" href="#클릭율을-최대한-높이기">클릭율을 최대한 높이기</a></h3>
<ul>
<li>이용자가 어떤 것을 클릭할 순 있어도 그렇게 오래 머물러있지 않는 경우가 발생할 수 있다.</li>
<li>이는 낚시 기사 내지는 어그로성 게시물들에 최적화될 것이며, 그렇기 때문에 다른 목표가 필요하다.</li>
</ul>
<h3 id="시청-시간-최대한-늘리기"><a class="header" href="#시청-시간-최대한-늘리기">시청 시간 최대한 늘리기</a></h3>
<ul>
<li>이용자가 오래동안 시청을 하더라도, 금방 세션에서 벗어날 수 있다.</li>
<li>예를 들어, 마인크래프트의 0.1% 시청자만이 3시간 동안 영상을 보고, 8%는 5분 동안 영상을 본다. 그 외의 나머지는 시청을 완전히 중단한다. 시스템은 시청 시간을 최대화할 것이므로, 다음 시청 목록은 긴 마인크래프트 비디오로만 구성될 것이다.</li>
<li>단순히 영상을 오래 보는 것 보다, 여러 짧은 동영상들을 많이 보게끔 하는 것이 더 중요하며, 전반적인 세션을 길게 유지하는 것 역시 중요하다.</li>
</ul>
<h3 id="세션-시청-시간을-최대한-늘리기"><a class="header" href="#세션-시청-시간을-최대한-늘리기">세션 시청 시간을 최대한 늘리기</a></h3>
<ul>
<li>앞선 예시처럼, 여전히 긴 영상을 선호하게 되는데, 이는 여전히 문제가 된다.</li>
<li>이 경우, 특정 관심사에 대해서만 편향되기 매우 쉽다.</li>
<li>예를 들어, 한 이용자가 르브론 제임스의 덩크 영상을 봤따면, 시스템은 해당 이용자에게 르브론 제임스의 모든 덩크 영상을 보여줄 것이다.</li>
<li>영상 추천 시스템은 이를 정말 잘 수행하겠지만, 이용자 경험은 그다지 좋지 않을 것이다.</li>
<li>이 경우 많은 이들이 유튜브를 단순히 특정 영상만 가득한 곳으로 판단할 것이며, 다양성이 사라지게 된다.</li>
</ul>
<h3 id="다양성-증가--세션-시청-시간을-최대한-늘리기"><a class="header" href="#다양성-증가--세션-시청-시간을-최대한-늘리기">다양성 증가 &amp; 세션 시청 시간을 최대한 늘리기</a></h3>
<ul>
<li>해당 목표에서는 어떤 문제가 발생할까? </li>
<li>여기서는 굿하트의 법칙을 떠올리자. &quot;측정이 곧 목표가 된다면, 올바른 측정은 불가능하다.&quot;</li>
</ul>
<h2 id="휴리스틱"><a class="header" href="#휴리스틱">휴리스틱</a></h2>
<p>어떻게 하면 ML 없이도 문제를 해결할 수 있을까?</p>
<p>어떤 서비스를 당장 내일 제공해야 한다고 가정하자. 그렇다면 ML 보다는 당장에 비즈니스 로직을 하드코딩할 시간 정도밖에 없을 것이다.
이 때는 아래 예시처럼 ML 없이 휴리스틱을 시도하고자 할 수 있다.</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>과거에 인기 있었던 영상들을 올린 사람이 새로 업로드하는 영상들 역시 인기있을 것이라고 가정한다.</td>
  </tr>
</tbody></table>
<p>이러한 예시는 세상에서 제일 완벽한 휴리스틱은 아니겠지만, 토대를 마련하기에는 충분할 것이다.
굳이 팬시한 ML 모델에 집착할 필요 없습니다. 굳이 휴리스틱을 이기지 못하는 ML 모델을 서비스로 제공할 필요가 없습니다.
휴리스틱을 만드는 연습은 ML 모델에서 좋은 신호를 판단하는 데에 도움이 됩니다.</p>
<p>ML이 아닌 해답은 대부분 ML을 통한 해답보다 유지보수가 더 쉽습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="formulate-your-problem-as-an-ml-problem"><a class="header" href="#formulate-your-problem-as-an-ml-problem">Formulate Your Problem as an ML Problem</a></h1>
<p>해당 섹션에서는 ML 문제를 구성하기 위한 적절한 접근에 대한 가이드를 제공합니다.</p>
<ol>
<li>문제를 분명히 하라.</li>
<li>간단하게 시작하라.</li>
<li>데이터 소스를 정의하라.</li>
<li>모델에 사용할 데이터를 디자인하라.</li>
<li>어디서 데이터가 올지 결정하라.</li>
<li>쉽게 얻을 수 있는 입력을 결정하라.</li>
<li>학습 능력</li>
<li>잠재적인 편향(bias)에 대해 생각하라.</li>
</ol>
<h2 id="문제를-분명히-하라"><a class="header" href="#문제를-분명히-하라">문제를 분명히 하라.</a></h2>
<p>분류와 회귀에도 여러 세부유형들이 존재합니다.
아래 플로우차트를 따라 정확히 어떤 유형의 문제인지를 정의하세요.</p>
<img src="https://developers.google.com/machine-learning/problem-framing/images/FlowChart1.svg?hl=ko" >
<img src="https://developers.google.com/machine-learning/problem-framing/images/FlowChart2.svg?hl=ko" >
<p>우리 문제는 다음과 같이 잘 구성됩니다.</p>
<ul>
<li>Binary classification</li>
<li>Unidimensional regression</li>
<li>Multi-class single-label classification</li>
<li>Multi-class multi-label classification</li>
<li>Multidimensional regression</li>
<li>Clustering (unsupervised)</li>
<li>Other (translation, parsing, bounding box id, etc.)</li>
</ul>
<p>문제를 정확히 한 이후에, 모델이 예측할 내용이 정확히 무엇인지 설명하세요.</p>
<p>이러한 각 요소들을 합쳐서 정리해보면, 문제에 대한 간결한 설명이 됩니다.</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>어떤 영상에 대해 다음 3개의 클래스 중 어떤 것에 해당할지 예측하는 단일 레이블 분류 문제를 정의해볼 수 있다.—<code translate="no" dir="ltr">{very popular,<wbr> somewhat popular,<wbr> not popular}</code>— 업로드 후 28일이 된 시점에 대한 예측이다.
    </td>
  </tr>
</tbody></table>
<h2 id="간단하게-시작하라"><a class="header" href="#간단하게-시작하라">간단하게 시작하라.</a></h2>
<p>먼저, 모델링 작업을 간단하게 만들어봅시다. 주어진 문제에 대해 이진 분류 또는 단일 회귀 문제(아니면 둘다)로 정의해보세요. 두 문제들은 도움이 되는 많은 도구와 전문가들의 지원이 있는, 제일 간단한 접근 방식입니다.</p>
<p>그 다음, 작업을 위해서 최대한 간단한 모델을 사용하세요. 간단한 모델은 실행하기도, 이해하기도 쉽습니다. 일단 전체 ML 파이프라인을 갖추고 나면, 간단한 모델에서부터 더 쉽게 발전시켜 나갈 수 있습니다.</p>
<table class="green">
  <tbody><tr><th>Examples</th></tr>
  <tr>
    <td>업로드된 영상이 유명해질 것 같은지 아닌지를 예측한다. (Binary Classification)</td>
  </tr>
    <tr>
    <td>업로드된 영상의 인기도를 28일 이내에 받을 조회수를 기준으로 에측한다. (Regression).</td>
  </tr>
</tbody></table>
<p>실제로 그것을 서비스에 곧장 이용하지 않더라도, 간단한 모델로부터 출발하는 것은 좋은 베이스라인이 됩니다. 사실, 간단한 모델은 오히려 생각보다 더 잘 동작할 겁니다. 단순한 모델은 모델이 제대로 정의되었는지 판단하기 훨씬 쉽습니다. 반면, 복잡한 모델은 훈련시키기도, 이해하기도 훨씬 더 어렵고 느립니다. 그러니 성능을 충분히 향상시킬 정도로 트레이드오프를 갖추지 않는 이상은 이를 단순하게 유지하는 편이 더 좋습니다.</p>
<blockquote>
<p><strong>주의</strong>: 대부분의 ML은 데이터 쪽에 있습니다. 복잡한 모델에 대한 전체 파이프라인을 실행하는 것은 모델 자체를 반복하는 것보다 어렵습니다.</p>
</blockquote>
<img src="https://developers.google.com/machine-learning/problem-framing/images/Barchart.svg?hl=ko">
<p>ML 도입 시에 가장 이득이 큰 시점은 데이터를 처음으로 활용하여 모델을 구축해냈을 때입니다. 추가적인 조정은 여전히 성능의 향상을 일으키지만, 일반적으로 가장 큰 이득을 얻는 시점은 시작점에 있으므로 프로세스를 더 쉽게 만들기 위해 잘 테스트된 방법을 고르는 것이 좋습니다.</p>
<h2 id="데이터-소스를-정의하라"><a class="header" href="#데이터-소스를-정의하라">데이터 소스를 정의하라.</a></h2>
<p>우리의 데이터 레이블에 대해 다음의 질문에 답해봅시다.</p>
<ul>
<li>레이블링된 데이터를 얼마나 많이 갖고 있나?</li>
<li>레이블의 출처가 어디인가?</li>
<li>해당 레이블은 내리고자 하는 결정과 긴밀하게 연관되어 있는가?</li>
</ul>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>우리의 데이터 셋은 인기도 데이터 및 영상 설명과 함께 과거에 업로드 된 영상에 대한 100,000 개의 예제로 구성되어 있다.</td>
  </tr>
</tbody></table>
<h2 id="모델에-사용할-데이터를-디자인하라"><a class="header" href="#모델에-사용할-데이터를-디자인하라">모델에 사용할 데이터를 디자인하라.</a></h2>
<p>ML 시스템이 의사 결정을 내리기 위해 사용할 데이터를 정의해야 합니다. (input =&gt; output)</p>
<table class="green" label="Example of table with data from a video sharing site.">
  <tbody><tr><th>Title</th><th>Channel</th><th>Upload Time</th><th>Uploader's Recent
    Videos</th><th>Output (label)</th></tr>
  <tr><td>My silly cat</td><td>Alice</td><td>2018-03-21 08:00</td><td>Another cat
    video, yet another cat</td><td>Very popular</td></tr>
  <tr><td>A snake video</td><td>Bob</td><td>2018-04-03 12:00</td><td>None
    </td><td>Not popular</td></tr>
</tbody></table>
<p>각각의 행(row)은 하나의 예측이 수행될 하나의 데이터가 됩니다. 예측이 이루어지는 순간에 사용할 수 있는 정보만을 포함합니다. 각 input은 스칼라 또는 정수/실수/바이트/문자열 등으로 구성된 1차원 리스트가 될 수 있습니다.</p>
<p>만약, input이 1차원 리스트가 아닌 경우, 해당 데이터를 가장 잘 나타낼 방법에 대해 고려해야 합니다. 예를 들자면 :</p>
<ul>
<li>한 input이 사실 상 서로 다른 둘 이상의 항목을 나타내는 경우, 이를 별도의 input으로 분할할 수 있습니다.</li>
<li>한 input이 중첩된 <a href="https://developers.google.com/protocol-buffers?hl=ko">프로토콜 버퍼</a>를 나타내는 경우, 이들의 각 field를 쪼갤 수 있습니다.</li>
<li>예외 : 오디오, 이미지, 영상 데이터.. (blob of bytes)</li>
</ul>
<table class="blue">
  <tbody><tr><th>Tips for audio/image/video data</th><th>Examples</th></tr>
  <tr>
    <td>There may not be explicit inputs.</td>
    <td>The only inputs may be the bytes for the audio/image/video.</td>
  </tr>
    <tr>
    <td>There may be metadata accompanying the image.</td>
    <td>Compression format, object bounding boxes, source</td>
  </tr>
  <tr>
    <td>Your outputs may be simplified for an initial implementation.</td>
    <td>Rather than doing bounding-box object detection, you may create a simple
      binary classifier that learns whether one type of object is present in the
      image or not.</td>
  </tr>
</tbody></table>
<h2 id="어디서-데이터가-올지-결정하라"><a class="header" href="#어디서-데이터가-올지-결정하라">어디서 데이터가 올지 결정하라.</a></h2>
<p>하나의 행(row)를 구성하기 위해 각 열(column)에 들어갈 값을 만들어줄 데이터 파이프라인을 개발하는 데 얼마나 많은 작업이 필요할지 평가해보세요. 예제 출력을 얻기 어려운 경우, 출력을 다시 고려하여 모델에 다른 출력을 사용할 수 있는지의 여부를 조사해볼 수 있습니다.</p>
<p>모든 입력이 예측 시에 정확히 작성한 형태로 사용할 수 있는지 확인하세요. 예측 시점에 특정한 feature 값을 얻는 것이 어렵다고 판단된다면 해당 특성을 생략해야 합니다.</p>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>We applied the labels <code translate="no" dir="ltr">{very popular,<wbr> somewhat popular,<wbr>
      not popular}</code> to each video that fell within a determined range of
      views and "thumbs ups" and determined keyword descriptions for each video.
      Hand-generating descriptions is not sustainable, so we are considering
      adding a keyword description to the upload form.</td>
  </tr>
</tbody></table>
<h2 id="쉽게-얻을-수-있는-입력을-결정하라"><a class="header" href="#쉽게-얻을-수-있는-입력을-결정하라">쉽게 얻을 수 있는 입력을 결정하라.</a></h2>
<p>얻기 쉽고, 합리적인 초기 결과를 얻을 수 있을 거라고 판단되는 1-3개의 입력을 선택하세요.</p>
<p>이전에 언급했던 휴리스틱을 구현하는 데 어떤 입력이 유용할까요?</p>
<p>input들을 준비하기 위해 데이터 파이프라인을 개발하는데 드는 엔지니어링 비용과, 모델에 각 input들을 가짐에 따라 예상되는 이득을 고려하세요. 간단한 파이프라인으로 단일 시스템에서 손쉽게 얻을 수 있는 입력에 중점을 두세요. 가능한 최소의 인프라로 시작하세요.</p>
<h2 id="학습-능력"><a class="header" href="#학습-능력">학습 능력</a></h2>
<p>우리 ML 모델이 과연 학습할 수 있을까요? 학습에 어려움을 줄 수 있을 것 같은 문제들을 나열해보세요. 예를 들어:</p>
<ul>
<li>데이터 셋에 충분한 양의 레이블이 포함되어 있지 않을 수 있습니다.</li>
<li>훈련 데이터에 충분한 예제가 없을 수 있습니다.</li>
<li>레이블에 노이즈가 너무 많이 끼어있을 수 있습니다.</li>
<li>시스템이 훈련 데이터들을 기억하는 바람에, 새로운 케이스에 일반화시키는 것에 어려움을 겪을 수 있습니다.</li>
</ul>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>The measure "popular" is subjective based on the audience and
        inconsistent across video genres.
        Tastes change over time, so today's "popular" video might
        be tomorrow's "not popular" video.</td>
  </tr>
</tbody></table>
<h2 id="잠재적인-편향에-대해-생각하세요"><a class="header" href="#잠재적인-편향에-대해-생각하세요">잠재적인 편향에 대해 생각하세요.</a></h2>
<p>많은 데이터 셋들은 어떤 방식으로는 <a href="https://developers.google.com/machine-learning/glossary?hl=ko#bias_ethics">편향(bias)</a>를 갖습니다. 이러한 편향은 훈련 및 예측에 부정적인 영향을 끼칠 수 있습니다. 예를 들어:</p>
<ul>
<li>편향된 데이터 소스가 여러 문맥 간에 적절하게 해석되지 않을 수 있습니다.</li>
<li>훈련 데이터 셋이 모델의 최종 이용자를 대표하지 못할 수 있으며, 이에 따라 부정적인 이용자 경험을 유발할 수 있습니다.</li>
</ul>
<table class="green">
  <tbody><tr><th>Example</th></tr>
  <tr>
    <td>Since the measure "popular" is subjective, it is possible that the model
      will serve popular videos that reinforce unfair or biased societal views.
    </td>
  </tr>
</tbody></table><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="crash-course"><a class="header" href="#crash-course">Crash Course</a></h1>
<p>ML 크래쉬 코스</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="framing"><a class="header" href="#framing">Framing</a></h1>
<p>지도 학습(Supervised Learning)이란 무엇일까요? 결론적으로는, 아래를 의미합니다.</p>
<ul>
<li>이전에 보지 못한 데이터에 대해 유용한 예측을 생성하는 방법을 배우는 ML 시스템</li>
</ul>
<h2 id="labels-레이블"><a class="header" href="#labels-레이블">Labels (레이블)</a></h2>
<p><strong>레이블</strong>은 <strong>우리가 예측하려는 것</strong>입니다. 단순 선형 회귀에서 <code>y</code> 변수에 해당하는 것이죠. 레이블에는 다음과 같은 것들이 될 수 있습니다.</p>
<ul>
<li>쌀의 추후 가격 예측</li>
<li>사진에 찍힌 동물의 종류</li>
<li>오디오 클립의 의미</li>
</ul>
<h2 id="features-피쳐"><a class="header" href="#features-피쳐">Features (피쳐)</a></h2>
<p><strong>Feature</strong>는 입력 변수입니다. 단순 선형 회귀에서 <code>x</code> 변수에 해당하는 것입니다.
가장 단순한 형태의 ML 프로젝트는 단 하나의 피쳐만 사용함으로써 이루어집니다.
반면, 엄청 섬세한 형태의 ML 프로젝트는 수십만개의 피쳐가 존재할수도 있죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>스팸 메일 분류기를 예시로 들자면, 피쳐는 아래와 같은 것들이 될 수 있습니다.</p>
<ul>
<li>이메일 텍스트에 들어간 단어들</li>
<li>발신자 주소</li>
<li>이메일이 보내진 시각</li>
<li>&quot;one weird trick&quot; 이라는 문구가 포함되었는지의 여부</li>
</ul>
<h2 id="examples-예시"><a class="header" href="#examples-예시">Examples (예시)</a></h2>
<p><strong>Example</strong>은 데이터의 구체적인 한 예시입니다. <b>x</b>로 표현되기도 합니다. (굵은 글씨로 되었다는 점을 유의하세요.) 이러한 Example은 또 두개로 분류될 수 있습니다.</p>
<ul>
<li>Labeled examples</li>
<li>Unlabeled examples</li>
</ul>
<p>레이블 처리된 예시의 경우 Feature들과 Label을 모두 갖습니다. </p>
<pre><code>labeled examples: {features, label}: (x, y)
</code></pre>
<p>이러한 레이블 처리된 예시들은 모델을 <b>Train(훈련)</b> 시키기 위해 사용됩니다. 우리의 스팸 분류기 예시에서, &quot;스팸인지 아닌지&quot;에 대해 명시되어있는 레이블 처리된 예시들이 곧 레이블 처리된 예시들이 됩니다.</p>
<p>예를 들어, 아래 5줄의 예시로 구성된 테이블은 켈리포니아의 집값 정보를 담고있는 데이터셋입니다.</p>
<table>
  <tbody><tr>
    <th>housingMedianAge<br>(feature)</th>
    <th>totalRooms<br>(feature)</th>
    <th>totalBedrooms<br>(feature)</th>
    <th>medianHouseValue<br>(label)</th>
  </tr>
<tr>
    <td>15</td>
    <td>5612</td>
    <td>1283</td>
    <td>66900</td>
  </tr>
  <tr>
    <td>19</td>
    <td>7650</td>
    <td>1901</td>
    <td>80100</td>
  </tr>
  <tr>
    <td>17</td>
    <td>720</td>
    <td>174</td>
    <td>85700</td>
  </tr>
  <tr>
    <td>14</td>
    <td>1501</td>
    <td>337</td>
    <td>73400</td>
  </tr>
  <tr>
    <td>20</td>
    <td>1454</td>
    <td>326</td>
    <td>65500</td>
  </tr>
</tbody></table>
<p>반면 레이블이 없는 예시의 경우 Feature는 갖고 있지만 Label은 없습니다.</p>
<pre><code>unlabeled examples: {features, ?}: (x, ?)
</code></pre>
<p>아래는 위와 동일한 집값 데이터이지만, Label에 해당하는 <code>medianHouseValue</code>가 존재하지 않습니다.</p>
<table>
  <tbody><tr>
      <th>housingMedianAge<br>(feature)</th>
      <th>totalRooms<br>(feature)</th>
      <th>totalBedrooms<br>(feature)</th>
    </tr>
    <tr>
      <td>42</td>
      <td>1686</td>
      <td>361</td>
    </tr> 
    <tr>
      <td>34</td>
      <td>1226</td>
      <td>180</td>
    </tr>
    <tr>
      <td>33</td>
      <td>1077</td>
      <td>271</td>
    </tr>
  </tbody>
</table>
<p>일단 우리가 레이블 처리된 모델을 훈련시키고 나면, 레이블이 없는 예시들에 대해서도 예측을 수행할 수 있습니다. 스팸 분류기에서 레이블이 없는 데이터는 사람들이 아직 레이블을 처리하지 않은 새로운 이메일이 되겠죠.</p>
<h2 id="models"><a class="header" href="#models">Models</a></h2>
<p><strong>모델</strong>은 Feature와 Label 간의 관계를 의미합니다. 예를 들어, 스팸 분류기 모델은 일부 Feature들은 스팸과 강하게 연관이 있다고 판단할 것입니다. 모델이 사용되는 두 단계에 대해서 살펴봅시다.</p>
<ul>
<li><b>Training(훈련)</b>은 모델을 만들고, <strong>가르치는 것</strong>을 의미합니다. 다시 말해, 모델에게 레이블처리된 예시를 보여주고, 점차 모델에게 Feature와 Label 간의 관계를 가르치는 것입니다.</li>
<li><b>Inference(추론)</b>는 훈련이 완료된 모델을 레이블이 되어있지 않은 예시에 적용함을 의미합니다. 다시 말해, 유용한 예측(<code>y'</code>)을 수행할 수 있는 모델을 사용하는 것이죠. 앞선 경우를 예로 들자면, 레이블이 없는 예시에 대해 집값에 해당하는 Label인 <code>medianHouseValue</code>를 예측하는 것을 의미합니다.</li>
</ul>
<h2 id="regression-vs-classification"><a class="header" href="#regression-vs-classification">Regression vs. Classification</a></h2>
<p>Regression(회귀)는 모델이 연속성을 띄는 값을 예측하는 것을 의미합니다. 예를 들어, 회귀 모델의 경우 아래와 같은 문제들에 대한 답을 예측합니다.</p>
<ul>
<li>켈리포니아의 집값은 얼마일까?</li>
<li>이 광고를 이용자가 클릭할 가능성은 얼마나 될까?</li>
</ul>
<p>Classification(분류)는 모델이 분리된 값에 대한 예측을 하는 것을 의미합니다. 예를 들어, 분류 모델은 아래와 같은 문제들에 대한 답을 예측합니다.</p>
<ul>
<li>수신한 이메일이 스팸일까 아닐까?</li>
<li>사진의 동물은 개일까 고양이일까?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="descending-into-ml"><a class="header" href="#descending-into-ml">Descending into ML</a></h1>
<h2 id="linear-regression"><a class="header" href="#linear-regression">Linear Regression</a></h2>
<p>귀뚜라미가 추운 날보다 더운 날에 더 자주 운다는 것은 익히 알려진 사실입니다. 지난 몇년간, 전문가들과 과학자들은 온도와 귀뚜라미의 울음 주기에 대한 데이터를 수집해왔습니다. 해당 데이터를 통해 둘 간의 상관 관계를 파악해봅시다.</p>
<p>먼저, 플롯을 통해 데이터에 대해 시각적으로 살펴봅시다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/CricketPoints.svg?hl=ko" />
<h4 id="그림-1-분당-울음횟수-vs-섭씨-온도"><a class="header" href="#그림-1-분당-울음횟수-vs-섭씨-온도">그림 1. 분당 울음횟수 vs. 섭씨 온도</a></h4>
<p>예상한 대로, 온도가 올라갈 수록 귀뚜라미의 울음 주기도 많아집니다. 이것이 둘 사이의 상관관계 일까요? 맞습니다. 여기에 하나의 선을 그어 보면 그 관계를 더 뚜렷하게 알 수 있습니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/CricketLine.svg?hl=ko" />
<h4 id="그림-2-선형-관계"><a class="header" href="#그림-2-선형-관계">그림 2. 선형 관계</a></h4>
<p>네, 맞습니다. 선이 모든 점들을 꿰뚫지는 않고 있죠. 하지만 위에 그은 선은 두 변수 간의 상관관계를 뚜렷하게 보여줍니다. 이걸 방정식으로 나타내본다면, 아래와 같은 형태겠죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>는 섭씨 온도입니다. -&gt; 예측하고자 하는 값이죠.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>는 선의 기울기입니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>는 귀뚜라미의 분당 울음 횟수입니다. -&gt; 입력 Feature로 주어지는 값이죠.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>는 y-절편(intercept)입니다.</li>
</ul>
<p>이걸 머신러닝 컨벤션에 따라 작성한다면 약간 다르게 아래와 같은 방정식이 됩니다.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>은 예측된 레이블입니다. (예상되는 결과)</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>는 bias(편향)입니다. 종종 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>로 불리기도 합니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>는 Feature1의 weight(가중치)입니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>은 Feature(피쳐)입니다. (알려진 입력)</li>
</ul>
<p>새로운 분당 귀뚜라미 울음 횟수값인 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대한 온도 예측 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>을 알기 위해서는 단순히 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 값을 위 모델에 집어넣기만 하면 됩니다.</p>
<p>반면, 우리가 지금껏 살펴본 모델은 하나의 Feature만을 갖는 매우 단순한 모델입니다. 실제로 더 복잡한 모델은 더 많은 Feature들에 의존합니다. (<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, ...) 예를 들어, Feature가 3개로 늘어난다면 아래와 같은 모델이 만들어지게 되는거죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="training-and-loss"><a class="header" href="#training-and-loss">Training and Loss</a></h2>
<p>모델을 <strong>훈련</strong>시키는 것은 레이블 처리된 예시들로부터 적절한 가중치(Weight)와 편향(Bias)를 배우게 하는 것을 의미합니다. 지도 학습에서, 머신러닝 알고리즘은 수많은 예시들을 살펴보고 loss(손실)을 줄여나가면서 모델을 완성하게 됩니다. 이러한 과정을 Empirical Risk Minimization(경험적 위험 최소화)라고 합니다.</p>
<p>loss는 좋지 않은 예측을 한 경우에 대한 페널티와 같은 개념입니다. 즉, <strong>loss</strong>는 하나의 예시에 대한 모델의 예측이 <b>얼마나 별로였나?</b>를 나타내는 값이죠. 만약 모델의 예측이 완벽했다면, loss는 0이 됩니다. 모델을 훈련시키는 것의 목적은 모든 예시에서 평균적으로 loss를 갖도록 하는 여러 가중치들과 편향을 찾아나가는 것입니다. 예를 들어, 아래의 그림3은 좌측에 loss가 큰 모델과 우측의 loss가 적은 모델을 각각 그래프로 나타내고 있습니다.</p>
<ul>
<li>화살표선은 loss를 나타냅니다.</li>
<li>파란색 선은 prediction을 의미합니다.</li>
</ul>
<img src="https://developers.google.com/machine-learning/crash-course/images/LossSideBySide.png?hl=ko" >
<h4 id="그림3-loss가-큰-왼쪽-모델-loss가-작은-오른쪽-모델"><a class="header" href="#그림3-loss가-큰-왼쪽-모델-loss가-작은-오른쪽-모델">그림3. loss가 큰 왼쪽 모델; loss가 작은 오른쪽 모델.</a></h4>
<p>왼쪽의 각 화살표선들이 오른쪽의 각 화살표선보다 훨씬 길다는 것을 유의하세요. 이런 경우, 우측 모델이 명백히 <strong>더 나은 모델</strong>이 됩니다.</p>
<p>이쯤 되면 수학적으로 어떻게 loss를 계산하는지에 대한 <b>Loss Function(손실 함수)</b>가 궁금할 겁니다.</p>
<h3 id="squared-loss-가장-인기있는-손실-함수"><a class="header" href="#squared-loss-가장-인기있는-손실-함수">Squared Loss: 가장 인기있는 손실 함수</a></h3>
<p>우리가 살펴볼 손실 함수는 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> loss 라고도 알려진 Squared Loss입니다. 이건 식으로 나타내자면 아래와 같습니다. <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>는 실제 Label의 값을, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>은 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>에 대한 예측값 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>을 의미합니다.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>평균제곱오차(Mean Square Error: MSE)는 전체 데이터셋의 각각에 대한 Squared Loss의 평균입니다. MSE를 계산하려면, 각각의 예시에 대한 Squared Loss를 전부 더하고, 예시의 갯수만큼 나누어주면 되죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">MSE</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.8374449999999998em;vertical-align:-1.516005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 는 아래를 의미합니다.
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>는 모델의 예측에 사용될 Feature들의 집합입니다. (ex. 분당 귀뚜라미 울음 횟수, 나이, 성별..)</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>는 예시의 Label입니다. (ex. 온도)</li>
</ul>
</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">re</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>는 여러 개의 Feature <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>와 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>), 편향(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>)의 조합으로 이루어진 함수입니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>는 레이블 처리 된 많은 예시들을 담고 있는 데이터셋입니다. 이는 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>의 쌍으로도 나타낼 수 있습니다.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>은 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>에 속하는 데이터 예시들의 갯수입니다.</li>
</ul>
<p>MSE는 머신러닝에서 일반적으로 사용되기는 하지만, 모든 상황에서 유일하게 사용되는 최상의 손실 함수는 아닙니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="reducing-loss"><a class="header" href="#reducing-loss">Reducing Loss</a></h1>
<h2 id="an-iterative-approach"><a class="header" href="#an-iterative-approach">An Iterative Approach</a></h2>
<p>이전 챕터에서는 loss에 대한 개념을 살펴봤습니다. 그렇다면 이번에는 어떻게 ML 모델이 loss를 반복적으로 줄여나갈 수 있는지에 대해 배워봅시다.</p>
<p>반복 학습(Iterative learning)은 흔히 하는 업앤다운 게임과 유사합니다. 여기서 정답이 되는 숫자를 찾는게 곧 최고의 모델이 되는거죠. 우리가 임의로 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)값을 추측하면 모델 시스템이 이에 따른 loss값이 얼마인지 알려줄겁니다. 그러면 이제 또다른 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)값을 추측하고, 또 이에 따른 loss값을 전달받죠. 이런식으로 진행해나가면서 가장 최적의 가중치를 찾는 것이 곧 최선의 모델을 찾는 방법입니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentDiagram.svg?hl=ko">
<h4 id="그림-1-모델-학습에-대한-반복적-접근iterative-approach-방식"><a class="header" href="#그림-1-모델-학습에-대한-반복적-접근iterative-approach-방식">그림 1. 모델 학습에 대한 반복적 접근(Iterative approach) 방식</a></h4>
<p>우리는 이번 ML코스 내내 이러한 접근 방식을 사용할 겁니다. 반복 전략은 대규모 데이터셋에 적합하도록 확장되기 때문에 머신러닝에서 널리 사용됩니다.</p>
<p>모델은 하나 이상의 Feature를 입력으로 받아, 하나의 예측(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>)을 결과로 반환합니다. 간단히 말해, 하나의 Feature를 받아 하나의 Prediction을 만들어내는 모델은 아래와 같은 형태죠.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>위의 식에서 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에는 무엇이 들어가야 할까요? 선형 회귀 문제에 있어서 사실 이는 그다지 중요하지 않은 것으로 나타났습니다. 임의의 값을 선택해도 되지만, 아래와 같은 값을 사용해보겠습니다.</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ul>
<p>처음으로 Feature에 대한 가중치 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>을 10이라고 해봅시다. 그러면 아래와 같은 예측이 나옵니다.</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">10</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>위 다이어그램에서 &quot;loss를 계산한다&quot;는 것은 곧 해당 모델이 사용할 손실함수를 통한 계산값입니다. 우리가 만약 Squared loss 함수(제곱 손실함수)를 사용하기로 정했다면, 아래와 같은 두가지 입력을 손실함수가 요구할겁니다.</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>: Feature x에 대한 모델의 예측</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> : Feature x에 대한 실제 label</li>
</ul>
<p>마지막으로 위 다이어그램에서 &quot;파라미터 갱신값을 계산한다&quot;는 부분을 살펴봅시다. 이 부분에서 ML 시스템이 손실 함수의 값을 검사하고, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대한 새로운 값을 생성해냅니다. 지금은 이 신비한 상자가 새로운 값을 고안한 다음 ML 시스템이 모든 레이블에 대한 모든 Feature들을 재평가하여 손실 함수에 대한 새로운 값을 산출해내고, 새로운 매개변수 값을 산출해낸다는 것만 이해하세요. 그리고 학습은 알고리즘이 가능한 최소의 loss값을 갖게끔 하는 모델에 대한 파라미터를 발견해낼 때까지 계속됩니다. 일반적으로, 이는 전체 loss가 변경되지 않거나, 극적으로 느리게 변경될 때까지 반복됩니다. 여기에 도달한 경우, 우리는 모델이 <b>수렴했다(converged)</b>고 말합니다.</p>
<blockquote>
<p><strong>요약!</strong> : 머신러닝 모델은 임의의 가중치(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>)와 편향(<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">bia</span><span class="mord mathnormal">s</span></span></span></span>)으로부터 시작하여 최대한 낮은 loss를 갖게될 때까지 반복적으로 가중치와 편향을 조정해나가며 학습합니다.</p>
</blockquote>
<h2 id="gradient-descent"><a class="header" href="#gradient-descent">Gradient Descent</a></h2>
<p>위쪽에서 ML 시스템이 loss를 줄이기 위해 가중치와 편향을 조정해나간다는 것은 이해했지만, 구체적으로 그것이 어떻게 이루어지는지에 대해서 아직 우리는 다루지 않았습니다.</p>
<p>가능한 모든 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>값에 대한 손실을 계산할 시간과 컴퓨팅 자원이 충분하다고 가정합시다. 우리가 다루는 회귀 문제의 경우 loss와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대해 그림을 그려보면 이는 항상 볼록합니다. 다시 말해, 이는 항상 그릇과 같은 모양이 되죠.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/convex.svg?hl=ko">
<h4 id="그림-2-회귀-문제에-대한-loss-vs-가중치-플롯"><a class="header" href="#그림-2-회귀-문제에-대한-loss-vs-가중치-플롯">그림 2. 회귀 문제에 대한 loss vs. 가중치 플롯</a></h4>
<p>이러한 경우에는 항상 유일한 최솟값을 갖게됩닌다. 즉, 어디 한 군데는 정확히 기울기가 0인 지점이 존재하죠. 그리고 그 최솟값이 되는 지점이 손실 함수가 수렴하는 부분이 됩니다.</p>
<p>전체 데이터셋에 대해 생각할 수 있는 모든 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 값에 대해 손실함수를 계산하는 것은 수렴하는 지점을 찾는 비효율적인 방법입니다. 그것보다는, 머신러닝에서 매우 널리 사용되는 <b>경사하강법(Gradient Descent)</b>이라는 매커니즘을 배워봅시다.</p>
<p>경사하강법은 처음에 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>에 대한 시작점에서부터 출발합니다. 시작점은 사실 중요하지 않습니다. 그렇기 때문에 많은 알고리즘은 이를 0 또는 랜덤한 숫자로부터 시작합니다. 아래 플롯에서는 0보다 약간 더 큰 값으로부터 출발해보겠습니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentStartingPoint.svg?hl=ko">
<h4 id="그림-3-경사하강법에-대한-시작점"><a class="header" href="#그림-3-경사하강법에-대한-시작점">그림 3. 경사하강법에 대한 시작점</a></h4>
<p>경사하강법 알고리즘은 시작점에 대한 loss 곡선의 경사를 계산합니다. 그림 3에서, loss의 경사는 곧 곡선의 기울기를 의미하고, 이 기울기가 값을 얼마나 조정해야하는지에 대한 정보가 됩니다. 만약 가중치가 여러 개가 된다면, 기울기는 가중치에 대한 도함수의 벡터가 됩니다.</p>
<p>경사가 하나의 벡터를 이룬다는 점을 기억하세요. 이는 곧 다음의 특징을 갖습니다.</p>
<ul>
<li>방향(direction)</li>
<li>크기(magnitude)</li>
</ul>
<p>경사는 항상 손실 함수 상에서 가장 가파른 증가 방향을 가리킵니다. 경사하강 알고리즘은 loss를 최대한 빨리 줄이기 위해 <strong>음의 기울기 방향</strong>으로 단계를 진행해나갑니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentNegativeGradient.svg?hl=ko" >
<h4 id="그림-4-경사-하강은-음의-기울기에-의존합니다"><a class="header" href="#그림-4-경사-하강은-음의-기울기에-의존합니다">그림 4. 경사 하강은 음의 기울기에 의존합니다.</a></h4>
<p>손실 함수 곡선을 따라 다음 지점을 결정하기 위해, 경사 하강 알고리즘은 아래 그림과 같이 시작점에서 기울기 크기의 일부만큼 더합니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/GradientDescentGradientStep.svg?hl=ko" >
<h4 id="그림-5-기울기-step은-손실-곡선의-다음-지점으로-이동합니다"><a class="header" href="#그림-5-기울기-step은-손실-곡선의-다음-지점으로-이동합니다">그림 5. 기울기 step은 손실 곡선의 다음 지점으로 이동합니다.</a></h4>
<p>경사 하강법은 이러한 과정을 반복해 나가면서 최소값에 점점 더 가까워지는 과정입니다.</p>
<blockquote>
<p><strong>노트</strong>: 경사하강법을 수행할 때는, 위의 과정을 일반화하여 모든 모델의 파라미터를 <em>동시에</em> 조정합니다. 예를 들어, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>과 편향 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>의 최적값을 찾기 위해 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>과 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 모두에 대한 기울기를 계산하죠. 그 다음 각각의 기울기에 따라 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>와 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>의 값을 수정합니다. 그 다음 최소 손실에 도달할 때까지 이 단계를 반복해나갑니다.</p>
</blockquote>
<h2 id="learning-rate"><a class="header" href="#learning-rate">Learning Rate</a></h2>
<p>앞서 살핀대로, 경사 벡터는 방향과 크기를 모두 갖습니다. 경사 하강 알고리즘은 기울기에 <b>학습률(Learning rate)</b>라는 스칼라를 곱해서 다음 지점을 결정합니다. 예를 들어, 경사의 크기가 2.5고, 학습률이 0.01이라면, 경사 하강 알고리즘은 이전 지점에서 0.025만큼 떨어진 다음 지점으로 진행합니다.</p>
<p><b>하이퍼 파라미터(Hyperparameter)</b>는 프로그래머가 직접 머신러닝 알고리즘 상에서 조정하는 값입니다. 대부분의 머신러닝 프로그래머는 이 학습률을 조정하는데에 대부분의 시간을 할애합니다. </p>
<p>만약 너무 작은 학습률을 선택하게 되면 시간이 너무 오래 걸리죠.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/LearningRateTooSmall.svg?hl=ko">
<h4 id="그림-6-학습률이-너무-작은-경우"><a class="header" href="#그림-6-학습률이-너무-작은-경우">그림 6. 학습률이 너무 작은 경우</a></h4>
<p>반대로, 학습률을 너무 크게 정했을 경우, 다음 지점은 저만치 멀리 가버리기 때문에 수렴하기가 어렵습니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/LearningRateTooLarge.svg?hl=ko">
<h4 id="그림-7-학습률이-너무-큰-경우"><a class="header" href="#그림-7-학습률이-너무-큰-경우">그림 7. 학습률이 너무 큰 경우</a></h4>
<p>모든 회귀 문제에는 <b>골디락스(Goldilocks)</b> 학습률이 존재합니다. 골디락스 값은 손실 함수가 얼마나 평평한지와 관련됩니다. 만약 손실 함수의 기울기가 작다는 것을 알고 있다면, 더 큰 학습률을 안전하게 시도하여 더 빠른 시간 내에 최소값에 도달할 수 있게 됩니다.</p>
<img src="https://developers.google.com/machine-learning/crash-course/images/LearningRateJustRight.svg?hl=ko">
<h4 id="그림-8-학습률이-적절한-경우"><a class="header" href="#그림-8-학습률이-적절한-경우">그림 8. 학습률이 적절한 경우</a></h4>
<blockquote>
<p>학습률에 대해 : 1차원에서 이상적인 학습률은 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(x에서 f(x)의 2차 도함수의 역)입니다. 2차원 이상에 대한 이상적인 학습률은 Hessian(2차 편도함수의 행렬)의 역입니다. 일반적인 볼록 함수에 대해서는 훨씬 더 복잡합니다.</p>
</blockquote>
<h2 id="stochastic-gradient-descent-확률적-경사하강법"><a class="header" href="#stochastic-gradient-descent-확률적-경사하강법">Stochastic Gradient Descent (확률적 경사하강법)</a></h2>
<p>경사하강법에서, <b>배치(Batch)</b>란 한 번의 반복에서 경사를 계산하기 위해 사용하는 예시(example)들의 갯수입니다. 지금껏 우리는 이 배치가 전체 데이터셋이 되는 것 처럼 이야기했지만, 구글의 경우 이 &quot;전체 데이터셋&quot;은 말도 안되게 큰 수치입니다. 게다가 구글 데이터는 Feature의 개수도 엄청나게 많죠. 결국, 한 배치가 너무 과대할 수 있습니다. 배치가 너무 크다면 한번의 반복이라고 해도 매우 오랜 시간이 걸릴 수 있습니다.</p>
<p>예시들 사이에서 랜덤하게 샘플링된 대규모 데이터셋에는 중복 데이터가 포함될 수 있습니다. 실제로 배치 크기가 그다면 중복 가능성이 커집니다. 일부 중복성은 노이즈가 심한 경사를 좀 더 부드럽게 만드는데 유용하지만, 너무 과대한 배치에서는 그다지 유용하지 않습니다.</p>
<p>훨씬 적은 계산을 통해 평균적으로 올바른 경사를 얻을 수 있다면 어떨까요? 데이터셋에서 무작위로 예시를 고르는 것은 훨씬 작은 데이터셋으로부터 큰 평균을 예측할 수 있도록 합니다. <b>확률적 경사하강법(SGD)</b>는 이 아이디어를 극단적으로 활용합니다. 한 반복 당 하나의 예시만 사용하는 것이죠.(배치 크기가 1) 충분한 반복이 주어진다면야 SGD는 올바르게 작동하지만, 매우 노이즈가 많다는 문제가 있습니다. &quot;확률적&quot;이라는 말은 각 배치를 구성하는 하나의 예시가 무작위로 선택됨을 나타내죠.</p>
<p><b>미니배치 확률적 경사 하강법(mini-batch SGD)<b>는 전체 데이터셋에 대한 반복과 SGD 간의 절충안입니다. 미니 배치는 일반적으로 10개에서 1000개 사이의 예시를 가지며, 이는 무작위로 선택됩니다. 미니 배치 SGD는 SGD의 노이즈 양을 줄이지만, 여전히 전체 배치에 대한 반복보다는 효율적으로 동작합니다.</p>
<p>설명을 쉽게 하기 위해서, 우리는 단일 Feature에 대한 경사 하강법만을 언급했습니다. 경사 하강법은 여러 Feature들을 갖는 경우에도 제대로 동작하니 안심하셔도 됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="iam"><a class="header" href="#iam">IAM</a></h1>
<ul>
<li>IAM = Identity and Access Management</li>
<li>글로벌 서비스에 해당함. (별도로 지역이 정의되어 있지 않다.)</li>
<li>기본적으로는 계정 생성 시에 **루트 계정(Root account)**이 생성된다.
<ul>
<li>루트 계정은 AWS 리소스에 대한 모든 권한을 갖는다.</li>
<li>하지만, 모든 권한을 갖는 만큼, 위험하기 때문에 루트 계정은 당장에 계정 세팅이 필요한 경우에만 사용하고, 그 이후에는 이용하거나 공유하지 말아야 한다.</li>
</ul>
</li>
<li>루트 계정을 사용하는 대신, **유저(User)**를 만들어 주어야 하는데, 이는 한 조직 내 하나의 이용자를 가리키며, 그룹에 속할 수 있다.</li>
<li>**그룹(Group)**은 오직 유저만 포함할 수 있으며, 다른 그룹은 포함할 수 없다.</li>
<li>유저가 꼭 하나의 그룹에 속해야 할 필요는 없으며, 동시에 여러 개의 그룹에 속하는 것도 가능하다.</li>
</ul>
<pre><code>// example
Group: Developers
  - Alice
  - Bob
  - Charles

Group: Operations
  - David
  - Edward

Group: Audit Team
  - Charles
  - David

User: (아무 그룹에도 속하지 않음)
  - Fred 
</code></pre>
<h2 id="권한-permissions"><a class="header" href="#권한-permissions">권한 (Permissions)</a></h2>
<ul>
<li><strong>유저</strong>와 <strong>그룹</strong>은 **정책(Policy)**이라고 불리는 JSON 문서로 할당될 수 있다.</li>
<li>**정책(Policy)**은 곧 유저들이 갖춘 권한을 의미한다.</li>
<li>AWS에서는 Least Privilege Principle (최소 권한의 원칙)을 적용하는데, 이는 곧 &quot;이용자가 필요한 것 이상으로 권한을 부여하지 않음&quot;을 의미한다.</li>
</ul>
<h3 id="정책-policy-구조"><a class="header" href="#정책-policy-구조">정책 (Policy) 구조</a></h3>
<pre><code class="language-JSON">// EC2 정책에 대한 예시
{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Action&quot;: [
                &quot;ec2:AttachVolume&quot;,
                &quot;ec2:DetachVolume&quot;
            ],
            &quot;Resource&quot;: [
                &quot;arn:aws:ec2:*:*:volume/*&quot;,
                &quot;arn:aws:ec2:*:*:instance/*&quot;
            ],
            &quot;Condition&quot;: {
                &quot;ArnEquals&quot;: {&quot;ec2:SourceInstanceARN&quot;: &quot;arn:aws:ec2:*:*:instance/instance-id&quot;}
            }
        }
    ]
}
</code></pre>
<ul>
<li>Version : 정책 언어의 버전, 거의 대부분 <code>2012-10-17</code>이 된다.</li>
<li>Id : 정책에 대한 구분 명칭 (선택)</li>
<li>Statement : 하나 이상의 독립적인 Statement (<strong>필수</strong>)
<ul>
<li>Sid : Statement에 대한 구분 명칭 (선택)</li>
<li>Effect : 특정 api 접근에 대한 허용/거부에 대한 여부 (Allow/Deny)</li>
<li>Principal : 해당 정책이 적용될 계정(account)/유저(user)/역할(role)</li>
<li>Action : 해당 정책이 허용하거나 거절할 액션 목록</li>
<li>Resource : 액션이 적용될 리소스의 목록</li>
<li>Condition : 해당 정책이 적용되는 조건 (선택)</li>
</ul>
</li>
</ul>
<h2 id="password-policy-패스워드-정책"><a class="header" href="#password-policy-패스워드-정책">Password Policy (패스워드 정책)</a></h2>
<ul>
<li>강력한 패스워드 = 계정에 대해 더 강력한 보안</li>
<li>AWS에서는 패스워드 정책을 갖추도록 할 수 있다.
<ul>
<li>패스워드 최소 길이</li>
<li>특정 타입의 문자 요구 ~ 대/소문자, 숫자, 특수문자 등...</li>
<li>IAM 유저가 패스워드를 본인 임의로 수정할 수 있도록 허용</li>
<li>유저가 특정 기간 이후 패스워드를 변경하도록 요구 (password expiration)</li>
<li>동일한 패스워드를 재사용할 수 없도록 함</li>
</ul>
</li>
</ul>
<h2 id="mfa--multi-factor-authentication"><a class="header" href="#mfa--multi-factor-authentication">MFA ~ Multi Factor Authentication</a></h2>
<ul>
<li>MFA = 알고 있는 패스워드 + 보유한 특정 보안 기기</li>
<li>패스워드와 MFA 토큰을 조합하여 로그인하도록 함</li>
<li><strong>패스워드를 도용당하더라도, 계정은 보호할 수 있음</strong></li>
<li>이용 가능한 MFA 디바이스 옵션
<ul>
<li>Virtual MFA devices ~ Google Authenticator, Authy, 등...
<ul>
<li>하나의 디바이스에 여러 토큰을 사용</li>
</ul>
</li>
<li>Universal 2nd Factor (U2F) Security Key ~ YubiKey
<ul>
<li>하나의 보안 키로 여러 루트 계정과 IAM 이용자들을 지원</li>
</ul>
</li>
<li>Hardware Key Fob MFA Device</li>
<li>Hardware Key Fob MFA Device for AWS GovCloud</li>
</ul>
</li>
</ul>
<h2 id="aws에-접근하는-여러가지-방법"><a class="header" href="#aws에-접근하는-여러가지-방법">AWS에 접근하는 여러가지 방법</a></h2>
<ul>
<li>AWS Management Console ~ 패스워드 및 MFA로 보호</li>
<li>AWS CLI (Command Line Interface) - Access Key로 보호</li>
<li>AWS SDK (Software Developer Kit) - Access Key로 보호</li>
</ul>
<h3 id="access-key"><a class="header" href="#access-key">Access Key</a></h3>
<ul>
<li>액세스 키는 AWS Console을 통해 생성</li>
<li>유저는 각자 본인의 Access key를 관리하게 됨</li>
<li><strong>Access Key는 패스워드와 마찬가지로, 비밀리에 관리되어야 하며, 공유해선 안된다.</strong></li>
<li>Access Key ID ~= username</li>
<li>Secret Access Key ~= password</li>
</ul>
<h2 id="aws-cli-"><a class="header" href="#aws-cli-">AWS CLI ?</a></h2>
<ul>
<li>AWS 서비스를 커맨드라인 셸을 통해 상호작용할 수 있게끔 하는 툴</li>
<li>AWS 서비스의 퍼블릭 api에 직접 접근할 수 있으며, 리소스들을 관리하는 별도의 스크립트를 작성할 수도 있다.</li>
<li>오픈 소스이며, AWS 관리 콘솔 대신 사용할 수도 있다.</li>
</ul>
<h2 id="aws-sdk-"><a class="header" href="#aws-sdk-">AWS SDK ?</a></h2>
<ul>
<li>특정 언어로 사용할 수 있는 API</li>
<li>AWS 서비스를 프로그래밍적인 방식으로 접근 및 관리할 수 있음</li>
<li>애플리케이션 자체에 포함될 수 있다.</li>
<li>지원
<ul>
<li>SDKs, Mobile SDKs, IoT Device SDKs...</li>
</ul>
</li>
<li>Ex.) AWS CLI 자체가 AWS SDK for Python으로 작성된 것이다.</li>
</ul>
<h2 id="aws-cloudshell"><a class="header" href="#aws-cloudshell">AWS CloudShell</a></h2>
<ul>
<li>AWS CLI가 탑재된 브라우저 기반의 셸</li>
<li>아직은 지역에 따라 지원 여부가 다름 (서울은 안 됨)</li>
</ul>
<h2 id="iam-roles-for-services"><a class="header" href="#iam-roles-for-services">IAM Roles for Services</a></h2>
<ul>
<li>일부 AWS 서비스는 특정한 동작을 수행할 필요가 있다.</li>
<li>이를 위해서, 이러한 AWS 서비스들이 이에 대한 권한을 가져야 하는데, 이것을 <strong>IAM Roles</strong>를 통해서 부여할 수 있다.</li>
<li>일반적인 Roles:
<ul>
<li>EC2 Instance Roles</li>
<li>Lambda Function Roles</li>
<li>Roles for CloudFormation</li>
</ul>
</li>
</ul>
<h2 id="iam-security-tools"><a class="header" href="#iam-security-tools">IAM Security Tools</a></h2>
<ul>
<li>IAM Credentials Report (account-level)
<ul>
<li>루트 계정에 속한 모든 유저와 그들의 증명에 대한 다양한 상태에 대한 리포트</li>
</ul>
</li>
<li>IAM Access Advisor (user-level)
<ul>
<li>한 유저에게 부여된 서비스 권한 및 그 유저가 접근한 서비스에 대해 보여줌</li>
<li>정책을 개정하는 데 있어 해당 정보를 활용할 수 있음 (권한을 늘리거나 줄임)</li>
</ul>
</li>
</ul>
<h2 id="iam-guidelines--best-practices"><a class="header" href="#iam-guidelines--best-practices">IAM Guidelines &amp; Best Practices</a></h2>
<ul>
<li>AWS 계정 설정을 위한 경우를 제외하고는 루트 계정을 사용하지 말 것</li>
<li>한 명의 실제 이용자 = 하나의 AWS User</li>
<li>여러 유저를 Group에 할당하고, 해당 그룹에 Permission을 부여함</li>
<li>강력한 패스워드 정책을 사용</li>
<li>MFA를 사용</li>
<li>AWS 서비스에 권한을 부여하기 위해 Role을 사용</li>
<li>프로그래밍적인 방식의 접근을 위해서는 Access Key를 사용 (CLI / SDK)</li>
<li>IAM Credentials Report를 사용해 계정 권한을 점검</li>
<li><strong>IAM 유저 및 Access Key는 절대 공유되어선 안됨</strong></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>Users: AWS 콘솔에 접근할 수 있는 이용자, password 부여</li>
<li>Groups: 여러 User들이 포함</li>
<li>Policies: 유저 및 그룹에 대한 권한에 대해 설명하는 JSON 문서</li>
<li>Roles: EC2와 같은 AWS 서비스에 부여하는 권한</li>
<li>Security: MFA + Password Policy</li>
<li>Access Keys: AWS CLI or SDK에 사용되는 접근 키</li>
<li>Audit: IAM Credential Reports &amp; IAM Access Advisor</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ec2"><a class="header" href="#ec2">EC2</a></h1>
<ul>
<li>EC2 = Elastic Compute Cloud = Infrastructure as a Service (IaaS)</li>
<li>EC2는 단순한 하나의 서비스일 뿐 아니라, 더 많은 서비스로 조합된다.
<ul>
<li>Virtual machine 대여 (EC2)</li>
<li>Virtual drive 내 데이터 저장 (EBS)</li>
<li>Virtual machin 간의 로드 분산 (ELB)</li>
<li>Auto-scaling group을 사용하는 서비스의 스케일링 (ASG)</li>
</ul>
</li>
<li>EC2의 이해는 곧 클라우드의 동작 방식을 이해하는 것의 기초가 된다.</li>
</ul>
<h2 id="sizing--configuration"><a class="header" href="#sizing--configuration">Sizing &amp; Configuration</a></h2>
<ul>
<li>운영 체제 (OS): Linux, Windows or MacOS</li>
<li>CPU</li>
<li>RAM</li>
<li>저장 공간
<ul>
<li>네트워크 결합 스토리지 : EBS &amp; EFS</li>
<li>하드웨어 : EC2 Instance Store</li>
</ul>
</li>
<li>Network card: 카드 속도 및 퍼블릭 IP 주소</li>
<li>Firewall Rules : Security group</li>
<li>Bootstrap script (최초 실행 시의 설정): EC2 User Data</li>
</ul>
<h3 id="ec2-user-data"><a class="header" href="#ec2-user-data">EC2 User Data</a></h3>
<ul>
<li>EC2 User data 스크립트를 통해 인스턴스를 부트스트랩(bootstrap)할 수 있다.</li>
<li>스크립트는 인스턴스가 최초 실행될 때 단 한번만 실행된다.</li>
<li>다음과 같은 부트 시의 작업을 자동화할 수 있다.
<ul>
<li>업데이트 설치</li>
<li>소프트웨어 설치</li>
<li>인터넷으로부터 파일 설치</li>
<li>생각하는 뭐든지!</li>
</ul>
</li>
<li>EC2 User Data는 root user로 실행된다. (즉, 모든 권한을 갖는다.)</li>
</ul>
<h2 id="ec2-instance-types"><a class="header" href="#ec2-instance-types">EC2 Instance Types</a></h2>
<ul>
<li>EC2에는 여러 유스케이스에 적용될 수 있는 다양한 타입의 EC2 인스턴스가 존재한다.</li>
<li>네이밍 컨벤션이 존재한다.</li>
</ul>
<blockquote>
<p>m5.2xlarge</p>
<ul>
<li>m : 인스턴스 클래스</li>
<li>5 : 세대 (AWS 측에서 시간이 지남에 따라 이를 향상시킴)</li>
<li>2xlarge : 인스턴스 클래스 내 사이즈</li>
</ul>
</blockquote>
<h3 id="instance-types---general-purpose-txx-mxx"><a class="header" href="#instance-types---general-purpose-txx-mxx">Instance Types - General Purpose (Txx, Mxx)</a></h3>
<ul>
<li>웹 서버 또는 코드 저장소와 같이 다양한 작업 상황에서 활용할 수 있음</li>
<li>다음의 각각을 적절히 고려한 밸런스형 인스턴스 타입
<ul>
<li>Compute</li>
<li>Memory</li>
<li>Network</li>
</ul>
</li>
</ul>
<h3 id="instance-types---compute-optimized-cxx"><a class="header" href="#instance-types---compute-optimized-cxx">Instance Types - Compute Optimized (Cxx)</a></h3>
<ul>
<li>높은 성능의 프로세서를 요구하는 연산 위주의 작업에 유용함.
<ul>
<li>Batch processing workloads</li>
<li>Media transcoding</li>
<li>High performance web servers</li>
<li>High performance computing (HPC)</li>
<li>Dedicated gaming servers</li>
</ul>
</li>
</ul>
<h3 id="instance-types---memory-optimized-rxx-xxx"><a class="header" href="#instance-types---memory-optimized-rxx-xxx">Instance Types - Memory Optimized (Rxx, Xxx)</a></h3>
<ul>
<li>메모리 내에서 거대한 데이터 셋을 처리해야 하는 경우에 유용함.
<ul>
<li>High performance, relational/non-relational databases</li>
<li>Distributed web scale cache stores</li>
<li>In-memory databases optimized for BI (Business Intelligence)</li>
<li>Applications performing real-time processing of big unstructured data</li>
</ul>
</li>
</ul>
<h3 id="instance-types---storage-optimized-ixx-gxx-hxx"><a class="header" href="#instance-types---storage-optimized-ixx-gxx-hxx">Instance Types - Storage Optimized (Ixx, Gxx, Hxx)</a></h3>
<ul>
<li>로컬 스토리지 내 거대한 데이터 셋에 접근해서 순차적인 읽기/쓰기를 처리해야 하는 상황에 유용함.
<ul>
<li>High frequency online transaction processing (OLTP) systems</li>
<li>Relational &amp; NoSQL databases</li>
<li>Cache for in-memory databases (for example, Redis)</li>
<li>Data warehousing applications</li>
<li>Distributed file systems</li>
</ul>
</li>
</ul>
<h2 id="security-groups"><a class="header" href="#security-groups">Security Groups</a></h2>
<ul>
<li>Security Groups는 AWS의 네트워크 보안의 기초가 된다.</li>
<li>EC2 인스턴스의 인/아웃바운드 트래픽을 어떻게 처리할지를 다룸.</li>
<li>오직 <strong>allow</strong> rule만 포함한다.</li>
<li>Security Groups의 rule은 IP 주소 혹은 Security Group에 의해 참조될 수 있다.</li>
</ul>
<h3 id="security-groups-deep-dive"><a class="header" href="#security-groups-deep-dive">Security Groups Deep Dive</a></h3>
<ul>
<li>Security Group은 곧 EC2 인스턴스의 <strong>방화벽</strong>처럼 동작한다.</li>
<li>다음을 다룰 수 있다.
<ul>
<li>특정 포트에 대한 엑세스</li>
<li>허용하는 IP의 범위 ~ IPv4 / IPv6</li>
<li>인바운드 네트워크에 대한 통제 (from other to the instance)</li>
<li>아웃바운드 네트워크에 대한 통제 (from the instance to other)</li>
</ul>
</li>
<li>그 밖에 알면 좋은 것들
<ul>
<li>여러 인스턴스들에 대해 적용될 수 있다.</li>
<li>하나의 리전(region) / VPC에 격리된다.</li>
<li>EC2 <strong>밖에</strong> 존재하는 것이다. ~ 즉, Security Group 쪽에서 트래픽이 막히는 경우, EC2 측에서는 이에 대해 알 수 없다.</li>
<li><em>SSH 엑세스만을 위한 별도의 Security group을 구축하는 편이 좋다.</em></li>
<li>만약 앱에서 타임 아웃이 발생한다면, 아마도 Security group 이슈일 가능성이 크다.</li>
<li>만약 앱에서 &quot;connection refused&quot; 에러가 발생한다면, 애플리케이션 자체의 에러이거나, 그것이 실행되지 않았을 가능성이 크다.</li>
<li>인바운드 트래픽은 기본적으로 <strong>막혀있다.(blocked)</strong></li>
<li>아웃바운드 트래픽은 기본적으로 <strong>권한을 갖는다.(authorized)</strong></li>
</ul>
</li>
</ul>
<h3 id="classic-ports-to-know"><a class="header" href="#classic-ports-to-know">Classic Ports to know</a></h3>
<ul>
<li>22 = SSH (Secure Shell) - 리눅스 인스턴스로 로그인</li>
<li>21 = FTP (File Transfer Protocol) - 파일 공유를 위한 파일 업로드</li>
<li>22 = SFTP (Secure File Transfer Protocol) - SSH를 통한 파일 업로드</li>
<li>80 = HTTP - 안전하지 않은 웹사이트 접근</li>
<li>443 - HTTPS - 안전한 웹사이트 접근</li>
<li>3389 = RDP (Remote Desktop Protocol) - 윈도우즈 인스턴스로 로그인</li>
</ul>
<h2 id="ec2-instances-purchasing-options"><a class="header" href="#ec2-instances-purchasing-options">EC2 Instances Purchasing Options</a></h2>
<ul>
<li>On-Demand Instances - short workload, predictable pricing, pay by second</li>
<li>Reserved (1 &amp; 3 years)
<ul>
<li>Reserved Instances - long workloads</li>
<li>Convertible Reserved Instances - long workloads with flexible instances</li>
</ul>
</li>
<li>Savings Plans (1 &amp; 3years) - commitment to an amount of usage, long workload</li>
<li>Spot Instances - short workloads, cheap, can lose instances (less reliable)</li>
<li>Dedicated Hosts - book an entire physical server, control instance placement</li>
<li>Dedicated Instances - no other customers will share your hardware</li>
<li>Capacity Reservations - reserve capacity in a specific AZ(availability zone) for any duration</li>
</ul>
<h3 id="on-demand"><a class="header" href="#on-demand">On-Demand</a></h3>
<ul>
<li>쓴 만큼 지불
<ul>
<li>Linux or Windows : 첫 1분 이후 초당 비용</li>
<li>그 외의 운영체제 : 시간 당 비용</li>
</ul>
</li>
<li>가장 비용이 높으나, 선불(upfront) 금액이 없음</li>
<li>장기 계약(long-term commitment)이 없음</li>
<li>즉, <strong>짧은 기간(short-term)</strong> 동안, **중단되어선 안되는 작업(un-interrupted workloads)**을 수행해야 하는 경우에 추천됨 ~ 앱이 어떻게 동작할지 예측할 수 없는 경우.</li>
</ul>
<h3 id="reserved-instances"><a class="header" href="#reserved-instances">Reserved Instances</a></h3>
<ul>
<li>On-demand 대비 72% 만큼 비용 절감</li>
<li>특정 인스턴스 속성에 대해 예약 (Instance type, Region, Tenancy, OS)</li>
<li>예약 기간 - 1년 또는 3년 (길수록 더 크게 절감)</li>
<li>결제 옵션 - No Upfront -&gt; Partial Upfront -&gt; All Upfront 순으로 비용 절감</li>
<li>예약 인스턴스 범위(Scope) - Regional or Zonal (하나의 AZ 내에 종속)</li>
<li>꾸준히 사용되어야 하는 앱에 추천됨 (Ex. DB)</li>
<li>Reserved Instance Marketplace에서 사거나 팔 수 있음</li>
<li><strong>Convertible Reserved Instance</strong>
<ul>
<li>인스턴스 type, family, OS, scope, tenancy 등을 변경할 수 있음</li>
</ul>
</li>
</ul>
<h3 id="savings-plans"><a class="header" href="#savings-plans">Savings Plans</a></h3>
<ul>
<li>장 기간의 사용에 대한 할인 (최대 72% ~ Reserved Instances와 동일)</li>
<li>특정량 만큼의 사용을 약속 (Ex. 1년 또는 3년 동안 시간 당 10를 쓸 것임)</li>
<li>On-Demand로 청구된 가격을 지불할 때 적용됨.</li>
<li>특정 Instance family와 AWS region에 제한됨. (Ex. M5 in us-east-1)
<ul>
<li>단, 다음에 대해선 유연하게 변경 가능
<ul>
<li>인스턴스 사이즈 (Ex. m5.xlarge, m5.2xlarge)</li>
<li>OS (Ex. Linux, Windows)</li>
<li>Tenancy (Host, Dedicated, Default)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="spot-instances"><a class="header" href="#spot-instances">Spot Instances</a></h3>
<ul>
<li>On-demand 대비 최대 90%까지 절감</li>
<li>단, 설정한 최대 비용보다 현재 spot price가 더 비싸지는 경우에 언제든지 인스턴스가 사라질 수 있음.</li>
<li>AWS에서 가장 비용 절감이 많이 되는 형태의 인스턴스</li>
<li><strong>실패하는 경우에도 문제없는 탄력적인(resilient) 작업에 유용함.</strong>
<ul>
<li>Batch jobs</li>
<li>Data analysis</li>
<li>Image processing</li>
<li>Any distributed workloads</li>
<li>Workloads with a flexible start and end time</li>
</ul>
</li>
<li><strong>중요한 작업이나 DB의 경우엔 적합하지 않음.</strong></li>
</ul>
<h3 id="dedicated-hosts"><a class="header" href="#dedicated-hosts">Dedicated Hosts</a></h3>
<ul>
<li>특정 이용자만 사용할 수 있는 전용 EC2 인스턴스에 대한 물리적 서버를 제공</li>
<li><strong>Compliance requirements</strong>를 준수하고, <strong>기존에 보유한 Server-bound software licenses</strong>(소켓 당, 코어 당, VM 당)를 사용할 수 있도록 허용.</li>
<li>구매 옵션
<ul>
<li>On-demand : 활성화된 Dedicated Host에 대해 초 당 비용</li>
<li>Reserved : 1년 또는 3년 (No Upfront, Partial Upfront, All Upfront)</li>
</ul>
</li>
<li>가장 비싼 인스턴스 옵션임.</li>
<li>복잡한 라이센싱 모델(Complicated licensing model)을 갖춘 소프트웨어의 경우에 유용함</li>
<li>또는, 강한 규제 및 법률을 보유한 기업의 경우에 사용함.</li>
</ul>
<h3 id="dedicated-instances"><a class="header" href="#dedicated-instances">Dedicated Instances</a></h3>
<ul>
<li>이용자에게 종속된 하드웨어에서 동작하는 인스턴스</li>
<li>동일한 계정 내 다른 인스턴스들과도 하드웨어를 공유할 수 있음</li>
<li>인스턴스의 위치에 대한 통제권은 없음 (인스턴스의 실행/종료마다 하드웨어가 변경될 수 있음)</li>
<li>Dedicated host와 비교했을 때, dedicated host는 말 그대로 물리적 서버 자체에 대한 접근권을 갖기 때문에 보다 저수준(low-level)의 하드웨어에 대한 가시성(visibility)을 갖는 반면, Dedicated Instance의 경우는 그렇지 못한다는 점에서 차이가 생김.</li>
</ul>
<h3 id="capacity-reservations"><a class="header" href="#capacity-reservations">Capacity Reservations</a></h3>
<ul>
<li>특정 AZ의 특정 기간 동안에 On-demand 인스턴스 용량(capacity)를 예약</li>
<li>필요한 경우 언제든 EC2 가용량에 접근할 수 있음</li>
<li><strong>별도의 계약이 없으며(언제든 생성/취소할 수 있음), 별도의 비용 절감도 없음</strong></li>
<li>Reserved Instance와 Saving Plans와 결합하여 비용 절감을 취할 수 있음</li>
<li>인스턴스가 실제로 실행되든 아니든 간에 비용이 On-demand로 청구됨.</li>
<li>짧은 기간 동안, 중단되어선 안되는 작업(uninterrupted workload)이 특정 AZ 내에서 수행되어야 하는 경우에 적합.</li>
</ul>
<h2 id="spot-instance"><a class="header" href="#spot-instance">Spot Instance</a></h2>
<ul>
<li>On-demand 대비 90%까지 비용 절감 가능한 인스턴스 옵션</li>
<li><strong>max spot price</strong>를 지정 후, 해당 인스턴스의 <strong>현재 spot price가 지정한 max spot price보다 작은 경우</strong>에 해당 인스턴스를 보유할 수 있게 됨.
<ul>
<li>매 시간마다 spot price는 수요/공급(offer/capacity)을 고려해서 달라짐.</li>
<li>만약, 보유할 수 없는 상황이 된 경우, 2분 동안의 유예 기간(grace period)를 부여받으며, 해당 인스턴스를 중지(stop)할 것인지, 종료(terminate)할 것인지 선택할 수 있음.</li>
</ul>
</li>
<li>Spot Block ~ 특정 시간대에 대해 적용하는 블록(block) spot instance. 지금은 없어짐.</li>
<li>실패해도 무방한 작업들, 즉 내결함성(resilient)을 갖춘 작업들의 경우에 적합함. 반대로, 중요한 작업이나 DB에는 부적합.</li>
</ul>
<h3 id="spot-instance-request를-종료하고자-하는-경우"><a class="header" href="#spot-instance-request를-종료하고자-하는-경우">Spot instance request를 종료하고자 하는 경우</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/spot_lifecycle.png" alt="Spot Instance Lifecycle" /></p>
<p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/spot_request_states.png" alt="Spot Instance State" /></p>
<ul>
<li>open, active, disabled 상태에서만 Spot instance request을 취소할 수 있음</li>
<li>Spot instance request의 취소가 곧 인스턴스의 종료(terminate)를 의미하진 않음</li>
<li>따라서, Spot instance를 종료하고 싶은 경우, 반드시 먼저 spot request를 취소한 다음, 그 다음에 관련된 Spot instance를 종료해야 함.</li>
</ul>
<h3 id="spot-fleets"><a class="header" href="#spot-fleets">Spot Fleets</a></h3>
<ul>
<li>Spot Fleets = set of Spot Instances + (선택) On-Demand Instances</li>
<li>주어진 비용 제한(price constraints)에 맞춰 목표 용량(target capacity)을 충족하려고 시도함.
<ul>
<li>가능한 launch pools 정의 : 인스턴스 타입, OS, AZ</li>
<li>여러 개의 launch pools를 가질 수 있으며, 이렇게 하면 fleet이 선택할 수 있게 됨</li>
<li>Spot Fleet은 용량 또는 최대 비용에 도달하는 경우 인스턴스 실행을 멈춤</li>
</ul>
</li>
<li>Spot instances 할당 전략
<ul>
<li>lowerPrice: 가장 비용이 저렴한 pool부터 시도 (cost optimization, short workload)</li>
<li>diversified: 모든 pool에 대해 광범위하게 적용 (great for availability, long workloads)</li>
<li>capacityOptimized: 인스턴스 개수 대비 최적의 용량을 가진 pool부터 시도</li>
</ul>
</li>
<li><strong>Spot Fleet은 Spot Instance에 대한 요청을 최소화된 비용으로 자동으로 처리할 수 있도록 해줌.</strong></li>
</ul>
<h2 id="elastic-ips"><a class="header" href="#elastic-ips">Elastic IPs</a></h2>
<ul>
<li>
<p>EC2 인스턴스를 중지/실행할 때마다, 퍼블릭 IP가 변경될 수 있다.</p>
</li>
<li>
<p>만약, 인스턴스의 퍼블릭 IP를 고정시키고자 한다면, Elastic IP가 필요하다.</p>
</li>
<li>
<p>Elastic IP는 퍼블릭 IPv4 IP에 해당하며, 삭제하지 않는 이상 유지된다.</p>
</li>
<li>
<p>한번에 하나의 인스턴스에 대해서만 부여할 수 있다.</p>
</li>
<li>
<p>Elastic IP 주소를 사용하면, 인스턴스 또는 소프트웨어에 문제가 발생했을 때, 해당 주소를 다른 인스턴스에 부여해서 문제에 대처할 수 있다.</p>
</li>
<li>
<p>단, Elastic IP 주소는 한 계정 당 오직 5개까지만 가질 수 있다. (AWS에 더 달라고 요청할 수는 있다.)</p>
</li>
<li>
<p>결론적으로, <strong>Elastic IP를 쓰는 것을 피하는 것이 좋다.</strong></p>
<ul>
<li>일반적으로는 좋지 않은 결정이다.</li>
<li>대신에, 랜덤 퍼블릭 IP를 사용하고, 그것에 대한 DNS 네임을 등록하는 편이 좋다.</li>
<li>또는, 로드 밸런서를 사용하면서 퍼블릭 IP 자체를 사용하지 않는 방법도 있는데, 이 방법이 가장 최적이다.</li>
</ul>
</li>
</ul>
<h3 id="private-vs-public-ip-in-aws-ec2"><a class="header" href="#private-vs-public-ip-in-aws-ec2">Private vs Public IP in AWS EC2</a></h3>
<ul>
<li>
<p>기본적으로, EC2 머신에서</p>
<ul>
<li>프라이빗 IP는 AWS 내부 네트워크를 위해서,</li>
<li>퍼블릭 IP는 WWW를 위해서 사용된다.</li>
</ul>
</li>
<li>
<p>만약, EC2 머신에 SSH 연결을 시도한다면</p>
<ul>
<li>(VPN이 구축되어 있지 않다면) 프라이빗 IP가 아닌, 퍼블릭 IP를 써야한다. 동일한 네트워크에 놓여있는 것이 아니기 때문.</li>
</ul>
</li>
<li>
<p>머신이 중지/재실행된다면, <strong>퍼블릭 IP는 바뀔 수 있다.</strong></p>
</li>
</ul>
<h2 id="placement-groups"><a class="header" href="#placement-groups">Placement Groups</a></h2>
<ul>
<li>EC2 인스턴스의 배치 전략(placement strategy)을 조정하고 싶을 때, <strong>Placement group</strong>을 정의할 수 있다.</li>
<li>Placement group은 다음의 전략 중 하나를 선택할 수 있다.
<ul>
<li>Cluster - 하나의 AZ 내에 low-latency group으로 인스턴스들을 밀집</li>
<li>Spread - 소규모 인스턴스 그룹을 다른 기본 하드웨어(underlying hardware)로 분산하여 오류를 줄임 (각 AZ의 그룹 당 최대 7개 인스턴스), 중요한 애플리케이션에서 활용.</li>
<li>Partition - 인스턴스들을 하나의 AZ 내의 파티션 별로 다른 기본 하드웨어로 분산하여 오류를 줄임.</li>
</ul>
</li>
</ul>
<h3 id="placement-groups---cluster"><a class="header" href="#placement-groups---cluster">Placement Groups - Cluster</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/placement-group-cluster.png" alt="Cluster" /></p>
<ul>
<li>장점 : 높은 네트워크 성능 (인스턴스 간 latency가 작음)</li>
<li>단점 : 하드웨어 상 결함이 발생한다면, 모든 인스턴스가 다 같이 실패함.</li>
<li>사례
<ul>
<li>빠르게 수행되어야 하는 거대한 데이터 기반의 작업</li>
<li>극도로 낮은 latency와 높은 네트워크 throughput을 보장해야하는 애플리케이션</li>
</ul>
</li>
</ul>
<h3 id="placement-groups---spread"><a class="header" href="#placement-groups---spread">Placement Groups - Spread</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/placement-group-spread.png" alt="Spread" /></p>
<ul>
<li>장점
<ul>
<li>동일한 지역의 여러 AZ로 확장할 수 있음</li>
<li>동시에 인스턴스들이 실패할 위험을 줄일 수 있음</li>
</ul>
</li>
<li>단점
<ul>
<li>각 Placement group 내 하나의 AZ에 최대 7개의 인스턴스로 제한됨.</li>
</ul>
</li>
<li>사례
<ul>
<li>최대한 높은 가용성(availability)을 확보해야 하는 애플리케이션</li>
<li>인스턴스 서로가 각자의 동작 실패로부터 격리되어야 하는 중요한 애플리케이션</li>
</ul>
</li>
</ul>
<h3 id="placement-groups---partition"><a class="header" href="#placement-groups---partition">Placement Groups - Partition</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/placement-group-partition.png" alt="Partition" /></p>
<ul>
<li>AZ 당 최대 7개의 파티션</li>
<li>동일한 지역 내 여러 AZ로 확장 가능</li>
<li>최대 100개의 인스턴스를 파티션 설정에 사용할 수 있음</li>
<li>하나의 파티션 내에 있는 인스턴스들은 다른 파티션의 인스턴스들과 rack을 공유하지 않음</li>
<li>하나의 파티션 내에서 발생한 문제는 해당 파티션에 속한 인스턴스들에는 영향을 끼칠 수 있으나, 그 외의 파티션에는 영향을 끼치지 않음.</li>
<li>EC2 인스턴스들은 메타데이터를 통해 파티션 정보에 접근할 수 있음</li>
<li><strong>사례</strong> : HDFS, HBase, Cassandra, Kafka</li>
</ul>
<h2 id="elastic-network-interfaces-eni"><a class="header" href="#elastic-network-interfaces-eni">Elastic Network Interfaces (ENI)</a></h2>
<ul>
<li><strong>가상의 네트워크 카드(virtual network card)를 나타내는 VPC 내 논리적 네트워킹 컴포넌트</strong></li>
<li>ENI는 다음과 같은 속성을 갖출 수 있음
<ul>
<li>기본(primary) 프라이빗 IPv4, 하나 또는 그 이상의 보조(secondary) IPv4</li>
<li>하나의 프라이빗 IPv4 당 하나의 Elastic IP (IPv4)</li>
<li>하나의 퍼블릭 IPv4</li>
<li>하나 이상의 Security groups</li>
<li>Mac address</li>
</ul>
</li>
<li>ENI를 독립적으로 생성하고, EC2 인스턴스가 실패했을 때에 대비하여 인스턴스에 적용(attach)한다.</li>
<li>하나의 특정한 AZ에 격리된다.</li>
</ul>
<h2 id="ec2-hibernate"><a class="header" href="#ec2-hibernate">EC2 Hibernate</a></h2>
<ul>
<li>인스턴스의 중지(stop) / 종료(terminate)
<ul>
<li><strong>Stop</strong> - 디스크에 저장된 데이터(EBS)가 다음 인스턴스의 실행까지 유지됨</li>
<li><strong>Termninate</strong> - 삭제 될 것으로 설정된 특정 EBS 볼륨(root)은 사라짐</li>
</ul>
</li>
<li>인스턴스의 실행 시, 다음과 같은 일이 일어난다.
<ul>
<li>최초 실행 시 : OS 부팅 &amp; EC2 User Data Script가 실행됨</li>
<li>그 이후의 실행 시 : OS 부팅</li>
<li>위의 각 단계 이후에 애플리케이션이 실행되고, 캐시가 웜업(warm-up) 된다.</li>
</ul>
</li>
</ul>
<h3 id="ec2-hibernate-란"><a class="header" href="#ec2-hibernate-란">EC2 Hibernate 란?</a></h3>
<ul>
<li>in-memory(RAM) 상태를 보존할 수 있음</li>
<li>인스턴스 부팅이 훨씬 빨라짐 (OS가 중지되거나 재실행되지 않음)</li>
<li>원리 : RAM의 상태가 루트 EBS 볼륨에 하나의 파일로 작성되어 보존.
<ul>
<li>즉, 루트 EBS 볼륨이 반드시 암호화되어야 함.</li>
</ul>
</li>
<li>사례 :
<ul>
<li>오래 동안 진행되어야 하는 프로세싱</li>
<li>RAM 상태를 저장해야 하는 경우</li>
<li>초기화에 시간이 많이 걸리는 서비스</li>
</ul>
</li>
<li>그 밖의 특징
<ul>
<li>지원하는 인스턴스 패밀리 - C3, C4, C5, I3, M3, M4, R3, R4, T2, T3, ...</li>
<li>인스턴스 RAM 사이즈 - 150GB 미만 이어야 함</li>
<li>인스턴스 사이즈 - 베어 메탈 인스턴스(bare metal instance)에는 지원하지 않음</li>
<li>AMI - Amazon Linux 2, Linux AMI, Ubuntu, RHEL, CentOS &amp; Windows, ...</li>
<li>루트 볼륨 - 반드시 다음의 속성을 갖춘 EBS여야 함
<ul>
<li>encrypted</li>
<li>not instance store</li>
<li>large</li>
</ul>
</li>
<li>On-Demand, Reserved, Spot 인스턴스 모두에 적용 가능.</li>
<li>인스턴스는 60일을 초과해서 hibernate 할 수 없음.</li>
</ul>
</li>
</ul>
<h2 id="ec2-instance-store"><a class="header" href="#ec2-instance-store">EC2 Instance Store</a></h2>
<ul>
<li>EBS 볼륨은 <strong>네트워크 드라이브</strong>에 해당하여 좋은 점도 있지만, <strong>제한된 성능</strong>을 갖는다.</li>
<li><strong>만약, 고성능의 하드웨어 디스크가 필요한 상황이라면, EC2 Instance Store의 사용을 고려해야 한다.</strong></li>
<li>더 나은 I/O 성능을 제공</li>
<li>EC2 Instance Store는 인스턴스가 멈추게 되면 데이터가 사라진다. (ephemeral = 일시적임)</li>
<li>buffer / cache / scratch data / temporary content에 유용함</li>
<li>하드웨어 문제가 발생하는 경우 데이터가 사라질 수 있음</li>
<li>백업 및 복제(replication)는 이용자가 직접 처리해야 함</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ami"><a class="header" href="#ami">AMI</a></h1>
<ul>
<li>
<p>AMI = Amazon Machine Image</p>
</li>
<li>
<p>AMI는 EC2 인스턴스의 customization다.</p>
<ul>
<li>나만의 소프트웨어, 설정, OS, 모니터링 등을 추가할 수 있음</li>
<li>모든 내 소프트웨어가 pre-package 되어 있으므로, 더 빠른 부트/설정 시간을 가질 수 있다.</li>
</ul>
</li>
<li>
<p>AMI는 <strong>하나의 리전</strong>에 대해서만 만들어질 수 있으며, 다른 리전에서 사용하고자 한다면 별도로 복사를 해야한다.</p>
</li>
<li>
<p>EC2 인스턴스를 다음과 같은 AMI들에서 실행할 수 있다.</p>
<ul>
<li>공용(Public) AMI: AWS가 제공</li>
<li>직접 만든 AMI: 직접 만들고 유지보수</li>
<li>AWS Marketplace AMI: 다른 누군가가 만든 AMI (판매도 할 수 있음)</li>
</ul>
</li>
</ul>
<h2 id="ami-process-from-an-ec2-instance"><a class="header" href="#ami-process-from-an-ec2-instance">AMI Process (from an EC2 instance)</a></h2>
<ul>
<li>EC2 인스턴스를 시작하여 커스터마이징함</li>
<li>인스턴스를 중지 (데이터 무결성 ~ data integrity를 위하여)</li>
<li>AMI를 빌드 - 해당 작업은 EBS 스냅샷도 마찬가지로 생성함</li>
<li>다른 AMI들로부터 인스턴스를 실행</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ebs"><a class="header" href="#ebs">EBS</a></h1>
<ul>
<li><strong>EBS (Elastic Block Store) 볼륨</strong>은 인스턴스가 돌아가는 동안에 부착할 수 있는 <strong>네트워크 드라이브</strong>이다.</li>
<li>인스턴스가 종료된 이후에도 데이터를 보존할 수 있도록 해준다.</li>
<li>기본적으로는 한번에 하나의 인스턴스에만 이용될 수 있으나, 일부 EBS에는 <strong>multi-attach</strong> 기능이 있다.</li>
<li>특정 AZ에 격리된다.</li>
<li>하나의 네트워크 USB 스틱으로 생각해도 좋다.</li>
<li>프리티어의 경우 General Purpose (SSD) 또는 Magenetic으로 한달에 30GB의 무료 EBS 스토리지를 제공받는다.</li>
</ul>
<h2 id="ebs-volume"><a class="header" href="#ebs-volume">EBS Volume</a></h2>
<ul>
<li>
<p>네트워크 드라이브에 해당 (즉, 물리적(physical) 드라이브가 아님.)</p>
<ul>
<li>인스턴스와 소통하기 위해 네트워크를 사용하며, 이는 즉 약간의 latency가 발생할 수 있음을 의미한다.</li>
<li>하나의 EC2 인스턴스로부터 분리(detach)되어, 다른 것에 부착(attach)될 수 있다.</li>
</ul>
</li>
<li>
<p>하나의 AZ에 갇혀있다.</p>
<ul>
<li>예를 들어, us-east-1a의 EBS볼륨은 us-east-1b에 부착될 수 없다.</li>
<li>볼륨을 AZ 너머로 이동시키려면, 먼저 그것에 대한 스냅샷(snapshot)을 사용해야 한다.</li>
</ul>
</li>
<li>
<p>프로비전(provision)된 가용량(capacity)을 갖고 있다. (size in GBs, and IOPS)</p>
<ul>
<li>모든 프로비전 가용량에는 비용이 지불된다.</li>
<li>추후에도 드라이브 용량을 증가시킬 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="delete-on-termination-attribute"><a class="header" href="#delete-on-termination-attribute">Delete on Termination attribute</a></h2>
<ul>
<li>EC2 인스턴스가 종료될 때 EBS의 동작을 컨트롤할 수 있다.
<ul>
<li>기본적으로, 루트 EBS 볼륨(root EBS volume)은 삭제된다. (= enabled)</li>
<li>기본적으로, 그 외의 EBS 볼륨들은 삭제되지 않는다. (= disabled)</li>
</ul>
</li>
<li>이는 AWS console / AWS CLI를 통해 이루어질 수 있으며, <strong>인스턴스가 종료(terminate)되더라도 루트 볼륨을 보존하고자 할 때 사용할 수 있다.</strong></li>
</ul>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<ul>
<li>특정한 시점에 보유한 EBS 볼륨에 대한 백업(=스냅샷)을 만들 수 있음</li>
<li>스냅샷을 위해 볼륨을 분리(detach)할 필요는 없지만, <strong>권장</strong>되는 사항임.</li>
<li>이를 통해 다른 AZ 또는 지역 너머로 스냅샷을 복사하여 볼륨을 복구(restore)할 수 있음.</li>
</ul>
<h3 id="ebs-snapshot-features"><a class="header" href="#ebs-snapshot-features">EBS Snapshot Features</a></h3>
<ul>
<li>
<p>EBS Snapshot Archive</p>
<ul>
<li>스냅샷을 75% 싼 스토리지 티어인 archive tier로 이동함.</li>
<li>아카이브한 내용을 복구하는데에 24 ~ 72 시간이 소요됨.</li>
</ul>
</li>
<li>
<p>Recycle Bin for EBS Snapshots</p>
<ul>
<li>삭제된 스냅샷을 보존하기 위한 것으로, 일시적인 삭제 이후에도 이를 복구할 수 있도록 Rule을 생성할 수 있음</li>
<li>보존기간을 명시할 수 있음 (1일부터 1년까지)</li>
</ul>
</li>
<li>
<p>Fast Snapshot Restore (FSR)</p>
<ul>
<li>첫 사용에도 latency가 존재하지 않도록 스냅샷의 완전한 초기화를 강제함.</li>
</ul>
</li>
</ul>
<h2 id="ebs-volume-types"><a class="header" href="#ebs-volume-types">EBS Volume Types</a></h2>
<ul>
<li>
<p>EBS 볼륨은 6가지 종류가 있음</p>
<ul>
<li>gp2 / gp3 (SSD): 폭넓은 종류의 작업을 처리할 수 있는 가격과 성능 간 밸런스를 갖춘 일반적인 목적의 SSD</li>
<li>io1 / io2 (SSD): 낮은 latency와 높은 throughput이 요구되는 상황에서 사용하는 높은 성능의 SSD</li>
<li>st1 (HDD): 자주 액세스 해야하고, throughput이 중요한 작업에 사용하기 위한 용도의 낮은 비용의 HDD</li>
<li>sc (HDD): 비교적 액세스 빈도가 낮은 작업을 처리하기 위한 용도의 가장 저렴한 HDD</li>
</ul>
</li>
<li>
<p>EBS 볼륨은 사이즈 / throughput / IOPS (I/O Ops Per Sec)에 따라 특징이 나뉨.</p>
</li>
<li>
<p>헷갈린다면 AWS 문서를 참조할 것.</p>
</li>
<li>
<p><strong>부트 볼륨(root OS가 실행되는 볼륨)으로는 오직 gp2/gp3와 io1/io2만 사용할 수 있음.</strong></p>
</li>
</ul>
<h3 id="ebs-volume-types---general-purpose-ssd"><a class="header" href="#ebs-volume-types---general-purpose-ssd">EBS Volume Types - General Purpose SSD</a></h3>
<ul>
<li>비용 효율적인 스토리지와 낮은 latency가 요구되는 상황에 사용</li>
<li>Ex.) System boot volumes, Virtual desktops, Development and test environments</li>
<li>1GB ~ 16TB</li>
<li>gp3
<ul>
<li>기본 3,000 IOPS와 125MB/s의 throughput</li>
<li>각각 16,000 IOPS 및 1000MB/s throughput 까지 높일 수 있음</li>
</ul>
</li>
<li>gp2
<ul>
<li>3,000 IOPS 까지 높일 수 있는 작은 gp2 볼륨</li>
<li>볼륨의 사이즈에 따라 IOPS도 달라지며, 최대 IOPS는 16,000</li>
<li>GB 당 3 IOPS, 즉 5,334GB에서 최대 IOPS에 도달할 수 있음.</li>
</ul>
</li>
</ul>
<h3 id="ebs-volume-types---provisioned-iops-piops-ssd"><a class="header" href="#ebs-volume-types---provisioned-iops-piops-ssd">EBS Volume Types - Provisioned IOPS (PIOPS) SSD</a></h3>
<ul>
<li>IOPS 성능을 유지해야 하는 중요한 비즈니스 애플리케이션에 사용</li>
<li>또는 16,000 IOPS 이상을 필요로 하는 애플레케이션에 사용</li>
<li>데이터베이스 작업에 유용 (스토리지 성능 및 consistency가 중요하기 때문)</li>
<li>io1/io2 (4GB - 16TB)
<ul>
<li>최대 PIOPS: Nitro EC2 인스턴스의 경우 64,000 &amp; 그 외에는 32,000</li>
<li>스토리지 사이즈와 별개로 PIOPS를 높일 수 있음</li>
<li>io2가 더 높은 내구성(durability)를 갖고 있으며, 각 GB 당 더 많은 IOPS 성능을 가짐 (io1와 동일한 비용인 경우)</li>
</ul>
</li>
<li>io2 Block Express (4GB - 64TB)
<ul>
<li>ms(밀리초) 미만의 latency가 요구되는 경우</li>
<li>최대 PIOPS: 1,000:1의 IOPS:GB 비율을 가지며, 최대 256,000</li>
</ul>
</li>
<li>EBS Multi-attach를 지원</li>
</ul>
<h3 id="ebs-volume-types---hard-disk-drives-hdd"><a class="header" href="#ebs-volume-types---hard-disk-drives-hdd">EBS Volume Types - Hard Disk Drives (HDD)</a></h3>
<ul>
<li>부트 볼륨으로 사용될 수 없음</li>
<li>125MB - 16TB</li>
<li>Throughput Optimized HDD (st1)
<ul>
<li>Big Data, Data Warehouses, Log Processing</li>
<li>최대 throuput 500MB/s - 최대 IOPS 500</li>
</ul>
</li>
<li>Cold HDD (sc1)
<ul>
<li>액세스 빈도가 낮은 데이터</li>
<li>비용을 낮추는 것이 중요한 상황에서 사용</li>
<li>최대 throughput 250MB/s - 최대 IOPS 250</li>
</ul>
</li>
</ul>
<h2 id="ebs-multi-attach---io1io2-family"><a class="header" href="#ebs-multi-attach---io1io2-family">EBS Multi-Attach - io1/io2 family</a></h2>
<ul>
<li>동일한 AZ 내에 여러 EC2 인스턴스에 동일한 EBS 볼륨을 부착하는 것.</li>
<li>각각의 인스턴스는 고성능 볼륨에 모든 읽기/쓰기 권한을 갖게 됨</li>
<li>사례 :
<ul>
<li>Clustered linux application 내에서 높은 애플리케이션 가용성(higher application availability)을 보존해야 할 때</li>
<li>단, 애플리케이션 자체가 동시 쓰기 작업을 다룰 수 있어야 함</li>
</ul>
</li>
<li><strong>한꺼번에 최대 16개의 인스턴스에만 적용할 수 있음</strong></li>
<li>클러스터에 대해 인지하는(cluster-aware) 파일 시스템을 사용해야 함. (즉, XFS, EX4 등을 사용할 수 없음)</li>
</ul>
<h2 id="ebs-encryption"><a class="header" href="#ebs-encryption">EBS Encryption</a></h2>
<ul>
<li>암호화된 EBS 볼륨을 생성하면
<ul>
<li>볼륨 내에 저장된 데이터가 암호화됨</li>
<li>인스턴스와 볼륨 사이를 이동하는 모든 데이터가 암호화됨</li>
<li>모든 스냅샷이 암호화됨</li>
<li>스냅샷으로부터 생성되는 모든 볼륨이 암호화됨</li>
</ul>
</li>
<li>암호화/복호화(encryption/decryption)는 투명하게 처리됨 (따로 처리해야 할 일이 없음)</li>
<li>암호화는 latency에 거의 영향을 끼치지 않음</li>
<li>EBS 암호화는 KMS(AES-256) 암호화를 사용</li>
<li>암호화되지 않은 스냅샷을 복사하는 경우 암호화가 가능</li>
<li>암호화된 볼륨의 스냅샷은 암호화됨</li>
</ul>
<h3 id="encryption-encrypt-an-unencrypted-ebs-volume"><a class="header" href="#encryption-encrypt-an-unencrypted-ebs-volume">Encryption: encrypt an unencrypted EBS Volume</a></h3>
<ul>
<li>볼륨의 EBS 스냅샷을 생성</li>
<li>EBS 스냅샷을 암호화 (using copy)</li>
<li>스냅샷을 통해 새 EBS 볼륨을 생성 (새로 생성된 볼륨은 암호화됨)</li>
<li>기존 인스턴스에 암호화된 볼륨을 부착</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="efs"><a class="header" href="#efs">EFS</a></h1>
<ul>
<li>여러 EC2 인스턴스에 마운트 될 수 있는 관리형 NFS (Managed NFS ~ network file system)</li>
<li>EFS는 여러 AZ에 있는 EC2 인스턴스와 함께 동작할 수 있음</li>
<li>높은 가용성이 있고(highly available), 확장 가능하며(scalable), 비쌈(expensive ~ gp2의 3배), 사용한 만큼 지불 (pay per use)</li>
<li>사례 :
<ul>
<li>content management</li>
<li>web serving</li>
<li>data sharing</li>
<li>wordpress</li>
</ul>
</li>
<li>NFSv4.I 프로토콜을 사용</li>
<li>EFS에 대한 엑세스를 관리하기 위해 Security Group을 사용</li>
<li><strong>Linux based AMI의 경우에만 호환됨 (Windows는 안됨)</strong></li>
<li>KMS를 이용해 암호화 (encryption at rest using KMS)</li>
<li>표준 파일 API를 가진 POSIX 파일 시스템 (~LINUX)</li>
<li>파일 시스템은 자동으로 크기가 변하며, 사용량에 따라 비용이 청구됨. 별도로 capacity plan이 없음.</li>
</ul>
<h2 id="efs---performance--storage-classes"><a class="header" href="#efs---performance--storage-classes">EFS - Performance &amp; Storage Classes</a></h2>
<ul>
<li>
<p>EFS Scale</p>
<ul>
<li>동시에 1000 개의 NFS client를 가질 수 있으며, 10GB/s 이상의 throughput</li>
<li>페타바이트(Petabyte)급의 네트워크 파일 시스템으로 자동으로 확장될 수 있음</li>
</ul>
</li>
<li>
<p>Performance mode (EFS 생성 시에 설정됨)</p>
<ul>
<li>General purpose (default): latency에 민감한 사례에 사용 (웹서버, CMS, 등등..)</li>
<li>Max I/O - 더 높은 latency을 갖춘 반면, 더 높은 throughput과 더 높은 병렬 처리(parallel) ~ 빅데이터, 미디어 프로세싱 사례에 사용</li>
</ul>
</li>
<li>
<p>Throughput mode</p>
<ul>
<li>Bursting (1TB = 50MB/s + burst of up to 100MB/s)</li>
<li>Provisioned (= Enhanced로 명칭 변경): 스토리지 사이즈와 무관하게 throughput을 설정 (Ex. 1TB 스토리지에 1GB/s으로 설정)</li>
</ul>
</li>
<li>
<p>Storage Tiers (lifecycle management feature - N일 이후에 파일 이동)</p>
<ul>
<li>Standard: 자주 엑세스되는 파일들에 사용</li>
<li>Infrequent access (EFS-IA): 파일 검색에 비용 부과하며, 저장에는 더 낮은 비용. Lifecycle Policy로 EFS-IA를 활성화.</li>
</ul>
</li>
<li>
<p>Availability and Durability (= Storage class로 명칭 변경)</p>
<ul>
<li>Standard: Multi-AZ, 프로덕션 환경에서 유용</li>
<li>One Zone: One AZ, 개발 환경에서 유용, 기본적으로 백업이 활성화 되어 있으며, IA(Infrequent Access)와 호환. (EFS One Zone-IA)</li>
</ul>
</li>
<li>
<p>최대 90%까지 비용 절감 가능</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="ebs-vs-efs"><a class="header" href="#ebs-vs-efs">EBS vs. EFS</a></h1>
<h2 id="ebs-volumes"><a class="header" href="#ebs-volumes">EBS Volumes</a></h2>
<ul>
<li>
<p>특징</p>
<ul>
<li>기본적으로는 하나의 인스턴스에 하나씩 부착</li>
<li>AZ 레벨에서 격리됨</li>
<li>gp2: 디스크 사이즈가 늘어남에 따라 IO 성능도 늘어남</li>
<li>io1: 디스크 사이즈와 무관하게 IO 성능을 별개로 늘릴 수 있음</li>
</ul>
</li>
<li>
<p>EBS 볼륨을 AZ 너머로 마이그레이션하려면</p>
<ul>
<li>스냅샷을 찍고</li>
<li>다른 AZ에서 해당 스냅샷을 복구</li>
<li>EBS 백업은 IO를 사용하며, 현재 애플리케이션이 많은 트래픽을 다루는 중인 경우에는 이를 작동시키지 말아야 한다.</li>
</ul>
</li>
<li>
<p>EC2 인스턴스가 종료되면, 기본적으로 해당 인스턴스의 EBS 볼륨도 종료된다. (해당 동작은 disable할 수 있음.)</p>
</li>
</ul>
<h2 id="efs---elastic-file-system"><a class="header" href="#efs---elastic-file-system">EFS - Elastic File System</a></h2>
<ul>
<li>특징
<ul>
<li>AZ와 무관하게 100개 까지 인스턴스를 마운팅 할 수 있음</li>
<li>웹사이트 파일 공유에 활용할 수 있음 (Ex. WordPress)</li>
<li>리눅스 인스턴스(POSIX)에만 사용할 수 있음</li>
<li>EBS보다 비용이 더 높지만, 비용 절감을 위해 EFS-IA를 활성화할 수 있음</li>
</ul>
</li>
</ul>
<h3 id="ec2-instance-store-1"><a class="header" href="#ec2-instance-store-1">EC2 Instance Store</a></h3>
<ul>
<li>극도로 높은 I/O 성능이 요구되는 상황에서 사용</li>
<li>기본적으로 인스턴스가 중지되면 데이터가 사라짐 (저장이 일시적임)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="elb"><a class="header" href="#elb">ELB</a></h1>
<h2 id="scalability--high-availability"><a class="header" href="#scalability--high-availability">Scalability &amp; High Availability</a></h2>
<ul>
<li>
<p>Scalability는 상황에 따라 애플리케이션 / 시스템의 규모가 더 크게 조정할 수 있음을 의미함.</p>
</li>
<li>
<p>두 종류의 Scalability</p>
<ul>
<li>Vertical Scalability</li>
<li>Horizontal Scalability (= elasticity)</li>
</ul>
</li>
<li>
<p><strong>Scalability는 High Availability와 관련이 있긴 하나, 엄연히 다른 개념</strong>이다.</p>
</li>
</ul>
<h3 id="vertical-scalability"><a class="header" href="#vertical-scalability">Vertical Scalability</a></h3>
<ul>
<li>인스턴스 사이즈의 크기를 늘리는 것을 의미한다. (Ex. t2.micro -&gt; t2.large)</li>
<li>DB와 같은 비분산 시스템에 적용하는 것이 일반적이다. (Ex. RDS, ElastiCach)</li>
<li>확장에 있어 한계점이 있다. (하드웨어 제한)</li>
</ul>
<h3 id="horizontal-scalability"><a class="header" href="#horizontal-scalability">Horizontal Scalability</a></h3>
<ul>
<li>애플리케이션에 대한 인스턴스 또는 시스템의 갯수를 늘리는 것을 의미한다.</li>
<li>분산 시스템에 적용할 수 있다.</li>
<li>웹 애플리케이션 / 모던 애플리케이션에 매우 일반적으로 사용된다.</li>
</ul>
<h3 id="high-availability"><a class="header" href="#high-availability">High Availability</a></h3>
<ul>
<li>High Availability는 주로 horizontal scaling과 일반적으로 관련이 있는 개념이다.</li>
<li>최소 2개의 데이터 센터(== AZ)에서 애플리케이션 / 시스템이 가동되고 있음을 의미한다.</li>
<li>High Availability의 목표는 데이터 센터의 소실에서 살아남기 위함이다.</li>
<li>High Availability는 수동적(passive)일 수도 있고(RDS Multi AZ), 능동적(active)일 수도 있다(Horizontal Scaling).</li>
</ul>
<h3 id="high-availability--scalability-for-ec2"><a class="header" href="#high-availability--scalability-for-ec2">High Availability &amp; Scalability For EC2</a></h3>
<ul>
<li>Vertical Scaling: 인스턴스 사이즈 증가 (= scale up / down)</li>
<li>Horizontal Scaling: 인스턴스의 개수 증가 (= scale out / in)
<ul>
<li>Auto Scaling Group</li>
<li>Load Balancer</li>
</ul>
</li>
<li>High Availability: 여러 AZ를 통해 동일한 애플리케이션에 대한 인스턴스를 실행
<ul>
<li>Auto Scaling Group multi AZ</li>
<li>Load Balancer multi AZ</li>
</ul>
</li>
</ul>
<h2 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h2>
<ul>
<li>Load Balances는 트래픽을 여러 downstream 서버(Ex. EC2 인스턴스)로 분산시켜주는 서버이다.</li>
</ul>
<h3 id="why-use-a-load-balancer"><a class="header" href="#why-use-a-load-balancer">Why use a load balancer?</a></h3>
<ul>
<li>부하(load)를 여러 다운스트림 인스턴스(downstream instance)로 분산시킬 수 있다.</li>
<li>애플리케이션에 대한 하나의 접근 지점(a single of access)를 노출시킬 수 있다.</li>
<li>다운스트림 인스턴스의 실패에 대해 유연하게(seamlessly) 대처할 수 있다.</li>
<li>인스턴스에 대한 정기 검진(regular health check)를 수행할 수 있다.</li>
<li>웹사이트에 SSL termination (HTTPS)을 제공할 수 있다.</li>
<li>쿠키를 통해 Session stickiness를 강화한다.</li>
<li>여러 AZ 너머로 High Availability를 갖는다.</li>
<li>퍼블릭 트래픽(Public traffic)을 프라이빗 트래픽(Private traffic)과 분리한다.</li>
</ul>
<h3 id="why-use-an-elastic-load-balancer"><a class="header" href="#why-use-an-elastic-load-balancer">Why use an Elastic Load Balancer?</a></h3>
<ul>
<li>ELB(Elastic Load Balancer)는 **managed load balancer(관리된 로드 밸런서)**다.
<ul>
<li>AWS가 동작을 보장함</li>
<li>AWS가 업그레이드, 유지보수, 고가용성(High availability)를 관리한다.</li>
<li>AWS는 오직 소수의 configuration knob를 제공한다.</li>
</ul>
</li>
<li>자체적인 로드 밸런서를 구축하는 경우, 비용은 더 적게 들지라도, 훨씬 더 많은 노력이 필요하다.</li>
<li>AWS에서 제공하는 다양한 서비스들과 함께 통합되어 있다.
<ul>
<li>EC2, EC2 Auto Scaling Groups, Amazon ECS</li>
<li>AWS Certificate Manager (ACM), CloudWatch</li>
<li>Route 53, AWS WAF, AWS Global Accelerator</li>
</ul>
</li>
</ul>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<ul>
<li>헬스 체크는 로드 밸런서에 중요함.</li>
<li>로드 밸런서가 &quot;트래픽을 전달받을 인스턴스가 요청에 응답할 수 있는지&quot;에 대한 여부를 알 수 있도록 함.</li>
<li>헬스 체크는 하나의 포트와 하나의 루트에서 이루어짐. (일반적으로 <code>/health</code>)</li>
</ul>
<h3 id="types-of-load-balancer-on-aws"><a class="header" href="#types-of-load-balancer-on-aws">Types of load balancer on AWS</a></h3>
<ul>
<li>
<p>AWS에는 <strong>4가지 종류의 managed load balancer</strong>가 있다.</p>
<ul>
<li>Classic Load Balancer (v1 - old generation, 사라질 예정) - 2009 - CLB
<ul>
<li>HTTP, HTTPS, TCP, SSL (secure TCP)</li>
</ul>
</li>
<li>Application Load Balancer (v2 - new generation) - 2016 - ALB
<ul>
<li>HTTP, HTTPS, WebSocket</li>
</ul>
</li>
<li>Network Load Balancer (v2 - new generation) - 2017 - NLB
<ul>
<li>TCP, TLS (secure TCP), UDP</li>
</ul>
</li>
<li>Gateway Load Balancer - 2020 - GWLB
<ul>
<li>Operates at layer 3 (Network layer) - IP Protocol</li>
</ul>
</li>
</ul>
</li>
<li>
<p>대체로는 새로운 세대의 로드 밸런서를 이용하는 것이 추천된다. 더 많은 기능을 보유하기 때문이다.</p>
</li>
<li>
<p>일부 로드 밸런서는 internal(private) 또는 external (public) ELB로써 설정될 수 있다.</p>
</li>
</ul>
<h2 id="application-load-balancer-v2"><a class="header" href="#application-load-balancer-v2">Application Load Balancer (v2)</a></h2>
<ul>
<li>Application load balancer는 레이어 7(Application Layer)에 해당</li>
<li>여러 머신들로 여러 HTTP 애플리케이션에 대한 로드 밸런싱 (target groups)</li>
<li>동일한 머신 내 여러 애플리케이션에 대한 로드 밸런싱 (Ex: containers)</li>
<li>HTTP/2와 웹 소켓을 지원</li>
<li>리다이렉트 지원 (from HTTP to HTTPS for example)</li>
<li>다른 타겟 그룹(target group)에 대한 라우팅 테이블
<ul>
<li>URL 내 path에 기반한 라우팅 (example.com<code>/users</code> &amp; example.com<code>/posts</code>)</li>
<li>URL 내 hostname에 기반한 라우팅 (<code>one.example.com</code> &amp; <code>other.example.com</code>)</li>
<li>쿼리스트링, 헤더에 기반한 라우팅 (example.com/users?<code>id=123&amp;order=false</code>)</li>
</ul>
</li>
<li>ALB는 마이크로 서비스 &amp; 컨테이너 기반 애플리케이션에 매우 적합함. (ex. Docker &amp; Amazon ECS)</li>
<li>ECS의 다이나믹 포트로 리다이렉트 해주는 포트 매핑(port mapping) 기능이 있음.</li>
<li>CLB(Classic Load Balancer)로 치면, 각각의 애플리케이션에 여러 개의 CLB를 두는 것과 유사함.</li>
</ul>
<h3 id="application-load-balancer-v2--target-groups"><a class="header" href="#application-load-balancer-v2--target-groups">Application Load Balancer (v2) ~ Target Groups</a></h3>
<ul>
<li>어떤 것들이 Target group이 될 수 있는가?
<ul>
<li>EC2 인스턴스 (Auto Scaling Group으로 관리될 수 있음) - HTTP</li>
<li>ECS tasks (ECS 자체적으로 관리됨) - HTTP</li>
<li>Lambda functions - HTTP 요청이 JSON 이벤트로 변환</li>
<li>IP Addresses - 반드시 private IP들이어야 함</li>
</ul>
</li>
<li>ALB는 여러 개의 target group에 라우팅을 할 수 있음</li>
<li>헬스 체크(health check)는 target group level에서 수행됨</li>
</ul>
<h3 id="application-load-balancer-v2--good-to-know"><a class="header" href="#application-load-balancer-v2--good-to-know">Application Load Balancer (v2) ~ Good to Know</a></h3>
<ul>
<li>호스트네임(hostname)이 고정됨 ~ (XXX.region.elb.amazonaws.com)</li>
<li>애플리케이션 서버는 클라이언트의 IP를 직접 볼 수 없음
<ul>
<li>클라이언트의 진짜 IP는 <code>X-Forwarded-For</code> 헤더에 삽입됨</li>
<li>포트(<code>X-Forwarded-Port</code>)와 프로토콜(<code>X-Forwarded-Proto</code>)도 알 수 있음</li>
</ul>
</li>
</ul>
<h2 id="network-load-balancer-v2"><a class="header" href="#network-load-balancer-v2">Network Load Balancer (v2)</a></h2>
<ul>
<li>Network load balancers (Layer 4)는
<ul>
<li><strong>인스턴스들에 TCP &amp; UDP 트래픽을 포워딩</strong></li>
<li>매초 수백만(million)의 요청을 처리할 수 있음</li>
<li>ALB(400ms)보다 더 낮은 레이턴시 (~100ms)</li>
</ul>
</li>
<li><strong><em>각 AZ마다 하나의 정적 IP</em>를 가지며, Elastic IP 할당을 지원</strong> (특정 IP에 대한 화이트리스팅(whitelisting)에 유용함)</li>
<li>NLB는 극도의 성능과 함께 TCP 또는 UDP 트래픽을 다루어야 하는 경우에 사용됨.</li>
<li>AWS 프리티어에 해당하지 않음.</li>
</ul>
<h3 id="network-load-balancer-v2---target-groups"><a class="header" href="#network-load-balancer-v2---target-groups">Network Load Balancer (v2) - Target Groups</a></h3>
<ul>
<li>EC2 instances</li>
<li>IP Addresses - 반드시 private IPs</li>
<li>Application Load Balancer (ALB)</li>
<li><strong>TCP, HTTP, HTTPS 프로토콜에 대한 헬스 체크를 지원</strong></li>
</ul>
<h2 id="gateway-load-balancer"><a class="header" href="#gateway-load-balancer">Gateway Load Balancer</a></h2>
<ul>
<li>3rd party network virtual appliance들을 배포, 확장, 관리할 수 있음
<ul>
<li>Ex.) Firewalls, Intrusion Detection and Prevention systems, Deep Packet Inspection Systems, payload manipulation</li>
</ul>
</li>
<li>Layer 3(Network Layer)에서 동작 - IP 패킷</li>
<li>아래 기능들을 합친 것
<ul>
<li><strong>Transparent Network Gateway</strong> - 모든 트래픽에 대한 단일 entry/exit</li>
<li><strong>Load Balancer</strong> - virtual appliance에 대한 트래픽 분산</li>
</ul>
</li>
<li><strong>6081 포트에 GENEVE 프로토콜을 사용</strong></li>
</ul>
<h3 id="gateway-load-balancer---target-groups"><a class="header" href="#gateway-load-balancer---target-groups">Gateway Load Balancer - Target Groups</a></h3>
<ul>
<li>EC2 instances</li>
<li>IP Addresses - must be private IPs</li>
</ul>
<h2 id="sticky-sessions-session-affinity"><a class="header" href="#sticky-sessions-session-affinity">Sticky Sessions (Session Affinity)</a></h2>
<ul>
<li>stickiness를 구현하여 동일한 클라이언트는 로드 밸런서를 거치더라도 항상 동일한 인스턴스로 리다이렉트되도록 할 수 있음</li>
<li>Classic Load Balancer &amp; Application Load Balancer에서 사용 가능</li>
<li>stickiness를 위해 사용되는 쿠키는 임의로 조정할 수 있는 expiration date가 존재</li>
<li>사례 : 이용자가 세션 데이터를 잃어버리지 않도록 해야하는 경우</li>
<li>stickiness의 적용은 EC2 인스턴스의 부하에 불균형을 일으킬 가능성도 있음.</li>
</ul>
<h3 id="sticky-sessions---cookie-names"><a class="header" href="#sticky-sessions---cookie-names">Sticky Sessions - Cookie Names</a></h3>
<ul>
<li>Application-based Cookies
<ul>
<li>Custom cookie
<ul>
<li>타겟에 의해 생성</li>
<li>애플리케이션에서 요구되는 커스텀 속성들을 추가할 수 있음</li>
<li>각 타겟 그룹에 대해 독립적으로 정의되어야 함</li>
<li><strong>AWSALB</strong>, <strong>AWSALBAPP</strong>, <strong>AWSALBTG</strong>는 사용할 수 없음 (ELB 자체적으로 사용됨)</li>
</ul>
</li>
<li>Application cookie
<ul>
<li>로드 밸런서에 의해 생성</li>
<li><strong>AWSALBAPP</strong>이 쿠키명이 됨</li>
</ul>
</li>
</ul>
</li>
<li>Duration-based Cookies
<ul>
<li>로드 밸런서에 의해 생성되는 쿠키</li>
<li>ALB의 경우 <strong>AWSALB</strong>, CLB의 경우 <strong>AWSELB</strong>라는 쿠키명이 됨.</li>
</ul>
</li>
</ul>
<h2 id="cross-zone-load-balancing"><a class="header" href="#cross-zone-load-balancing">Cross-Zone Load Balancing</a></h2>
<p><img src="https://docs.aws.amazon.com/images/elasticloadbalancing/latest/userguide/images/cross_zone_load_balancing_enabled.png" alt="With CZLB" /></p>
<ul>
<li>Cross Zone Load Balancing을 이용하는 경우:
<ul>
<li>각각의 로드 밸런서 인스턴스가 모든 AZ에 있는 모든 등록 인스턴스 너머로 균일하게 로드를 분산시킴</li>
</ul>
</li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/elasticloadbalancing/latest/userguide/images/cross_zone_load_balancing_disabled.png" alt="Without CZLB" /></p>
<ul>
<li>
<p>Cross Zone Load Balancing을 이용하지 않는 경우:</p>
<ul>
<li>Elastic Load Balancer의 노드 내에 있는 인스턴스들 내에서만 균일하게 분산시킴</li>
</ul>
</li>
<li>
<p>Application Load Balancer</p>
<ul>
<li>기본적으로 활성화되어 있음 (타겟 그룹 단위로 비활성화 가능)</li>
<li>AZ 간 데이터(inter AZ data)에 부과되는 비용 없음</li>
</ul>
</li>
<li>
<p>Network Load Balancer &amp; Gateway Load Balancer</p>
<ul>
<li>기본적으로 비활성화</li>
<li>활성화 시에는 AZ 간 데이터(inter AZ data)에 비용이 부과됨</li>
</ul>
</li>
<li>
<p>Classic Load Balancer</p>
<ul>
<li>기본적으로 비활성화</li>
<li>활성화 시에는 AZ 간 데이터(inter AZ data)에 비용이 부과됨</li>
</ul>
</li>
</ul>
<h2 id="ssltls---basics"><a class="header" href="#ssltls---basics">SSL/TLS - Basics</a></h2>
<ul>
<li>SSL 인증서는 클라이언트와 로드밸런서 간의 트래픽을 전송 중에(in transit) 암호화해주는 역할을 한다. (in-flight encryption)</li>
<li><strong>SSL</strong> : Secure Socket Layer, 암호화 연결을 위해 사용</li>
<li><strong>TLS</strong> : Transport Layer Security, SSL의 새 버전</li>
<li>요즘은 <strong>TLS 인증서가 주로 사용</strong>되지만, 사람들은 여전히 이걸 SSL이라는 명칭으로 부른다.</li>
<li>공공 SSL 인증서는 Certificate Authorities(CA)에서 발급함
<ul>
<li>ex.) Comodo, Symantec, GoDaddy, GlobalSign, Digicert, Letsencrypt, etc...</li>
</ul>
</li>
<li>SSL 인증서는 (직접 정하는) 만료일이 존재하며, 반드시 정기적으로 갱신되어야 한다.</li>
</ul>
<h3 id="load-balancer---ssl-certificates"><a class="header" href="#load-balancer---ssl-certificates">Load Balancer - SSL Certificates</a></h3>
<ul>
<li>로드 밸런서는 X.509 인증서를 사용함 (SSL/TLS server certificate)</li>
<li>ACM(AWS Certificate Manager)를 통해서 인증서를 관리할 수 있음</li>
<li>원한다면 직접 본인이 소유한 인증서를 업로드할 수도 있음</li>
<li>HTTPS listener:
<ul>
<li>기본 인증서를 지정해야 함</li>
<li>다중 도메인(multiple domains)을 지원하기 위해 선택적 인증서 목록(optional list of certs)을 추가할 수 있음</li>
<li>클라이언트는 본인이 도달한 호스트 네임을 지정하기 위해 SNI (Server Name Indication) 을 사용할 수 있음</li>
<li>구 버전의 SSL/TLS을 지원하고자 하는 경우, HTTPS에 특정 보안 정책을 설정할 수 있음 (legacy clients)</li>
</ul>
</li>
</ul>
<h3 id="ssl---server-name-indication-sni"><a class="header" href="#ssl---server-name-indication-sni">SSL - Server Name Indication (SNI)</a></h3>
<ul>
<li>SNI는 <strong>하나의 웹 서버에서 여러 SSL 인증서들이 로드되는 문제를 해결</strong>함 (여러 웹사이트를 서빙하기 위해)</li>
<li>이는 새로운 프로토콜이며, 클라이언트에게 처음 SSL 핸드셰이크를 할 때에 <strong>타겟 서버의 호스트네임을 알려주는(indicate) 역할</strong>을 함</li>
<li>클라이언트는 이를 바탕으로 올바른 인증서를 찾거나, 또는 기본 인증서를 반환함</li>
<li>유의점:
<ul>
<li>ALB와 NLB, 그리고 CloudFront에서만 동작 (신세대)</li>
<li>CLB에는 적용할 수 없음 (구세대)</li>
</ul>
</li>
</ul>
<h2 id="elastic-load-balancers---ssl-certificates"><a class="header" href="#elastic-load-balancers---ssl-certificates">Elastic Load Balancers - SSL Certificates</a></h2>
<ul>
<li>
<p>Classic Load Balancer (v1)</p>
<ul>
<li>오직 하나의 SSL 인증서만 지원</li>
<li>여러개의 SSL 인증서를 가진 여러 개의 호스트네임을 위해서는 반드시 여러 개의 CLB를 사용해야만 함</li>
</ul>
</li>
<li>
<p>Application Load Balancer (v2)</p>
<ul>
<li>여러 개의 SSL 인증서를 가진 여러 개의 리스너를 지원함</li>
<li>이것이 가능하게 하도록 SNI (Server Name Indication)을 사용함</li>
</ul>
</li>
<li>
<p>Network Load Balancer (v2)</p>
<ul>
<li>여러 개의 SSL 인증서를 가진 여러 개의 리스너를 지원함</li>
<li>이것이 가능하게 하도록 SNI (Server Name Indication)을 사용함</li>
</ul>
</li>
</ul>
<h2 id="connection-draining"><a class="header" href="#connection-draining">Connection Draining</a></h2>
<ul>
<li>
<p>명칭</p>
<ul>
<li>Connection Draining - CLB의 경우</li>
<li>Deregistration Delay - ALB &amp; NLB의 경우</li>
</ul>
</li>
<li>
<p>인스턴스가 de-registering(등록 해제) 또는 unhealthy 상태인 동안에 이루어진 &quot;in-flight requests&quot;를 완수하는 시점</p>
</li>
<li>
<p>de-registering 상태인 EC2 인스턴스에 대한 새 요청들을 멈춤</p>
</li>
<li>
<p>1 ~ 3600초 사이 (기본 300초)</p>
</li>
<li>
<p>비활성화 가능 (0초로 설정할 경우)</p>
</li>
<li>
<p>요청들이 짧게 이루어지는 경우라면 낮은 값으로 설정</p>
</li>
</ul>
<h2 id="auto-scaling-group---asg"><a class="header" href="#auto-scaling-group---asg">Auto Scaling Group - ASG</a></h2>
<ul>
<li>
<p>현실에서, 웹사이트와 애플리케이션에 대한 부하(load)는 변할 수 있음</p>
</li>
<li>
<p>클라우드에서는 서버를 매우 빠르게 자유롭게 생성하고 앲앨 수 없음</p>
</li>
<li>
<p>Auto Scaling Group (ASG)의 목표는</p>
<ul>
<li>Scale out (EC2 인스턴스의 추가) ~ 더 높은 부하에 대응</li>
<li>Scale in (EC2 인스턴스 제거) ~ 더 낮은 부하에 대응</li>
<li>작동 중인 EC2 인스턴스의 최소/최대 개수를 보장</li>
<li>하나의 로드 밸런서에 새 인스턴스들을 자동으로 등록(register)</li>
<li>이전의 인스턴스가 종료되는 경우(ex. unhealthy인 경우), EC2 인스턴스를 재생성</li>
</ul>
</li>
<li>
<p>ASG는 무료 (EC2 인스턴스에 대한 값만 지불)</p>
</li>
</ul>
<h3 id="auto-scaling-group-attributes"><a class="header" href="#auto-scaling-group-attributes">Auto Scaling Group Attributes</a></h3>
<ul>
<li><strong>Launch Template</strong> (구 Launch Configurations ~ deprecated)
<ul>
<li>AMI + Instance Type</li>
<li>EC2 User Data</li>
<li>EBS Volumes</li>
<li>Security Groups</li>
<li>SSH Key Pair</li>
<li>IAM Roles for your EC2 Instances</li>
<li>Network + Subnets Information</li>
<li>Load Balancer Information</li>
</ul>
</li>
<li>Min Size / Max Size / Initial Capacity</li>
<li>Scaling Policies</li>
</ul>
<h3 id="auto-scaling---cloudwatch-alarms--scaling"><a class="header" href="#auto-scaling---cloudwatch-alarms--scaling">Auto Scaling - CloudWatch Alarms &amp; Scaling</a></h3>
<ul>
<li>CloudWatch 알람에 기반하여 ASG를 스케일링할 수 있음</li>
<li>알람은 metric을 모니터함 (<strong>Average CPU, 또는 커스텀 metric</strong>)</li>
<li><strong>Average CPU와 같은 Metric들은 ASG 인스턴스 전체에 대하여 계산됨</strong></li>
<li>이러한 알람에 기반해서
<ul>
<li>scale-out 정책을 생성 (인스턴스 개수 증가)</li>
<li>scale-in 정책을 생성 (인스턴스 개수 감소)</li>
</ul>
</li>
</ul>
<h3 id="auto-scaling-groups---dynamic-scaling-policies"><a class="header" href="#auto-scaling-groups---dynamic-scaling-policies">Auto Scaling Groups - Dynamic Scaling Policies</a></h3>
<ul>
<li>Target Tracking Scaling
<ul>
<li>제일 간단하고 셋업하기 쉬움</li>
<li>예시: 평균 ASG CPU를 40% 정도에 머무르게 하고 싶음</li>
</ul>
</li>
<li>Simple / Step Scaling
<ul>
<li>CloudWatch 알람이 트리거 될 때 (ex. CPU &gt; 70%), 유닛을 2개  추가</li>
<li>CloudWatch 알람이 트리거 될 때 (ex. CPU &lt; 30%), 유닛을 하나 제거</li>
</ul>
</li>
</ul>
<h3 id="auto-scaling-groups---scheduled-actions"><a class="header" href="#auto-scaling-groups---scheduled-actions">Auto Scaling Groups - Scheduled Actions</a></h3>
<ul>
<li>알려진 사용 패턴(known usage patterns)에 기반하여 스케일링을 기대(anticipate)하는 것</li>
<li>예시: 금요일 10시부터 5시에는 최소 가용량을 증가시킴</li>
</ul>
<h3 id="auto-scaling-groups---predictive-scaling"><a class="header" href="#auto-scaling-groups---predictive-scaling">Auto Scaling Groups - Predictive Scaling</a></h3>
<ul>
<li><strong>Predictive scaling</strong>: 지속적으로 부하를 예측하고, 스케일링을 미리 스케줄함 (머신러닝 기반)</li>
</ul>
<h3 id="good-metrics-to-scale-on"><a class="header" href="#good-metrics-to-scale-on">Good metrics to scale on</a></h3>
<ul>
<li><strong>CPUUtilization</strong>: 인스턴스 전반적인 평균 CPU 활성량</li>
<li><strong>RequestCountPerTarget</strong>: 각 EC2 인스턴스 별 안정적인 요청의 개수를 보장</li>
<li><strong>Average Network In / Out</strong> (애플리케이션이 네트워크 영역(bound)에 있는 경우)</li>
<li><strong>Any custom metric</strong> (CloudWatch를 통해 push 가능)</li>
</ul>
<h3 id="auto-scaling-groups---scaling-cooldowns"><a class="header" href="#auto-scaling-groups---scaling-cooldowns">Auto Scaling Groups - Scaling Cooldowns</a></h3>
<ul>
<li>스케일링 활동이 일어난 이후에는, <strong>cooldown period</strong>를 갖는다. (<strong>기본 300초</strong>)</li>
<li>이 cooldown period 동안에는, ASG가 추가로 인스턴스를 실행하거나 종료하지 않음 (metrics가 안정화되는 시간을 갖게하기 위해서)</li>
<li><strong>조언</strong>: ready-to-use AMI를 사용하여 인스턴스의 설정 시간 줄여 요청에 대한 처리를 빠르게 하고, cooldown period를 줄일 수 있도록 하자.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="aws-rds"><a class="header" href="#aws-rds">AWS RDS</a></h1>
<ul>
<li>RDS : Relational Database Service</li>
<li>SQL을 쿼리 언어로 사용하는 DB를 위한 관리형 DB 서비스</li>
<li>AWS를 통해 관리되는 클라우드에 데이터베이스를 생성할 수 있도록 해줌
<ul>
<li>Postgres</li>
<li>MySql</li>
<li>MariaDB</li>
<li>Oracle</li>
<li>Microsoft SQL Server</li>
<li>Aurora (AWS Proprietary database)</li>
</ul>
</li>
</ul>
<h2 id="advantage-over-using-rds-versus-deploying-db-on-ec2"><a class="header" href="#advantage-over-using-rds-versus-deploying-db-on-ec2">Advantage over using RDS versus deploying DB on EC2</a></h2>
<ul>
<li>RDS는 관리형 서비스
<ul>
<li>자동화된 프로비저닝(provisioning), OS 패칭(patching)</li>
<li>지속적인 백업과 구체적인 타임스탬프로 복구 (Point in Time Restore)</li>
<li>대쉬보드 모니터링</li>
<li>Read replica -&gt; 읽기 성능 향상</li>
<li>Multi AZ setup for DR (Disaster Recovery)</li>
<li>Maintenance windows for upgrades</li>
<li>Scaling capability (vertical and horizontal)</li>
<li>저장소를 EBS로 백업 (gp2 or io1)</li>
</ul>
</li>
<li>인스턴스로 SSH 접속을 할 수는 없음</li>
</ul>
<h2 id="rds---storage-auto-scaling"><a class="header" href="#rds---storage-auto-scaling">RDS - Storage Auto Scaling</a></h2>
<ul>
<li>RDS DB 인스턴스의 가용량(storage)를 동적으로 상승시킬 수 있도록 도와줌</li>
<li>RDS가 남은 데이터베이스의 가용량이 고갈됨을 확인할 때, 자동으로 스케일을 확장</li>
<li>DB 스토리지를 수동으로 확장하지 않아도 됨</li>
<li><strong>Maximum Storage Threshold</strong> (DB 스토리지의 최대 한계값)을 설정해야 함</li>
<li>다음의 경우들에 스토리지는 자동으로 수정됨
<ul>
<li>할당된 스토리지의 10%보다 남은 가용량이 적은 경우</li>
<li>낮은 가용량이 최소 5분 동안 지속되는 경우</li>
<li>최근의 수정으로부터 6시간이 지난 이후</li>
</ul>
</li>
<li><strong>예측 불가능한 워크로드(unpredictable workloads)</strong> 를 가진 애플리케이션에 유용함.</li>
<li>모든 RDS DB 엔진에 대해 지원 (MariaDB, MySQL, PostgreSQL, SQL Server, Oracle)</li>
</ul>
<h2 id="rds-read-replicas-for-read-scalability"><a class="header" href="#rds-read-replicas-for-read-scalability">RDS Read Replicas for read scalability</a></h2>
<ul>
<li>5개의 Read Replicas 까지 지원</li>
<li>Within AZ, Cross AZ 또는 Cross Region (세가지 옵션)</li>
<li>Replication은 <strong>비동기적</strong>(ASYNC), 따라서 읽기 작업이 결국 일관적(consistent)이다.</li>
<li>Replica는 그들 자신의 DB로 승격(promote)될 수 있다.</li>
<li>애플리케이션들은 read replica들을 사용하고자 하는 경우 connection string을 업데이트해야만 한다.</li>
</ul>
<h2 id="rds-read-replicas---use-cases"><a class="header" href="#rds-read-replicas---use-cases">RDS Read Replicas - Use Cases</a></h2>
<ul>
<li>일반적인 load를 처리하는 프로덕션 DB를 보유한 경우</li>
<li>분석을 위해 리포팅을 하는 애플리케이션을 실행하고 싶다면</li>
<li>새로운 workload를 처리하는 Read Replica를 만듬</li>
<li>이 때, 프로덕션 애플리케이션에는 영향이 가지 않음</li>
<li>Read Replica는 오직 SELECT(=read) 관련문만 처리할 수 있음 (not INSERT, UPDATE, DELETE)</li>
</ul>
<h2 id="rds-read-replicas---network-cost"><a class="header" href="#rds-read-replicas---network-cost">RDS Read Replicas - Network Cost</a></h2>
<ul>
<li>AWS에서는 하나의 AZ에서 다른 곳으로 전달되는 데이터의 경우에는 network cost가 발생함</li>
<li><strong>동일한 region 내에 있는 RDS Read Replica의 경우에는 비용이 부과되지 않음</strong></li>
</ul>
<h2 id="rds-multi-az-disaster-recovery"><a class="header" href="#rds-multi-az-disaster-recovery">RDS Multi AZ (Disaster Recovery)</a></h2>
<ul>
<li>SYNC replication</li>
<li>하나의 DNS 네임 -&gt; automatic app failover 대비</li>
<li><strong>availability</strong> 향상</li>
<li>AZ의 손실, Network 손실, 인스턴스 또는 스토리지의 실패에 대한 장애조치</li>
<li>앱에 대한 어떤 수동적인 개입(intervention)을 하지 않음</li>
<li>확장을 위해 사용되지 않음</li>
<li><strong>중요</strong>: <strong>Read Replica는 Disaster Recovery(DR)을 위해 Multi AZ로 셋업될 수 있다.</strong></li>
</ul>
<h3 id="rds---from-single-az-to-multi-az"><a class="header" href="#rds---from-single-az-to-multi-az">RDS - From Single-AZ to Multi-AZ</a></h3>
<ul>
<li>Zero downtime operation (DB를 멈출 필요 없음)</li>
<li>단순히 DB에 대한 &quot;수정(modify)&quot; 버튼을 클릭하기만 하면 됨</li>
<li>그러면 아래와 같은 작업들이 내부적으로 일어남
<ul>
<li>스냅샷이 찍힘</li>
<li>새 DB가 새로운 AZ에서 앞서 찍은 스냅샷을 통해 복구됨.</li>
<li>두 DB 사이에 동기화(synchronization) 작업이 이루어짐.</li>
</ul>
</li>
</ul>
<h2 id="rds-custom"><a class="header" href="#rds-custom">RDS Custom</a></h2>
<ul>
<li><strong>OS와 DB에 대한 커스터마이징이 가능한 관리형 Oracle 또는 Microsoft SQL Server 데이터베이스</strong></li>
<li>RDS: AWS 내 DB의 설정, 작업, 스케일링의 자동화</li>
<li>Custom: 그 아래 놓인 DB와 OS에 대한 접근으로, 다음과 같은 일들을 할 수 있음.
<ul>
<li>Configure settings</li>
<li>Install patches</li>
<li>Enable native features</li>
<li><strong>SSH 또는 SSM Session Manager</strong>를 통해 RDS 아래의 EC2 인스턴스에 접근</li>
</ul>
</li>
<li>커스터마이징을 하려면 <strong>Automation Mode</strong>를 비활성화 해야함 -&gt; 그 전에 DB 스냅샷을 찍어두는 것을 권장</li>
<li>RDS vs. RDS Custom
<ul>
<li>RDS: AWS로부터 관리되는 DB와 OS 전체</li>
<li>RDS Custom: 그 아래 놓인 OS와 DB에 대해 완전한 어드민 접근</li>
</ul>
</li>
</ul>
<h2 id="amazon-aurora"><a class="header" href="#amazon-aurora">Amazon Aurora</a></h2>
<ul>
<li>Aurora는 AWS가 소유한(proprietary) 자체적인 기술 (오픈 소스가 아님)</li>
<li>Postgres와 MySQL 모두 Aurora DB와 호환됨 (= Aurora를 Postgres나 MySQL DB처럼 사용할 수 있음)</li>
<li>Aurora는 AWS 클라우드에 최적화되어 있어, RDS의 MySQL보다 5배, RDS의 Postgres보다 3배 더 높은 성능 향상을 기대할 수 있음</li>
<li>Aurora 스토리지는 자동으로 10GB까지 증가될 수 있으며, 최대 128TB까지.</li>
<li>Aurora는 15개의 replica를 가질 수 있음. (MySQL은 5개까지) 또한 이러한 replication 과정이 빠름 (10ms 미만의 replica lag)</li>
<li>Aurora의 장애조치(Failover)는 즉각적(instantaneous)이며, High-Availity(HA) native임.</li>
<li>Aurora는 RDS보다 높은 가격(20% 이상)이지만, 더 효율적임.</li>
</ul>
<h3 id="aurora-high-availability-and-read-scaling"><a class="header" href="#aurora-high-availability-and-read-scaling">Aurora High Availability and Read Scaling</a></h3>
<ul>
<li>3개의 AZ에 걸쳐 6개의 데이터 사본이 생성됨
<ul>
<li>쓰기 시 6개 중 4개 필요</li>
<li>읽기 시 6개 중 3개 필요</li>
<li>peer-to-peer 복제를 통한 자가 복구</li>
<li>스토리지가 100개의 볼륨에 걸쳐 스트라이프 처리</li>
</ul>
</li>
<li>하나의 Aurora 인스턴스가 쓰기 작업을 처리 (master)</li>
<li>마스터에 대한 장애조치는 30초 이내로 처리됨</li>
<li>master에 더해, 최대 15개의 Aurora Read Replicas가 읽기 작업을 처리</li>
<li>Cross Region Replication을 지원함</li>
</ul>
<h3 id="aurora-db-cluster"><a class="header" href="#aurora-db-cluster">Aurora DB Cluster</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2017/11/01/AZ-Cluster-Endpoint.jpg" alt="Aurora Cluster" /></p>
<h3 id="features-of-aurora"><a class="header" href="#features-of-aurora">Features of Aurora</a></h3>
<ul>
<li>자동 장애조치</li>
<li>백업 및 복구</li>
<li>격리(isolation) 및 보안</li>
<li>산업 규정 준수 (industry compliance)</li>
<li>Push-button scaling</li>
<li>Zero downtime으로 자동화된 패칭(Patching)</li>
<li>고급 모니터링(Advanced Monitoring)</li>
<li>Routine maintenace</li>
<li>백트래킹(Backtrack): 백업 없이 특정한 시점으로 데이터를 복구</li>
</ul>
<h3 id="aurora-replicas---auto-scaling"><a class="header" href="#aurora-replicas---auto-scaling">Aurora Replicas - Auto Scaling</a></h3>
<p><img src="https://velog.velcdn.com/images%2Fcombi_jihoon%2Fpost%2F79a5fe80-4bb1-4883-a750-62b40d4d2c69%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-07%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.38.10.png" alt="Aurora auto scaling" /></p>
<h3 id="aurora---custom-endpoints"><a class="header" href="#aurora---custom-endpoints">Aurora - Custom Endpoints</a></h3>
<p><img src="https://miro.medium.com/v2/resize:fit:1200/1*VC6IYPGQ_JR4ZDam1VktJw.png" alt="Aurora custom endpoint" /></p>
<ul>
<li>Aurora Instance의 부분 집합을 커스텀 엔드포인트로 정의</li>
<li>Ex. 특정 replica(사본)들에서만 분석 쿼리를 실행</li>
<li>Custom Endpoint의 정의 이후에 일반적으로 Reader Endpoint는 사용되지 않음.</li>
</ul>
<h3 id="aurora-serverless"><a class="header" href="#aurora-serverless">Aurora Serverless</a></h3>
<ul>
<li>실제 사용에 기반한 자동화된 데이터베이스 인스턴스화(Instantiation)와 오토 스케일링</li>
<li>비주기적(infrequent)이고, 간헐적(intermittent)이며, 예측 불가능한(unpredictable) 워크로드의 경우에 유용함</li>
<li>capacity planning(특정 capacity를 선택해야 할 필요)가없음</li>
<li>매초마다 비용을 지불하며, 더 비용 효율적임(cost-effective).</li>
</ul>
<h3 id="aurora-multi-master"><a class="header" href="#aurora-multi-master">Aurora Multi-Master</a></h3>
<ul>
<li>write node 에 대한 즉각적인 failover를 원할 때 (high availability)</li>
<li>모든 노드가 R/W를 수행 - vs. 하나의 Read replica를 새로운 master로 승격</li>
</ul>
<h3 id="global-aurora"><a class="header" href="#global-aurora">Global Aurora</a></h3>
<ul>
<li>Aurora Cross Region Read Replicas:
<ul>
<li>disaster recovery(장애 조치)에 유용</li>
<li>설치가 간편함</li>
</ul>
</li>
<li>Aurora Global Database (recommended):
<ul>
<li>하나의 주요 리전 (Read / Write)</li>
<li>5개 까지의 보조 리전(Read 전용), 복제에 걸리는 지연 시간이 1초 미만임</li>
<li>각 보조 리전 당 16개까지의 Read Replica</li>
<li>latency 감소에 도움</li>
<li>또다른 리전 승격(장애 조치 목적)은 RTO(= Recovery Time Objective)가 1분 미만</li>
<li><strong>일반적인 cross-region 복제는 1초 미만이 소요됨</strong></li>
</ul>
</li>
</ul>
<h3 id="aurora-machine-learning"><a class="header" href="#aurora-machine-learning">Aurora Machine Learning</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2019/11/23/aurora-ml-integrations.png" alt="Aurora Machin Learning" /></p>
<ul>
<li>SQL을 통해 애플리케이션에 대한 ML 기반 예측 활성화</li>
<li>간단하고, 최적화되어 있으며, 안전하게 통합된 Aurora와 AWS ML 서비스</li>
<li>지원되는 서비스
<ul>
<li>Amazon SageMaker (어떤 ML 모델도 사용 가능)</li>
<li>Amazon Comprehend (감성 분석 용도)</li>
</ul>
</li>
<li>굳이 ML 경험을 필요로 하지 않음</li>
<li>이용 사례: 사기 감지(fraud detection), 광고 타겟팅(ads targeting), 감성 분석(sentiment analysis), 제품 추천(product recommendation)</li>
</ul>
<h2 id="backups"><a class="header" href="#backups">Backups</a></h2>
<h3 id="rds-backups"><a class="header" href="#rds-backups">RDS Backups</a></h3>
<ul>
<li>Automated backups:
<ul>
<li>매일 데이터베이스 전체를 백업 (window 백업 도중)</li>
<li>매 5분마다 Transaction log가 RDS에 의해 백업됨
<ul>
<li>백업된 시점의 어디로든 복구가 가능함 (가장 오래된 백업부터, 최소 5분 전까지)</li>
</ul>
</li>
<li>1일에서 35일까지 보존(retention), 0으로 설정하면 automated backup을 비활성화</li>
</ul>
</li>
<li>Manual DB Snapshots
<ul>
<li>말 그대로 수동으로 백업</li>
<li>원하는 기간만큼 백업 보존</li>
</ul>
</li>
<li><strong>요령:</strong> RDS 데이터베이스를 중지하더라도, 여전히 storage에 대한 비용은 청구됨. 따라서, DB를 오랜기간 동안 중지하고자 한다면, 중지하는 대신에 스냅샷을 찍어놓고, 복구를 시키는 편이 더 좋음.</li>
</ul>
<h3 id="aurora-backups-rds와-유사"><a class="header" href="#aurora-backups-rds와-유사">Aurora Backups (RDS와 유사)</a></h3>
<ul>
<li>
<p>Automated backups:</p>
<ul>
<li>1일에서 35일까지 (비활성화 불가능)</li>
<li>위 해당 기간의 특정 시점으로 복구 가능</li>
</ul>
</li>
<li>
<p>Manual DB Snapshots</p>
<ul>
<li>수동으로 백업</li>
<li>원하는 기간만큼 백업 보존</li>
</ul>
</li>
</ul>
<h3 id="rds--aurora-restore-options"><a class="header" href="#rds--aurora-restore-options">RDS &amp; Aurora Restore Options</a></h3>
<ul>
<li><strong>RDS / Aurora 백업 또는 스냅샷의 복구는 새로운 DB를 생성함</strong></li>
<li><strong>S3로부터 MySQL RDS DB를 복구</strong>
<ul>
<li>온-프로미스 DB의 백업을 생성</li>
<li>AWS S3에 이를 저장</li>
<li>MySQL을 실행하는 새로운 RDS 인스턴스로 백업 파일을 복구</li>
</ul>
</li>
<li><strong>S3로부터 MySQL Aurora cluster를 복구</strong>
<ul>
<li>Percona XtraBackup을 사용하는 온-프로미스 DB의 백업 생성</li>
<li>AWS S3에 이를 저장</li>
<li>MySQL을 실행하는 새로운 Aurora cluster로 백업 파일을 복구</li>
</ul>
</li>
</ul>
<h3 id="aurora-database-cloning"><a class="header" href="#aurora-database-cloning">Aurora Database Cloning</a></h3>
<ul>
<li>기존에 갖고있던 Aurora DB 클러스터를 새로 복제하여 생성</li>
<li>스냅샷을 찍고 이를 복구하는 것보다 빠름</li>
<li><strong>copy-on-write</strong> 프로토콜을 사용
<ul>
<li>최초에 새로 생성된 DB 클러스터는 기존의 DB클러스터와 동일한 데이터 볼륨을 사용함 (빠르고 효율적임 -&gt; 데이터를 따로 복제할 필요가 없음)</li>
<li>새로운 DB 클러스터 데이터에 업데이트가 이루어지면, 그제서야 새로운 스토리지가 할당되고, 데이터가 복제 및 분리됨</li>
</ul>
</li>
<li>매우 빠르고 비용 효율적</li>
<li><strong>프로덕션 DB에는 영향을 주지 않으면서 프로덕션 DB로부터 staging DB를 새로 생성하기에 유용함</strong></li>
</ul>
<h2 id="rds--aurora-security"><a class="header" href="#rds--aurora-security">RDS &amp; Aurora Security</a></h2>
<ul>
<li>
<p><strong>At-rest encryption</strong></p>
<ul>
<li>DB master &amp; replica는 AWS KMS를 통해 암호화됨 -&gt; 실행 시점에 정의되어야 함</li>
<li>master가 암호화되지 않았다면, read replica도 암호화될 수 없음</li>
<li>암호화되지 않은 DB를 암호화하려면, DB 스냅샷을 찍은 후, 암호화된 형태로 복구해야 함</li>
</ul>
</li>
<li>
<p><strong>In-flight encryption</strong></p>
<ul>
<li>기본적으로 TLS-ready, 클라이언트 측에서는 AWS TLS 루트 인증서를 사용</li>
</ul>
</li>
<li>
<p><strong>IAM Authentication</strong></p>
<ul>
<li>DB에 접속하기 위한 IAM role (username/pw 대신)</li>
</ul>
</li>
<li>
<p><strong>Security Groups</strong></p>
<ul>
<li>RDS / Aurora DB에 대한 네트워크 접근을 통제</li>
</ul>
</li>
<li>
<p><strong>RDS Custom이 아니라면 SSH 접근은 허용하지 않음</strong></p>
</li>
<li>
<p><strong>Audit Logs를 활성화한다면</strong> 더 장기적인 보관을 위해 Cloudwatch Log로 전송할 수 있음</p>
</li>
</ul>
<h2 id="rds-proxy"><a class="header" href="#rds-proxy">RDS Proxy</a></h2>
<ul>
<li>RDS를 위한 완전 관리형(Fully managed) DB 프록시</li>
<li>앱들이 pooling 하거나, DB에 연결된 DB 커넥션들을 공유할 수 있도록 해줌</li>
<li><strong>DB 리소스들에 대한 부하를 줄이고, open connection들을 최소화(+ timeout 추가) 함으로써 DB 효율성을 높임</strong></li>
<li>서버리스, 오토스케일링, High available (multi-AZ)</li>
<li><strong>RDS &amp; Aurora의 failover 시간을 최대 66%까지 단축</strong></li>
<li>RDS(MySQL, PostgreSQL, MariaDB)와 Aurora(MySQL, PostgreSQL)에 대해 지원</li>
<li>대부분 앱의 경우, 별도로 요구되는 코드 변경이 없음</li>
<li><strong>DB에 대한 IAM 인증을 강화하며, AWS Secrets Manager 내에 안전하게 credential들을 저장</strong></li>
<li><strong>RDS Proxy는 절대 공개적으로 접근할 수 없음 (반드시 VPC를 통해 접근되어야 함)</strong></li>
</ul>
<h2 id="elasticache"><a class="header" href="#elasticache">ElastiCache</a></h2>
<h3 id="elasticache-overview"><a class="header" href="#elasticache-overview">ElastiCache Overview</a></h3>
<ul>
<li>ElastiCache는 관리형 Redis 또는 Memcached라고 할 수 있다.</li>
<li>Cache는 인-메모리(in-memory) DB로, 매우 높은 성능과 낮은 레이턴시를 보유한다.</li>
<li>읽기 집약적인 워크로드에 대한 데이터베이스 부하를 줄이는 데에 도움을 준다.</li>
<li>애플리케이션을 무상태성(stateless)으로 만드는데에 도움을 준다.</li>
<li>AWS는 OS 유지 보수 / 패칭(patch), 최적화, 설정, 구성, 모니터링, 장애 조치 및 백업을 관리해준다.</li>
<li><strong>ElastiCache의 사용은 애플리케이션에 많은 코드 변경을 요구한다.</strong></li>
<li>과정
<ul>
<li>애플리케이션이 ElastiCache에 쿼리를 보내고, 그것이 처리가 불가능하다면, 그 결과를 RDS로부터 가져와 ElastiCache에 저장</li>
<li>이로부터 RDS에 대한 부하를 완화할 수 있음</li>
<li>가장 최신의 데이터가 사용될 수 있도록, 캐시는 반드시 비활성화 전략을 갖추어야 함</li>
</ul>
</li>
</ul>
<h3 id="elasticache---user-session-store"><a class="header" href="#elasticache---user-session-store">ElastiCache - User Session Store</a></h3>
<ul>
<li>과정
<ul>
<li>이용자가 애플리케이션의 어디로든 로그인</li>
<li>애플리케이션이 ElastiCache에 세션 데이터를 작성</li>
<li>이용자가 애플리케이션의 다른 인스턴스로 접근</li>
<li>해당 인스턴스는 앞서 작성한 세션 데이터를 검색하여 사용하고, 이에 따라 이용자는 로그인 상태를 유지할 수 있음</li>
</ul>
</li>
</ul>
<h3 id="elasticache---redis-vs-memcached"><a class="header" href="#elasticache---redis-vs-memcached">ElastiCache - Redis vs Memcached</a></h3>
<ul>
<li>
<p>Redis</p>
<ul>
<li>Auto-failover와 함께 <strong>Multi AZ</strong></li>
<li>읽기 확장(scale read)를 위한 <strong>Read Replica</strong>와 함께, <strong>High availability</strong>를 보유</li>
<li>AOF persistence를 통한 Data Durability(데이터 내구성)</li>
<li><strong>백업과 복구 기능</strong></li>
<li><strong>Sets와 Sorted Sets 기능 지원</strong></li>
</ul>
</li>
<li>
<p>Memcached</p>
<ul>
<li>데이터의 파티셔닝을 위한 멀티 노드 (sharding)</li>
<li><strong>High availability (replication) 없음</strong></li>
<li><strong>비영구적 (Non persistent)</strong></li>
<li><strong>백업 및 복구 기능 없음</strong></li>
<li>멀티 쓰레드 기반의 아키텍처</li>
</ul>
</li>
</ul>
<h3 id="elasticache---cache-security"><a class="header" href="#elasticache---cache-security">ElastiCache - Cache Security</a></h3>
<ul>
<li>ElastiCache는 <strong>Redis에 대한 IAM 인증</strong>을 지원</li>
<li>ElastiCache에 대한 IAM 정책은 오직 AWS API 레벨의 보안을 위해서만 사용됨</li>
<li><strong>Redis AUTH</strong>
<ul>
<li>Redis 클러스터 생성 시 &quot;password/token&quot;을 설정할 수 있음</li>
<li>이는 캐시에 대한 추가 보안 수준에 해당함 (보안 그룹에 더해서)</li>
<li>flight encryption 내 SSL 지원</li>
</ul>
</li>
<li>Memcached
<ul>
<li>SASL 기반의 인증 지원</li>
</ul>
</li>
</ul>
<h3 id="patterns-for-elasticache"><a class="header" href="#patterns-for-elasticache">Patterns for ElastiCache</a></h3>
<ul>
<li><strong>Lazy Loading</strong>: 모든 읽기 데이터가 캐시되며, 이에 따라 데이터가 캐시 내에서 stale한 상태가 될 수 있음</li>
<li><strong>Write Through</strong>: DB 내에 쓰기 작업이 이루어 질때, 캐시에 데이터를 추가하거나 업데이트 (stale data가 없음)</li>
<li><strong>Session Store</strong>: 캐시 내에 일시적인 세션 데이터를 저장 (TTL 기능을 사용)
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things</p>
</blockquote>
</li>
</ul>
<h3 id="elasticache---redis-use-case"><a class="header" href="#elasticache---redis-use-case">ElastiCache - Redis Use Case</a></h3>
<ul>
<li>게임 리더보드 -&gt; 계산하기 복잡함</li>
<li><strong>Redis Sorted Sets</strong>는 요소의 고유함(uniqueness)와 순서를 보장함</li>
<li>새로운 요소가 추가될 때마다, 랭킹이 실시간으로 반영되고, 이에 따라 올바른 순서로 추가됨</li>
</ul>
<h2 id="list-of-ports-to-be-familiar-with"><a class="header" href="#list-of-ports-to-be-familiar-with">List of Ports to be familiar with</a></h2>
<ul>
<li>
<p>아래는 최소한 한번쯤 봤을 법한, <strong>일반적인</strong> 포트 번호의 목록이며, 이를 외울 필요는 없지만, 주요한 포트 번호들과 DB 포트를 각각 구분할 줄은 아는 것이 좋다.</p>
</li>
<li>
<p><strong>Important ports</strong>:</p>
<ul>
<li>FTP: 21</li>
<li>SSH: 22</li>
<li>SFTP: 22 (SSH와 동일)</li>
<li>HTTP: 80</li>
<li>HTTPS: 443</li>
</ul>
</li>
<li>
<p><strong>RDS Databases ports</strong>:</p>
<ul>
<li>PostgreSQL: 5432</li>
<li>MySQL: 3306</li>
<li>Oracle RDS: 1521</li>
<li>MSSQL Server: 1433</li>
<li>MariaDB: 3306 (MySQL과 동일)</li>
<li>Aurora: 5432(postgreSQL 호환의 경우) 또는 3306 (MySQL 호환의 경우)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="route-53"><a class="header" href="#route-53">Route 53</a></h1>
<h2 id="what-is-dns"><a class="header" href="#what-is-dns">What is DNS?</a></h2>
<ul>
<li>DNS은 IP 주소를 인간 친화적인 형태의 호스트네임으로 변환해주는 역할을 한다.</li>
<li>ex.) <code>www.google.com</code> -&gt; <code>172.217.18.36</code></li>
<li>DNS는 인터넷의 백본(backbone)이다.</li>
<li>DNS는 계층적 네이밍 구조를 사용한다.</li>
</ul>
<h2 id="dns-terminologies"><a class="header" href="#dns-terminologies">DNS Terminologies</a></h2>
<p><img src="https://miro.medium.com/v2/resize:fit:1102/1*neC9vjKw-9WVVjHJy03ZIw.png" alt="DNS Terminologies" /></p>
<ul>
<li>Domain Registrar: Amazon Route 53, GoDaddy, ...</li>
<li>DNS Records: A, AAAA, CNAME, NS, ...</li>
<li>Zone File: DNS 레코드를 포함</li>
<li>Name Server: DNS 쿼리를 처리 (Authoritative or Non-Authoritative)</li>
<li>Top Level Domain (TLD): .com, .us, .in, .gov, .org, ...</li>
<li>Second Level Domain (SLD): amazon.com, google.com, ...</li>
</ul>
<h2 id="how-dns-works"><a class="header" href="#how-dns-works">How DNS Works</a></h2>
<p><img src="https://d1.awsstatic.com/Route53/how-route-53-routes-traffic.8d313c7da075c3c7303aaef32e89b5d0b7885e7c.png" alt="How DNS Works" /></p>
<h2 id="amazon-route-53"><a class="header" href="#amazon-route-53">Amazon Route 53</a></h2>
<ul>
<li>highly available하고, scalable한, 완전 관리형 권한 보유(authoritative) DNS
<ul>
<li>authoritative = 고객(나)이 DNS 레코드를 갱신할 수 있음</li>
</ul>
</li>
<li>Route53은 또한 Domain Registrar이기도 함.</li>
<li>보유한 리소스에 대한 health check가 가능</li>
<li>100% availability SLA를 제공하는 유일한 AWS 서비스</li>
<li>왜 Route53이란 이름일까? -&gt; 53은 전통적인 DNS 포트넘버</li>
</ul>
<h3 id="route-53---records"><a class="header" href="#route-53---records">Route 53 - Records</a></h3>
<ul>
<li>
<p>레코드 -&gt; 도메인에 대한 트래픽을 라우팅하는 방법</p>
</li>
<li>
<p>각각의 record는 다음을 보유함</p>
<ul>
<li><strong>Domain/subdomain Name</strong> -&gt; ex. example.com</li>
<li><strong>Record Type</strong> -&gt; ex. A or AAAA</li>
<li><strong>Value</strong> -&gt; ex. 12.34.56.78</li>
<li><strong>Route Policy</strong> -&gt; Route53이 쿼리에 대응하는 방식</li>
<li><strong>TTL</strong> -&gt; DNS resolver들에 레코드가 캐시되는 시간</li>
</ul>
</li>
<li>
<p>Route53은 아래의 DNS 레코드 타입들을 지원함</p>
<ul>
<li>(<strong>필수</strong>) A / AAAA / CNAME / NS</li>
<li>(고급) CAA / DS / MX / NAPTR/ PTR / SOA / TXT / SPF/ SRV</li>
</ul>
</li>
</ul>
<h3 id="route-53---record-types"><a class="header" href="#route-53---record-types">Route 53 - Record Types</a></h3>
<ul>
<li><strong>A</strong> - 호스트네임을 IPv4로 매핑</li>
<li><strong>AAAA</strong> - 호스트네임을 IPv6로 매핑</li>
<li><strong>CNAME</strong> - 호스트네임을 또 다른 호스트네임으로 매핑
<ul>
<li>매핑한 대상은 반드시 A 또는 AAAA 레코드를 갖고 있어야 함</li>
<li>CNAME을 DNS 네임스페이스의 최상위 노드에서 생성할 수는 없음 (Zone Apex)</li>
<li>ex. <code>example.com</code>에서는 만들수 없지만, <code>www.example.com</code>에서는 만들 수 있음</li>
</ul>
</li>
<li><strong>NS</strong> - Hosted Zone에 대한 네임 서버
<ul>
<li>한 도메인에 대한 트래픽을 어떻게 라우트할지 통제함</li>
</ul>
</li>
</ul>
<h3 id="route-53---hosted-zones"><a class="header" href="#route-53---hosted-zones">Route 53 - Hosted Zones</a></h3>
<ul>
<li>하나의 도메인과 그것의 서브도메인에 대한 트래픽을 어떻게 라우팅할 것인지 정의하는 레코드들의 컨테이너</li>
<li><strong>Public Hosted Zones</strong> - 인터넷(public domain names)에서 트래픽을 어떻게 라우팅할지 명시하는 레코드들을 보유 -&gt; ex. <code>application1.mypublicdomain.com</code></li>
<li><strong>Private Hosted Zones</strong> - 하나 또는 그 이상의 VPC(private domain names)에서 트래픽을 어떻게 라우팅할지 명시하는 레코드들을 보유 -&gt; ex. <code>application1.company.internal</code></li>
<li>각 hosted zone마다 한달에 0.50 만큼 지불</li>
</ul>
<h3 id="route-53---records-ttl-time-to-live"><a class="header" href="#route-53---records-ttl-time-to-live">Route 53 - Records TTL (Time To Live)</a></h3>
<ul>
<li>High TTL - ex. 24hr
<ul>
<li>Route 53에 낮은 트래픽을 전달</li>
<li>Record가 최신의 것이 아닐 가능성이 있음</li>
</ul>
</li>
<li>Low TTL - ex. 60sec
<ul>
<li>Route53에 더 많은 트래픽 (그에 따라 더 많은 비용)</li>
<li>Record를 최신으로 유지하기 쉬움 -&gt; Record 변경이 쉬움</li>
</ul>
</li>
<li><strong>Alias 레코드를 제외하면, TTL은 각각의 DNS 레코드에 의무적으로 필요함</strong></li>
</ul>
<h3 id="cname-vs-alias"><a class="header" href="#cname-vs-alias">CNAME vs Alias</a></h3>
<ul>
<li>AWS 리소스(Load Balancer, CloudFront...)들은 AWS 호스트 네임을 갖고 있음
<ul>
<li><code>lbl-1234.us-east-2.elb.amazonaws.com</code></li>
</ul>
</li>
<li>CNAME:
<ul>
<li>하나의 호스트네임을 다른 호스트네임을 가리키도록 함 (<code>app.mydomain.com</code> -&gt; <code>blabla.anything.com</code>)</li>
<li><strong>오직 루트가 아닌 도메인에 대해서만 사용 가능 (aka. somthing.mydomain.com)</strong></li>
</ul>
</li>
<li>Alias:
<ul>
<li>하나의 호스트네임을 AWS 리소스를 가리키도록 함 (<code>app.mydomain.com</code> -&gt; <code>blabla.amazonaws.com</code>)</li>
<li><strong>루트 도메인 여부와 상관없이 사용 가능 (aka. mydomain.com)</strong></li>
<li>비용 청구 없음</li>
<li>자체적인 헬스 체크</li>
</ul>
</li>
</ul>
<h3 id="route-53---alias-records"><a class="header" href="#route-53---alias-records">Route 53 - Alias Records</a></h3>
<ul>
<li>AWS 리소스에 대한 호스트네임을 매핑</li>
<li>DNS 기능에 대한 확장</li>
<li>자동으로 AWS 리소스의 IP 주소 변경을 감지</li>
<li>CNAME과 다르게, DNS 네임스페이스의 최상위 노드 (Zone Apex)에서도 사용할 수 있음 -&gt; e.g: <code>example.com</code></li>
<li>Alias 레코드는 항상 AWS 리소스를 가리키는 A/AAAA 타입이어야 함 (IPv4 / IPv6)</li>
<li><strong>TTL을 설정할 수 없음</strong> ~ Route 53 자체적으로 알아서 처리</li>
</ul>
<h3 id="route-53---alias-records-targets"><a class="header" href="#route-53---alias-records-targets">Route 53 - Alias Records Targets</a></h3>
<ul>
<li>Elastic Load Balancers</li>
<li>CloudFront Distributions</li>
<li>API Gateway</li>
<li>Elastic Beanstalk environment</li>
<li>S3 Websites</li>
<li>VPC Interface Endpoints</li>
<li>Global Accelerator accelerator</li>
<li>동일한 hosted zone 내의 Route53 record</li>
<li><strong>EC2 DNS 네임을 ALIAS 레코드로 지정할 수는 없음</strong></li>
</ul>
<h2 id="route-53---routing-policies"><a class="header" href="#route-53---routing-policies">Route 53 - Routing Policies</a></h2>
<ul>
<li>Route 53이 DNS 쿼리에 어떻게 응답할지 정의</li>
<li>&quot;Routing&quot;이라는 명칭으로 인해 혼동하지 말 것
<ul>
<li>LB 관점에서의 트래픽 라우팅과는 다름</li>
<li>DNS는 어떤 트래픽도 라우트하지 않음, 단지 DNS 쿼리에 응답을 해줄 뿐임</li>
</ul>
</li>
<li>Route 53은 아래의 Routing 정책들을 지원함
<ul>
<li>Simple</li>
<li>Weighted</li>
<li>Failover</li>
<li>Latency based</li>
<li>Geolocation</li>
<li>Multi-Value Answer</li>
<li>Geoproximity (using Route 53 Traffic Flow feature)</li>
</ul>
</li>
</ul>
<h3 id="routing-policies---simple"><a class="header" href="#routing-policies---simple">Routing Policies - Simple</a></h3>
<ul>
<li>일반적으로, 트래픽을 하나의 리소스로 라우팅</li>
<li>동일한 레코드에 여러 값을 정의할 수도 있음</li>
<li><strong>만약, 여러 값이 정의된 경우, 클라이언트에 의해 무작위 값 하나가 선택됨</strong></li>
<li>Alias가 활성화된 경우, 하나의 AWS만 정의할 수 있음</li>
<li>헬스 체크에 연결할 수 없음</li>
</ul>
<h3 id="routing-policies---weighted"><a class="header" href="#routing-policies---weighted">Routing Policies - Weighted</a></h3>
<ul>
<li>각각의 특정 리소스마다 요청 비율을 관리</li>
<li>각각의 레코드에 상대적 가중치를 할당 (합계가 꼭 100이어야 할 필요 없음)</li>
</ul>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.10764em;">ff</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord">%</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace"> </span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">recor</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace"> </span><span class="mord mathnormal">a</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">recor</span><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>DNS 레코드들은 반드시 동일한 이름과 타입을 지녀야 함</li>
<li>헬스 체크에 연결할 수 있음</li>
<li>유스 케이스: 리전 간의 로드 밸런싱, 새로운 애플리케이션 버전에 대한 테스트</li>
<li><strong>가중치를 0으로 할당하는 경우, 레코드는 해당 리소스로는 트래픽을 전송하지 않음</strong></li>
<li><strong>만약 모든 레코드의 가중치가 0이라면, 모든 레코드들이 동일한 가중치로 반환됨</strong></li>
</ul>
<h3 id="routing-policies---latency-based"><a class="header" href="#routing-policies---latency-based">Routing Policies - Latency-based</a></h3>
<ul>
<li>이용자에게 가장 적은 레이턴시를 제공할 수 있는(아마도 가장 가까운) 리소스로 리다이렉트</li>
<li>이용자들에 대한 레이턴시 보장이 최우선인 경우 매우 유용</li>
<li><strong>레이턴시는 이용자와 AWS 리전 사이의 트래픽에 근거하여 결정됨</strong>
<ul>
<li>e.g.) 독일인 이용자는 아마 US로 리다이렉트될 것 (만약 그쪽이 제일 레이턴시가 낮다면)</li>
</ul>
</li>
<li>헬스 체크에 연결될 수 있음 (failover capability ~ 장애조치 기능)</li>
</ul>
<h3 id="routing-policies---failover-active-passive"><a class="header" href="#routing-policies---failover-active-passive">Routing Policies - Failover (Active-Passive)</a></h3>
<ul>
<li>먼저 주 인스턴스(primary)에 헬스체크를 시도한 이후, 그것이 실패하면 장애 조치 목적의 보조 인스턴스(secondary)로 라우팅</li>
</ul>
<h3 id="routing-policies---geolocation"><a class="header" href="#routing-policies---geolocation">Routing Policies - Geolocation</a></h3>
<ul>
<li>Latency-based와는 차이가 있음</li>
<li><strong>이용자의 위치 자체에 근거하여 결정됨</strong></li>
<li>대륙, 국가, 또는 주(미국)으로 위치를 정의 (겹치는 상황이라면, 가장 좁은 범위로 선택됨)</li>
<li><strong>기본 레코드</strong>를 생성하는 편이 좋음 (해당하는 위치가 없는 경우)</li>
<li>사례 - 웹사이트 localization, 컨텐츠 배포를 제한, 로드 밸런싱, ...</li>
<li>헬스 체크와 연결 가능</li>
</ul>
<h3 id="geoproximity-routing-policies---geoproximity"><a class="header" href="#geoproximity-routing-policies---geoproximity">Geoproximity Routing Policies - Geoproximity</a></h3>
<ul>
<li>
<p>이용자와 리소스의 지리적인 위치에 기반하여 트래픽을 라우팅</p>
</li>
<li>
<p>정의된 <strong>바이어스</strong>(bias)에 기반하여 <strong>더 많은 트래픽을 각 리소스에 할당</strong></p>
</li>
<li>
<p>지리학적 지역의 크기를 변경하려면, 바이어스의 값을 정의</p>
<ul>
<li>확장(expand)하고자 하는 경우 (1 ~ 99): 해당 리소스에 더 많은 트래픽</li>
<li>축소(shrink)하고자 하는 경우 (-1 ~ -99): 해당 리소스에 더 적은 트래픽</li>
</ul>
</li>
<li>
<p>리소스는 아래와 같은 것이 될 수 있음</p>
<ul>
<li>AWS 리소스 (AWS 리전 명시)</li>
<li>Non-AWS 리소스 (위도, 경도 명시)</li>
</ul>
</li>
<li>
<p>해당 기능을 사용하기 위해서는 반드시 Route 53 Traffic Flow(고급)를 사용해야 함</p>
</li>
</ul>
<h3 id="routing-policies---ip-based-routing"><a class="header" href="#routing-policies---ip-based-routing">Routing Policies - IP-based Routing</a></h3>
<ul>
<li><strong>클라이언트의 IP 주소에 기반하여 라우팅</strong></li>
<li><strong>클라이언트의 CIDR와 엔드포인트/로케이션 목록을 제공</strong> (이용자 IP-엔드포인트 매핑)</li>
<li>사례: 성능 최적화, 네트워크 비용 감축</li>
<li>e.g., 특정 ISP로부터의 엔드 유저를 특정 엔드포인트로 라우팅</li>
</ul>
<h3 id="routing-policies---multi-value"><a class="header" href="#routing-policies---multi-value">Routing Policies - Multi-Value</a></h3>
<ul>
<li>트래픽을 여러 개의 리소스에 라우팅하고자 할 때 사용</li>
<li>Route 53이 여러 개의 값/리소스를 반환</li>
<li>헬스 체크 연결 가능 (healthy resources에 대한 값들만 반환해줌)</li>
<li>각각의 Multi-Value 쿼리에 대해 최대 8개까지의 healthy record만 반환됨</li>
<li><strong>Multi-Value가 ELB를 대체할 수는 없음</strong></li>
</ul>
<h2 id="route-53---health-checks"><a class="header" href="#route-53---health-checks">Route 53 - Health Checks</a></h2>
<ul>
<li>
<p>HTTP 헬스 체크는 오직 <strong>public 리소스</strong> 들에만 적용 가능</p>
</li>
<li>
<p>헬스 체크 -&gt; 자동화된 DNS 장애 조치:</p>
<ol>
<li>엔드포인트에 대한 모니터링 (애플리케이션, 서버, 그 외 AWS 리소스)</li>
<li>다른 헬스 체크에 대한 모니터링 (Calculated Health Checks)</li>
<li>CloudWatch 알람(완전 제어)에 대한 모니터링 - e.g., DynamoDB 쓰로틀링, RDS 알람, 커스텀 메트릭스, ... (private 리소스들의 경우에 유용)</li>
</ol>
</li>
<li>
<p>헬스체크는 CloudWatch metrics와 함께 사용될 수 있음</p>
</li>
</ul>
<h3 id="health-checks---monitor-an-endpoint"><a class="header" href="#health-checks---monitor-an-endpoint">Health Checks - Monitor an Endpoint</a></h3>
<ul>
<li><strong>약 15개의 글로벌 헬스 체커가 엔드포인트 헬스 상태를 체크</strong>
<ul>
<li>Healthy/Unhealthy Threshold - 3 (default)</li>
<li>Interval - 30초 (10초로도 지정 가능 - 더 높은 비용)</li>
<li>지원 프로토콜: HTTP, HTTPS, TCP</li>
<li>약 18% 이상의 헬스 체커가 엔드포인트가 healthy 하다고 리포트한다면, Route 53은 이를 <strong>Healthy</strong>하다고 간주, 그렇지 않다면, <strong>Unhealthy</strong></li>
<li>Route 53이 헬스 체크에 사용할 위치(location)이 어디인지 선택할 수 있음</li>
</ul>
</li>
<li>헬스 체크는 오직 엔드포인트가 2xx, 3xx 상태 코드를 응답할 때만 통과</li>
<li>헬스 체크는 응답의 첫 <strong>5120 bytes</strong>의 텍스트에 기반하여 pass / fail 상태를 설정 (특정 텍스트를 체크)</li>
<li>Route 53 헬스 체커로부터 오는 요청은 라우터/방화벽이 허용하도록 설정해야 함</li>
</ul>
<h3 id="health-checks---calculated-health-checks"><a class="header" href="#health-checks---calculated-health-checks">Health Checks - Calculated Health Checks</a></h3>
<ul>
<li>여러 개의 헬스 체크 결과를 하나의 헬스 체크로 통합</li>
<li><strong>OR, AND, NOT</strong> 조건을 사용 가능</li>
<li>최대 256개의 자식 헬스 체크(child health check)를 모니터링할 수 있음</li>
<li>부모의 헬스 체크를 통과시키려면 얼마나 많은 자식의 헬스 체크가 필요한지 정의 가능</li>
<li>e.g., 모든 헬스 체크가 실패하도록 하지 않으면서 웹사이트를 유지보수하고자 할 때</li>
</ul>
<h3 id="health-checks---private-hosted-zones"><a class="header" href="#health-checks---private-hosted-zones">Health Checks - Private Hosted Zones</a></h3>
<ul>
<li>Route 53 헬스체커는 VPC 외부에 존재</li>
<li>따라서 <strong>private 엔드포인트</strong>에 접근할 수 없음 (private VPC 또는 온-프로미스 리소스)</li>
<li>이에 대처하기 위해, <strong>CloudWatch Metric</strong>을 만들고, 여기에 <strong>CloudWatch Alarm</strong>을 연결 후 해당 알람 자체를 체크하는 헬스 체크를 만들면 됨</li>
</ul>
<h2 id="domain-registar-vs-dns-service"><a class="header" href="#domain-registar-vs-dns-service">Domain Registar vs. DNS Service</a></h2>
<ul>
<li><strong>Domain Registrar != DNS Service</strong></li>
<li>일반적으로 매년 비용을 청구하며 Domain Registrar로부터 도메인 네임을 구매하거나 등록</li>
<li>Domain Registrar는 보통 DNS 레코드 관리를 위해 DNS 서비스도 함께 제공하는 경우가 많음</li>
<li>하지만, DNS 레코드 관리를 위해 다른 DNS 서비스를 사용할 수도 있음</li>
<li>e.g.) GoDaddy에서 구매한 도메인을 Route 53에서 DNS 레코드 관리</li>
<li>어떻게?
<ul>
<li>Route 53에 Hosted Zone을 생성</li>
<li>써드파티 웹사이트(도메인 제공 업체 ~ ex. GoDaddy)에서 NS 레코드를 Route 53의 <strong>네임 서버</strong>로 변경</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="elastic-beanstalk"><a class="header" href="#elastic-beanstalk">Elastic Beanstalk</a></h1>
<h2 id="instantiating-applications-quickly"><a class="header" href="#instantiating-applications-quickly">Instantiating Applications quickly</a></h2>
<ul>
<li>EC2 인스턴스
<ul>
<li><strong>Golden AMI 사용</strong>: 애플리케이션 설치, OS 의존성 등을 미리 처리한 Golden AMI로부터 바로 EC2 인스턴스를 실행</li>
<li><strong>User Data를 사용한 부트스트랩</strong>: 동적인 환경 설정에 대해서는 User Data 스크립트를 사용</li>
<li><strong>Hybrid</strong>: Golden AMI와 User Data를 함께 사용 (Elastic Beanstalk)</li>
</ul>
</li>
<li>RDS 데이터베이스
<ul>
<li>스냅샷으로부터 복구: 동일한 스키마와 데이터를 가진 데이터베이스를 만들 수 있음</li>
</ul>
</li>
<li>EBS 볼륨
<ul>
<li>스냅샷으로부터 복구: 이미 디스크가 포맷되고, 데이터를 가진 상태로 시작</li>
</ul>
</li>
</ul>
<h2 id="developer-problems-on-aws"><a class="header" href="#developer-problems-on-aws">Developer problems on AWS</a></h2>
<ul>
<li>
<p>인프라(infrastructure) 관리</p>
</li>
<li>
<p>코드 배포</p>
</li>
<li>
<p>데이터베이스, 로드 밸런서 등의 설정</p>
</li>
<li>
<p>스케일링</p>
</li>
<li>
<p>대부분의 웹앱은 동일한 아키텍처를 가짐 (ALB + ASG)</p>
</li>
<li>
<p>모든 개발자들이 원하는 것은 단순히 직접 작성한 코드가 실행되길 원함</p>
</li>
<li>
<p>또, 여러 다른 애플리케이션과 환경을 오고가는 상황에서, 내 애플리케이션을 한가지 방법으로 쉽게 배포하고자 할 수 있음</p>
</li>
</ul>
<h2 id="elastic-beanstalk---overview"><a class="header" href="#elastic-beanstalk---overview">Elastic Beanstalk - Overview</a></h2>
<ul>
<li>Elastic Beanstalk는 AWS에서의 애플리케이션 배포에 있어 개발자를 위한 서비스</li>
<li>앞서 봤던 모든 컴포넌트들을 사용함: EC2, ASG, ELB, RDS, ...</li>
<li>관리형 서비스
<ul>
<li>다음의 것들을 자동으로 처리해줌 - 용량 프로비저닝(capacity provisioning), 로드 밸런싱, 스케일링, 애플리케이션 헬스 모니터링, 인스턴스 설정, ...</li>
<li>개발자가 신경쓸 것은 단순히 애플리케이션 코드 뿐임</li>
</ul>
</li>
<li>여전히 설정에 대한 모든 통제는 갖고 있음</li>
<li>Beanstalk 자체는 무료지만, 여기서 사용되는 인스턴스들에 대한 가격은 지불함</li>
</ul>
<h2 id="elastic-beanstalk---components"><a class="header" href="#elastic-beanstalk---components">Elastic Beanstalk - Components</a></h2>
<ul>
<li><strong>Application</strong>: Elastic Beanstalk 컴포넌트의 집합 (환경, 버전, 설정, ...)</li>
<li><strong>Application Version</strong>: 애플리케이션 코드의 iteration</li>
<li><strong>Environment</strong>
<ul>
<li>애플리케이션 버전을 작동시키는 AWS 리소스들의 집합 (오직 한번에 하나의 애플리케이션 버전만)</li>
<li><strong>Tiers</strong>: 웹 서버 환경 티어 &amp; 워커 환경 티어</li>
<li>여러 개의 환경을 만들 수 있음 (dev, test, prod, ...)</li>
</ul>
</li>
</ul>
<h3 id="elastic-beanstalk---worker-environments"><a class="header" href="#elastic-beanstalk---worker-environments">Elastic Beanstalk - Worker environments</a></h3>
<p><img src="https://docs.aws.amazon.com/images/elasticbeanstalk/latest/dg/images/aeb-architecture_worker.png" alt="Worker environment" /></p>
<h2 id="elastic-beanstalk---supported-platforms"><a class="header" href="#elastic-beanstalk---supported-platforms">Elastic Beanstalk - Supported Platforms</a></h2>
<ul>
<li>Go, Java, .NET, Node.js 등등등..</li>
<li>Packer Builder</li>
<li>Single Container Docker</li>
<li>Multi Container Docker</li>
<li>Preconfigured Docker</li>
<li>만약, 해당하는 게 없다면 별도로 커스텀 플랫폼을 작성할 수도 있음 (고급)</li>
</ul>
<h2 id="elastic-beanstalk---deployment-modes"><a class="header" href="#elastic-beanstalk---deployment-modes">Elastic Beanstalk - Deployment Modes</a></h2>
<ul>
<li>Single Instance - dev 환경에 좋음</li>
<li>High Availability with Load Balancer - prod 환경에 좋음</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="s3"><a class="header" href="#s3">S3</a></h1>
<ul>
<li>Amazon S3는 AWS의 주요한 서비스로, &quot;무한하게 확장하는&quot; 스토리지로 광고됨.</li>
<li>많은 웹사이트들이 S3를 백본으로 사용</li>
<li>AWS 서비스들도 S3를 통합(integration)으로 사용함</li>
</ul>
<h2 id="s3---use-cases"><a class="header" href="#s3---use-cases">S3 - Use cases</a></h2>
<ul>
<li>백업 및 저장소</li>
<li>장애 복구</li>
<li>아카이빙</li>
<li>하이브리드 클라우드 저장소</li>
<li>애플리케이션 호스팅</li>
<li>미디어 호스팅</li>
<li>데이터 레이크 &amp; 빅데이터 분석</li>
<li>소프트웨어 배포</li>
<li>정적 웹사이트</li>
</ul>
<h2 id="s3---buckets"><a class="header" href="#s3---buckets">S3 - Buckets</a></h2>
<ul>
<li>AWS S3는 사람들이 objects(파일)들을 버킷(directories) 안에 저장할 수 있도록 해줌</li>
<li>버킷은 <strong>반드시 전역적으로 고유한 이름을 가져야 함</strong> (<strong>모든 리전과 모든 계정 통틀어서</strong>)</li>
<li>버킷은 리전 수준에서 정의됨
<ul>
<li>S3는 마치 글로벌 서비스처럼 보이지만 사실 리전 내에 생성됨</li>
</ul>
</li>
<li>네이밍 컨벤션
<ul>
<li>uppercase 안됨, underscore 안됨</li>
<li>3-63자</li>
<li>IP 불가</li>
<li>반드시 숫자 또는 lowercase 글자로 시작되어야 함</li>
<li>**xn--**으로 시작하는 prefix(접두사)를 붙일 수 없음</li>
<li><strong>-s3alias</strong>로 끝나는 suffix(접미사)를 붙일 수 없음</li>
</ul>
</li>
</ul>
<h2 id="s3---objects"><a class="header" href="#s3---objects">S3 - Objects</a></h2>
<ul>
<li>objects(파일)은 하나의 key를 가짐</li>
<li><strong>key</strong>는 <strong>FULL</strong> path
<ul>
<li><code>s3://my-bucket/my_file.txt</code></li>
<li><code>s3://my-bucket/my_folder1/another_folder/my_file.txt</code></li>
</ul>
</li>
<li>key는 <strong>prefix</strong> + <strong>object name</strong> 의 조합
<ul>
<li><code>s3://my-bucket/my_folder1/another_folder/my_file.txt</code>
<ul>
<li><code>my_folder1/another_folder/</code> -&gt; prefix</li>
<li><code>my_file.txt</code> -&gt; object name</li>
</ul>
</li>
</ul>
</li>
<li>버킷에는 &quot;디렉토리&quot; 라는 개념은 없음 (UI가 마치 디렉토리처럼 느껴지도록 할 수는 있지만)
<ul>
<li>단순히 슬래시(<code>/</code>)를 포함한 매우 긴 key가 있을 뿐임</li>
</ul>
</li>
</ul>
<h2 id="s3---objects-content"><a class="header" href="#s3---objects-content">S3 - Objects content</a></h2>
<ul>
<li>Object value -&gt; body의 content
<ul>
<li>최대 Object 사이즈는 5TB (5000GB)</li>
<li>만약 5GB 이상의 것을 업로드 한다면, 반드시 &quot;multi-part upload&quot;를 사용해야 함</li>
</ul>
</li>
<li>Metadata (텍스트 key-value 페어 목록 - 시스템 또는 이용자 메타데이터)</li>
<li>Tags (유니코드 key-value 페어 - 10개까지) - 보안 / 라이프사이클에 유용</li>
<li>Version ID (버저닝이 활성화된 상태에서만 존재)</li>
</ul>
<h2 id="s3---security"><a class="header" href="#s3---security">S3 - Security</a></h2>
<ul>
<li><strong>User-Based</strong>
<ul>
<li><strong>IAM Policies</strong> - IAM으로부터 특정 이용자에 대한 API 호출이 허용되어야 함</li>
</ul>
</li>
<li><strong>Resource-Based</strong>
<ul>
<li><strong>Bucket Policies</strong> - S3 콘솔을 통해 버킷 전반에 적용되는 룰(bucket wide rules)를 정의 -&gt; 다른 계정으로부터의 호출을 허용</li>
<li><strong>Object Access Control List (ACL)</strong> - 더 미세함 (비활성화 가능)</li>
<li><strong>Bucket Access Control List (ACL)</strong> - 덜 일반적임 (비활성화 가능)</li>
</ul>
</li>
<li><strong>중요</strong>: IAM 책임자(principal)은 다음과 같은 경우라면 S3 오브젝트에 접근할 수 있음
<ul>
<li>해당 이용자의 IAM 권한이 접근을 허용하거나 <strong>또는</strong> 리소스 규칙(resouce policy)가 접근을 허용</li>
<li><strong>그리고</strong> 명시적인 거부(DENY)가 없어야 함</li>
</ul>
</li>
<li><strong>Encryption</strong>: S3 내 오브젝트를 encryption key를 통해 암호화</li>
</ul>
<h3 id="s3---bucket-policies"><a class="header" href="#s3---bucket-policies">S3 - Bucket Policies</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/22d200f8670dbdb3e253a90eee5098477c95c23d/2020/07/10/Resource-Based-Policies-Secrets-Manager-Figure-1.png" alt="JSON Based Policy" /></p>
<ul>
<li>JSON based policies
<ul>
<li>Resources: 버킷과 오브젝트</li>
<li>Effect: Allow / Deny</li>
<li>Actions: 각 API에 대한 Allow / Deny 목록</li>
<li>Principal: 규칙을 적용할 계정 또는 이용자</li>
</ul>
</li>
<li>다음과 같은 경우에 S3 버킷에 대한 policy를 사용
<ul>
<li>버킷에 대한 퍼블릭 액세스를 허용하고자 하는 경우</li>
<li>업로드 시점에 오브젝트가 암호화되도록 강제하고자 할 경우</li>
<li>다른 계정의 액세스를 허용하고자 하는 경우 (Cross Account)</li>
</ul>
</li>
</ul>
<h3 id="s3---bucket-settings-for-block-public-access"><a class="header" href="#s3---bucket-settings-for-block-public-access">S3 - Bucket settings for Block Public Access</a></h3>
<p><img src="https://media.amazonwebservices.com/blog/2019/cb_lock_it_up_3.png" alt="Block public access" /></p>
<ul>
<li><strong>위 옵션들은 기업의 데이터 유출을 막기 위해 생성됨</strong></li>
<li>따라서, 절대 퍼블릭 액세스를 허용해선 안되는 버킷의 경우, 위의 옵션을 유지해둘 것</li>
<li>계정(account) 수준에서 적용 가능</li>
</ul>
<h2 id="s3---static-website-hosting"><a class="header" href="#s3---static-website-hosting">S3 - Static Website Hosting</a></h2>
<ul>
<li>
<p>S3으로는 정적 웹사이트 호스팅을 할 수 있으며, 그것을 인터넷의 누구나 접근할 수 있도록 만들 수 있음</p>
</li>
<li>
<p>웹사이트 URL은 다음과 같음 (리전마다 차이) ~ 외울 필요는 없다</p>
<ul>
<li><a href="http://**bucket-name**.s3-website-**aws-region**.amazonaws.com">http://**bucket-name**.s3-website-**aws-region**.amazonaws.com</a></li>
<li>또는 <a href="http://**bucket-name**.s3-website.**aws-region**.amazonaws.com">http://**bucket-name**.s3-website.**aws-region**.amazonaws.com</a></li>
</ul>
</li>
<li>
<p>만약 위의 웹사이트에서 <strong>403 Forbidden</strong> 에러가 뜬다면, 버킷의 policy가 퍼블릭 읽기 권한을 허용하고 있는지 확인할 것</p>
</li>
</ul>
<h2 id="s3---versioning"><a class="header" href="#s3---versioning">S3 - Versioning</a></h2>
<ul>
<li>S3에 있는 파일들에 버저닝(versioning)을 할 수 있음</li>
<li><strong>버킷 레벨</strong>에서 활성화하는 것도 가능</li>
<li>동일한 key에 대한 덮어쓰기 작업은 key의 버전을 바꾸게 됨 ~ <code>&quot;version&quot;: 1, 2, 3...</code></li>
<li>버킷에다 버저닝을 하는 것이 베스트 프랙티스
<ul>
<li>의도치 않은 삭제 작업으로부터 보호 가능 (특정 버전으로 복구할 수 있음)</li>
<li>이전 버전으로 롤백하기가 쉬움</li>
</ul>
</li>
<li><strong>중요</strong>:
<ul>
<li>버전 활성화를 할 때, 이전에 버저닝이 되지 않았던 파일들은 <code>null</code> 버전을 갖게 됨</li>
<li>버전의 일시중단(suspend) 작업이 이전 버전들을 삭제하지는 않음</li>
</ul>
</li>
</ul>
<h2 id="s3---replication-crr--srr"><a class="header" href="#s3---replication-crr--srr">S3 - Replication (CRR &amp; SRR)</a></h2>
<ul>
<li>source 버킷과 destination 버킷들에 대해 <strong>버저닝이 활성화되어 있어야 함</strong></li>
<li><strong>Cross-Region Replication (CRR)</strong></li>
<li><strong>Same-Region Replication (SRR)</strong></li>
<li>다른 AWS 계정에 있는 버킷도 가능</li>
<li>복사 작업은 비동기적</li>
<li>반드시 S3에게 적절한 IAM 권한을 줘야함</li>
<li>사례
<ul>
<li><strong>CRR</strong> - 규정 준수, 낮은 레이턴시 접근, 계정이 다른 상황에서의 복제</li>
<li><strong>SRR</strong> - 로그 집계, 프로덕션 및 테스트 계정 간의 실시간 복제</li>
</ul>
</li>
</ul>
<h3 id="s3---replications-notes"><a class="header" href="#s3---replications-notes">S3 - Replications (Notes)</a></h3>
<ul>
<li>복제를 활성화한 이후, 오직 새로운 오브젝트만 복제됨</li>
<li>선택적으로, <strong>S3 Batch Replication</strong>을 사용하면 기존에 존재하던 오브젝트에 대해서도 복제를 수행할 수 있음
<ul>
<li>기존에 존재하던 오브젝트나 복제에 실패한 오브젝트를 복제</li>
</ul>
</li>
<li>DELETE 작업의 경우
<ul>
<li>source로부터 target에 <strong>delete marker</strong>들을 복제할 수 있음 (선택 사항)</li>
<li>version ID로 삭제한 내용은 복제되지 않음 (malicious delete를 막기 위해)</li>
</ul>
</li>
<li><strong>복제에 &quot;체이닝&quot;은 없음</strong>
<ul>
<li>만약 버킷1을 버킷2에 복제하고, 이 버킷2를 버킷3로 복제했을 때
<ul>
<li>버킷1에 있는 오브젝트들이 버킷3에 복제되진 않음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="s3---storage-classes"><a class="header" href="#s3---storage-classes">S3 - Storage Classes</a></h2>
<ul>
<li>
<p>Amazon S3 Standard - General Purpose</p>
</li>
<li>
<p>Amazon S3 Standard-Infrequent Access (IA)</p>
</li>
<li>
<p>Amazon S3 One Zone-Infrequent Access</p>
</li>
<li>
<p>Amazon S3 Glacier Instant Retrieval</p>
</li>
<li>
<p>Amazon S3 Glacier Flexible Retrieval</p>
</li>
<li>
<p>Amazon S3 Glacier Deep Archive</p>
</li>
<li>
<p>Amazon S3 Intelligent Tiering</p>
</li>
<li>
<p>각 클래스를 수동으로 변경하거나, S3 라이프사이클 설정을 통해 변경할 수 있음</p>
</li>
</ul>
<h3 id="s3---durability-and-availability"><a class="header" href="#s3---durability-and-availability">S3 - Durability and Availability</a></h3>
<ul>
<li>
<p>Durability:</p>
<ul>
<li>여러 AZ 간에 오브젝트의 높은 durability (99.999999999%) 보장</li>
<li>만약 S3에 10,000,000 개의 오브젝트를 저장한다고 할 때, 평균적으로 10,000년에 한 번씩 하나의 오브젝트가 손실될 것으로 예상 가능함 (아무튼 드물다는 뜻)</li>
<li>모든 스토리지 클래스에 대해 동일</li>
</ul>
</li>
<li>
<p>Availability (가용성)</p>
<ul>
<li>서비스가 말그대로 이용 가능한 상태인지의 여부</li>
<li>스토리지 클래스에 따라 달라짐</li>
<li>ex. S3 Standard는 99.99%의 availability를 가짐 =&gt; 즉, 1년에 53분 정도는 not available함</li>
</ul>
</li>
</ul>
<h3 id="s3-standard---general-purpose"><a class="header" href="#s3-standard---general-purpose">S3 Standard - General Purpose</a></h3>
<ul>
<li>99.99% Availability</li>
<li>자주 액세스되는 데이터에 사용</li>
<li>낮은 latency와 높은 throughput</li>
<li>2개의 concurrent facility failure를 가짐 =&gt; 2개의 데이터 센터에 문제가 생겨도, 다른 데이터 센터에서 대처가 가능</li>
<li>사례: 빅데이터 분석, 모바일 &amp; 게임 앱, 컨텐츠 전송(content distribution), ...</li>
</ul>
<h3 id="s3-storage-classes---infrequent-access"><a class="header" href="#s3-storage-classes---infrequent-access">S3 Storage Classes - Infrequent Access</a></h3>
<ul>
<li>
<p>액세스 빈도가 덜하지만, 필요하다면 빠르게 액세스 되어야 하는 데이터에 사용</p>
</li>
<li>
<p>S3 Standard보다 낮은 비용</p>
</li>
<li>
<p><strong>Amazon S3 Standard-Infrequent Access (S3 Standard-IA)</strong></p>
<ul>
<li>99.9% Availability</li>
<li>사례: 장애 복구, 백업</li>
</ul>
</li>
<li>
<p><strong>Amazon S3 One Zone-Infrequent Access (S3 One Zone-IA)</strong></p>
<ul>
<li>하나의 AZ 내에서 High durability(99.999999999%, 9가 11개), AZ가 파괴되면 데이터가 사라짐</li>
<li>99.5% Availability</li>
<li>사례: 온-프레미스(on-premise) 데이터의 보조 백업 복사본에 대한 저장, 또는 재생성 가능한 데이터</li>
</ul>
</li>
</ul>
<h3 id="s3-glacier-storage-classes"><a class="header" href="#s3-glacier-storage-classes">S3 Glacier Storage Classes</a></h3>
<ul>
<li>
<p>아카이빙 / 백업 의도의 낮은 비용 오브젝트 저장소</p>
</li>
<li>
<p>비용: 스토리지 비용 + 오브젝트 조회(retrieval) 비용</p>
</li>
<li>
<p><strong>Amazon S3 Glacier Instant Retrieval</strong></p>
<ul>
<li>밀리세컨드(ms) 단위 조회, 분기 별로 한번 액세스되는 데이터의 경우에 좋음</li>
<li>저장소의 최소 지속시간 90일</li>
</ul>
</li>
<li>
<p><strong>Amazon S3 Glacier Flexible Retrieval</strong> (Amazon S3 Glacier 이전 버전)</p>
<ul>
<li>데이터 조회에 걸리는 시간
<ul>
<li>Expedited (1 ~ 5분), Standard (3 ~ 5시간), Bulk (5 ~ 12시간) - 무료</li>
</ul>
</li>
<li>저장소의 최소 지속시간 90일</li>
</ul>
</li>
<li>
<p><strong>Amazon S3 Glacier Deep Archive - 장기간 보관에 사용</strong>:</p>
<ul>
<li>데이터 조회에 걸리는 시간
<ul>
<li>Standard (12 시간), Bulk (48 시간)</li>
</ul>
</li>
<li>저장소의 최소 지속시간 180일</li>
</ul>
</li>
</ul>
<h3 id="s3-intelligent-tiering"><a class="header" href="#s3-intelligent-tiering">S3 Intelligent-Tiering</a></h3>
<ul>
<li>매달 약간의 모니터링 및 auto-tiering 비용을 지불</li>
<li>사용 패턴에 따라 Access Tier 간에 오브젝트들을 자동으로 이동시킴</li>
<li>별도로 조회(retrieval) 비용이 존재하지 않음</li>
<li>티어 종류
<ul>
<li>Frequent Access tier (자동): 기본 티어</li>
<li>Infrequent Access tier (자동): 30일 동안 액세스하지 않은 오브젝트</li>
<li>Archive Instant Access tier (자동): 90일 동안 액세스하지 않은 오브젝트</li>
<li>Archive Access tier (선택): 90일에서 700+일 사이로 설정 가능</li>
<li>Deep Archive Access tier (선택): 180일에서 700+일 사이로 설정 가능</li>
</ul>
</li>
</ul>
<h2 id="s3---moving-between-storage-classes"><a class="header" href="#s3---moving-between-storage-classes">S3 - Moving between Storage Classes</a></h2>
<p><img src="https://docs.aws.amazon.com/images/AmazonS3/latest/userguide/images/lifecycle-transitions-v3.png" alt="S3 Lifecycle" /></p>
<ul>
<li>오브젝트들을 각 스토리지 클래스 간에 전환할 수 있음</li>
<li>자주 액세스되지 않는 오브젝트의 경우, <strong>Standard IA</strong>로 이동</li>
<li>빠른 액세스가 요구되지 않는, 아카이빙 오브젝트의 경우 <strong>Glacier 또는 Glacier Deep Archive</strong>로 이동</li>
<li>오브젝트의 이동은 <strong>Lifecycle Rules</strong>를 통해 자동화 될 수 있음</li>
</ul>
<h2 id="s3---lifecycle-rules"><a class="header" href="#s3---lifecycle-rules">S3 - Lifecycle Rules</a></h2>
<ul>
<li>
<p><strong>Transition Actions</strong> - 오브젝트를 다른 스토리지 클래스로 전환하도록 설정</p>
<ul>
<li>생성 이후 60일이 지나면 Standard IA 클래스로 오브젝트 이동</li>
<li>6개월이 지나면 Glacier로 이동</li>
</ul>
</li>
<li>
<p><strong>Expiration Actions</strong> - 일부 시간이 지나면 오브젝트를 만료(삭제)하도록 설정</p>
<ul>
<li>액세스 로그 파일들은 365일이 지난 이후에는 삭제되도록 설정</li>
<li><strong>오래된 버전의 파일들은 삭제되도록 설정 (버저닝이 활성화되어 있는 경우)</strong></li>
<li>불완전한 Multi-Part 업로드들에 대해서는 삭제하도록 설정</li>
</ul>
</li>
<li>
<p>특정한 prefix를 가진 경우에 대해서만 적용할 수도 있음 (ex. <code>s3://mybucket/mp3/*</code>)</p>
</li>
<li>
<p>특정한 오브젝트 태그를 가진 경우에만 적용할 수도 있음 (ex. <code>Department: Finance</code>)</p>
</li>
</ul>
<h3 id="s3---lifecycle-rules-scenario-1"><a class="header" href="#s3---lifecycle-rules-scenario-1">S3 - Lifecycle Rules (Scenario 1)</a></h3>
<blockquote>
<p>내 EC2 애플리케이션은 프로필 사진을 썸네일로 만들어 업로드한다. 이 썸네일들은 쉽게 재생성될 수 있고, 60일 동안 보존되어야 한다. 소스 이미지들은 60일 동안 즉각적으로 조회될 수 있어야하고, 60일이 지난 이후에는 6시간까지 기다릴 수 있다. 이를 어떻게 구현할 수 있을까?</p>
</blockquote>
<ul>
<li>S3 소스 이미지는 <strong>Standard</strong>로 두고, 60일이 지나면 <strong>Glacier</strong>로 전환하도록 라이프사이클 설정을 할 수 있다.</li>
<li>S3 썸네일 이미지는 <strong>One-Zone IA</strong>로 두고, 60일이 지나면 이것이 만료되도록(삭제하도록) 설정할 수 있다.</li>
</ul>
<h3 id="s3---lifecycle-rules-scenario-2"><a class="header" href="#s3---lifecycle-rules-scenario-2">S3 - Lifecycle Rules (Scenario 2)</a></h3>
<blockquote>
<p>내 회사에는 삭제된 S3 오브젝트를 30일 동안은 드물긴 하겠지만 즉각적으로 복구할 수 있어야 한다는 룰이 성명되어 있다. 또 30일이 지난 이후, 최대 365일 동안은 삭제된 오브젝트들이 48시간 내에는 복구 가능(recoverable)한 상태에 있어야 한다.</p>
</blockquote>
<ul>
<li>오브젝트들이 버전을 갖도록 <strong>S3 버저닝을 활성화</strong>한다. 이를 통해, &quot;삭제된 오브젝트&quot;는 실제로 삭제된 것이 아니라, &quot;delete marker&quot;를 가짐으로써, 사실을 숨김 처리가 되었을 뿐, 복구 가능한 상태가 된다.</li>
<li>오브젝트의 비현재 버전(noncurrent version)들을 <strong>Standard IA</strong>로 전환한다.</li>
<li>시간이 지난 이후에는 비현재 버전(noncurrent version)들을  <strong>Glacier Deep Archive</strong>로 전환한다.</li>
</ul>
<h3 id="s3---storage-class-analysis"><a class="header" href="#s3---storage-class-analysis">S3 - Storage Class Analysis</a></h3>
<ul>
<li>오브젝트를 적절한 스토리지 클래스로 전환할 때 결정을 도와줌</li>
<li><strong>Standard</strong>와 <strong>Standard IA</strong>의 경우 추천
<ul>
<li>One-Zone IA나 Glacier에는 적용되지 않음</li>
</ul>
</li>
<li>1일 단위로 리포트가 업데이트됨</li>
<li>데이터 분석 시작까지 24 ~ 48시간</li>
<li>라이프사이클 룰을 적용(또는 향상)하기 위한 좋은 시작</li>
</ul>
<h2 id="s3---requester-pays"><a class="header" href="#s3---requester-pays">S3 - Requester Pays</a></h2>
<ul>
<li>일반적으로 버킷 소유자는 S3 스토리지와 해당 스토리지와 관련된 모든 데이터 전송 비용을 지불함</li>
<li>하지만 <strong>Requester Pays</strong> 버킷을 사용하면, 버킷 소유자가 아닌 요청자(requester)가 버킷으로부터의 데이터 다운로드 및 요청 비용을 지불</li>
<li>다른 계정과 거대한 데이터셋을 공유하고자 할 때 유용함</li>
<li>requester는 반드시 AWS 상에서 인증되어야 함 (익명 이용자가 될 수 없음)</li>
</ul>
<h2 id="s3---event-notifications"><a class="header" href="#s3---event-notifications">S3 - Event Notifications</a></h2>
<ul>
<li>S3:ObjectCreated, S3:ObjectRemoved, S3:ObjectRestore, S3:Replication...</li>
<li>오브젝트 명칭에 대한 필터링 가능 (ex. <code>*.jpg</code>)</li>
<li><strong>사례</strong>: S3로 업로드되는 이미지에 대한 썸네일 생성</li>
<li><strong>원하는 만큼의 &quot;S3 이벤트&quot;를 생성할 수 있음</strong></li>
<li>AWS SNS, SQS, Lambda와 연동 (EventBridge를 통해 더 많은 Destination과 연동 가능)</li>
<li>S3 event notifications는 이벤트 전달에 일반적으로 몇 초 정도가 소요되지만, 가끔 1분, 또는 그 이상이 소요될 수 있음</li>
</ul>
<h3 id="s3---event-notifications-with-amazon-eventbridge"><a class="header" href="#s3---event-notifications-with-amazon-eventbridge">S3 - Event Notifications with Amazon EventBridge</a></h3>
<ul>
<li>JSON 룰을 이용한 <strong>고급 필터링</strong> (메타 데이터, 오브젝트 크기, 명칭...)</li>
<li><strong>Multiple Destinations</strong> - ex. Step functions, Kinesis Streams / Firehose...</li>
<li><strong>EventBridge Capabilities</strong> - Archive, Replay Event, Reliable delivery</li>
</ul>
<h2 id="s3---baseline-performance"><a class="header" href="#s3---baseline-performance">S3 - Baseline Performance</a></h2>
<ul>
<li>S3는 많은 요청 횟수를 처리하고 100-200ms의 레이턴시를 보유하도록 자동으로 스케일링됨</li>
<li><strong>하나의 버킷에 각 prefix 당 매초 최소 3,500 개의 PUT/COPY/POST/DELETE 또는 5,500 GET/HEAD 요청 작업을</strong> 수행할 수 있음</li>
<li>하나의 버킷에 가질 수 있는 prefix 갯수의 제한은 없음</li>
<li><strong>예시 (object path =&gt; prefix)</strong>:
<ul>
<li>bucket/folder1/sub1/file =&gt; /folder1/sub1/</li>
<li>bucket/folder1/sub2/file =&gt; /folder1/sub2/</li>
<li>bucket/1/file =&gt; /1/</li>
<li>bucket/2/file =&gt; /2/</li>
</ul>
</li>
<li>위 4개의 prefix 모두에 균등하게 읽기를 분산시키면, GET과 HEAD에 대해 초당 22,000건의 요청을 달성할 수 있음</li>
</ul>
<h2 id="s3---performance"><a class="header" href="#s3---performance">S3 - Performance</a></h2>
<ul>
<li><strong>Multi-Part upload</strong>:
<ul>
<li>100MB 이상의 파일에 추천</li>
<li>5GB 이상의 파일에는 필수</li>
<li>업로드를 병렬화(parallelize)할 수 있음 (전송 속도 상승)</li>
</ul>
</li>
<li><strong>S3 Transfer Acceleration</strong>
<ul>
<li>타깃 리전에 해당하는 S3 버킷으로 데이터를 전달하는 AWS 엣지 로케이션으로 파일을 전송하여 전송 속도를 향상시킴</li>
<li>Multi-part upload와 호환 가능함</li>
</ul>
</li>
</ul>
<h3 id="s3---performance--s3-byte-range-fetches"><a class="header" href="#s3---performance--s3-byte-range-fetches">S3 - Performance ~ S3 Byte-Range Fetches</a></h3>
<ul>
<li>특정 바이트 범위(byte range)에 대한 요청을 보내서 GET 요청을 병렬화</li>
<li>장애 발생 시 복원력(resilience) 향상</li>
<li><strong>다운로드 속도를 향상시킬 수 있음</strong></li>
<li><strong>데이터의 일부만 조회하는데에 사용할 수 있음</strong> (ex. 파일 헤드)</li>
</ul>
<h2 id="s3---select--glacier-select"><a class="header" href="#s3---select--glacier-select">S3 - Select &amp; Glacier Select</a></h2>
<ul>
<li>SQL을 사용하는 <strong>서버사이드 필터링</strong>을 적용하여 적은 데이터를 조회할 수 있음</li>
<li>row &amp; column으로 필터링 가능 (간단한 SQL 문)</li>
<li>더 적은 양의 네트워크 전송이 이루어지고, 또 더 적은 클라이언트 측 CPU 비용이 발생</li>
</ul>
<h2 id="s3---batch-operations"><a class="header" href="#s3---batch-operations">S3 - Batch Operations</a></h2>
<ul>
<li>
<p>존재하는 S3 오브젝트들에 하나의 요청을 통해 대량 작업을 수행</p>
<ul>
<li>오브젝트의 메타데이터와 프로퍼티를 수정</li>
<li>S3 버킷 간에 오브젝트 복사</li>
<li><strong>비암호화된 오브젝트를 암호화</strong></li>
<li>ACL과 태그를 수정</li>
<li>S3 Glacier로부터 오브젝트들을 복구</li>
<li>각 오브젝트에 커스텀 액션을 수행하는 람다 함수를 실행</li>
</ul>
</li>
<li>
<p>대상 오브젝트 목록, 수행할 액션, 옵션 파라미터로 하나의 작업이 구성됨</p>
</li>
<li>
<p>S3 Batch Operation로 재시도를 관리하고, 진행 상황을 추적하고, 완료 알림을 보내고, 리포트를 생성할 수 있음</p>
</li>
<li>
<p><strong>대상 오브젝트 목록을 얻기위해 S3 Inventory를 사용할 수 있고, 그 목록을 필터링하기 위해 S3 Select를 사용할 수 있음</strong></p>
</li>
</ul>
<h2 id="s3---object-encryption"><a class="header" href="#s3---object-encryption">S3 - Object Encryption</a></h2>
<ul>
<li>
<p>S3 버킷 내 오브젝트들은 아래 4가지 방법 중 하나로 암호화할 수 있음 ~ 어떤 상황에서 어떤 암호화를 적용할 지 이해하는 것이 중요함</p>
</li>
<li>
<p><strong>Server-Side Encryption (SSE)</strong></p>
<ul>
<li><strong>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)</strong> - <em><strong>기본 활성화</strong></em>
<ul>
<li>AWS로부터 소유/관리되는 키를 통해 S3 오브젝트를 암호화</li>
</ul>
</li>
<li><strong>Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)</strong>
<ul>
<li>암호화 키 관리를 위해 AWS Key Management Service (AWS KMS)를 활용</li>
</ul>
</li>
<li><strong>Server-Side Encryption with Customer-Provided Keys (SSE-C)</strong>
<ul>
<li>본인의 커스텀 암호화 키로 관리하고자 할 때</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Client-Side Encryption</strong></p>
</li>
</ul>
<h3 id="s3-encryption---sse-s3"><a class="header" href="#s3-encryption---sse-s3">S3 Encryption - SSE-S3</a></h3>
<ul>
<li>AWS가 다루고, 관리하고, 소유한 키를 통해 암호화</li>
<li>오브젝트는 서버사이드에서 암호화됨</li>
<li>암호화 타입은 <strong>AES-256</strong></li>
<li>반드시 헤더에 다음을 포함 =&gt; <strong>&quot;x-amz-server-side-encryption&quot;: &quot;AES256&quot;</strong></li>
<li><strong>새로 만든 버킷 &amp; 새로운 오브젝트들에는 기본적으로 활성화되어 있음</strong></li>
</ul>
<h3 id="s3-encryption---sse-kms"><a class="header" href="#s3-encryption---sse-kms">S3 Encryption - SSE-KMS</a></h3>
<ul>
<li>AWS KMS(Key Management Service)를 통해 관리되는 키로 암호화</li>
<li>KMS 이점: 이용자 통제 + CloudTrail을 사용한 키 사용 감사(audit)</li>
<li>오브젝트는 서버사이드에서 암호화됨</li>
<li>반드시 헤더에 다음을 포함 =&gt; <strong>&quot;x-amz-server-side-encryption&quot;: &quot;aws:kms&quot;</strong></li>
</ul>
<h3 id="sse-kms-limitation"><a class="header" href="#sse-kms-limitation">SSE-KMS Limitation</a></h3>
<ul>
<li>SSE-KMS를 사용하는 경우, KMS의 한계에 부딫힐 수도 있음</li>
<li>업로드 시에, <strong>GenerateDataKey</strong> KMS API를 호출함</li>
<li>다운로드 시에, <strong>Decrypt</strong> KMS API를 호출함</li>
<li>초당 KMS 할당량(quota)에 포함됨 (리전에 따라 5500, 10000, 30000 req/s)</li>
<li>Service Quotas Console을 사용해서 quota 증량을 요청할 수 있음</li>
</ul>
<h3 id="s3-encryption---sse-c"><a class="header" href="#s3-encryption---sse-c">S3 Encryption - SSE-C</a></h3>
<ul>
<li>AWS 외부의, 이용 고객으로부터 완전히 관리되는 키를 통한 서버사이드 암호화</li>
<li>S3는 관리자(나)가 제공하는 암호화 키를 <strong>보관하지 않음</strong></li>
<li><strong>HTTPS 필수</strong></li>
<li>모든 HTTP 요청의 HTTP 헤더에 암호화 키가 제공되어야 함</li>
</ul>
<h3 id="se-encryption---client-side-encryption"><a class="header" href="#se-encryption---client-side-encryption">SE Encryption - Client-Side Encryption</a></h3>
<ul>
<li><strong>Amazon S3 클라이언트 사이드 암호화 라이브러리</strong>같은 클라이언트 라이브러리를 사용</li>
<li>클라이언트 쪽에서 S3로 데이터를 전송하기 전에 반드시 스스로 암호화를 해서 보내야 함</li>
<li>클라이언트 쪽에서 S3로부터 데이터를 조회할 때도 반드시 스스로 복호화를 해야함</li>
<li>AWS 이용고객(나)가 key와 암호화 사이클을 모두 관리해야함</li>
</ul>
<h3 id="s3---encryption-in-transit-ssltls"><a class="header" href="#s3---encryption-in-transit-ssltls">S3 - Encryption in transit (SSL/TLS)</a></h3>
<ul>
<li>
<p>전송 중 암호화(Encryption in flight)는 SSL/TLS로도 불림</p>
</li>
<li>
<p>S3는 다음의 두가지 엔드포인트를 노출</p>
<ul>
<li><strong>HTTP Endpoint</strong> - 비암호화</li>
<li><strong>HTTPS Endpoint</strong> - encryption in flight</li>
</ul>
</li>
<li>
<p><strong>HTTPS가 권장됨</strong></p>
</li>
<li>
<p><strong>HTTPS는 SSE-C를 사용하고자 하는 경우 필수</strong></p>
</li>
<li>
<p>대부분의 클라이언트들은 기본적으로 HTTPS 엔드포인트를 사용</p>
</li>
</ul>
<h3 id="s3---force-encryption-in-transit"><a class="header" href="#s3---force-encryption-in-transit">S3 - Force encryption in Transit</a></h3>
<p><img src="https://docs.aws.amazon.com/images/whitepapers/latest/efs-encrypted-file-systems/images/image8.jpeg" alt="Secure Transport" /></p>
<ul>
<li><code>aws:SecureTransport</code>를 사용</li>
</ul>
<h3 id="s3---default-encryption-vs-bucket-policies"><a class="header" href="#s3---default-encryption-vs-bucket-policies">S3 - Default Encryption vs. Bucket Policies</a></h3>
<ul>
<li><strong>SSE-S3 암호화는 S3 버킷에 저장되는 새 오브젝트들에 자동으로 적용됨</strong></li>
<li>선택적으로, bucket policy를 활용하여 암호화를 강제하거나, ecnryption header(SSE-KMS 또는 SSE-C)가 없는 경우는 PutObject API 호출을 거부할수도 있음</li>
<li><strong>중요</strong>: Bucker Policy는 <strong>Default Encryption</strong>보다 우선하여 적용됨</li>
</ul>
<h2 id="s3---cors"><a class="header" href="#s3---cors">S3 - CORS</a></h2>
<h3 id="what-is-cors"><a class="header" href="#what-is-cors">What is CORS?</a></h3>
<ul>
<li>Cross-Origin Resource Sharing (CORS)</li>
<li>Origin = scheme (protocol) + host (domain) + port
<ul>
<li>ex.) <code>https://www.example.com</code> (포트 - 443 for HTTPS, 80 for HTTP)</li>
</ul>
</li>
<li><strong>웹 브라우저</strong>는 기본 오리진을 방문하는 동안, 다른 오리진에 대한 요청을 허용
<ul>
<li>동일 오리진: <code>http://example.com/app1</code> &amp; <code>http://example.com/app2</code></li>
<li>서로 다른 오리진: <code>http://www.example.com</code> &amp; <code>http://other.example.com</code></li>
</ul>
</li>
<li>다른 오리진에서 일어난 요청은 <strong>CORS 헤더</strong>를 사용하여 요청을 허용하지 않는 한 처리되지 않음 (ex. <strong>Access-Control-Allow-Origin</strong>)</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/images/cors-overview.png" alt="AWS CORS" /></p>
<h3 id="s3---cors--allow-origin"><a class="header" href="#s3---cors--allow-origin">S3 - CORS ~ allow origin</a></h3>
<ul>
<li>만약 클라이언트가 cross-origin 요청을 S3 버킷에 보낸다면, 적절한 CORS 헤더를 활성화해야 함</li>
<li>시험에 잘 나옴</li>
<li>특정 오리진 또는 *(모든 오리진)을 허용할 수 있음</li>
</ul>
<h2 id="s3---mfa-delete"><a class="header" href="#s3---mfa-delete">S3 - MFA Delete</a></h2>
<ul>
<li><strong>MFA (Multi-Factor Authentication)</strong> - 이용자가 S3에서 중요한 작업을 수행하기 전에, 디바이스(주로 모바일 또는 하드웨어)를 통해 코드를 생성하여 인증하도록 강제</li>
<li>MFA는 다음과 같은 경우에 요구됨
<ul>
<li>오브젝트 버전을 영구적으로 삭제</li>
<li>버킷의 버저닝을 중지</li>
</ul>
</li>
<li>MFA가 요구되지 않는 경우
<ul>
<li>버저닝의 활성화</li>
<li>삭제된 버전의 리스팅</li>
</ul>
</li>
<li>MFA Delete를 사용하려면, <strong>버킷에 반드시 버저닝이 활성화되어야 함</strong></li>
<li><strong>버킷 소유자(루트 계정)만이 오직 MFA Delete를 활성화/비활성화할 수 있음</strong></li>
</ul>
<h2 id="s3---access-logs"><a class="header" href="#s3---access-logs">S3 - Access Logs</a></h2>
<ul>
<li>감사(audit) 목적으로, S3에 대한 모든 액세스를 로그하고 싶을 수 있음</li>
<li>인증 유무에 상관없이 어떤 계정이든 S3에 이루어진 어떤 요청이 다른 S3 버킷에 로깅됨</li>
<li>데이터 분석 툴을 통해 분석될 수 있음</li>
<li>타깃이 되는 로그 버킷(로그가 저장되는 버킷)은 동일한 AWS 리전 내에 있어야 함</li>
</ul>
<details>
  <summary>로그 포맷</summary>
<pre><code>79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be DOC-EXAMPLE-BUCKET1 [06/Feb/2019:00:00:38 +0000] 192.0.2.3 79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be 3E57427F3EXAMPLE REST.GET.VERSIONING - &quot;GET /DOC-EXAMPLE-BUCKET1?versioning HTTP/1.1&quot; 200 - 113 - 7 - &quot;-&quot; &quot;S3Console/0.4&quot; - s9lzHYrFp76ZVxRcpX9+5cjAnEH2ROuNkd2BHfIa6UkFVdtjf5mKR3/eTPFvsiP/XV/VLi31234= SigV4 ECDHE-RSA-AES128-GCM-SHA256 AuthHeader DOC-EXAMPLE-BUCKET1.s3.us-west-1.amazonaws.com TLSV1.2 arn:aws:s3:us-west-1:123456789012:accesspoint/example-AP Yes
79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be DOC-EXAMPLE-BUCKET1 [06/Feb/2019:00:00:38 +0000] 192.0.2.3 79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be 891CE47D2EXAMPLE REST.GET.LOGGING_STATUS - &quot;GET /DOC-EXAMPLE-BUCKET1?logging HTTP/1.1&quot; 200 - 242 - 11 - &quot;-&quot; &quot;S3Console/0.4&quot; - 9vKBE6vMhrNiWHZmb2L0mXOcqPGzQOI5XLnCtZNPxev+Hf+7tpT6sxDwDty4LHBUOZJG96N1234= SigV4 ECDHE-RSA-AES128-GCM-SHA256 AuthHeader DOC-EXAMPLE-BUCKET1.s3.us-west-1.amazonaws.com TLSV1.2 - -
79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be DOC-EXAMPLE-BUCKET1 [06/Feb/2019:00:00:38 +0000] 192.0.2.3 79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be A1206F460EXAMPLE REST.GET.BUCKETPOLICY - &quot;GET /DOC-EXAMPLE-BUCKET1?policy HTTP/1.1&quot; 404 NoSuchBucketPolicy 297 - 38 - &quot;-&quot; &quot;S3Console/0.4&quot; - BNaBsXZQQDbssi6xMBdBU2sLt+Yf5kZDmeBUP35sFoKa3sLLeMC78iwEIWxs99CRUrbS4n11234= SigV4 ECDHE-RSA-AES128-GCM-SHA256 AuthHeader DOC-EXAMPLE-BUCKET1.s3.us-west-1.amazonaws.com TLSV1.2 - Yes
79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be DOC-EXAMPLE-BUCKET1 [06/Feb/2019:00:01:00 +0000] 192.0.2.3 79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be 7B4A0FABBEXAMPLE REST.GET.VERSIONING - &quot;GET /DOC-EXAMPLE-BUCKET1?versioning HTTP/1.1&quot; 200 - 113 - 33 - &quot;-&quot; &quot;S3Console/0.4&quot; - Ke1bUcazaN1jWuUlPJaxF64cQVpUEhoZKEG/hmy/gijN/I1DeWqDfFvnpybfEseEME/u7ME1234= SigV4 ECDHE-RSA-AES128-GCM-SHA256 AuthHeader DOC-EXAMPLE-BUCKET1.s3.us-west-1.amazonaws.com TLSV1.2 - -
79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be DOC-EXAMPLE-BUCKET1 [06/Feb/2019:00:01:57 +0000] 192.0.2.3 79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be DD6CC733AEXAMPLE REST.PUT.OBJECT s3-dg.pdf &quot;PUT /DOC-EXAMPLE-BUCKET1/s3-dg.pdf HTTP/1.1&quot; 200 - - 4406583 41754 28 &quot;-&quot; &quot;S3Console/0.4&quot; - 10S62Zv81kBW7BB6SX4XJ48o6kpcl6LPwEoizZQQxJd5qDSCTLX0TgS37kYUBKQW3+bPdrg1234= SigV4 ECDHE-RSA-AES128-SHA AuthHeader DOC-EXAMPLE-BUCKET1.s3.us-west-1.amazonaws.com TLSV1.2 - Yes
</code></pre>
</details>
<h3 id="s3---access-logs-warning"><a class="header" href="#s3---access-logs-warning">S3 - Access Logs: Warning</a></h3>
<ul>
<li>모니터링 버킷(감시 대상이 되는 버킷)을 로깅 버킷으로 설정해서는 안됨</li>
<li>이 경우, 로깅 루프를 유발하여, <strong>버킷이 무한정 커지게 됨</strong></li>
</ul>
<h2 id="s3---pre-signed-urls"><a class="header" href="#s3---pre-signed-urls">S3 - Pre-Signed URLs</a></h2>
<ul>
<li><strong>S3 콘솔, AWS CLI 또는 SDK</strong>를 통해, pre-signed URL을 생성</li>
<li><strong>URL Expiration</strong>
<ul>
<li><strong>S3 Console</strong> - 1분에서 720분(12시간)까지</li>
<li><strong>AWS CLI</strong> - <code>--expires-in</code> 파라미터로 초 단위 유효기간 설정 가능 (기본 3600초, 최대 604800초 ~ 168시간)</li>
</ul>
</li>
<li>pre-signed URL를 전달받은 이용자는 GET/PUT에 대한 URL을 생성한 이용자의 권한을 상속받음</li>
<li>예시:
<ul>
<li>로그인을 한 유저에게만 S3 버킷으로부터 프리미엄 비디오를 다운로드할 수 있도록 하는 경우</li>
<li>끊임없이 변화하는 이용자 목록들에게만 파일 다운로드 경로를 동적으로 제공하고자 하는 경우</li>
<li>S3 버킷의 특정한 위치에 이용자가 파일을 업로드하도록 일시적으로 허용하고자 하는 경우</li>
</ul>
</li>
</ul>
<h2 id="s3---glacier-vault-lock"><a class="header" href="#s3---glacier-vault-lock">S3 - Glacier Vault Lock</a></h2>
<ul>
<li>WORM(Write Once Read Many) 모델 적용</li>
<li>Vault Lock Policy를 생성</li>
<li>추후의 변경에 대해 policy를 잠금 (더 이상 변경되거나 삭제될 수 없음)</li>
<li>규정 준수(compliance)와 데이터 보관(data retention)에 유용</li>
</ul>
<h2 id="s3---object-lock-versioning-must-be-enabled"><a class="header" href="#s3---object-lock-versioning-must-be-enabled">S3 - Object Lock (versioning must be enabled)</a></h2>
<ul>
<li>WORM(Write Once Read Many) 모델 적용</li>
<li>특정 시간 동안 오브젝트 버전의 삭제를 막음</li>
<li><strong>Retention mode - Compliance</strong>:
<ul>
<li>루트 이용자를 포함해 그 누구도 버전을 덮어씌우거나 삭제할 수 없음</li>
<li>해당 모드는 변경될 수 없고, 정해진 기간도 더 줄일 수 없음</li>
</ul>
</li>
<li><strong>Retention mode - Governance</strong>:
<ul>
<li>대부분의 이용자들은 오브젝트 버전을 덮어씌우거나 삭제하거나, 잠겨진 세팅을 변경할 수 없음</li>
<li>일부 이용자들에게 보관된 내용을 변경하거나, 오브젝트를 삭제할 수 있는 특별한 권한을 부여할 수 있음</li>
</ul>
</li>
<li><strong>Retention Period</strong>:
<ul>
<li>정해진 기간 동안 특정한 오브젝트를 보호하며, 연장될 수 없음</li>
</ul>
</li>
<li><strong>Legal Hold</strong>:
<ul>
<li>보관 기간과 무관하게 오브젝트를 무기한 보호</li>
<li><code>s3:PutObjectLegalHold</code> IAM 권한을 통해 보호를 해제하거나, 오브젝트를 삭제할 수 있음</li>
</ul>
</li>
</ul>
<h2 id="s3---access-points"><a class="header" href="#s3---access-points">S3 - Access Points</a></h2>
<ul>
<li><strong>Access Point는 S3 버킷에 대한 보안 관리를 쉽게 만들어줌</strong></li>
<li><strong>각각의 Access Point는 다음을 가짐</strong>:
<ul>
<li>본인의 DNS 네임 (인터넷 오리진 or VPC 오리진)</li>
<li>액세스 포인트 정책 (버킷 정책과 유사함) - 규모에 따라 보안을 관리</li>
</ul>
</li>
</ul>
<h3 id="s3---access-points--vpc-origin"><a class="header" href="#s3---access-points--vpc-origin">S3 - Access Points ~ VPC Origin</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/e1822db470e60d090affd0956d743cb0e7cdf113/2020/10/12/Set-up-S3-Access-Points-for-an-Amazon-S3-bucket-and-use-it-with-VPC-endpoints.png" alt="S3 Access Points by VPC Origin" /></p>
<ul>
<li>VPC 내에서만 액세스할 수 있도록 액세스 포인트를 정의할 수도 있음</li>
<li>반드시 액세스 포인트로 액세스하는 VPC 엔드포인트를 만들어야 함 (Gateway 또는 Interface 엔드포인트)</li>
<li>반드시 타깃 버킷과 액세스 포인트에 대한 액세스를 VPC 엔드포인트 정책 상으로 허용하고 있어야 함</li>
</ul>
<h2 id="s3-object-lambda"><a class="header" href="#s3-object-lambda">S3 Object Lambda</a></h2>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/03/16/s3-object-lambda-architecture-1.png" alt="S3 Object Lambda" /></p>
<ul>
<li>호출 애플리케이션(caller application)에 의해 오브젝트가 조회되기 전에, AWS 람다 함수를 오브젝트에 적용할 수 있음</li>
<li><strong>S3 Access Point</strong>와 <strong>S3 Object Lambda Access Points</strong>를 갖고 있는 하나의 S3 버킷만 필요함</li>
<li>사례:
<ul>
<li>분석 또는 비프로덕션 환경을 위한 개인 식별 정보 삭제</li>
<li>데이터 포맷 간의 변환 (ex. XML to JSON)</li>
<li>오브젝트를 요청한 사용자 등 호출 세부 정보(caller-specific detail)를 사용하여 즉석에서 이미지 크기를 조정하거나, 워터마킹을 할 수 있음</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="cloudfront"><a class="header" href="#cloudfront">CloudFront</a></h1>
<ul>
<li>Content Delivery Network (CDN) - 컨텐츠 전송 네트워크</li>
<li><strong>컨텐츠를 엣지에 캐시하여 읽기 성능을 향상</strong></li>
<li>이용자 경험 향상</li>
<li>전 세계 216개 지점 (엣지 로케이션)</li>
<li><strong>DDoS 보호 (전 세계적으로 애플리케이션이 배포되기 때문), AWS Shield, AWS Web Application Firewall와 통합</strong></li>
</ul>
<h2 id="cloudfront---origins"><a class="header" href="#cloudfront---origins">CloudFront - Origins</a></h2>
<p><img src="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/images/cloudfront-events-that-trigger-lambda-functions.png" alt="AWS CloudFront" /></p>
<ul>
<li>
<p><strong>S3 버킷</strong></p>
<ul>
<li>엣지에 파일을 배포하고 캐시하는 용도로 사용</li>
<li>CloudFront **Origin Access Control(OAC)**를 사용하여 보안 강화</li>
<li>OAC는 Origin Access Indentitiy (OAI)의 대체</li>
<li>CloudFront는 S3에 파일을 업로드하기 위한 ingress로 사용될 수 있음</li>
</ul>
</li>
<li>
<p><strong>Custom Origin (HTTP)</strong></p>
<ul>
<li>Application Load Balancer</li>
<li>EC2 Instance</li>
<li>S3 웹사이트 (먼저 반드시 버킷을 정적 S3 웹사이트로 활성화해야함)</li>
<li>원하는 HTTP 백엔드 뭐든지</li>
</ul>
</li>
</ul>
<h2 id="cloudfront-vs-cross-region-replication"><a class="header" href="#cloudfront-vs-cross-region-replication">CloudFront vs Cross Region Replication</a></h2>
<ul>
<li>CloudFront
<ul>
<li>글로벌 엣지 네트워크</li>
<li>TTL 기반으로 파일이 캐시됨 (아마 1일)</li>
<li><strong>어디서든 사용 가능해야 하는 정적 컨텐츠에 유용함</strong></li>
</ul>
</li>
<li>S3 Cross Region Replication
<ul>
<li>복제가 일어나길 원하는 각 리전마다 직접 세팅해주어야 함</li>
<li>거의 실시간으로 파일이 업데이트됨</li>
<li>읽기 전용</li>
<li><strong>일부 지역에서 낮은 레이턴시로 사용해야 하는 동적 컨텐츠에 유용함</strong></li>
</ul>
</li>
</ul>
<h2 id="cloudfront---alb-or-ec2-as-an-origin"><a class="header" href="#cloudfront---alb-or-ec2-as-an-origin">CloudFront - ALB or EC2 as an origin</a></h2>
<p><img src="https://s2.51cto.com/images/blog/202107/30/9919472bfa0c101d1597350721fa406e.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="ALB and EC2 as an origin" /></p>
<h2 id="cloudfront---geo-restriction"><a class="header" href="#cloudfront---geo-restriction">CloudFront - Geo Restriction</a></h2>
<ul>
<li>내 배포에 액세스할 수 있는 대상을 제한할 수 있음
<ul>
<li><strong>Allowlist</strong>: 허용한 나라 목록에 포함된 이용자들만 컨텐츠에 액세스 가능</li>
<li><strong>Blocklist</strong>: 금지된 나라 목록에 포함되지 않은 이용자들만 컨텐츠에 액세스 가능</li>
</ul>
</li>
<li>대상 국가의 경우 써드파티 Geo-IP 데이터베이스를 통해 결정됨</li>
<li>사례: 컨텐츠 액세스를 제어하는 저작권법</li>
</ul>
<h2 id="cloudfront---pricing"><a class="header" href="#cloudfront---pricing">CloudFront - Pricing</a></h2>
<ul>
<li>CloudFront 엣지 로케이션은 전 세계에 분포</li>
<li>각 엣지 로케이션 마다 데이터 비용이 다름</li>
</ul>
<h3 id="cloudfront---price-classes"><a class="header" href="#cloudfront---price-classes">CloudFront - Price Classes</a></h3>
<p><img src="https://user-images.githubusercontent.com/29729545/153042484-2e8e09f3-92ad-494d-ad07-f79914c14772.png" alt="Price Classes Map" /></p>
<ul>
<li><strong>비용 감축</strong>을 위해 엣지 로케이션의 갯수를 줄일 수 있음</li>
<li>3개의 Price class가 존재
<ul>
<li>Price Class All: 모든 리전 - 최고 성능</li>
<li>Price Class 200: 대부분의 리전, 제일 비싼 리전들은 제외</li>
<li>Price Class 100: 가장 저렴한 리전만</li>
</ul>
</li>
</ul>
<h2 id="cloudfront---cache-invalidations"><a class="header" href="#cloudfront---cache-invalidations">CloudFront - Cache Invalidations</a></h2>
<ul>
<li>내가 백엔드 오리진을 업데이트했을 경우, CloudFront는 그것을 알 방도가 없기 때문에, 오직 TTL이 만료되고 나서야 갱신된 컨텐츠를 제공하게 됨</li>
<li>다만, <strong>CloudFront Invalidation</strong>을 통해서 강제로 전체 또는 일부 캐시를 갱신(refresh)할 수 있음 (TTL을 우회)</li>
<li>모든 파일(<code>*</code>), 또는 특정 경로(<code>/images/*</code>)에 대해 무효화 할 수 있음</li>
</ul>
<h2 id="global-accelerator"><a class="header" href="#global-accelerator">Global Accelerator</a></h2>
<ul>
<li>배포된 애플리케이션에 직접 접근하고자 하는 글로벌 이용자들은, 많은 홉(hop)으로 인해 레이턴시가 길어질 수 있는 공용 인터넷을 통해 전송됨.</li>
<li>이 때, 레이턴시를 최소화하기 위해 AWS 네트워크를 거쳐 최대한 빠르게 이동하고자 함</li>
</ul>
<h3 id="unicast-ip-vs-anycast-ip"><a class="header" href="#unicast-ip-vs-anycast-ip">Unicast IP vs Anycast IP</a></h3>
<ul>
<li><strong>Unicast IP</strong>: 하나의 서버는 하나의 IP를 가짐</li>
<li><strong>Anycast IP</strong>: 모든 서버가 동일한 IP를 가지며, 클라이언트는 가장 가까운 서버로 라우트됨</li>
</ul>
<h3 id="global-accelerator---overview"><a class="header" href="#global-accelerator---overview">Global Accelerator - Overview</a></h3>
<p><img src="https://d1.awsstatic.com/product-page-diagram_AWS-Global-Accelerator%402x.dd86ff5885ab5035037ad065d54120f8c44183fa.png" alt="Global Accelerator" /></p>
<ul>
<li>AWS 내부 네트워크를 활용하여 애플리케이션으로 라우팅</li>
<li>애플리케이션에 대한 <strong>2개의 Anycast IP</strong>를 생성</li>
<li>Anycast IP는 엣지 로케이션으로 트래픽을 직접 전송</li>
<li>엣지 로케이션은 애플리케이션으로 트래픽을 전송</li>
</ul>
<h3 id="global-accelerator---description"><a class="header" href="#global-accelerator---description">Global Accelerator - Description</a></h3>
<ul>
<li><strong>퍼블릭/프라이빗 상관없이 Elastic IP, EC2 인스턴스, ALB, NLB</strong>과 함께 사용할 수 있음</li>
<li>일관된 성능
<ul>
<li>지능적인 라우팅을 통한 낮은 레이턴시와 빠른 리전 내 장애 복구</li>
<li>클라이언트 캐시와 관련한 문제 없음</li>
<li>내부적으로 AWS 네트워크 사용</li>
</ul>
</li>
<li>헬스 체크
<ul>
<li>Global Accelerator는 애플리케이션에 대한 헬스체크를 수행함</li>
<li>애플리케이션이 글로벌화 될 수 있도록 도와줌 (unhealthy 상태인 경우 1분 이하로 장애 복구)</li>
<li>이러한 헬스체크 덕에 재해 복구(disaster recovery)에 유용함</li>
</ul>
</li>
<li>보안
<ul>
<li>오직 2개의 외부 IP만 화이트리스트에 추가하면 됨</li>
<li>AWS Shield 덕에 DDoS 보호</li>
</ul>
</li>
</ul>
<h3 id="global-accelerator-vs-cloudfront"><a class="header" href="#global-accelerator-vs-cloudfront">Global Accelerator vs CloudFront</a></h3>
<ul>
<li>
<p>둘다 AWS 글로벌 네트워크과 그것의 엣지 로케이션을 사용함</p>
</li>
<li>
<p>두 서비스 모두 AWS Shield를 통한 DDoS 보호를 할 수 있음</p>
</li>
<li>
<p><strong>CloudFront</strong></p>
<ul>
<li>캐시 가능한 컨텐츠 모두에 대한 성능 향상 (이미지나 비디오)</li>
<li>동적 컨텐츠 (API 가속 및 동적 사이트 전송)</li>
<li>컨텐츠가 엣지를 통해 제공됨</li>
</ul>
</li>
<li>
<p><strong>Global Accelerator</strong></p>
<ul>
<li>
<p>TCP나 UDP를 거치는 넓은 범위의 애플리케이션</p>
</li>
<li>
<p>하나 이상의 AWS 리전에 실행되는 애플리케이션으로 엣지에서의 패킷을 프록시해줌</p>
</li>
<li>
<p>non-HTTP 사례에 유용함 - 게이밍 (UDP), IoT (MQTT), 또는 Voice over IP(VoIP)</p>
</li>
<li>
<p>정적인 IP 주소들을 필요로 하는 사례에 적합함</p>
</li>
<li>
<p>결정론적(deterministic)이고 빠른 지역 장애 복구가 필요한 사례에 적합함</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="storage-extras"><a class="header" href="#storage-extras">Storage Extras</a></h1>
<h2 id="aws-snow-family"><a class="header" href="#aws-snow-family">AWS Snow Family</a></h2>
<ul>
<li>
<p>엣지에서 데이터를 수집, 처리하며 <strong>AWS의 안팎으로 데이터를 마이그레이션</strong>하게 해주는 높은 보안성을 지니고 휴대가능한 디바이스</p>
</li>
<li>
<p><strong>Data migration</strong>: Snowcone, Snowball Edge, Snowmobile</p>
</li>
<li>
<p><strong>Edge computing</strong>: Snowcone, Snowball Edge</p>
</li>
</ul>
<h2 id="data-migrations-with-aws-snow-family"><a class="header" href="#data-migrations-with-aws-snow-family">Data Migrations with AWS Snow Family</a></h2>
<p><img src="data:image/png;base64,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AP//jwoKFwAAQABJREFU7N33m2VVlTfwA900OedcjUSRpKgElTbniAhGUDGAacZnfpjnmT9hZpzxHXV0zAFUxACIEbGJKkFyTk0QUIJEgW4a3/1Zt1b1rtP3Vt3bVbe6wNrdt845++yw9lprr/Xda5977hp/L6l5miSkrrHGGs1NN93U/PCHP2w22XiTZvfdd28OOfSQZsGCBeNGoWyWd+Opp56K6yeeeKK59957m5NOOqlZvHhx8/jjjzdvectbmle/+tXNwoULo/3bb7+9+dnPftZccMEFzT333NPssssuzRFHHNG85CUviT70f/755zff/va3m8cee6zZc889m+OPP77Zddddm4022mgcHfUFGm688cbm97//fXPyySc3y5Yta5797Gc3H/rQh5qRkZFm7bXXDjqbIpE7/nRH84UvfKG55pprmqVLlzY77bRTs9122zUbbLBBc8sttzR/+tOfmoceeqjZcccdg3b0b7zxxs28efNinGuuuWbd9YyeJ+91Sl7Sgw8+GOM+88wzm/e9733NXnvt1aAx70ehKf7BX59st5a/ps8777zmt7/9bfPLX/6y+fCHP9y87GUva7bffvuuvaJr+fLl8dHmCSec0JxzzjnNfffd1xx77LHNS1/60mbDDTccR79yZLfmvDWbP/7xj81Zi89qTj/99OY5+zyned7zntfsv//+zQ033NBcdtllzUUXXRS04sMHPvCBoAOPfvWrX4X8Nttss2a33XYLvb7rrruaX/ziF81f/vKX0AH8mz9/fnP11Vc3X/nKV0J3XvziFzevec1rmvXXXz/04vobb2h++tOfNkuW3Br6vdFGG4bO/OAHP2he+MIXNq94xSuarbfeOuRCj9TbYYcdSt42wQ9S60iuK3sGziQLyRjx5JFHHmm22WabBt3GOqyU/ZLNAw88EHMfH33MxWuvvbb529/+FrJ561vf2my/3fbNww8/3Fx51ZXNd7/73ZDx4Ycf3jznOc9pNt988zGbcvPNN4c+/PznP2923nnn5rjjjov76623XszBHA8dOuOMM6Ise8I+mPOLFi0KPaUPv/71r0POz3/+85v3v//9oVPmt/JnnXVW6OChhx7a7LHHHkEP+n5RdPi6668LHXrve9/bvPhFL2q22HyL5kc//lFzdtFTNuwDH/hgc9hhhzVoMv4bi0785CenNPRpZGTnoscfinvGctJJ328uueSS0J2RYosOKjqyx+57xH36gU/kZs6QGdnhITmyO3QHf4aZ2EsyNIdvu+225t3vfnfo8LBtHR168sknQy7kSTb3339/6DJ7cNVVV8VcZL/J6XWve13Qtc466wTf0Y3GtdZaK9jDp5i7J554Yuggm33QQQc1++yzT9gBcr/yyiubP//5z8173vOe5uCDDw7+qmfs5jDbs++++4Z8tYsf6vEXbNob3vCGZr/99gt91RdfxXfgGbuyyaabNsufWh72iP7xh/patOilcf+yyy5tfvOb3zQ//vGPox4fiMZNNtkk5LzVVls13/rWt6Jf917+8pcX27R94ckDISM68dz9D4hxT7dO5JzWbvoPeXw72/o///M/zdve9rbmVa96Vdi1LDPddMyG9tYoA39GAjjMzaHVAgTYTDqTAIB79NFHQ9lf+cpXBlDjGO+4445Q3IsvvjjKMtAAHKetrSVLlgQY+c53vhMGzISYTgD396f+3tx+x+3N5z//+TEHw8EyCAwBAw44SgznouIMTKBtt902QKBx12OOgjP4R/9t3tcA7uijjw7Qm0BrukjLfnP8eJB8kAfAAZDA0Ec+8pHgWTcAl+0w1uhmHH/yk580HB3Q8453vCMAGV0J0FYGYCxRr8juqb8/1Zx66qnN2Wef3dx6663Nm970pgD/6qbBR8Pdd98dxhaAA9DRqi9tcboconOOkq4CfcoAcOhW/8tf/nI4l2fv9ezm6GOObjYthpmhP6OM88ILL4h7QMGyZU82V1xxeRhqAO61r31dARJ7BesZPmmDDTYMgxcotMC3GsDV51F4wD94I800gNOnvjlR8rvqyqvCOT740IPBV7wFqjhJcgJM0HjFFVc03/ve94Kf5r5FGqCZ+mQRR76c3EgBPAAc57buuuuGzPQrJYBTlvwsAgE1gJBsAaNTTjklaAHs6GXm/+hHP4p87aOB02QDyOv83/2u+f0ffl9kfGEDYAJqFpA//tGPy73zi278OcDgSwrYWq/QtKwAkOsLWNTX7bffFqCTzdpg/Q0KX25qvlvGyvkDIcD9PoW+7bbdrpm35rzmxptubP7whz+ETrOBbI2FB576ABBpnzqjHs5ffa0OAGc05rkPwIrnwH8uoukQuthf/LGQoguCCnRv+ZPLQ2/mzZ8XjDE/8dqiUD3+Bc/5ESCLnprvwPvrX//6AMz4TSfpGxC3qNh8gAqIoy8ApcUA+fJxwBsQpz06BsCxKUceeWQsBDYtury8jOe6666NNgVEADh69KxnPau59NJLy8IDgPtRc8ABBzQveMELmhcVcEr/AM4ni2383//93wimoBto3WOPPePe48U3rVVsI/tlvoRdLHxwnvNnKhqStkQb2Z68OQA3Fa7OQF1CIrB+InBJTgo766YR+P73vx/O3Oqb8plAC0sEzqQzMSm0KIponSgXp21ymiycstWOCWhCM5wf+9jHAgBaGfVKnVXw+AiciSkaNFKMdETglj8VKyMr6M997nNlgl0XYI2TYSTRZwz6BeLki+wccsghASqsfFZ3wuvke06wGsAdc/Qx4RDXWHN6JnR7vJymRFaZ8F7UtB2BA4DrlIYa/fgr2gn4MWgMl+gDXpOXlH25l9cMyTe+8Y0A+Rw6w/iiEiFBz1NFvrcsuSUMLYNMfh/84AfDiKfu0EkLCx/t//Wvf40V+++K03YNANMb5aycOQPtfPSjH40I3d1l5f6doptW8JzKBz7w/lL2sdDn73//e1Hmuc99XjHy+zZbbLFlrObXX3+9EtVbK8bYlt0aZWA+U0nZ5uoAcOgWxc7op1W6a3NIdIlcOCFy3XeffQP0XnX1VbHI44gBpD2LcwoAV3RW4sA5WcBMBALwUpaDS51XjrxEOJRjT5QTpQG09Wt+n3baaeFk6RRbQJdEw7761a+GbDhPMgeUUqdvKKBK/xyzSMOi4tAPfN6BzY9/8uOGntx7730FwB0TkTk0AfDX33B9LEQsQHfaaefmk5/8RLNhAe03lbZOKNEgiwf6cswxxzTbF/AWkbuirwCcNgFKzp29ES3ioOkdvUVzPW5jn+6UtnumInCpszkusqS/wCy5WeizEfTInMev5z73uQGCyBI4NnEsyB1TdjWAswi0eACKLR7YHzopsisCzG4A/UCUSC49Mt/NdQsxMpCWLV3W/PWBv4bO0E26aOEG9F9//fWNYANb9Pa3vz1sx2abbd4sLwvNa6+9JgCcBaronL5qACf/iCPeHr5vv333CzuwtPifRx99pPlK0U82zLjNHQuQbbbZtuyMbRyLhrSJ+MjuGT+bP9WUctFOykbeHICbKmeHXJ+QCGwyAJcCVta5SSEETqGcc3wcrO0q12984xvDCJp0lMzEFEGxYjbZREcAuEXFSCrPAJrEQuDasrXxqU99qlHfJOmV1DW56i1Ujri9hcpQAHAZgdOe1daBBx4Yjh7AZOB9rOA4Ayt6Rh4gyXGrlwrufKYSntcy0O+wAVz2l2PEax8yd4/xx3fboKJwol7kCZwrZ+uTcWEEXNMDQF0dYJ6htA0qEsJhAdJhkIqOSclnwECElGMFFHI7g2HngLVNvzghiwDOldMmN4ZQfc4ht2W0BciRM8OuHONt0aBPwNJWqW0x2wZ08aGHH2q+9KUvlW2SzSLa84Y3vD74AMBwCkCpcTLu++23fzid5zxn71itr1kiLn8vhr2MKNrPccUgqz9rVuf9nKZ8VheA07/IxGMFyHK6y55cFosztkRUwzw3jzg9jpTsARYRDAu8BCw5VvVESMhRBMUc3nLLLUOG+kq+mcvsTAK4T3/60+GU2QlltMMxA3cekQDm5SeAk2fui5zUAO6uu+9qzvjNmc1///d/F+f/suaVr3hlcbKLYmFwXlmosBHGIgK37jodm3RDsT0n//DkYr9uLTTvFIvODcv4brzxpubb3/l20aG7m5Fiw44//rhm4402btYsdKCfjQMaLBa0y5YaKyAHWLBhdBcYGWZa3QCOXPEjF8+hT6OLPPPVfGcX8MNc5DcC2JpLxbakTtQAzqL8ZWVbGhjDU/bBHAHgRIABI6AKr+0asUcWZv/6r/8avNemf9Jjjz8WQO2SP14S58d99Lhm2+22DQCnrQRwe++9d1m4bdGY5WwN/fth0YujjjqqWXTYorK43qO57PLLy7w4M/zgscd+MGigi2uuMfrYS+HFL4ten3PuOaG72raFuvfez44Fyq4F6AeALX0YE77hBZs51ZS2RDvJU3lzAG6qnB1y/TSMkwE4ZNRCdp4fRiAdLMPtGoDzDJmVNIVgpCi1Veedd94ZTpMBNdG0IyR97rnnxnNslMaEYJhNWBO4V6LI/QI4Tt4zcJ5fQJMIoegP44B+jltECcg0OUQQgMgcQw0uetEzrPzktfZzgg0bwOlLv3XC70zuAUyLS9SCceRwATgRB9tEaWABKA4ejzlojpQzx3uO1NZEGGWGs3yyT+c+nBsDb4HAoNMJ+nXA/gc0tlCUp190jzFm+GxlAVP6JE8rZlE34IGB1y7+yQf4gE9AjdME3Bj2y4vBZeStnunkd048IYDZK1/5qjD0a6+9oIDAB4sjvjq2aCwQbMGih+PgKOgWwKk/AE7qnMfpuD+DmuHk00wBuOzPMRxcGY5zOuFozpCzCLttJ/MJz22FAse2uj3jYz6/9rWvjcUTGWXisOkR4GV7VWRN9FsUPfoc1Qf9JIDzSMa//Mu/BIDLSJ3tMrpgQUgXtYPnytoeB9hF7N75zneO6R0a7v7Ln0OXRenZpZe99GXRri0vz8CJpmmLjuuruN2IQJ508g9iAQp02jXYKCJwBcCd8J3Ydl24cGHJ72ytAnDpfPGG3QP+zQf2CaBMgCn64nyYaaYBXD0WMs2EJ/kx3+kKnySSyl+IflmU0YtaH9Im23IFiO3gmOPkJ8q6ZYmGe/wCrz1iATCzOz4WEAngAMB/+7d/i3mdukxn8CfszqWXxS4OGsiEz7GgRItoMlmZ80XR4jnKX//6jNL2SQHgXrropc2zix24tNiu35SF7qmnnhJ6BER6PlZ/9MJYbr3t1rAlFob0Ad1oYINE62y5sm+5iEZjL3uSvO3nWMsi25M3B+D64d5qLENIBNYPgENmLWjnJptVEydiRWL1TOieFfAMHMWjbCYYcLS4OHt95XNPJhqjxbi6xzBbdXKcn/jEJ8IAT7QKNeknAnAMLYOvXBvAAZgmskibMh5ytaoXTbJCBtw4B2PAozQWqeAzKTa8Tt5n/zMB4FLm2WfQYfuiJF8s4CTxS8SKc7MlzilnZEN5Tt0KF1jKyAxnh/94zyAlb5UnK9G77MO1NhhSYEz7VuOee6JbEgfoSzL0SDTvk5/8ZDj/JSWya6uD/okGoY8BVu/Ou+5szlp8VkTjPLS+ZzGym5Uy+hIpOqcsKIA0q2AELS7gU+QIeJRnjBLdua+AlltvXRJGGkAFYkQX6bfjfHQWHSp/ok63P08HABc6WGTDKZILvfAhP3xwNP89qC0yC0yJblqQ4asoJkC/qIAgnwS32iJbDpWsRFd9sYWDTBlnX2yOLVSLAWCvF4A77/zz4pkzYB7QJ5cv/9+Xmy2L/hxcFg624dcscuE8tb2kOE/zH8hku9AnQi9azDYBWsDoy4tM11tv/ZiPnnc6sURggQz2AoCzhXrzzTfFFiq9B+COOw6AKwsHGlD6SptED4yXTaS7QC8+AR+2cT2PNcy0ugBc6FEZGLk7Txkbq2s6gndkAdjTK/4A6LLIogP4yDc44qFydnAyAhcAroAq7XmeLQEcuQJPbI9dIX7J4uuf//mfw6awR/iSduerX/tqc8P1NzQblq1tdmKb8twtvf56sUfm9Zvf/Oaga8utCoArEr7s8gLUygIC+DzyyKOal5b+EsCd+dszY3HDVqIht3iN2xizT8BNn3zSxX+8uPBjWfRxbFloeuyAX5vOlPLQJn5K8uYAXLBi9v4hJALrF8DlSCiaSWSiAXC2pAA4hs69fIZkZGQkJpRICANlEtnj52Q9TOoBT46Vsaf0JqEtONELW6z1Q87Zd31Efw3g0CPqIRrEcHIAnhXgcExS36YR4uZ8GWnPSoi02UrzIC0DbvVjMokaAALAhpQOyr2ZTsbpI+UEmykA1x4rfkoAHLkB7aKrjBLAwiihEb3KikoxQgwaPcFXWwuAlNUyfWHA8TXrqUu/0rCTq61Kz87RN186oDuiOcqRGecPJFocfPzjHw8A59qDwYy6RQHgx/jd/9f7m8uLHgKfaAoAt+desQ1SCGrOLGP6bTG2V155VbNeeZaN06DDvlXpgWpRliKRsiovq2f6UPRr6RNLm78++EDouEizPkWa8GRBeRaO9x6VYJulHX52ze2dmfowUxG4mhKG3SIHDeYYp5dO1T2OFA84VgBOlNX8AaAAZ3bBs0PmHv5xmADZ17/+9Vi0eU6JrOq5lnqvnW4RODQow5axJecWXbHdBcCRnwgNML+86CTn/e53vatZd711iw51QOIFF/yh2K+z4hvVb33rWyIC95wCPH9YwPxvF/82dAuofEV5tmrz8rzTE0UnRYS/8tWvhE4CqeYAAHfLLTfHlxiAkF2KHbL1hoZMdJjeL1hrQdgm+i3KzIayk4Ctb/KLUA8zrQ4A5/k1eiNCjw/0xVwhazzxwQ+8++Y3vxl8xzvgGI/NX3STNfvgSM/srIjAtQEc/gFwFnie07aIYzvoJPt1ztnnlIXXpfEoB79jwY6+R4pdoKtA5L333NvsVt7O4Es5osI3FnsjAsevpB9h99D1q191ns+89NJLQscPe8lhzV4lcmgLFYADGj/84Y9E8GCrAvrSxtFr5+aRuTWv8OO2224vC8fFsbMQdu34j4V9M8bpTGlLtJnzTN4cgJtOLg+hrZhIo0bPSnOi14hk9yYYp8cxmzS2Fgg6z01EoAcQA86sIl0rY2sFSKLoVqwjxZDHQ79lxcrwcpK2N2xvilxMpqjonwjArbN2+dp5mWQeSF1SIiRf/OIXA8CZLCYqQyk8b9VrHEtKxMY52oA7EReh8dro1E4leTLso3H6SDnBZhLAkXnoSkEh+PjX+0tovzzzBHBbJdpuBNqtkPHT1tWmm2waxvbsc84O4CVaB5DjO9kCbwwWY60OPgN1Gb0joxhrGfaTy58MB2+bXdRF9A0gU952ixWxfIZ6YXGYHKlnUujG//t//y/aARZE/YzjTyViAlQCfhtuuFGJ9nwwXp8TC4bC40suuTSeRfGtsSeeeDwWHPQZIKOfnoHyIHrn2bel5XUTnYfPH37k4QL8Fhd+dLZ6gT1gBIAjPaBvjfLMS7fUPbdbyU5e6sPqAHD4LVqkbw/d4w1ZcsicKQDFPnB2nhvjeDmmk75/UjhLCyYPmZOJOW4LnA4BL4sWLQqekXHqes0FemHBwI4oLwIXMikATkKb/j23ts2228TW2+ZF7yzgTvvp6dHPegW46Z/OAX7a/MMfLig26MaymHs4no875JCD4zUiFqUAHGcvasLxb73V1uHcLRBEDo3ds2v0zgPnt9yypETmTgwQQh+PP+74GGfB8JGMlb1Zq+jFJpt2vqiBd14rQid3L2BBpFcEcJhptQC4UVtGf/GPDcF/esRfkDk/QCcssNBIT0RM8TJBjnLOJVugbQCXz8Dph13AWwDZrgsdE6GzhW0BKqLrFS97l+dW6Wq0WaLoN9zYeUXRlltuFUBtv+LL6IvnJW3H29Xh2wBt9KMDqKeDovAWfPrba8+9IjJnPKeccmroyWGHvSTsF38CsKnLXrGHwJp+RHbpnaDDSOmHHtHZXAx0mx9B/IB/0paolm3KmwNwAzJyposTEoENEoFjiIV4TT4rYQprAppoHH2GtbVLOTk9E8azJwwvJQaUtOMBTg5bXSsyDjTLc8DZVi++oN9k8SyWbS9GkPH7UHlWgcJbrT1FEUv+kltvbb5VVnTXFboZiNyeYVRNGvRI3udz8MEHldD3S5tdd9u1fPtnvbFvPXG+axY6ZzoZp4+UE2wmAFz2S74SeVkRkj0Qb5XMYTM+QC+Z4SvHI9LmWuSMEWKMAC5fXmCAcguS7OV7Bo3RZbhy2zyBM+CTcrZd6762R8oCAIBjoBlB4FveMcccE5FATuBrX/ta0KjP5xSA+WTp77777yvPm9wWeqzvY4/9UKH3WQEkcfm2sp120YUXlWdmflDG9pfI5/ABBdsha5XInwhTPtNpWxc9aLjuus7zdi94wfPDeFvArDWvvB6ltIufvRYATycAZ86byxyOOZbPqppXniHEdw5NpAsQ4eTMMRFUW1aAFzlxVKLxgDBQRydEOWyhkku3RBc5XW1px9aXxRY6JHoi0sEmbF2iIgDk1sUBa//iso16+s9Ob+4uNLJHnOHaIjqFNjZJooevec1r43krsrruumtDzgAAsL/55puFDgOo9I7NoY/kLEJn4XJrsTW+nezbyzvvPBJRyA2K/pm7dADv0I4m8wGI5SxFCR2NB1j0zNcwk7nnyzz4CVDO5HvgyJGM9E1n8IA+4Dk9Mq/pEd3KLx6QF/6pi5c1gAPGADTzXISt2xaqCBzeAlVsDT/muVnPXpq7FpL6K42HbL07dK0SJT2wLDhtlW622aYh60ceeTS+pEKGaKUzbMK9xQ6yi/mljDe+8U3FZhwS4PDyKy6PsZ522k9DT9C4Qwkg6OuB8m1Xc8DCA00LC1C1u0C/ANNSqBENfmfZucjnQo0/fcFUdQRPM2Wb8uYAXHJllh4JicAGAXAmD/DA4DFEtkRTAbI9k9A5oy2axhhZpVuVUEj1rIgZMKGJjTfZOCZORlZGinFX3wTt5fCwFO1WQRyK0LRvCzKYx5Yt1J1KfwuKQ+A4RVEACGF0Ex3gWLDA1kmHTu/ZWX/9DYrB3zqMplU246m+yRPjKsAtnpcp1zOd9O8j5QSbCQBH1oCtvslBxEBkgeFlYDkAZSTOVzmTntMmSzJnVEXfGLWUpXK+6CCJkHLWonJWrAyXcj45ZuX0xTEy+Bwd4IgXQD/DDkS5L7LnCzLyGFOROf3fVBz730tf84qzZait6jmt+YVu5XcZWViM40bNk6NbONeU1wGI2NIv2yMffP8H4tUX8ZqB0q9IycUXXxT0kAVaOXLABWCxVbNw4S7hoG2HkJ4yyQNjqtPTBcAZA96LCoiIsgOcGFmkLoiymkNkKhoL1LMFnKSIre1SfKUT2jPPM+oNCJFlgvjU9zxaJALOZCoK6MFyCwYADo/JeXEBcFcVO7NteXUHUCKys6DIhm4uPrt8kabU60RPO9+Q9ozctttsG06SY6UfFhJrFh1F8003dV4xQuZsmLT99l60u1noq7kAENqK903BO+4Q7ftpRCF3KOV8m92744wV/WyQyJ0oYvKA3tPdhcV5i2aPFBuI7mGm1Qng2BU6wB8A9RaDwDA9oS+ACkDHjgBw9cLOoxkW/DmXAB2LCYt4dUXE1LOowm8gdXGJpFr80RULBIsLNosvYE88QmN34QFzuWzzrluA4BZb+Kb8geULBPuWub9HPDPJ+tPzK8trcX5XwB9ddk3/NivfUt95552KzjxW7MP18Sz4gQc+v9m52MHryrX58rOf/bw8AvLeAJIiueh7uMyDv5Qv0fjywzXXXF3860OjtmKNoNH4fWlrjxKcoCcJXM2JnBdT0RN6mSnbkzcH4JIrs/RISAQ2GYCjoBQtFcYkMymWFONtArSTiaW8cow5Y2SlbYIydvrLqIk2GS6TjRF0dM24aCeVtd2Ha308WlZD99w7Gn4udUx8TmCj0p/6VNMWHEOp33vvva9MsEfHxqL/nIBo5Ph90nh2dLvDJ5O3TBldz2gip5xk6JVmAsDpE2+kkH0Zu/d5WRkDR+7JT2dLHgyz6JvtabJgHIHnBHvKhN6VtkTWnCsHxImeMqrkpt0ccxBQ/pAh4K8941eGrgBNPpwrfclnZdBiRQvY/bmADnqgbat0/dFhbfgWmdc8MP4itsuferK5tgAU30hUhg5/+IPHFiC3bRjQUql5qPQPyHgHnYUIXdd26tBI0Xk0abMzls4onHdLTxcAh3agBl8BYPNY5JN8JQ4G4AXcHGP8RdZ4LymvHjtAh8hIHaAN8AWQM5oWFao/yTvyp4OOGa0j978X1tIL7bNLwBRHvaDIIO3I7X/qfFvYc02Pl4UdHZ43r7wktYAlNC8scltjVP90TV851DsKKPvzn/8Ssl5exsJOhXwL7bZdOfy99352s07pi0266Zaboywa2CMPvAMeHj2gxwALQIiX+gBQRKHYHiCOXuPLMNPqBnDGTl7mNL3AF7ygM+YRG2ye+oxLxajTBSBO4lfMUzsD5Kw83cNTNgQQYQPcZ5fcIz92S119o+He++4NMGWnZZ111g75WoTSTfbBLy2UnmMhj24RuhuLT9EGu6UM8L9s2dLQP4tEL2/euNiB+8t88TL5G2+8KR41EX1bv+iMl/96Dxxe0Ft68VB5KXZHL+eFraIP25RvrPJpxpfzII/BhCn8qe1stpl8ExyZ+yWGKTB3mFUJicAmA3DpfJWlQBwVBVO/Fn7Sqpx8Ts1kTEPEWGe9bFN7lL/tuJXVj087ZfvakoCqGMu8zqqsDbKAuHgWblmJJpUJE9cxGTuGQB+5PWrVrf3yf6Ukq932SoWGkFHzGW0SAyL8b0t62C/yHesf40piZDlk/EdPbVQ6JTp8la9Mylw9KeWX7ZK9sq4dU+auuyV6pa0s25Ff+dr/0rKNX6Js9C37YqQZcPq0Rom4Ej4Wzi/RRGANN0Vasye0PfLoI80VV10Z35qkv563e1f5RtkGxYCqYys5vvpfytIm7aMpeaFPemS7XV4n5bHbiMr2dPfsnrnJG3pge4/z45hsD4lKDjPhbco0++HEjJUs8X+cDAtz0Ru8GGWD+myAj/Ihy8LXdMrZ7tiRgEpd7WqLPPEd2FNXAuAyLS26gPWdLwqUyFfRi+VkN1rA4kEbJSvoArBESsnWPXJmK1J++vQFiI4+F9BZxil6a3ucA+aIRfTnsx9oLP1E+/KLPpSf6AkAZ97gkXZTL5FEz4wjxzJK5lj/eT2dR7wHfFbHFirekGWOFy8sBOSZP3jkKKWu12MPO1zkm/Jxj17K76ZDxmqOpq3Rj7rqdPTAwq3It/gFgN49+kN2Uba0S3byyVhSVl0f+dpGqzZ9jG1+aYtedRaGnb7ojnvUVX6UL0f90LmlBQCilS6uu65fC+rYROX1M92p5m+2L49M5gDcdHN7GtsjJAKbDMApl58UMDLq8zZZylNsipqTNI0+RZWy/2wnj3kvCrX+rFRm1LBHsTKWtnp3IMNoI8ZbTlWJ8US2sa0wEjGxxiaJkitSTKCVelhxf1hnyXvt5/hnEsCRm5TbnuHgGLsKwLmftDlP2SrDQOW1MqkPyknuS/JtX0jdjHDkl/ra0i79YuS1yUAHsGIE/SPrku++cvpgYCMVQdKUsgQJZWBglxXjDIwtKAbXC1r9fJLf193nOfvEduhB5dmZdQtYkPChs51eaC/XnfaXhzNHvY++y/846m2ylMBisnJ53/ik1QHg9J2fIKJDSgyzM25j78gp5DnKhzwPR1Xa4KQAPxFRcsoxRZtd/mTbWc6xzqsBnJ+6QhZgRlZ+quixpY836y5YJxxw0crQAYXIfV5xliT3ZHHK6bA5aM66uPqQc0ePO7oc+UVv9G/bvRAfjjrGHS2Vhv0vwFHf9C1A/2gd5XJeGGraROcxr9QoZXzbe1hpdQE440nZ5dhcp1zlGXvwspWf5fFWYieUmyylvVAOr+t3VepXdDSatDVb2pPnlxUk7Uf50U7J0mJACq1Rv5xrIWRc7pcGYkERpdi0URq1pYzknjO0WQSwfz7afLRE5CSvn1F38hFG8VX60+a7RuTNAbhVYufMVSIkCtUPgBvTtlHhhpGhWKPKWFMtT9sMBMPsI7lmtKy4s4x8ZX3SsTtXTpmJ2k8DmHW7le9MQb10JlvnrDN5nJee40IbUi/gEPfcH+pU0svKCW1j9I3yeyYBHD5L6WSSntQBcusmJ3XGZFSMWBrbbMd9KduTz8n716u9ToXSLsc4CuDUQ0sNEJTThntJAzr1xdA6pr5w0Iy11bDkuTnvEfvd+b+L5zdfXp7jHBkZGX0msvAhnD1d6OhRtj8f/aN52umIqj/TO6ibRr80kwAu+4yOy5+U1dg13o7OW3wPecorzlH0IoBvASQ5z8mMDAFrsmi3n+3WuhBlOkMf05O8XwO4TqSd/EedcaEromToKn2JuJN3uRvyRJ+2vRsu24v+6W0RoSiI+/EpdaJMoSPngKgb+UvI03bQoA/9lby63cgZVY3MTz3K66in8yGl1QHg8C/H1x6We3gg1WOXv1IqWfIB3F7t1XXqtuXHHK7473583CtydP5ksQkkSlf0UUp05Fj+siFopdvzyzOUcR+Zpc2UGLI7dTpgvdwt5cqf0XKx2+Oy9CO6K2lH/2SjobXLlyiGnYw1U/JS3hyAS67M0iMhEdikAG7UqVIsieJSMNcp8HqI8rStDOOcAM6KW13bBXWSp3wCAedpGLPPunyeK6OupA/9tumhmqmebSeZ+TnhtGPCZb7rOjG6ddn63jDP8cNHyvHNJIBrjy3pwXv0pENul8vrKF8BuMzvdsxxdrsnL+4XVoScCk/oR+oIMOB+6kK3NmLLopQppjeiLjUYc08ExjfGrvCqh1tva0Tenl9eOeAnkgCQrqnUI5159L4cO5Lytz9tUaq/kqXgaEo+rQ4AlzoYc290mOjJ+Zg6QQ7yyYUzyK3SXvqibI4rx+mY/WFsznf5uO5efmoAV89VMkUm+XWeYxp/Lpr2+NInou/Oq4eU5uQ9H9t5ds9WGBm509G9Di3GZjyx/coejt5/quh79uWHyNFjbMmzoLmASynHh3/KpB2Mm0P8M9MArpZtjrkeHt74KOd+6kldb6x8R0Qd3hU2dmtvrGyPk2w366ZtyHksyjZPhC+kWsB6SL/oDlmWNsnLM42+qQq8kyZgl6lUj6T9p+jgaIaFj8WsrVrapJ4+6Isiync+nfxOK8P7m3TpIXkhbw7ADY/n09IyIRHYZACuW2e10Nv3tel+lqmVQlnXmee6XS7z6jLyMmX5vHZU1nzJ6dOZFJ0Smd8GcJ27K/8NAx3ZWlmR6jZX5A7/rBsvVyeAM+KkqS3LntwghPHs7FnUjW4ylj+mE6W9dODypawzVqaTPfa3A/U7l1G3K0HFcD3+RHnAvTw3VxYgHoRep3wSJI41NnqyOnUCCTMN4HrxNnm/En/KvEzHjIfd6td5vdrpla+/rF8DuF7KRu5Rp8i+owOdK1GQOCv0rkgdOxY54/KVKLWjqdH2xu5nffdX3AsQ0MUmruhr/FmOaXzu9F7NNIBDffLEeXuM7uX99j3lM3UrM1H5rNfPkcRI0JFGpDTL6UqJ/vivb+XaZdPe8DsxtmjVxWidUi/HMq7x0fbG5Q3xoqYh+ShvDsANkenT0TQhEdiqALh++q8Vo10+FaWd3891u91sy6TzkdoTSn57gkXBLn/qdurb7Tbre8M8N94cc451NgC4HHPSlNfTcczxttta1b56ybTd/qDX/S4KBm13svLJn5kEcJPR1L6fNMp33kt2dX5dp26vV/64uuMm+LiLuqke52k52rd7tdOrfLt+5zpaGaBKPa7uLU49d3UAuImo7iXjierkvenm16D2gnzbmpLilj/I2KZ7LMmjXseatuxb3hyA68WxWZJPSAT2jwDgBmF5r8nbbZIO0u6qliWnnGQ5weYA3GDc7CXTwVpZufQcgFuZJ5mTOus6bU3eq4+p01muvpfndVuZ5ziu7jgPOu6irtLjPN1t+3avdnqVb9fvXK8xWPFx4+re4tRz5wBcbx4Oai+6+YYUuXu99LcbBbVOd7s/3Xk1bdm3vARwfs3m8MMPj/cTetVNlpluOmZDe+Xb4mXkT5OEVMKYA3DjBdZr8nabpONrDueKnFKtcvI80wHcdHOyl0yn2s8cgOvNwdRZJdLWdCudOp3lupWp26rvj6s7DmuNu6ir9DjvZbZ7tdOrfPfm5wBcd77Uub1kXJfpdV7rQa8yg+QPai+6+YbUEPcGGdt0j2Wycde0Zd/yEsB99rOfjd919YLpOQA3GTdn8D4hEdgcgBvP9F6Tt9skHV9zOFfklJMsJ9gcgBuM171kOlgrK0qnW8/jijszc5b6MLeFukIC/TwD11s66W7bJVa0P/5Or/LjS+XVHIBLTvQ+pk73LtH7TtrF3iUGuzOovaAlbU1JDZE/yNimeyyTjbymLfuWB8D5tZOMwPkt6TkANxk3Z/A+IRFYArj111u/WbjLwvgduXxnVi3cQUjrp14qyyDtKttuO9upJ123CdVvP3U7dZ2ptFm3M+i58eaYc6wct9/i8/MsR5WXzHrrd76mY9D2By2ftAxabyrlc9zd2khD2e1enRdyLbycjjSoLgT9k3Wt0QESOdADP03nVw28xd/P7uSviAzQ1LQXrXV2osZTrnmcqF43vct60UfNv2LXVnapE1GyYo7VpTrt1w2P3g09mkygdUvlfIDi+h03tlZT7ctuvGmXaV/bQvUrIn6r2C9bHHHEEaFDg/TbbnMq16syBv1NG70h5hWyrsVVnxdjvBJYk9H5KsMKDhSNCplni/2Mb9rGsoKMvs6StuzftbdG+Om7L3/5y6EbcwCuL1bOXCFCIrAEcN5k73dJ/RRS/QqAFG6bshR2nV+Xrc/rMs671W3nT1Q/7/Vqp92W635TTNYw0P3WGG45Y8xx5rk3qJObn4fxI+vbb7d9vBMJX/IzTKqS/+0+4l1s7cw+rmN8aela5XPsrexxl+OjL+Nujbsg1pr2MLKlBJlH9yH8cVV6Xiifdfqlv1ckpl/6EaMvr1jwCgsO+KqrrooX4vppJz8d5WeI2qkec/veMK7bOui6lxzrb/i269W0dRvDSm2mDo2+q6+uP/F5dwDnNTPZZF0/6BwEkQ2gV/oxrpXGVhPQOu/Gm1aRcZe+GUx/vEiZk/YzdH6/t5vujKs4pItB6W+TMRmv+mJ/EXSCsHHlS/7YtRO6vBIBK+q61Slf/o6Wbxef7Hqy8UxWf5D7Ne9zLtIPETg/MebXft71rnc1cwBuEK7OQFmCoygJ4PwmnMjbTjvtFPl5vxZwm6y2otVl6/N2Pdftulkm83vVb+dn+ayfx175eb/Xsd1+r3IzmZ9jyVcx+C3K/D1Iv7Uo+qKMVZMEgA8r9eKP/F73JqOF4ez1EuUc+0Rt9AuAOjR2WurQWmiurHEvgNWr7yzfL/1Zvt1eTUP7Xq9rDljkze88Ovf7mSMjI/HLBu06qyqXdjv9Xnf43HFj6rjuJUf5ea9dL/vrRX/Wy3Jjx3jHWiXYsRvdTzrtr6A3S4Fv3froRWfWm+qx5kk/bQ1KTwI4UbhbbrklIrl+V9avYvTidT90rGqZqfbZTUZtWiafY91lrR11Q5uKHgNwKxBduRk3FIiTsW5jTPRefXX6TP2Mpc+m+ipW05b+xTvu+BK/zXp5eSfme97znuY1r3nN3BZqXxydoUIER1kSwPmBaS/Z3WWXXYIC91cVCNRK0Ws4q6qo7bZXtZ1edM22/Hq8+QZxEbg77rgjPgwvACflb1K2X5Y8nWOq6anbld/rXl2u13mu/rrdn0jG/ZvGjiHN8h1apwfAoRmNveiM/Oy42wCjgV43xuejm4H18fuR5q/zjTfeOBZf3l3XTlORS7utfq7r/pz79OJP4dqoE+zt6LKNdt+92iydjbXZrtPtutP+ync6AG7lfOWHnXrpUrd+B6UHgKMzABz9YU8OPPDA1QrgBh1D8qGnDmSBciStySQWKuNPK9X1YgHWTfaqterGeEplt5z3M75+xtIib8qXNW1tAHf33XfHL9O8973vnQNwU+b0NDdAcBQmAZwfhl64cGHzwhe+cAy4DWJEppm8ueZGOUBOfrJFCpBTLIJnny655JL4Qft3vOMdzbOe9ay4zzCvDiOg834MVBDZ489M6Np4Q16MaouWlc13q0B9OVo568wE/boPfShylmyh/upXv2r+Vn47ceutt24OOuigZpNNNol74/4UWqcqn3Ht9XHh584y6bsbf0JXw8V1SpJILzq75XdrMxxpy5kmHb2P3fstv/NRUbei9kR0rii16mf5CyH9tjAoPewIftIbW2SiuO9+97ubzTbbLIBdv/1OZ7lu8u2n/a460K5YJml7rq9UJHQmZ3N1t87SyOjcq0p0wNtKOheTbqzjfsbX11jGdTw9F0lb/vpFbqF6POMrX/lKc9RRR80BuOlh9fS1QmgUJgGcZ2h233335tBDDm3mld93k1Y1Ajd9VM61lKtlnMgVkhXzhRdeGF9ieM+739PsvsfuXR3kTHMvDcGq9DsTxov9XWHIO2crrjur5UFor7dEZ4L+pC1/95Ue/PSnP20eeeSRZtttt21e/OIXhxPOcmPHepBjmcM7ASgy1TrRi0eicHWdrJvHuo3My2OvNgPIZaFJjtpfQfGKwl4TExHCFVlx1r10q9AUL7v126vJQekxXhE4egPA3XbbbQHgtthii9ViRyaSb68x1/k9dWC0ENl2k++4NspFt3ayLhxX3hNWVxl/Pg7AFYmMFlVvkPF1o2F8R9N7VdOWfcvLb6H+13/9VyNI8NrXvnZuC3V6WT+11giJwBLAbbzRxs1uu+/WHHLwIfFAvNbzh6an1tNc7alwoAZw5AXEeQbuoosuim+QWTnvsfseYzKbSl9TrVsbg0HbSuMxaL1Byqcx7tTpWNjaJNeL7X7aXV0ALmkD4E4//fRwxNtss01vAJcVVtMxbc2qdt9Lr6ZLZ8brxQoqw2mvuHzGnAFvnnEC4OpvoW611VY9fzZu2IPvJePJ+u1HB3rJt267l6yz7lTe+TjI2PoZT033VM9r2rJveQCcXZ7PfOYzcwBuqkweRn1CIrAxAFeeoRGB8yqCBeUHeu0duF8LuKYjhV3nzZ1PPwfwH4iTkue2UP/whz80v/3tb5uj33d0s+eee87Ya0Smf4Qz22Ia5OnodSpGfSr955ykBwCcLzMAcC960Yu6R+Cm0tlc3WccB+iPL75YACxevDgicL5paBs+HtN4ho2415zvBdqmdfg6n46E2CGktCWaTv8ibw7ADYHZ09kkIRFYArhNNt5kBYBbuwC40VQLOPMcU9h13tz59HMA/1MGyXOO+/e//31sfxxz9DFzAG4Atvcy5gM0MVZ0dQE4gJ4uzAG4MVHMnQzIgdn2U1oDkj9Q8V5zfg7Ajd/eTf/C38wBuIFUbOYLExKBzQG4mef9ID3OAbhBuDV52V7GfPKaK5eYA3Ar82Qu5+nBgTkAV4IQRVRDCmytUIK5CNwKXszys2fGb6HaQp2LwM0aVZsDcNMrijkAN738nGvt6cmBOQA3iwDc0FFkbx3lXzLNReBqbiRXZukRqcOOwCU7UjFmKSumhaxhjVW77baHsYXa7mMipig7HTKdrnYmorW+l6Yqj/W9VTmfi8CtCteGW6fWqfp8uL0+/Vr/RwdwiZnyODQJ9mNshk5E79GZI5nSpsvLLdT//M//bI488si5b6Emk2bLMY3bZFuo+QB9vjso6+U4Uuh5XR+V9en1YKx7mep2Mr/Oy3IrHTWxihMg+1mpzdGMvvovZbWTbanTb71e/db57bbdm40Arh5/Tf9E52N14hszvUuOlSu8HTT5xp36IZfyDd5yMmgTPctrafpa69nNSjfmnoFbiSVjGakrmUHu8ur8nJ95zLL/SMdhArjkdc3fzMPjOr/meZbpdb8u67wuX5+3yy0vz4z68ENrxq90mLeDvKil3eIA1ytcXO9Kq8OIjFKTfHOZfJfnW8p//OMfGwAuXyPi116yTO/BPH3vPCO3UCFxDsOLfkPYRSHXnLdmfIuJqLz8r5dQ03nmb6sqr40sn/ddm1yZX5fJPHXbyfuwlA2A2GUSuJdt1e1kftTv8YYg0ztoGp3w7b7zeqwt4yr//A96ssAUj9m+ZnIMqwvAoSVT0uKafuS9/LWI+n7WyWOWdZ3vNEue5Xizvus8z2O208/x4Ucebh4vOrxgwYLQ4bV8w3qIiRp2UcVp7XE2AbhaPoMMspbzqsi17ktbdcIfSbs+rgGWzGezvCIpda6u+49yPiwAl7KoZSrPt16T/zXv3cuyWTdlN5Essk0yzBfQtstne489/ljzyKN/Kz83t37YAXXY6mHP0zY9T6frBHD/8R//MQfgZqPgcuJMFoEz8ZQdA2GjAM5kzA9A4a3eynkhMKRuko4BrAL43NOWn//x/iGvPmBE1l9//fgRZb/Dp47JqF5M6tEZlnUefvjheAGlCegngzZYf4Nm3fXWbebPm9/1NRr6VBdtOQ6y0LZ7SZOjpG9ANWiZv1Zx/I9HXUBTSkOjHECgXLeXHU+nY0g66/6HAeBigK0/+tYXHpK1H7vGd2NOHspXbukTnfdKPfq3R4PXeJS6gKd1UkcKfhbWe2u/Nrzfzs+B4a26fhIM77W1qjy9uKwib1lyS7Tlx9533nkk+h7mn2FvreIf3pHNbHmNCJqSrpwnfikidccvRNAD93zIW3lyJWMLRfObXeA8zC365qNMftpy0047ZV72Y/77qcArrrgi+t1nn30aL63Vx6rqVbvPp9v1sABcmw9kzPaSAX1g+9POsv0+7D5ZkUXqhTL5rjp10CuPb/Fhh+hN1mv3q50nlz3Z/OnOPzXX33BD2AC/VDKy887Ftmw8B97aDGtd1wDuiCOOaF73utcF3/H7mZqekRG4NIaEFufFXvrh8ZyU999/f7xH6J577on7u+66azMyMhIOOIQ9Wp5j5nD8CPtdd93VqKcNP9/iBZIMqt/09JuOgmLqcuwm/p133hm/++m32UxkE56D9/Z577/afLPNw0GLDLbT7bfd3iy5dUm0kw4jldB4KCpD4Fy72tx+++3D2ejPW8r1KTEw6irH+KN30003DZoZF0k70+kUtOcjJd3TDeC0n23rB5/Ii0NdsmRJyAqPvG8Of4xd+TTO6Ln33ntDrhylukCesikjBjcNtbYkPNO38sDbjTfeGEcGWl/eS6WstpK/UXGAPyf94AfNeeefX/RjQfPmN7+5Obi8qHrYaWUtnN4e8R3/ZwuAI0NyMp+ldLzmjneNScCz+UKOKXflATfj8MPZf/nLX0LXOOzNN9885ra5yEbQOfqTKedEXvc64hVbc/PNNzff//73Q9/e+c53NiPFRmm32wKsV1vPpPxhAriUDR0FyOkA+bL7/AT7aI7j/3bbbReyBtTJQl16gT76cPvtt4dtoSfu8xNpV4A/ebXtShkJArArF150Ybwv84Jy/OAHPxg/N7fdNttmsbljDw4kgPv3f//3phuA68bzHk09bbKfkQCOYTapCCx/o2/5U8tjIt5QVjbnF+fot/Q4YOnVr351c9hhh8UkW3vB2h0wU0A7Y3755Zc3v/nNb2Iym1wiLdpmnBcuXNi87GUvix9Vlq8/K7Yrr7yy+d3vfhd1AQrlGQDGnIPfa6+9mje+8Y3N1ltt3ay1YIWBT605/aenN6eedmqs/LRpwjPqmRgKBiOdoh91PvTQQ2OF5+eqzj777DGHk2Ai+wc8rer8hBGDlAAl256Oo/H6SDlpphPAGbcPp5rtc6DXXXdd/FTX9ddfHw7QPT9q/IIXvCDAc+2E/ZwTXgHnDC0+KS/iMlIc5cEHH9zsu+++YayzXvJGOfpDL0RIGG1g7z3veU+8VDoNdNKW9fo9nvjd7zbnnHtO0bW1m8MPPzxedttv3VUt948G4MwfMvchfzrjPYVXX311LJw4Xb8Ysvfee49F4fDW3CNzunPBBRdEXY5De6KvQBz9efnLX97stttuYwsHdXPrvZteoCPtBJt17333hj5/t+iCuXvMMcc0O+20Uyy+6Nc/YhomgKttyrXXXhu6cPHFF0cUlGzYBUeyoxNeQJ2/wS2Pb/A7nOedd17oRVs+u+yyS/gJtsiigEx9MqW9pEt+seaMYlt+X158fvzxxzUHld/63nKLLbPo3LEHB+YAXA/GzJZsSm6yTLaFajJmUp6BtqL1SwAmh6gJYEXg0lvf+tbmVa96VbPjjjuOATQT8qyzzorPNddcE/3m1qm2ADVO+6UvfWl8GGsT0urr1FNPDfDGsYu6mfxospJjfBnit7zlLbHCtzKTcgKj9xe/+EVsMwE96rnn3Dic6xdgTPD1vOc9L4yJssAbYMGZ6NsqUR3j9VF3v/32a17ykpc0BxxwQDiEIKD80fd0JP35SNnmdAK4bF/bHKcVM8AMOIu+4buxMrgf//jHA6ziBSCGR+R+wgknNOQKiOORRKaAmTIjxQmTEV7hdSZ9KwfYf+9734u+RFzJ/rjjjgvHnWA+6wx6POHEE5qzihwBuCOOeHuh/yWDNrFS+ZRsRyor3S4/gT55yrrZ1uQ1VpTAU/KiB7NhC5VumE9kCYhx2hZs5i+gAIh9+MMfjjli3qOd7JctXdacfc7ZzaWXXhq6JppOh4yPXRK5MS/ZFAsr0bicA08t72y/2gvTVubjkvryRPLp6X333xf6SceUO/roo2PBKAJUO/4VHO7/LPopxev++6+9+koOE8DRBzJgnz0I7+e62BF21I6FI/0QACAfC2a/tUm+5MG2/+xnPwsbRAcs0tkcOsbOoN3i3YJsjz32CJuD/ynz3B9lm+jjb8rvvf6hHNkUAG6rAvp8qcHcm6r8J5Wgid5lkrd1dtJ2+iwwXfo4B+D6ZPjqKpYKNBmAq+lTh5EG2n7yk58EgDNJTdictBw1ALdzedaA8TXpTEirX2BIG1ZQPgyoSWxSCrF7NmXRokXN6177ujAAV151ZfO1r30tJr8I13Of+9wwANq0otMuQCcCJnp3wP4HxGRhPCST+rLLLouynJ2JD6BwMICjcugE/BgW5W0BP+tZz4qw/eLFiwN0cip+ZsxHG2l88ILTAd5sywCtdZoOo45fPlK2N50ArqYXeMJTgMyWE56IrOpPVA6As1pmTNFC5ia6CBx+PvvZzw5+iHr8+S9/bn75i182V19zdZT56Ec/GkCXA5dyXGQBMJ522mnxE24MqoeOlSfTfgAc7pDLskILelzPK9vpIsDf/8FJsZKni7YCgG1KgnaAVb2MIJUhFaezVvTJyfy96MeyUiajxWjhcNIeG8PSqL+stPdU1At6Sz4d9Xmy9BPtluc0tYmOAL9BRahrORss0Vv8ny0ADh/MK48c0B2PPADyrumUhc6HPvShmL/y0S6CRlbn/+78iNwak21W0Trnv/rVryIyd8stt8TWN7mxDzkHlEnnq/9osxzl47u2fdgHCxD6fNJJJ0U50UCLRMBSyrJ0IdvSXsorbZz72iZjH/0rLymvHbqEhqxb00PnlNMeuhxzDNHIDP4xFuDIz/GxZ3gyXT+llb7A+ERY2WA2Y4cddgiQRv/Z7zPOOCMAnug8kL7//vsHP/mXb33rWzHvPErxile8ImijY7/+9a9DL/iL973vfbHYZndD/kWnQi/K3Hdt3iaAs5X64Q9/pHle8SEbF1oeX/pE7CitU+YkWcS8LnUyhVSLbM3/mMeVbqT8zeU6RblR+WtzrWJLIpVm8SRtDZnTD0f59Cb1Dh2PFbqfKvnzCv/WK3NHXpZT1jneoiPbMV7Jwkbq9jhR3Ojzj36A77kt1D4ZNtPFUknRuQkAAEAASURBVGEGBXActYiJLRLOniEUrQHEGK/Xv/71AeCAHQrOyQiHn3LKKTFpgTbbrPm7jbZgGRE/nOv5NyvtY489NsLt6djRqr2jjjoqDADgxOGr45kroIsBeOUrXhnP51FwE1n/fyvfPoqHYJ9cFhPFNt+3v/3tWOGbBKJ+wvcMhXomHgQAPDIW5557btCFZmMz6RgkNFNwE4hj+chHPhKg1P3c3nE+1WTsPlJO0mEBOA+c4yejh3bAlCNlbEVTEsAB0xIekzkHyTgxKLUhPPkHJ4eD9uyL508WFXBO/jGmYmz94/BFc9UHGLW3pET+OHwADn/b44/OR/+4t7x87i593H5Hed6x1AW8Niq6tGsB4mcWOZEXXTj8cBG4F0fNRx55OMb6pz/dGYsHOgX02RbfacedQq99iQUIsZ28ww47NgtHOs92hoz1Wx4lMLY777yr8OChZmRkYYkI71genl7W3FCc0A033Ng8WJwkPdt0s02jTc/fbFwe6H9qVKZrFsPbMb31qCY+x3e6MNsAHHsgKk9mCxcubH75y18G7zg28qdPGaElN87mb4/9LWTvGtAjJ/OQzM4skRMRdA7cPGUzjDv0oUyJOKdFpa5zOsTJAwDmOV32jJVFA4f04x//OPTaYkvkJgGcSDEQc8cdd4T+0WG0GAPQoRwdJ2sLDotP+RttuFEIih6TiTki0oQG9oouARFso/bJi30BUtlN2385lyaW+PTfxathADiyYP8czZNHHn0k7C+d8GEjyApP2H6LP/b7TW96Uzxmwb+wB2SFz+y6+/hEhmT785//PMAf++DjMRZtkoFP2iC8tz3PBgBwbIoo333led1777u/0LJWs83W2zR77LlHs9mmJRpb5v+oQGN+AlEWojeVPu8ugHFp0eN111k3dn2ARrqVSb8WCSl/PoH88UAie/pFJ42F/uHHg8Xu3HzLzaF3eMMH8qcPPfRwebZ7s2b/A/YvtG3aPPDXBxqLGXrteeOwU2X3STs5b/AcHRIeTCXNAbipcG8G6qbRGxTAWVEzZJQxHzZmqAE6Qvc8mggcA8VxUTZALI25LU+TkkFmWIEDYMhqDE2eifjEJz4RBi+3XSm8rc0PfOADEeERFdLe4hIhYwi223a7eNngG9/0xlDcnMicQbGtY99yRN+S4uA/97nPhWMxYXy7xjN7JlyuXozxkksviT6E/00q43r7298eE5JRYEQASNE5K0e0MfgMiT555TifoizxxEfK9qYTwNVtM+pAHCOEd4zUD8qXAIBYxikBXEbR0ITXSZfzuj1AWV2OHX/wGUiTHnn4kebOu+5sTjzxxNAlz7OQj5W1iGwCODJKHugn+9KGfM7yrj/fXQz1RSFTQEqZdYqh3WKLzYNuRtO3II844h0BAtS7+OKLxrbmGXpjl+gs4/jCQg+gRX9tU9JbEeD99t0vnLAtmGXLSgSpOCGgBe3Aoe0eW4LXXHNtRKLmz+98UYPjZmyfe8Bzm93L3FCf46co84uRr8cVhEzwJ3k+mwBcgieyJjMRF7oDiJER+dcALoZXhh/jbiHYBHAi9h6hYE/YC1ttmciw5hmecG7sCZBFbpwnXUWPshaeQJNoE3AgH0A3n9kFuq+cRQSd4OzZI3IF4DhWOw/04MDnHRgRQ05/+ZPL4xvri4s9orto8dwePdI2gAgsocc9vGEf8cMOwOpIwwJwxkI2aQON13WCKtfmCl56RAXPPFohOm7ngz3nC/gMNsGzsAA0WdELcxno++EPfxgRf7phcZ39pl6Qo4WDuWkhcF6J9Hp8Yr3y1oJ77rk3aFB2nXXWDnmSM6Bo98DCjC6IHpIn20cnykDijQfmMgBvrgPqFqXGxV957pPu8Rfu8w/64S/RQjfphZ0quilafc5558a49JF5S5da0G4SW8uicOede17YUXqID/iJBs8X0yE+Sj/J9wSOwZhV+ENGcxG4VWDcTFVJRR8EwFFSiXKYHJQc2OGETRJCp5gm1MjISCgZA+kekGaFSuHf9ra3xVYWJfTAMydoxZUr109+8pMxkdWj9BTeKosTMFms0hIUUrItNt+iOeqdRwUwtKpJo8EZS8bq41UXXinx+c9/fgWAK9u1YwBudHyiApwwkMjImFQcCGOhHfcAO0bfKswk8g1H57VTic6n+Cdp10y2PV0ATtuSY7YdGeWPa3xsAzhOFKDultTxSQdo+zuja2SnLl7qj0EjdwCPQbQdQhcYTRHbrgAuUPEKPujnrrvvigeUzzzTVtCtsR2+YEHn9SPAHLCPJgDMG8VFcYyLIyZbjsx40KA9dDk+//nPD2DOWH7pS/9X9G7TiNQC8V5DsLyUoSeeqxKp5ZQZbfr9rW99uwCDuwIMMq5PFL17skSAAYIXHfqi2MZ5sjgJdMAutlrQ2G+KeqX8bAJwSXvqq7nsW58WOc7bEbgs3z6qTybmN+fObphbi0r0FuBxX8pj8k0fwFs+S2kBMlJskHxOT4TVuUg7UOAeGwbUeVjeogVQUM/CVMRMH7Z1jylfenDOFn32s58NvRD5IW/Agt0ji29+85vh9NgodlBkxBxQl4P1qAYaJI9esDuAw+pIwwRw9XiM3RziK/DJhyzoBRkD3eYkACcyiccAmmgT/pCVuclXaEs7Fs90i1945StfGXa/7jPPawD327MWR3kyoTOO6OCfLKzYdzssC8pcNK/vLEEKIBEg046+1lm72Iiim/wYPwOEv+2tb2v23GvPoI+tZNPYEM988gubbLxJofupYttuaH59xq9D19iET33qU2EzgMOfnHpK+LsHH+w8C77xxp1XcaFR9PnRRx5tvvH1r0f02gKYnvKBdIpfFHyw/S3y6Q0ROSeSD6tyJKcEcPki34yea286+lgVuoZZ5xn5LVSTRiIwjs01YGRSUmwGSaTFallibE0qDtOk+9Mdf2pO++lpodiMpFUJAGdVq00AktIzvNriAEXgbFsx4FZqlJOicvIU+MEHHowImcgIgMB5HvmOI5u3vu2tARAATHTmEV2u0Qt0JYBjrE3afL6GY5Ry9WX7Bg3KMS4mThogkx/9xiH8b1ICJ9Od0O0j5aSZLgCnzWw7tz28usUqlCGQVgXAcYAM49eL0SFHkbx3vetdY8+4JH89F8kQcpIeSLaCpQuAHAPISXKQyQNHMsUHshIlsUI+4bsnFgd8T+jJm9/8piKrLYsTfji2gkWG6R1jC3wBkfPXnNdcceUVYaTpFsO0dnnB79ICsmwZX3TRxeE0RGeBrm984xsFCN7fLFy4MOjyjWcA7p5772l8y5UOej3J/vvvF3NDeWAeCAQY5henAMChXwRo87LgcF42A8tncIM7mwCccXRLZGxhxwmY1/0COHbFovBHP/pRRPU5y2MKgCI3ACj7y7ngWuScHTnr7LNCXyNCVh7FECX76wN/jUWBuQzIibIA8hFtKbpkS04+PdM+mwX000HgUT/sFf2x80Cn0UhnjQn4p4ciKZ7bAjzQChRoB4BjI4CUkQIa2VA2RBtAXEaku/FwmHkzAeDIxke0/YILLwiwBniYjz50xO4FoGOHhQzMfwBOJNf8t91tzmei++Zo2g6+hjwz6S91IwHcL0v5M35zRkRdRfXIgg8TJSfj+8uXXDJAsH6JmImYnlMWlueWqNcmm2wc0dQddtgxnkd7vNC8uPgEwJ8+8EmHlN8PZ0cEIdDPx9it0KboWSGoueXmW5rFBURasLKHghT8xZLS1y9++YuwVfReFFL0dtdddwu/c99998Yc+tHJPwzf6nEffSkrsV2AHLBXj70+T94MckwAN/ci30G4NoNlU8CDROBqAGciiWg9VKIc3/nOdyLKpk2rUpOKkgI+VlgUm5MzKTm0BHCMpRWIlZgJyfEzrB/72Mdi5WNyMbCcqEkOBGy6SXke4MEHYgXHKNuiYEQBAECKMms3E5okR0rJwCaAYzA46RrAmfwMC+CofVFABsQE8cEDBltbwEd+C5UhyhW8/rSThsT1qiZ05xiyvekAcNlm0pX9kOtUABz+MGAilIwZmhliRg6o57hsIwBWDDHeu+dBZtfqcZ7tCBy6gExbVtp07vkaW91f+r//C7nvt9/+RQfeGE5R1OvWEm095ZRTA6wxegDci4vxnlcAnG8m/q3ImRHVHhCwdNnSEk07I+gG0A8//G1ldbtvWZx42PqSUq4Jp20LdM2iY3SEs2Hw3/nOdzUjIzvHyvjLX/5ybNkCEox4rN7XKYa8gGO/BLFW0btyUaBb0ZP4m1Lo74gXaJ4NEbjUI0d05dxbVQBni8ycFyEVyTCnRADoR0Z+U1fxQNIvG0J32AxRG0565512ji/E2JYzj0XORcc8SwuQ2d7SH5rZKvOZ/truFIEDIoG717zmNQHG3bNoFCXWjmd12SZjFf0TGWIX9M8O6fdLX/pS2IgEKewXu7OsAHr96Xd1pGECuNSJHJfnt4AUtheAw3M8Jjd2E+C12CFfizj+gi/gRwC4lLP2tC3ibcGPdyJU9MPWYbGUcT8Xeew0/wC8nVuirHZQXvyiF8dCi1cQ6TffL7vs0oiE+nYyuV1V5vVPyjPbQKZHJvgdj1MsKP15Ds4zwvTMh99ZVKLDvsBlu180l/4CaGS+3rremdkUP9cBcOwenfGNWIEHtuP0n/+s0HlRsUXrhT86oDxmYQFoHEuKDTvn7HOaE4qPBey0mVuz9EgZ+ptjTp7jU823zO/3OAfg+uXUaiqXAp4MwCknUQbO1zVlMWEIGZjKLVRGIQEcZ81AWZkKRQNwng0A0Cg9x20VZFIzvkLiuUI+/vjjY4XD6AJ4IyMj4eSttKxYTX6hdhPZCt9EsGWhb+fpRNCd9Dv2E4EzThO/BnDyOOGMAHDuVtfKWQF5nkb/nIL+pZxYcTGFP+jOMeSEHAaACxKLTEXg9OOjXxE4RokcrCoZ226RxqQNSGc01ePwGDZGGP8AYDoE9JC56Ip3y2nTNolnX4A+UTVbrrY16FDSwuDTGdfOUw/+90tfjIjIi0o7BxcwqB8gbV7R0xNLdM5W6fxifI94e/kW6mjkly4AgBzKw8VZcMK2RzyzddVVnmO5pzl8NGK3pOjoaYXmJQWYkvNBLzyo2WDDDcJhX1iMuS8kfOxjHy8r461iwfKNEoG7rzwkzckbG/2IaEtxDmvbDipjMIGeCQAuVZtcfVI++WhFbqHWz8ClrrAhNX4lExHbjMRyfoctOizAGHuibYns9ZWOyzVgRXeA/3/6p39qDj7o4Igim4fsDp3yLVQpv4XquUh9smOihPTJnAYezG/2hV7QQ4AQwKAf+biHbT8ARBlf0tIHOdtBQCug95WvfCVsgQWt6A9d2HabbUN/OODaVgVxM/RnJgBcypm9skMDkOMtXpMJfuOp6Jvt0oULFwYIJyf641EcsqrBCbmzE8qwGRaHFmZ0IO1k8jQBHKB18R8vbo4vgYEXFKDoCwu+HX7DjTcU23Z+6JsdlCOPfEd8YeCiAsb5tA033KhZZBu30JBfOiqdBOjyeI0vYOmffpjndCABHB0AtoxvjaLnNxX7+dvF5csUxTYCcBaofBmbckp5TyldQYPgxcblEQ12gn24r9in35fn97721a/FLhD/6VEC84FNBTjxueYRFcKL5P+qqNQcgFsVrs1gnRTwZACOE1aWQXJM4+naPYaOspughC4KZqVj9RsA7q474xujFNsD6kCOCbeorFooGIPL8HL4jKkIHSUWojZJACmKbYJbCXGK+swIDgdhlQ4kcK4mb624aM5PP8/Aqes1FlbrGREC0qx+rMSNP7+NZkwAC0ADPIq2GJ+knfxMRaxJe7bpOB0ALmlKmaYByP7Q7vzkk08OowRoM0qiZQASPkhtp0pm5MkgMWqHlK3F5x34vHh+RIQLYBKxFYVjyMjVtoEE1AHkIhdAPqfJyFlp68cnnTbaLA4sDGxToYtOiYgy7CJkDCBDT07GZ3tfm9q46eabijMu36YufQLkTy5/MkAfByMypy49JXdOQ4T4vPPPa/bac6/mDW94Q6yQv1iAo+gC/Xx3ibowqI+W+nRSNOjKssL3mgJjUEbfxmobFf14LOUxLvr4g/fqzIYIXJJb2wVj46RFScjTFtr7P/D+ADscGjmGfj1VeDD6zI76ohFkBeCToW+kA93Asmty07ayPqkLzsmHLoiaeL7IVpM+fOicqIhHPZS1aDBPzWuLRtta7I3dAuWVYYtEitgWemXBSV/x/P9KxFf0xuIEyEATHUSPrVWgwxxhGyw00aV/9lFkJb8YwQkDkasjDRPA1ePBm/QTxm8u4S8w5/ky8mY/AWG+w9wHhERARdeOKdvn5r/5m20BcOySegDUW978lmhTBC5l7kiG8RqR4pvIwAL0hQe9MJ6Z1hZ9Ix87LTsUgP2u4kNE2i4oZb9dbJSo/WFF7uyAMUhkTK7qAOfsDhp8BCpyYSoIIapIb+k7+7m4bL0CcOQuAod++fQdLwBYNIoMR2S2jMGrkegO/0pH9a1NCwE8o5dAnDxjzmR83VJdxv26XN6TlwBu7sfsu3FxFuQREoFNBuBMOMkEktQzAV1TagaNQzapTBiTkFFbOLIwfhnBs1CUnZE0aSmvlatVi8lAcd3zWhDtMm6U2EoXGOAATCSrGZOZkwTg9CdCZ9XLKAJwHHQ7oTc+xVlQynFfYijbWeO+hVr657mtqDlh/TMwJghwKAJo3ByCSAGnYXIZB3AHjJhUORHQUp+3aevnOumv25puAKePMTrLvE9DKD8BkAicbQGgjOFxT8IPOsLZ0SVRC5E1jokBBqi22nKr4CtnSQcAfgAOkOEURS21x2gDZVbn9MCHo/WhA/ryQavydAuQt03FkNIp25YiG8r4JAB17tvPQLaVOToZU4ANrUCWcaGPIwfqGG66bCEi6sKI6p+xFo0VaXOkm/qmJ+YEXlh40E1jsXDhMDl3z0NZQec40DVoMk/Umw0ALvXAGNIuyBNBAeAuuvCiiNJ7zY65kc4J/VmXPMxpkVJOih6IVvmIzijrkzxTL+vKl+gUXcDrT3/60yFn+amb9FcZyRYnnSITdob9ISeyzAg++tFibi8aBXAcrDoiLxw1WdNxZdgC+poLCQCOvdEuPaDvaBB1wgNbwtq1YF0daSYAHBnRCceUt3NyJG+Ld6CaHgMk73//+2NxbCuaX2BPjyk2P0G/tiwM2GXb23wJHtpqDR1hvP0f1Qn+KHdq6Aa/Yv57nlkS/WIDvDRYhBTwZgvk0RX2yXy1mMw5p22LhARwFnjmvoXqKaeeEjoIGNJ3+kvW9ANQE1kGJNEN4LE3dAKAoyP0yyJZHaAvdLyYWbtc5oQyyrOR7BZfSN/MEd9IzYh28rqbXiVv8l70MXqR9+ThHR84B+CSU7PsSEgENhmAS7KzvCNl9mGgOGUGjXNjiAE4E2pkZCQcH7DDMAtjW12ZPBwpJ8jIXfLHTrTCG9mtIjh8ym8Cc7ImnnwGz0PDjKw2PW/AiHK2vviQzjbpzSN64zMggPNMC0MhksKoA4cAnJURI2IiWXUzQiabqCNjAkDkREBDfZ40DXJM+uu2phPAJS3Zj6Nn4BhC57a2OTjjZVxEkXKbOOtySowLQE3GgAwdwAvgWqIvvnyy5NYlwVfy1b787BtfOU7GQxt0SBtWmbYOlJOSp4AS/fif//mf0A/lGH0y0i4Hmw/DkxEdEdVhADkOzlukBqDSvnEB7CKIxqu8L7nQP8aXDgPuIi/0mM4z8BYBAAHgqF/JXMAXhhf/GEM0WAhoM6MKyuZ4nPeT9KHObANwaE8ZGT8nKALCWdMdfAaG8YETV5YNEdGmP5xiOvPkqfIJ3Iw5z9VNPsgX/SA7CyoAzkJDP4CK9ukbR6k9jlok1ALAAsUctkDIrX7tsTF0hLPmoM1tIAMgZJfYNPpjTGTpmu1j1+hCjlFb9BmQ049y5gjbJxKo3dWRhg3gUj7ki2fGK5EZ3si3WPrCF74QNpxdZ/fJ37yiN4AJmbAh6pvP5i49AfIsnMw/kS5t4rV+HaUEcBb7fEUN4JQDquRrD6gC7C3kzFV2T58AEruf8kT/kgL8+Ab6zZexOfs8Z5/m57/4ebRHvp6PBBYBQuOnl/kcpmh8DeAEL+g//UIjYKc/NPpIxsQ+8neiv3hEN0eKjcQjdtJzvOYH290rJW/yfrbvOu/JmwNwyaFZeiQkAusHwCmb5U0iiuSTz4KZTCYcoXPcjKfVgQ+ForwZXjYpGC2TzwqHY2TUTEzf3DIhGULKyTkLp3MAni2xEjKZ9csYo137jKaPFX47Je0eemc0+o3AAXBWZuizAjSu+Jp5cdKcu/tWdwyzCYc24/aAqT4z5aTI60GPSb962dZ0Arhsn2GSrBazH3kZwWLsGB1jxI86ASicJ2MIaDOogJ5yQI2E/0+Ut59bOZI14E92ca/wi5FjOBknK1gRTTpC3rbN8TjLOqKRHpCB9/rZDgPOOOfcGuMwyVD0g/4AZAzttdddG8COA2GARcb0o026DKi5Z8se4ALgGGVjtNVvhYwmcrCdilZbbfTfh/Hl1PESkKHH6t58080B9t705jcFkNAf/tc8j0FO8odc1NW/Z7/MRePDc3TNZEI/enyco0sCxEWlzBOy9ssanAw5krty6pjn9MaCjG3xSgTzH0COyMu84pirVyMoI2UbjvoFqjhItsTzdouKjeEo3aNT5GbeiviSK2fJEX/xi18MGYmeqUdf6ZWywB0gx7YAcbmIoHPsAt1CI/1gW+ieckAAPUAr2dIFdIjsAwv0wVbYMSW6xK6sjjRsAEe2eMI+kr8IkXkT8iq2wO/TAi3fKFFsuiISKQKnngiYL7Hk9jW9pg/KmUdkbE77BihbQ6apT+rjuWTuaYtu5BZq+h32hk3jt8hkYYl+aU+fgDnZi+YCkfQCEAP+yZR98KG3QJ+F40gBUkAV2uwaqZN+0EJO/0AhnpgHAB7doWd033joq2/f058EvHRRn/SSHhkfPtj10o+xep4OWATg8CHfINBNr3J+5j16mSnvyaO/7PFnPvOZ+JKInzozd7NM1nkmHZ+RrxFJAREq4XEWogq2iEwA15ybVa4yFJkzpOyiGwANh2ZCWglRSBPOisekENHQjjKMn5C0yWzyUWrbMACgCce4c84MoXv6Yxg4Yfes4tpJmfgUozEIgGOkOUcTleIy3lbWEqPEwYsAuWc1L0Ln+SgGoF4BTVXhk379ZlvTCeC0qw+GwYexYFg5LsZWBJKMXJONaKcxc4Dkpw7DJGqFJyKoypBv0qsPEQ4gA6jnPMgzna820LC4PCOiHbrFmOtPJI6RUlZSVnLNkNEDxtbKFF2MPQNIR9Dtg190w7cPvVritttvizr6QS/5AT7qABwcPqDJoANwHA+9taXm+Sdyp9/GAmygkxM3frqMFnqKDjzQ3tVXdX5SjCF89WteHfpuHMZtLDWv5E+U8ED52QLgjIE8zVm6gz94SZZLCkjiDPAIn8nTXMJv9Tg8crcIMHdENzkjyRj9mzd/XugOu5C6kPyKMqM8NlctFMnUYpBT1jd7xVFzpOawiAUayMurPywoLCZtl2sfX9GtDtnYJgXi1JHIl/NWlw5ytuwQ/UI7Z6u+hQi7aJ5w1pJ67JkyIjsWrKsjzQSAow/mEyBAtiLc5pLF3N1/vjsW4OaguQnsLCqgG//5E3OanQXcbEWqT6fIBPg11wFxNtc5m0ufpNSJBHD8DtCcETiyNocEAMjDs87s2TEFUOuPPgCKQLp5DfTJN+e1CTjRAToPtIvCGhv7QAdF1OgB38cXAoLsENqNT3sWNBtusGEAOFuvdQROWwnW2A56CgSzJ+jRL1CKTlu/FqYWzvgaPCi8SHvZ1q2cN5mfPEu+OcqbA3DJoVl6JCTC7CcCVw+BEaRUwI3JyeFL2qLgBE/J5XtdiAgFw2cyWCFTZKDPBGLEgCrKavUhwsWguaaAFB/wM2E8V0X5KS/aAT51TB59AAf6bydl0+nrizHnhEVnFpRn4BjtQ190aLP3s/fulCvKz1Dki3zRrV19a0cbzuX5cBSAKuCw+Wabx7c40yEnj9s0DXKtDR8pJ98wAJy2jQ1QEXXjZMhhSXFEZC4xYowLIwKILCwOkiP4RllFM9La4Jg5NLxy7YN+chIhs2LGv0zKpXw4coAR760qOf1ciSqvrShb2OF1IvrmIK2yGVzgSfkEfYCE8sYBUHGwtkQYQ2PUnzEz6O4DbaK9juoxznQrIwfa/+pXvxoAU9/GI/pG/sbECFtpAyXo0G7qMZ1n0AEBDmkqCW14MRsAnHGQr/lOT0S6zC1zKIGc+wA8uQAzuT2KN96rBuhxRpw0J0XHtJdznfzojyg3Z81uSO5LeE9uHKTFBPmqQ1/RkTaKbgORXjvhiN6MzuAlZ8iukK1rQAFNFpaiLPQd37VHR9kRdglNHLY5IZJnvOYDXTA2YzJ2ieN3n8MVfRP9XR3JGI0f4GAT6Xo+Zzod9NBRfkBEG6DRn3lEtsZPNywK8QagMS+AHbIE3NTjX4AXi0HzCd/xWwAAv8nFT2FlhJZsfDKZ2+RgjHTDFq05y04DfHwf+bhPtqJpdIZesStAJF02FnSizZjoBjtHhmQ+MjISZegL++WRInQA7RZ5ypv/fCM+sIF2MzZYf4OwWaf/7PTwi/yk54zpd+qZ9gQTPAKANjzEB3yhU3jAnlhA4CtaJbR2SzV/3FcnU96TNwfgkiuz9EhIBDYogLPipDwUi8OSsi3tUSATwIcD5jAZQRNWuDjBGINLEYEBExJwswracovi9Ipz1pbJwrCbfAwmA2xSMrImhlC0bVOO0gSX305Ji3vObdnYfk1AyPkyur41i3av0TDJTGC0MgDqGaMPmk1MfTL4I2XyOjJM+qh50aZlVa6zX3VzgjEIVpQA8TFHHxMRyzRig/ahfeMz4fGWUbciJSuJDNyXjM9HWVEJY3fP8yBWzdpyn2NOPkTF8kdUjrPiiDNluaQBvy0OOBTAiGyBZHLJth0lvHCOZoDL6pc+kqt8BhdgIi/36Q4njAZ1GGbflLVdInHCZOioP89HMY4cBTr1l1/IsWpnkAEBNDKeAAPggHZgkt7qVz3gUBkgn65nNCY6XoU/6NMuPVjdW6jIx+PUHdEOQJfe4Fsm/KE35vuiEmnhrMxZ9JM5vVNeGZ+Us/ryRdiBafXdN/7US9dosOCjA9ojKzRxciI8+qMjHGA4/rLgU49dYl+uv+762NZDE0eZW6z6pjP0l81RB//zsRB2iTxF09AIBKGLLphDwIFz/OAU2UJgAZCgC3RudaRhA7icm3yFuUYugBlALZnX5ijeioqyoQlc0MY/iM4Bcc7lkYU6gBPQQrb0qsC2YhA6XKQXmeiEBSgbri36s/tuu8d8ZC/ZeLrCBpAbEAmYkbH5bS6jXZTfXDYmdNMn+iFanL7HvfRXymsXoKMLAg3aZRvZpx132DGCG/PXmj/m3wB7ANZuknFK2mS38M68QhPdM2Z8oNPALz7kosZ9yRi6pZo/7usjU96TNwfgkiuz9EhIBDYogCNYE4qDcmwn7VIiimuVa2IyuiYgZaSojCajpixltCrnbDnPGgBohxFmBHzUMSmVUUfbJpNrCpuKX9OkDR9j1R8DYoJpSz1G1CTkZNGc9Bsnh8AR6FO+pC2TWHmGvt4eyTI5EWo6VvVcm+12pxvAGRPeGScjxDmRbfbbpt34yJYRkTgqMu1VXhmOi5EkL6F+CVDP8TniNaOnb0ZdeUl/6Osm3yhQ/gDmWZ+u0SWOkkwtOuielbw2jZdB1pdtLuOmhxyxepLoAFC//Q7bxzUa6LxvozL4ylvR60O9dOza5TTwg8GV3Of88cxcmGpKfZ5NAA4PzRm6QH74bn615wI+cWj0AS8Af7IjI2Xb5fFKHrmxEepnOXyQUi/0jydsBfm5xnvOU6Tm9jtuj7IjZeEByJEhOjlquoNujpBD5EzJUB/sg3mujr7k2UkQ7WM/lfXsEt0GANOO0DlzKQEcvUSLsdBFdsR4VkdCyzAicGkDcl6zJ/hAJvpzLRk78MqGsyN4207sr/mpHj+AV+TAZqvXTtln6odrMtUO8Ajw4D8Z+6LWw488HLrHDpj32kSHfsgYre7Rjxp40l06wf6nXUq9yPGqo298tjvEX2j3vns7P2bv57fUYS/YFTqijIVCnYwB7SJw5gjdord4Ro/QXM8Z5SVtd0t1WfezvPO8J8/cAXznnoHDmVmYCInABgVwDDVlNgET9dfD064PRUvl1o96JgXlc65Mnme+dpIuec4l7WQbed9kcO7j3H2fbkkZfWY7aQz0n0l/aXi1Uzsf9euU1xP1WZefyrm+6v60VQM4bw/3HMiqRuCStuzDdZ73MgJ1meR5TWe7zeRTlvWwrQTA4XucFxlrwzWjl7IhK+fkMVFKmpVJOWYdbab8veAXrzKhKes6Jo3akIpW+RNlgBNbqBwCw+k5FkY09S/byTayj+k+Go8+ZguAS17lnAy+9ZiL7tXlXZNNylwb7VTzs18eZ7loq0xfPMvIfravjI97UtqHuj/52Vbmc9Iib7Z/0S7yBszX4DzL1vXrdur7ysx0GiaAywVaPc+M3Zhz3HQgZFLmffK95kHyqs5znu20811rjzzM+7RdxqnPtCdZTzvRR9ENdDpPPVA+aUKnNrRZ66by7jkqm7Ym2hztJMcqLz5l4eooP+11lkm6HOs28rk2O0NSTZvruqzrTN3ada+dX9fPe/LmAFxycpYeCYnABgVw6lH0FHZ7eHlfGQrvo2w9YV3nR/msU+fV51lXW8pKJow+fJwr3y1l+/X9MWc+2l67/7qsNnOiOs+JrUwYKv59dDzuT3dK+rWbdNUAzoP2IhNJ11T6T97ij77SKHVrM8smTa7xqU51GfT5SDWAi3cXySx8TD7nWMgWLbUeKdotpY6kLBzlZb9oSVodtS1P25LzHHf+lJg8H2VFdGy5erWEyIHte19wEBHQnnJS9pF1My/zo9AU/6BHe7MFwOXY62HJyzHnMe9n+SxDTnhP31JHsqyj+tlG1s3rulyep2yz/axf16nb6XWuPffQljqBviUlwupLF3TBFqCtec9CpS7Vdippcqz7r/NXx/mwAJyx4JkPOeR18I8cC1jCh5yveNVN5lFxkj8pN8W0mf06T17rp77OsmQq6T/LZntJe8ox7UKWUy/LOCoHIOaYIm90oZhj4yvww0+oSWvNL895jz4q5FodH6nuJzJaf9zPsm7V51m0Vxvt/Lpu3pM3B+CSk7P0SEgENiiAy+HUgs88R/mprBSUAusnJjP9bAGeNLbqKueTtDmXcmKYKJL7zrNu9hE3W3+SzmzLdXzduhiSnFxBW6mXfdd15LmffblOY66rbDePre6nfImWmh4N1gDOu6Rya8m9qdIR/Bk1vMlv7bZTm6a6Xrus61pGNb9retOocuTZHtmri5a6bLuPlJEyWU4beT1OfqW9uLYiLv9ynBmZnT+vRPs6qhd0oMEWm2dRPPQu+uZZPs+/5bZaTU833iQP6nKreo5245oNAC7HmmPJ65RB5tfHvJdlHY2p1pFu5eVlnWyjLhf3io0J2Ra5KlN/6rp5rr4yroOvRfBRZzQqM5ZfyuS8ZzM9m+W5JM/Qeig9F1FZ3ljq8WhzNqVhAjjjTD44+iQvUh4hoyq/G2+6lTEXs41udWJBOMpq5fSdSXuSfD4go1rthUPSjuakP9vIY52vPTYk86KfUV9X2y33ly1dFjanG4DTtjLaG0sryA+bVN9TVsrjWJ1yUpebKL+um3XkzQG4mmuz8JyQCGxVAdxEQ9J2v9EpE1L5WtG7tZ30drs3Wd64ukXnTTBjr0P82QZ6cqKjKSexvPww5DU4zbrDOAYvC3+knGBtAOf1CnW0LMsNg55sE13SqvSVYwoZVMYqdWFVAFxNV9BWyCMjidw4LEmf5CrRUaDRw8TyGS0raZ8cn3Lo8iyMB5A9swXAeZ7Ns1L5HFPyQV/q0hsfKfVmMh2Pwn380Z7+ZguAM170+OCVZKzJwzzm0LJsXg9yzLa00U7upWN2v54TyuIbB596IS/bcw/tMbfJruiOe3m/ptkzS57NYjtF4EZGRuIZqhyzLVYOOoDBqA7qa6KU/WSZbuPLe9NxHDaAQ6Mx4atjPR/6pZ88fIKPo2AK3drKOZxtBf+KbC3IUlZtHmpLuaKpUc21iJit73Z7CkSb5Vi3k3n1fefZp/s+7Ipj0kqv0Jb5HuVwL3xQx5TGfW3ViY3KPsfKjxbIvuryeV7TnHmO7fxsu74nbw7A1VybheeERJjDAHCGG+2bKCvb2XHcSAVqK9a4QtN8kWPv1qx73Wiq89VLeh19sk62mffzelWPdb/ZZgI4L47MCFwbdKxqf9nHqtafSr02D+trdPVN26ghr2mp+VgsZUdmTOboPNB2fd6uy3GI0OXzn2n0GdVuqU2rtnuV7VY/aXHPeZ3y3mwAcDVdzpPW9vjb5Vb1ulv7mefY78Ix5Z11a3pq2uvzLEMPgDQfEdjUBfeDhkqn5HVrQ36dJqOjLjsd5zMB4NCZ4+qHB+1xJS/reRMgvBTUXrZd1wtwNupz2n22y9ftt8vWbU52nu3UbSSd6iZgdB5Rv1H7MxZAqKf3JP5SG91S3Xe3+xPlJV+yDdd03FsB6i8x+EJQlpmovafrvWf0i3yfrkIZlO5U5m71ut2bSKEnutet/W55+sx+s70awHl3ka+zA3BpNLJct/Ymy5tK3cna7vd+jrddflDaurZTjGXkdzGUvdpX3r28X7dbnye9WS6v89grP+/nsVub7Xvamo0ALukc1jF5U/My8xwBuLhX5FuX6UVP1u1Wtlter3bkZ1vdytRtTVSuXbeu1743lWsAzrckveZEZNl74PI1KVNpd5h1u/Gtzmvzqn09LNrQ4NPur6bNorFOpcZY+SxXg8+6bD/n7b77qaNM9D1KWwJKc8iv5vgWav4Wqnc3zgG4frk6A+VS4YYVgZuBIQyli5xM3Rrvda/X5OmV363tXnn6zH6zvRrAMbwAnG8E55cDciL2anOq+UnHVNvpVT/H274/aL+92umVP13t92qnV357nDV99XldTlv/iAAuFykZlan547zfCFzNy17n/cor69e0ZF6vY7usvrK/9r1ebUwl31aeL+Y8nQDcVMY72+rOhIz7GXPQMQrgYk6VhQ8/kgBOBO6II46Il2/XAC51tZ8+ni5l5iJwTxdJTUDnRBOr171eytwrf4LuV7qlz+w326sBnJ+TAeA8izVTAG4lImcoI8ffb3fJt3b5XvnT1X6vdnrlT0TfRLS2AZyXZm+2aZffQu0SbWz3OZPXE/Ehx9urTAK4fN5MZCMfRs/z+LIBQFS+iDCV1IuGXm0m7b3u1/lRttDu6J/oS/Q3NZLrLnqe6ycBnJeBZwTOK3ESGPesPHfjGcWB1EODmgNwg8zg1awGSDWR5yJw4wUxkQh73etl6Hvlj+9x4it9Zr/Z3hyAm5hneTf5ltd57JWf/M1ykx0Hbaff9ut26/OaHm21AdzBBx3cbLLpJnWxOO+335Uq9pkxUfuASdfUJbsea9TrUsaD5/pLAKdORN1KJ86BOfc4o4no6kpTK3PQ+jX9raZWugy6R+e28xxv9tmTbyu1NHgGYAvAeVGxCJyXznoUI7ZQy8P1c+kfhwOhh1Y+JcWcKZq4/Knl8Qxcvsh3LgI3C/UhjEYF4NZdZ91mZOFI/ESJ56kypUHJ62f6EV96pW73JuLPRPd69dHOjwk2SlO2x3F7jYGfM/P7kN7ebQs1HdlUIw9tGmbLdY6/X3q6yUvdXvnT1X6vdnrlt8dT01ef1+W05Q33XmviDe2cr3fT+WZsO/Xbb7tev9e92pc/CBAZi6SVjnvV5VzcGwNw5XmdrIdXInTsl/urI/WSVzdalM1Pfb/X2OsyUzlPAOcZOO+z8+s4fhA9fsawx5dyptLfXN3Zy4HQvxrAlbllkeRLDH5+zO/9+pk47zn0SxGZ6OgzLT2tt1CtwgCAnUd2DqOSX7nOr3A/04Q10XjSCK+Kkk6lbjeaagMfhr1MHADOzw/5iRU/OVW/TDZc5hS3jrrRMRvycvz90FLzrV0+ZdTOH1Teg7bTL/017e0+tJHgBXDzu6Pm6oYbbBggbsHanR96r8c26Ljquv2cd2u/TXc/7bTrdGu33kLNNrOeo09G37rVzzqTHbPNLNe+zvz2cbJy3WhSp86vz9vtT8c1HorA+bD7fsbJe+z8nNSw+54O+ufamF4OpM7moicBnGck7dD5tR8ALn9mUO/PRD15WgM4wvJ1eL8XxwCa5D5pDKdXZWZ3a6nQ/7+9O3+XrajuBt4KqChwETAMItzLaKKMKiKDoBEccR4R8wCKmschPsmvb/6AJM8TkycOL+KAokaJxqgoalBRkFEZ8sqgEAUFBEcQBBXQtz7rnHWsu+k+p/t0nz59LlVw7t69d9WqVWutWvWtVbX3Xo6RjlO2n1TQy0GLLvz5NqB9K/68TNZ3+VzPDpj5+9Fby9dG1UfqotvmQdcnRX8QnUHXu/z5nTzmMfOgQc+OvrXqA+0G4m3Xbdvbbffd4lucmTePo9SbZUY59qNf812fL0U38/ajqWzadsrAtSyT9yfhs2qa9bk6FktL5R3Urvp6fb5YXcu9h0c24zUovunK9/souk3qLT34JJA2W48f3gP3k5/8pPftb3+752s/z3nOc+KVOSttm6sp/TUN4HweaI899oi3itsQL3GWlJsKXk3hTqvubltHMdhxyg5qH5o5aOXABMBZQr3gggt6L3/Zy3t77b1XvOzSMnjRVoS/B9Fb69eH1UdXF9nuQdfdH5a2vIvRWYzWMHXUtOtzdKUE65ZQzzrrrFhC9cHsQw45JD5yPZdr43+HqXfjEqP9qunXPNfni1FcyJc7GMoKTU1TWXmyL3Rf0pv3rSJYIlS2W36x+ut7C7zM11nfW+w8yiX/gzL2aVdmrfmtz/P+JI+iLPVrRLxP0sfZ67ZPsr5GazYlUOs7+4w+BsD5dOCpp566sIS65ZZbLrtPzWbrN+ZqTQO4Rz/60bGXyqdhcg+cpxrDkWx6y90ba67zK416OU50nLIdNuInel2allAvvvjinifIzI723Xff0JNBDc+Zvx+9B/u1pWQzrM4nRWcpfQyqB5/5EMNdd93VA+AOP/zwvgBu2DYtxcug+136Nc/1+aDyeT3yzgOgoNnH7wAe7mW0IMs6Kt8AXC2RwecicCYAfIhlVK8jEsnv6nIwhXZnU5NA6l4/sgfuiiuu6P3Lv/xLA3CzqGhKorB8ChWAAwSE0jnHvJ9KncU2rAhPZQARxZJiA3afQWRgveOUHUA0BqWiKyl1YeC+6KKL4luM9if4lBadZYRuAKl2uUiAPBdLKePF8rg3KTqj1pP2gE928LnPfS6WUnfZZZfekUce+QAAN2x7luJjsfv96qjlU58vRke3W+h7pX39Ukbg2HvWW9N3fxL9oKZZn/fjaeFaxf/Ctc5J8ty5vNAW1wfl6ZZZ7m/t8SJfS/AA3A033LDwIt+Vrnu5PLdyKyiBdImly9G/SZD3wAFw73znO3uvfOUrYw9ci8CtoA5GJa0TU1YCOHtoPM142OGHhQN0XyTO0d+DJnHC8+0NZ9Z/HOkvjnHK9qcYvOSglQNTAjif0vL4vw3InkJN55v8DyC5Zi9n+4ZtwCA5DLo+KfqD6Ay63q89NY/dc1EoAIYdfOYzn4kl1F133bX39Kc/vbfddg98D9wo9fbjZdxrNf+L0arzDeJ5yQhc6bvKDiq/WP2D7tV8Dcrj+jD5BvE16Ppi9S33HhkCcPbAnXPOOQHgLKGKwLX0IJNANWYZX0rUYuFFvnUEru2BmzG74Gw4jQUAt+22EYE79NBDYz+Ve6HQGeN7pdkJJ5x4dX5GMmyd45QdVAeaCeDSyVv6uPDCC8P5nnTSSfEi3wejrgbJbLHroaPFMkzgXuppAqQeQAL//tRhL6QInKdRd95554EA7gFEZvTCMLrJPIvJeLF7K9n05G2UOlaDV/7k3t/f27vrN3ctvAfOC8G9iqb5kVG0t/bzstm027RFv/Nj9pZQMwLnu7/yuJ95174E/tSCTWIPHAAn8kZBm6KS/qSu/mdpzHl3VBnU5Uctm3XWR/SSZtITeQHgvAPsDW94Q0Tg8l5dtp33l0DKs//d8a+utC6SfwDOQwyWwgA4S6j9InDjt2g6FLJd49a20vIfxN+o/K8WnwsAruyd/Pq5c99Cfc1rXtMA3CDFbsLX02Yd0x6dDwJwKYrMm783hWMDcJuAFtOgsymjGmpdftSyWWd9RC9pJr0EcJY/Xv/61zcAVwtsiPOU5xBZl5Ul9bSswkMUSv4bgOsvrJWWf/9ah1tCrcuuFp8NwNVaeHCfpy9xTHt03gDcjNtFKiyXUPMp1BaBy/XTOQWmUQ+rzuwQ8o9atl8d6CXNpFcDuIzA9SvbrvWXQMqz/93xr6aexqfUn0Ly3wBcf/mstPz719oA3CC5tOuzK4H0JY7Zb5w3ADe7OgvOUmENwG2sqDTovJpGnb+XOtblRy3bjzZ6STPprRUAl3xrV/Ler439rmXZUcv1o9W9lrS718f+bUNw+Q/PK8F38pf8NwCXEtn4uJKy37imjX+lXja+uviv1eC1ReAW18mD6W7arGPaovMG4GbcClJhkwBwaOVfboJNYxhGDFnWMVOW7x7zfpbJ33mUP8vktVGP/fgYlsY4ZfvVUbcz29UPwMmX9/vRmfS15MtgIKXc8+ia9wgGX50Xq7om1fx2+VdWeuhm5cmoKmXZ6tJGdOrrmbeux/28Xudd6rwuUyysMP/AEh6/999y+sADqQ2+krxME8BlnbjqyrNrA4M4R6P+Q4eskl5dRz8adVn367Ld/Emzez3ryPt+expTG+z9HebTgUkD7aTjvL7ud78kv3yZ1+9+NOpr/eiMc201AZx2D2rbILnUstLuzFdfr2nmed5XJq85Xyp5R573oCnPHvo94T8KvaXqW837KSPHbJPzBuBWUytD1J0KGwbAZd4k63c6ba8zsIn6nnvuCYP3rhif5Br0nqY0ErSSrkfaPVmZNN3TcfylU63pycfAlPNIvOQah77Vo7aKul3zWx3+nHcH3axf3kklNDPVbc1rox6Tf+WSXgI4rxHJPXB1vYPqyPKD7o9ynYOjd7xI9OQppUdu+cjeFg/bIuR9/333LwCafnUnz+5179Or+2wgU+Z3pO/8vdlDyzvB5kFi5nWfI0aX7tlPv5Q03OvyUOdHzx/whp76JOWTH7+zvjx3nHRKnlcTwCUPjmzA0Rdc9P3od9UXEbL99MFPyE+WBkZbN/LLL0kz89dH9/R3Ly12VIdPPylLt+wl9DOv7366TB06slcJLXtJfU7K63h8jabfgyA1OM/BvR7Ya17r87pNyZNr+GVL7EhbMvXLn/cmddT+eAp1lR5iiDaKVhc5FBFEn3HuaWqyxZ/vbtJRyobsUn50xo6MGRKbkz99hSN66Chflx1GhjfeeGPvsssuC/+222679fLNDGiyYTTZXPLWj6a8/qTkO4+ZP32c3/X4luVc75ZxbZIp63LMupw3ADdJKa8ArVTYsgFciZB4DP3mm2/uMfif/exn0WGe8IQnxPdUfZorDVxHYhz5O5uDB2V9kNt313ReST6dl3MGCL2k9LGPfWx8tN09A8B3v/vd3m233RadjPGrQwLgtnzklr1169b1Hve4x8UA8ahHlo80zw+48mRe512eXBsnaVOm7BD5ezlH9JJm0tN+L/IF4E4++eR4ke8wtLP8MHkH5QHa6PqG8vLPW2+9dQHAGcwMqHvvvXfIffvttw854129/erOe+rq3qcj9+k2U8rBMe+799CHzAGquh55agA3SM9JE53kwTV/+bug0N4f/jgfaZwfdBfulXLypk0lD/V9tCeZkufVAHDZLjz84he/iP7LFqQdd9wxXmkDlLmfcjHg3nTTTb1bbrkl+iz7NXjp395ft/vuu/cMlGyor56K/H9z95zd6ffqZRdPfvKTo6yJQ20PqYNgqvonQZ5LOcgbqN73vvcFf15i/pSnPCXsF42U88J54YMfYVfuoZHyqKrZ6LSm4UbyiRdt9Vfzm/nlXYq2PMtJeFhtAIcHUXbtT90ai9gGuT7pSU+Kp2IT3GsnufM5N/34pt5NN98UnwJDB4DbeuutY4zYsGFDjBPGD7JM2S4my9SJOvDj+8Jf/OIXg5cnPvGJvRe/+MW9Rzz8EaF7edFK3SnTL9V6zPtdHrr15v26bF5LGpM+Zl0pK/SdNwA3aUlPmF4qbBgAl0plTMpxPpYdfILFm7wvv/zycOQM8hWveEV8+BbgylluPWupm4GWjvLlL385QByarimnEycoOPjgg3s+8fUXf/EX4fR9xP0jH/lIfKvt5z//eYA8sOmPpf6HFse+bQFvBoQjn35kb//99g8nj/eaf3zUA3/N1zjn+M80ic6HXtJMejWAE4HzBY3Mo+7Ml3zkcdD1vD/M0UB8ySWX9L71rW+FzhMkoW1QfcYznhFf8zjggAPCyaFZ89atYymeSDNXK7t0IiqS8p6fyXOsy03o48eRjTvP3+UsHPhS/C637lHKpRymCeCSP32cbDh430rU/x31VxGsV73qVb0999wzsrMN+dirKJcXgwJ7riWAAeD0bS8KBfoNxt1Ez7f85JYYWL/whS/EuyvZ2hvf+Mb4fJhveNYp5VNfc44fKYFX8vdP//RPvR/84AfxHr2jjjqqt+cee8bSPR4lEd4FI4wrD/wnbeeBdza+gmbSTRBQ21R93m1HfW9jqqP9osNVA3ClQxePFroA7O+7974ef/7dq77bO++883o//elPe+u2Wdc75Y2nhL83KZTwLPr6zW9+s/ftS7/du/rqqwP4pU6NGcD3c5/73HghvQk8eSnnOEh2ZIxGyppt+ID7mWeeGRE+Y49XrPjO9OZbbL7g00aT+FzurMOvxfjpd1/ZQWXmqC/v3+Sppu+8AbjlyXNqpVJhwwK4ZIxifQT5/PPPj4H8uuuuiyhYhr5f8pKXRCeyFAGA6UA6CIfrL5P6/X3605/uccoicJIyom7AnLp0KJ3YoID2+jLDuuOO23unllmz2fiv7/h1vEFcmWLh5fftUU5dO5bvQz63DAzHPOuYoKGTu67eTJPuFJOmnXLCb/KaAM7gKQI3TQBndvrxj3889LptefnzhqIPur/5pptj2WG77bcLR/rqV7869Eh/tUwGyT3bmW10dO3+P4hUlOWK8luiuQXtpR4NCiVCJr9BUdmkE4VG+Kcfr1m8pilf93e/fHltJY764bTfA3fnnXdGJA2Av+aaayJyZWDNPurbvHvttVfYB6ACZBqgTdQseYmmW+6yXCYiB9ABYEcccUQAKICumwA44O9Tn/5UgDc06dlLrH3/1Tvwap0P0qHr+Zd+AIjwuSCrAHjwt379+qCXeRlcRmD72Zd82pqArMt//XuBZnWxtiOX5elec73fNddHTasF4LRL3Y7GBPb7jW98o3fttdeGjZiMi8rttPNOvb/+67+OCUH49dJAkX+TR+OFFQArPDv+2Y69e++7N0CfccjYwRe+5tWv6e2x5x4hL3oht3rsSXnhxR+9ZcIbAPef//mfwR9Q6HOF/JgJfz8gn/4oJ5poAalz14svKr/re1mXuuczbTQ5xDM+JHxPSu9Zb33MehyzHucNwNVSmsHzVNgoAE4ZTvj666/vnX322TFgMzbKNohzhi972ct6z3ve82JgB5iU6To31yRHMx1vk9cp7T2x7GkZzh4HoE5d6nRPKPvgJz8pDO3UU0+NAYQj2H///Uu53UoYfaseJ2Bg0S7p2GOO7R33ghcEPwaOdNzupcE6n1TKtqE3CfroJc2kt5oAzkB37rnnxhJLuK6aAAA1bklEQVS1N7eLtNI7ByqSagbNiYqO0BkHnPzXMmYTQDp95J/2ZRvp1d/vi4PeskRlHrbFw6L4faXc7+/9fSk7Z3Oc7zYF4KejSxp5DBrFNtmocwlPHLK/LIfH5Mm5ZTn58cgWlXFNGe113Z/6XWPrOUFwLdsRFa7QP6sB4ICuq6+6unfe+edF+0U6DMBkp++aUOi/OVADd/o2ACZZLtUPDciAXQJQ3/MV6XCsE12YHFx40YWRlw6AP9snDKxeXgz0kbc6u76mpkVv7ED5Wlf/9m//FqsJRx5xZO/wIw7vrS8ATlI3v3bXnXeFzbkGJFjWc/QnoaudeKuX/OJm+QdPWTc7Ug4odZ0t40ddbDFtzHk3TcqmyGk1InDamFHzBF78P5+tD9Ep32Yy8Na3vjUicCKyyumD7MjWEXKzXO/TX86V81Jz9kS+b33LW3v77bdf72EPf1jcJzf0u0lZfZxNOJfUd+WVVy6MSQDcG17/hkBg6PijS3aRPsWDVo8o9Vpm3Xxeb/f8bu7BGPVuVvwBnxAAsGJCm0QgJXxbnkfTdXXkdTyxK3KQJmUHaCVNx6TrHB9W1rpfYlBGyrxzvzaNfzf5F/nq+D//2c9737nsOxHuNiPiPAEtfwzPZzee//znx/XaCdUKr43mk5/85EJnMfCbASuvY1111VW9f//3f+/d+KMbe1tsvkVsJj3q6KN7jy7A4P3vPy1Aw8Mf8fDIf8hTDokBxP6Yz3/+8zHj51SfdPCTes/6y7+Msvbm4EM7HHWqSadsG7p1m5dbD3pJM+mtJoBLUMOp1E4RgBNlMXsF7N70pjdFtIUzTv5rGdANMGAwM6Bv9+jtYvk79iqWNov0/PrOX/fuLPnMtNeVGTc6rt1enDzwIg8eHvfYXWNGzgmyudQrJygPefkDGsjQUp09M/5yryYHzn4BUMBMVAePBhd/uQ9THSJABhO2pn6DLloikui5pp7UV93uSZ6TAVsHAKb1JYYf/O8Pet/5zndi+Xz9hvWxD+0DH/hAAKCdSsQ7I8J1O/U3AwJ5GIgc/Sa/97znPb3vf//7oRM2YzKWcqNvOhRptmwv30EHHRR6tNymLt9/zahd2qY62EHSCcBS6NCbhxX8yUOXdPfBD34wQAAwmBE4/P/2nt+Gnd18y81hG/iRH2ila3akjowO+e06m8660WGDWTc74ocAKHu/2CWbY3/4IUM01NNNNc3uvVF+hzxK/ex7Nb7EkPrQh/7rv/4r5Clq68EBPp+83vGOd/Tsp+Zn5BepcmQ3m22+WVxPvyL/Rz/60bAR5295y1t6lj71RTZBbtEnxcHmQ2HK6udkAADq+/wGUGjy/5WvfCWuH3LIIb1T3nBK+B6rAfQkoEBvjnS/RdH39jtsX/zUnwX4tOR+28/m/IiJAt9Atw8rY5ikbrRu/cmt0Xc3L3keM78NIP0KfvCddpafOSteJYDeKPpeLG/K0DHty3kDcItJbQbupcJGisCVWSOnY+DNgY5x2kx/8cUXh0G/9KUvjQicmXYCuDSMbHZtNJ/4xCeiE3sYQoe1B+UFJWLGwdqXYq/b9773vd5999/XO7A4778sYIwxc7rfL6BBvuOOe0Hso9mtROHSKQATOqgniEThnlw2xeLVHCaW5UrniD1w5TjJlG1Ds9vu5dSDXtJMepyHmei0l1CTF04sZpTF4SVPllY5URFTEZi/+7u/C8dMP8l/3X5RG7rn4AD35xXQbsZMJ2asl5eIzWWXXxazYfujbCa++zd3R+SHPeAh6BaFyi9yY9ZtgDeAAgcGBMvsbIvzzz/lLPEDC+zDYMnRK/P1r389IrhsDEBiT5y8mfiBBx4YedG17wudlIMB4lnPelYAgBzAUzZ1uyd5jr/8FqpIKPDR7wnKSdYJLBq4DDDkRn8iWCKzwIdlTfrsJvoijwTX5M2O//Vf/zUieAZOETU6SfmpA3j+2Mc+FstnQKqBXqQFcAX4ji4TOqAIbfqgY+f5hw86tGeK3uzb1Qa+iT+gZ5EG7bB/05IsegZmy3v0rHz4smJrAOU267YJG+eLgDn8ACJkbx8gH4aehCfgU9382THHHNPbZ+99ej/68Y8iKukhLok8lBFZYkdsrU7aM6lERqsRgav5117+2TiS+uazyYns3/72t8d4APiETufBl3OJHaVMgDY2YgxiU3/7t38bAI59Zn556UJyZFvAoomAByP8RlMZ9kHnEvtiZ+z3hrLcf8mll8ZEAiA32cSrQWXLUu7Qspdzv/33623YsEfZYnTegu+xcnRAsWt7+4o3L2Po3REIOftLZwewf/y+jy99Zp/wN186+0tRP77JBZCyfehFL3pR2Bf+8JltCSb7/JOy6XNro0tJxzHLOG8AbiMxzd6PVNhIAK4oVsdj4ByZc3SEwYE4HSn3wK1fv76Ek8v+p/JfOu2UgjKSYwI40TyDtA4jAseZieqcccYZveuuv67sQfljDKLPfOYzY8+MJ8cAuIcUYz7ssKf19t1nn972220fDt93Qi3ZMHb5n33ss3sbCj8PN5srdHQOe6r8pdEmb+Mes23oTII2ekkz6a0WgNMmssMPB8bpcWyARD65ReaeDjzxxBMDXBv4kn/lMxkYTz/99IiGGJRPev3JEZnYoiyV/qHQ/MIXv7DwoIT9dPKI/KgHoNqn6Fve35TzH5aBURTPBMAEwqzVwGAWza44I4MrXoAPdmVg8FCMh27swcIjsGCPjf2dZv7yaA/awKGBHT1LLOhnhEA/oBMA6rDDDgvHWw8w2eZJH8n9s5/9bOhhWgCu2wZ93jILP7IYgOuWo0PAWj82gNIn3QH/wDD5ierrx7ZrGMye/exnx5Ht0JOBFVhKAJd1pL3pL0AC8AbwAW/uecCJztgvvdGp6Nmxxx4bOgSiyBagMCGh/6232jr2wQH58rMxG+bZgIgeP2VZDXh93eteF+BQG/hJ4O6CCy4Imi9/+ct764sv8lAHQKD/aLsjntgon1UDuOz32b5xj/rwagM4esCHpH36JZ2K4HcBXK3PbHteI3Ngy+TR1hnye9vb3hZ6cZ79UP4sQ87y0om+LlIHzOvrdEnHjvQOcNsOwod40OK/z5kb57bYYvMA78ZCvoBtAe/6P/2hCxwai+wLPerpR/XWl6CGke+nP72t0Loq7IIMbDnib/ixsz5/Vvg6kxX8iA6aZMjDT+UbFdiLpH390rA2kzJxzDLOG4DrJ9UZupYKGwXAJfvK6gSUzBGb/XBIHGICuA0bNizMWsPIHpKl54CbX+gAcAYhztqAahA0A9UxdbL/+I//6FnCeGTpTEcXcHdE2adiWe7d735X73tlSeV3JZ/Ba5vSAUViAAsdiuPGg2ieTvio0hlshteBPK3KWLGURoufSSRtyjQJ2uglzaS32gCO7g2KIrF0LppmeUuEgfMSybC0FXov4igtSJEsHEVs7Jkza956m617JxbAt6FExThNDlzk1WxchMPs0wBu36OjQdNeSwDrJ4WHr371awGq2MCb3/zmnkispVY2yVYssQGAHLrB18CMf45bftFiEwaDtiV95difqJsnJIEKy14cu8kKpwqs4JlTZWvaAyRyvKKOOXAsNHgFTgwyInB0sJYAHHumB4Ac//SibwNj5Me+JEAN+OEbTO7I20BpcPzMZz4T70C07JkALvtHilo9QLlI2nvf+96Ibllae+ELXxiTUHb7pS99KSJo9AiQoUe3dM026dYrLejWoCnaZluHo4nKcccdFwMtPtkUIHjKKacET2wVwAUutNVAzJYNzO9+97tj0DYxEKEBWuXVVgCPHKRum7Jt4xxnAcB1+ee3BwG4bt78Tb/6gDGMjJ2LrAPQfL925mRA3pQl0GVcsYrBhxkf6IEN8DkmaHTJFxmLfK5QmWuuLaCvADIRMT6DjoyBdPuZon/1HfrUQ3snnXxS7weFp3PLXmFtMvE4+qije08ty7HS9f97fQGC54Qd71xszQMbVhzQ+fYll4adiwSzOX6F3Zl0AJl8i2RioE0Z6Y2L1T/Z1upS31M0pFo+zhuA6yuu2bmYClsOgEuFUzIwYfaZgx5nZMlLB+KY1dMdzFxLGpwhAGcWpQPZCO0PMDQzBwqEqncvTs0Mfa+99yoD/N29D3/4wwHwfnX7r8IRAmelsnD+jFvdHPEzysDwzAIodACbTBegxDwPwxr6sJrLtsk/CdroJc2kt5oALoG7iAZHB/RwnAYfg52B2B8AR9jAW/Jdy9AAaQAFiNA49jnP7h1+2OFlkP2z3k+K3kXnflCclyVOgE2eD37ggzFoirhaatu87Cm56647w8mxoTvKIHD88a8NZ7zdPOBie2a3nDF+2Nkll14Sm57Zr9k6W5XHIAI4GvABInZsRg0oeojCu6fcz4iNyKCyQCIQxZlysNqbf3WbJ31OJtptrxaQagM+oDnNNGoEji2TlWVFoAcYFoHiNwy+QLUBS3QugRoA5R1tdMFmLHMrCyj1i8Bpf9opwOfVE/RmIGWXgLk62IJJIhBngDZ5RA+A4kPYg0HZwEm3NuDj/QMf/EAsu4rUsQH59QV9gt96yYtf0jv4SXN7sAzABnF8sGX08faud70r1KTtJr18H7DBJtlb2tFK6HJTAXBkA+TbSiKaxt8DXOSsH9AxvcVEcl6QZK/fWPa3fA38A9UmaWTOtwLuHq5hA2zCq5rYLRv5VbEJAJy/sPftj3/8QyzFnvWFsyKgYKLhIQoyFn1732nvi755ZKHzyle8KujYGnJGsUd9hx970ylv7H31a1/tfbNE7C6+8KJ4FQ8fKprL3tBK32Jck7QNT92xdb6ZfX1u3quPObY4pp923gBcLaUZPE+FLRfAaZIohdB3ALj/PqdEw34XnYGjTABn0ATA0jiUq41GBM4snCPXKThLRwYEEMi7awF0+xVDP/bYY8oDDI+OAf4jH/5IzIhEawy2OuzDC0D7XSlzWwlRAwiM/Yll8D/saYeVGdBRvUdvO/cQQ81DzZfr46ZsGzqToI1e0kx6qwngOI7f/+73vYsuviiWl/DCyQBxBimDmtmsSNzOO+3c22rrrfrKIcu8//3v7137vWt7+5Y9bBzprkWXV5XZr0HPAwzeK2Zv3HXfv673yU98suf9cgDd9uV1JRIbvPvue2KwR/OFLzyu97TiwHffbfcYKEVg/BmMOW8DLMdtqYbzs+FZdM6gybEb6Dlw9bBj4CH2ShYbZqOidwYNzhcfypqNa3faLr7oKvXl90ok/EYErrT/sbvO7YGbdQBHB/YlAmeAMvBjozh7SaBk4ATSDIBkbdnRoGwSpqx7wJKBFSATCekOZGGnxTbscxIJ+dSnPhUPPdi3JoIiGZD5Ccu4IjEAooEz77Nt90X02Rne/Z1TfN0NN94QOvfkLDsw2eQH+VOROds2dnjMDgFUbS/hzyzXy6teExd2iG/7NskBCNeWmDAUcLBSaa0DuOC/2Ih+7XU2GTzQV22/IUNgjA0AxXU/NKbox5b9+QK2p58LGmQCBkX0+BMTB/s6jSWegFf+p6X8L0vf458e8pBeWSG6pXfFlVdEsGH//Q/ova08QWvJne19/BMfDz6f+IQn9k4+6eRe2YDSu7RMXt5/2mlhZyatL3rRC3sXl2vnn3d+76slMmc/rz/gnk2I6pokZjQRn/E074DJsft1m/0elHJsccwyzhuAGySxGbmeChsFwKWyKdo5R6sTfPxjH49OdM9v74klBXtJNpTIBIOTj5OqU9Jx5MgMQhyo/Om8nOuE9pocVGaznKLB0hM7nOdp7zstlu08kcQp71de2LvTTjtGZ9EB/d1y8y0F2JXyBx4Us/XHlc4QL+WcZ0b9abQ1f+OcZ9vQmARt9JJm0ltNAIcX72ryUIlBjUPT2T1YYK+SpQcDMad4dBkMRVWS/1qunDAHC8BZynho0aOlDw5LxIRjBv7eUmazIl+XXHxJ74vlfYEACptgU+zv/sLL5qXsXXf9JpYcjj76qIjkGexF5Oyhsm+OnavPAAz0m3gA/qI4HKVZtQFBRFg0xRIG582RWgoje7aODuAB5BnY0bD0n/YpCsDZdwFF3fZJnSeAAwjwIVpg2WWaqRuB82QoefZLZE+GlqktVdGByJtBdH0BMGRMR/RjyRNY4w8sl5sU+Ezb1ddcHX3boA08AXaiKBERKb6hm4BAERoRFdFWERpLmZK62O4//uM/hl7Za9os+xSdYzvsgYzl9Ufv/JOoDVAG7LtuVeDSssmdfZp4sAXRPTTYrfrVrX2XX3Z5WUb777jHjvk2dNgdMIFG9vdum8b9vRoArvYB2S7X8ry7hPo3f/M30a/ov5v4HT7QkqN9ZvSj/5kEAPSL1cX+RNBtx1C3MuzPQzTJj7EDGOfbgHoP10gAm9UBOr6+7MsGBNHwKpi7ik7vKRMpWy5sy9h2m3UB6s+/8FsR7dcv/+p1f1Ug1x8jevvRj5wRK0oisqJ2t956W++y0p7Pl7HQZIBtispa0rfsr08ZD9ldN9XtzXsp1/w96Jhls+3yOWfP7TUig6Q2A9dTYSMBuLKE4IWWWZZD5sDtgftq2dx59z13x54zAC7AFmMrEbhBHyRHhzO3HMJoDd4GQ2Fle58YLMe8bXF+Im8G2QKLej+84Yexh+R73/9eDK72rjyt7D3Ya8+9er/93W97/1Nm7RcCccV526y79957xVNNBoktCk8lNrJiGtCmTMN2oszf74he0kx60wRw3brxmDzRP2cKrAATNnzTJ8dmwM2BN2l02+c60PfN875ZBuZrFgY9gzOHDvydeNKJveuvuz4iNl74bMA20G1THKSByBKG+gE5y6R0vMMO28cLnr9WIh/25plJm1AkuGFrIjuAmf0tnCPQSa45CGc0hnMld38B/gpQNNlgg2hbItN2A669f0CUc4429dVt96R+q1ckCrgAYqYB4EL3xQ9kVD0BHDngwWCn7+f7vuSb08/9YR+AuQEwouNFtgZcYJsu5KMrS5teTUJHZLi+6JRMlWEXomL+RD2BHREzwKd+8j1lLNIHwImcercYAAdYaUcAmQKe/uEf/iH0aCKIzmN2eEzv1ttujReMs2m2wTexH3yKlPgyhEiP1yYBD/ikC5MPZVxXj8mpuvi1E044IWixoztuvyMmovwvO2KT+hKAZ/IDVPB9XRtCq5u6ebr3u79nDcDhhy17eS5gzwYSwBkDop8Xm/OfRFa5lG7SZayw15mMgR4p7LTIik3lb3JKACfqSg/07S9tQr+1vC+wIK/ldnoDqK4sQNzDVWxeRIztsQ3978ay+nB9eThKhBWA89ojKwM/vPGHvdPLdpDfFL/hFViFsd4N5eEV/UAEWZ8FHr0P7vYiA3sr2YT+5E+97J/d8lPap22j6jyE0OeftKeapvMG4PoIa5YupcKGBXDy1386FSUzZoM2J2nGYt9QLlP4/Ajwxthqg0NHckwAZ8+LNX+dyaZSM1adKaIZaMx3xD+Ujmzp4b3vfU9ZQr02Pm8ibC4Uvc9e5QXAJQpoRmYWdWHZT4DHPffcoziEdyw4+Hj6dIWUkW1Dvm7zcqtLmdf0pgngunxzKCIG9mRoHydIT+yADk8rSwMcD2dqEAO2BiXlRSfMoj931ucj4mUPFCcuomRJ5HnPe35xeD8MAGfjsRmzWWl87qjYRMi74HH26F2BnLkZMQf/sTM+GnwBFiYVnB97EFkRRTNgZgROvRw2Z8uBA3AAGSCqDryqQ9sDyJUZt5k8/v0ZtPFmMgFIGHgmof9BsnO9BnDABLkkSF2s3Dj30h6zbWRmOUqfpLPjjz8+ABUAB7xJ5GZ5nVzPPffckIvIJvmuL4OT5Sav9kGTDwHOAB9PC7O3jDy4z86025K9pSWy5jdEMroADq9siW/y0IOnAfkmkTN0Dbzq8i46oMCyJ717t6RyJgy/Ky+M9gTgro/bdQFEWo7NBxZE2gzy/JRleXYl6mZg5sPYtr6Q9qTfkIcoNlu0h9eALtrBZvGh37DXBK1kGHbupE9KXfS51fdS2HGZ2NLdtN4DV/PvvObZb8CcjsidDQBwbIRvkeTR7+hdfxO1Z1OAF/mb2CV4A9pq+lneETg0wQTg1AlwGT9MIiT9W3SdjulHRO21r31tyOobBZx/9GMfDTtXTr2AHJ1deum3y7hzRdiiiYJvcheme3f8+o7e/y3RPv7BhEMAgt396le/jCV9NNi3laFoY6kff/oTe4jVidKenBzqL/JJ3TbGxRH/SVqOSc+5trcI3IjCnGb2VNgwAE5ef5k4P47UEggnYOYJMBkQjy6zDCBMhzCYiIowjPxDI2k5mumIwHFiHsNmqPZCGVAz/bGUz5SDgffAXXX1VXH5Wcc8qzzh89TY9/TLX/4iZvgM3wMQOge6b3rTm6PjKRAdvBz/RDXITOSfbBti2SHGIYxe0kx6qwXgyJ7z4UTNPOsIgYHQgOszWyIoIgjHveC4GLxyIO/KQXuUu7DoipPbaqtHhW5cA+INyqKxP/vZz4sjuzCiMqIdTy9A5WmHPi10yyrtTeFwysJ+obF1DPBeNv2B094fg6gy9lGxRbyxVVE+A4VXURjQcyZt6cRAbMBVP0ct0QHnTvZsStslg4iIkqVXgDNfLSFanPqKjBP8J+3BAKTvWZIDUqcF4NgBH4AP/d8TleSAB3LeUKKdEhllHqBG1AF4xifZkjFa84GVAEHyi6KLvhnIyJwc/em3op+W603SLHHbP2agF60FmDKh448PAKroFXgT8TPYo4s+fuy3ZAv5FKq2kauBHCj9+//z9+U9X1sGgNBe+6OACIChjsDhjd8RxeX7gDURFQ8piKCsL4Mv2vyk+nK7iLZZDhQtZJf5NRvRuAQwAF9GPbONeRzVzsh8tV4jQidkkDqlB8lYArQDDWQDBInk0rn+5gh8uW9PIWAMsLOjeMuAh5RKQlt+sie7tIO8BwTqw7ZusA16snXDJEDKfXUeDkIDEAfg2IqJwCfO/GTYrzEOuPPmg2uuubZE5r5Ylvz/X/gLLyF+ZAleqB8/pxd7uODCCwLobbbZ3OtHHlcmBPqKsUnCl/HIq7dMBsiAHzy9TCjZkJUAEwlROG1K+UXhMf5BS0qaed4AXIhldv9JhS0F4HR2eXUg5xyYyIPZNEfKGYm8MHz5OB2OTSfiLHN/QTqiNJA8isCZeZlxmKkeXQAgACeSko6JiSV8ZFgiPGec8ZHyfrjrY9lWfd7k/8iyX8JgxvD9OTcARycv30M1o0XnoSUyMPcfLiabyCBT8p+/l3NEL2kmvWkAOLr2x5monyNSr4HLchTnKerDAXKsXn9gz9INBYibaRqEbNw1Q+4H4JKmOpQ7vTw8wEkCiGU8i2ULtiDKwpnZy/ahD30o7ns4gm1ZerAHUkRGWYABsHvElo+IZYgPf+j04BkPIsPawlYBCYMtW/WOJwDOTBogAkANEsAF580m2T4egBSvPjG5MLA7sltgA+gzSHtFhaUV9p/6Wo7eFyuT9oDf/BTVNCJwbED/19cNKs71MVG1XMrK5SiDn3eZkQEfY3kMWGIrorJAnn4bwKTksTS5x557hE3ppwZ0viUTOtptkkB/lt5PLK8VoSP6BZjVWSf52QbAbsJHX+sLiLKniD5FTvDEZtUp6sVXoGMpFOgEdJ7/gudHHfgRFdEHtB0tT6Gi5x5btnFdFFq9ruFB5I9t8GnkpA2AHsDrD5BDkx3hxcCOl1yF0Hayd2SL3eT6KAmfqwngyAQPZAiIOyZgYCt8ADCtj+mXwBUZkZ2JEl/AFwHu/BD969vk4EimruuHkvr8AUmO6tJvAHT9lw2ZALAh+hUt09fZAXvwEIP65iJwHyvL6Y8tdf952PGdd/46lsAvuujisO1DD31qvBbES3s9pXr/fffGK0MATmPmvWWpdK+99oz2eeXILrvsXL7nel+AUnu2Lb3iXzLO+kQY3bMfEx/t0gZtHVXvQbTzD1pS0szz1Ef7lFaIZ/b+SYWNAuCUMWgwcjNFnY9xZcdgUIBagj0zBstKOhIHnQZXGw3HbqmCseqQOpPBlrNdyM/A5kXIKepcZ5aZkPfp/Or2O4rxldlp/De3XKN+A6jBX/TFTGmPDXvENS/ybQBuaXukI7rNAYPDFXUVKbCUCSxxeKJa9G/ANSACdJYdOeAA1SJR80tpda3oo4k+J/qFs79YHOol4aR33nmnmBUDUTGLLstxP/7xj8qj9l+LgY4z5dzXrZvbF8WJcjiusTk8+OTbl8sADBwCGWaunLt8bNhGdPnsbzHTF4FD11PR7Frd/gweyhlU9BVLK0CItrNRA7W/++8rTrZEgo8uoNN1fKf91u2exHn2n2kDOPqiYwDEUpcBVQQFeCcTA56+DqiQJxvQ74EaAybQJw+Ab2Am17Qx9iQyBjCL3mtj9OliO+rNJGpybgGMomb2GvEX+nnKpJa5awm6+Bh+g60C7mj6Uz/wj2d+Aj1gThtNVEwWY4JYbEUSwWUn7BZwMFEBVMlB29iyFQWAXqQasD7htSf0jjjyiLhPZmwSbT6KHMgID+wUaDNYi+aSSTx0VfAZXtVZty9l0u9a3ut3RGs1AFzqCE/0QBbsgk35zY7IjM7sa6QH8tCn6Fj+00tESj/UZvLnfzI4kDIyjgDV+TJk9fqja+UcgWUgGohDI22WbtkyfvR5NmlfJ/16V9tZxY70u0eUZfYdd9ypXC8PMBQA6hr9qffEMrHgmx5e9Gp14Jprro4osKievboHHXRg0Ny92PnWxVfg57Of/VzvqmIXvy11a6ukveTBr3nfYEaZc3vCqHoPop1/UieOSc95A3AdQc3az1TYUgBOvsyrDQZqm27NKMxeGR/HUv9lJzFj4BR1NM4oOxp6kqMZhiUODsxACnAZOHWqTHIngPMS3tvK4Ht2GfB9oeHnJdKm4zLqQjCcpAFUnYCEmZJBxby1pmPOOtq8NbkZfMx2ZY7sEPl7OUc0k27S42Q4HyH9/PZk5lFH5uvWN+h6N1/9O+tX1rkIgegEEE9nIhl0688sme5EWHIjO1r9AFxcLzQlg+IV/3NlDMqcuMHrRS98UW//or/7S532LP6+vKLml7/8VYm+nF8+sXV5DJRsoTQ2+KJj9cbeoTIY27uUg73oBj7xZ0DlZPHvGsC3YcOGhSVU0WD7m0SO7U/JV0okULF8A+CJ5Hk3nMF3u+236x14wIFRZp99J7vEEQLq/JO6njaAwwaAArxln9Xv6Z598AUSYAIciyQBKCL1omYGJPIyOOqzWcaRbmyfsCRqoMo2ukf2EsAHeItkWOL0BChbMeBl3fJItd3qL+yWz6J3gyIADijSMbCmDvX6djIbsY/y3AIUTViUxS+f5F76Ov7MZNPylvrwKvIvQmRiCrDyZzbYsw/Jg143/PCG3jlfnfsSA5moW/vXr18fE14ABMjMNiiHdv6lbFyXXB8lactqADg8Ju9sgP+wHJ3AWp8t3i7kq010CcR5UtlDJIASvYuea4P+i558joCf64CbSLAl9qyvrtu5yajxy1PK+jvwRb9sgD3RLVunC3asDk+gXlH6vojuj8o99a/bdl0ALLozloqQeV/p1sXu46syha/byz7Hb3zjm7Fsq28YE1//+pOjPnm0lU17CvXKYjvops2rX34PtrA77RG1zr3l2jJOSvk4ph05bwBuHKlOoWwqbBgAh53Mr+Mxdk5Qh3Jdovw0gLhQ/uHEzWzMTHUIBthNHBinx2ByJpRLB3XeBHCuycuR+y6rThv3Kj7UZVARBTCA2I+QKemM5vKydP9jyqD/3fGuop30U74J4LwPKwEcxyVl1KJfrVm+ey/p5/U6X9KlO+d0T1+57KGseyIFnByd+1YkXSbdml7W4ZjXzcDtI+OcOa+XlqjGwWUgN/MsxAuAK3tbSoTLzFi0644yiXAeNOYIxfI54L7DDo8p9ja39wSPeOWs8Y4/DtSg4KkwT1QbKA3mbAYIwItybJDtuodP5dkdejlL9344swD2LS+6sXm5XMu25TGYndA/KddhAVzmH7d6bSF37c8+61r266zHbzIBdsiczeSSYtpR8pJl5DNwpszzunzO1eOPDrRb/0c//Qv9sP184l0Z1+jIK29EU/gsvPAZ6gOawhbKNXkzqspGlE9d+wYvYGF/kgcckhdtsYzPz0iuAyWiOiJL6rRH7uCDDg5bVgeb87oJk5b0X+wOP+oX7UOP/5JSDllnXBzzH3ysFoDLNmkzXZqwJRBLEC6P9krsKAMAxh56l1/K/JlXu8iLH+CH9OGUXxSo/kFLP2eXjn7zAXSgTjTZuvGDnRlk7in1eihBmXuKbu8v9fE1MXkt5e4pL9RW3grCFsVWCpF4OEd/AeBOKy/1BfAOP9xLfV9R7Kks+xYbksKvFbuWN9vhuvrZKDtb6GclWJH7IbPt8i4npXwck5ZzurGVpC2hLkeqUyiTChsVwI3KmnoYJONLAxmWxqD8nGkCsaVocQMc+0ombVyphHZEF0sFGcnSyTMC51H0fffZN2SMBzLLfF2eBsqzD/+Zl+6kHHiDHzzNl8l8IeMRgYuy6IuUWVIC4gzI9qWJqHHE0JsIHBlw2FkvnhbqpN/4f+7IOMJGSpn4r/Cqrn75h5GVslnvwrk6yEFlyUuc/UlPcb2UnXRKXqYN4Aa1I/kZdH/c62S+VEoeFgY5ujHQKbt08QXySWfhgpNu90ayw5PfQIAlV+BN1BeA8JCMiUhOaLIc3vKVTOpcsM1CR55sR/KR5fL3OEd9brUBnDb7y3ZqX1/Zj9HQSdKkr/hvnu+N2KKz4qfiv9Afk5trjyVUr7s699xvlKjsp+ObqE8v++qOKqtTdQo/O++3FuwtTPdP9qs9YQclXxz72GFNc5jzlLlj0CyFnDcAN4z0VjFPKmxYALeKrEbVC8YV3Wh4boqNzznH4YuMnDM7wcgFhyiANuchJdiYBoDrx1rdzjxPvXTzD7pe55NHNMRMLx/rtwfq7W9/ewA5L22OPYslX4C4IguObmFgrok5n3dowdv8oMvp+n8QPynTB5AqdfZLNZ2UQTdfnad7bxK/s94G4CYhzcnRELFJW6YjS3n26YnK1Mm9/GObgBybqf/kXyk7Wm0AV8siz9Om8/ckjuQ3Kbo1nTif9y/BJ/CWAK7DuEnn58rKwtfLcvyVV15R9r6dGA9GbCiRuDrVNOOcL+PQpHm/NvdjY7sY10ayXY5Jy3kDcCntGT2mwtYKgFsQYzHmuu8sXB9wogssdIQBeca9nJ1gXDr9yqM9CwBuks4w24kmMGpPlafLLJXYA2Vfkb1SnGLEJjgwXmx+4Ivy/YyAsjPN3w8AV66lc0rjSWAX2ety8+UX8ie9eRr9rldZNjod1i5GoamCpNsA3EbiXvUflmgBOPu67AG1j/Loo48OW+4ylzrMY9j3vB2Oag9d2kv9frAAuKXkMOx9+kg9DSwDgHduerr0N2WpVUTWQxO/Lsuvr3zlq8qXgQ7sbTO/7K7IIPrD2MEweTpsbfQz2+WYtJw3ALeRmGbvRypsrQG4GJe7PWUR8cr6wK61SIFl3MpOsIyiSxZBe1YA3JLMlgzDyiKdhf1pNgtbPrXUtGHDhthInHXZ0xQByHkH00/1g+rMOpJWHiN/MaSNQFzenD8Oiszlkk8ne9+fg/jqZh7EZzdf/k66DcClRGbjyJZvKA882BhvM7zX09gKYH/boJS6HNUGBtEb5noDcMNI6U95lqsbAM5DKx56sjdSesqTnxJ+zvvjMvWj372WdpJl8tjNl9eHPSZdx6TlvAvgTKptA8iUefP3pnB8SGl4v7jATLYtFdYA3HjqWWmVo78YgPMQw+P3ffzE98B1pTJshx1GHjWtXBK1jGSgcw+N3KBsQ/F95S39rm1WNqS7X5fHZ8ioT9cbBLbq/CnbjdpbUGK3jrw/iGbe7x7VtVQaVNegckmzAbhBEpr+9dQhu/UEIVv2N6q9TIPzAHCFx7vunPsSg6dAfVfWAz2Lgc2V5C1teiXrWC7t1O2o5fk0e+AicQPFr8SDC+Wkbi/6o9aR5Uct121D0nFMWs4BOE9Tv/Od74ynvQE4D1Rkyrz5e1M4rmkA56kd78ry3huDpkRJqeBNQUFrsQ3knyAjo0L1HriTTjyp9/g/f3zoyuPlnETXCa8FHeKxdgrRFjZYllEz1ffz2rjHQbJZiboG8TpqXckzAOdls56s9G41r06wcX7aKfmZdr0zVd88ThfVTXnQ62IALvIlvl9k0rAS7fTAhVdCeTG1By+86yyfGl6J+h6MNOdsQcvZRPm37N/lm9lF2oi7o/Z/ZSaZurz4nRE4AM5rVAA4T0evNq+TbHeX1poGcB5VBuC8x2tTAnC1cXYVNqnfK2nU+F8UwJ1UAFyJwHEWEl66g0YtgzjPQSMKrL4DCcY7/4gSaFLIdsqDW4eVqfwc1oboj2zkB+Q9vet1FfYP6rv9ANywtMdpaG1j49BZq2Wz/bFdo9hr9rN8rYl2ZZ6FNhrUq367cL066eruATSqvMOeoilSCMB95StfCQDnc1JsyKs0Wpq8BOit+/621GVXx5OvfWmKeEk+nCeA8xoRL6vOCFx3bFma8trJsaYBnPAoAOcTRTaQZ0ojy99r8bjSbUjDXwnZ4L0fgPOuKS/y9ZmX/Dg34K2Dddtb/47zGQJwKbuaR3KsAVzk+VMgbiXEvKo0UwbDMEFOCeAMwN7uDsDZP+grAiLp3TQK/W7ZYX53dTdMmU0tTy0D8s4+uxiA65bpJ5Nad3X+fnlHuQbA2bN3bnk60hKq99Wt5hLqKLyvxbx0t9YAXC6hAnBeJCwC1wDcjFgfg+Icunvg6gjcjLA6FhuTdHqDGKmd7KA8y72O/xwMYmAoM3YDt43SPmdm6cPbur2w1HdB+/EyDRkst33Jb5fH/J33l0t/LZQbpY0pF+2q98CJnph89QNwa0EGa5nHWifaQZ8xASnniw14/cpNQw78yb33lT1w5QW2AJwvRhx//PHxEuFRbHEavG4qddC1P/JdCzLO1zv98z//c0TgGoCbMUtMY0oAx6jsgfAah4zi9Fuvn7FmDMVO11EOVWjITNPojN3BwNKZJ5s8uZmfgvKW+NBXtWesXxP6yWIabejHy2LXaj5nkb/FeF/peykbERSfNfNmem9q13fj5ccrzUCj/wAJpE7cYK/5ezHbzTxZ5gFEV+pCicDn1yn4EF8f8d1a22hWK9WyWC0eJllvV+/a5697fVCd3Xz95NPNM4jWUteTdtLzG4DzycwzzzwzorNtCXUpKU7pfldZAJzv9vmYPAV6f5ENrvL51IzULTMlVidSTfI+EWIDiKThD7g91mX8ZxsAa3WJvPgWp28Cir6Jurhn/0rmqSvN8q7V55lnJfnPOkY9JmhN3vI4Kp21kH+UttFfygZw8x1Pvw2+u+yyy8InmLrtHqWObtmlfvezqaXKbEr3u+0nazpx1B+lbp5+1wbpKK/3oxHER/wHT2ixH19B4U+8QDv9/Yjkxs4+qXaNzcgECaTOHNmCNjrW/jnbnXm71dfXM+9iebr3hvmddB3TVvEJwPmUHP9ywgknxBKq14jUPA1Dfy3lWRN74FJhqQggwCzet9jsi7AXLvOkseVvZWKT7prSyhSYrfeUrUR18/u/Umc2mHrrOwdMX/a+uZf6ShZCW+V6gYBzepvBfWTZprSx5J0TkbINnq7dVFPKYKn2kVH9p796AlWyb9UAnFHzpWhN8n5Xd5OknbSGlVHmn+ax2368pv1mn+zmwV/32qA25vVu/nHaiD8TdfbjtSfrtln3gKfXx6E/alk+alNKdFbrjbz9pT1oa+oz89Xtj3G28nmZd7E89b1Rz9GPOktBurBfD4i78647Y2vGAQccEN+R7sfrqHXNav41AeAIj7JCYcXILMOYhQEDBgRpkJJcTyVHxrXwT+kEg9ozCfajY62k76k6cfKb+svf3aP2pn4X9LXCcujyMO5vzm6hDZUzHJfumi5f7Cx0z8WWPiylbUffXEROmX+l2r9S9LN9K8X3JOmSQfKb8jBg1ymv57X8neXyeh671zN/3h/lmLTQqP9gpy6fo9BteftIoPK3KesFADc/GwWUpAUfXZPplJ/PWudQcMHeNr4x2q+wqTlWNiqIP/d2L5/98pqiTf0J5TUF4My+zNZ13DCwsrHVfzp5dvSNtFl+DLrezdd+T1YC0cHmSQ6rg7pMcjNs2cy/msewyfkBcS3xvZoyG1R3P1sYlHc511ea/lrQfy0D/OaDR7P2FGpXlsl39/py7KCVWVwCZN3kvLiMVvPuzAO47KyElMYUzqYYVp2akdXSmI3zBd0VVeXMqOYsZnHVjGxT0GHaaN3Odj57EliwzRVibS3Yci2D2qcuxnu3zAqJry9ZdQOZcSwepV7a61ugXRxZAqn7kHGR90IErgB8KfWf+UauYAULBG/zsMDL1GeRx0k3f00BuFRIGtcwwkiQMEzelmd8CaSOUMrOnuddvaVu8tiv9ppev/uzdK1u72JtmiWep8XLrOmx1tVKyGDW2tuvjbUM8Ju/F+M98yS9xfJmnkkcs14AzueeCn7riRROq/5JtGEt0Eh5kjfw5m+zh5ZXPc2/KSD1kPlmqU3BWwNws6SSjUEAo6Ekf/a+pTHheJBBuR6D6Ww1a1Fuoi1zE55F8y37pohYkeGkUnZu9FIPeazrSN1F3VX1/aJzQYvm5md+NZ3VPk+eujI0sLjmfvzZ8LGJplrnwzQxZdbNO+h6V7bdcuP+Xmn6g9o1Lt+TLF/LAL+zuoSqzSlPPC/waa/eptvFJqnqZdEi61l+kW+3UV177t7fFH/PfASO0FMx4WTmgUdeW0op2fGXytfuT0YCKe9h9RO1ApSm1Gsk5YSgH8/anTJYI81ZFpsr3caVpj+SfS5LQmuwUHbBAooGyb+W26A8K93y5GG16l/p9s0S/QeLP5slmY/Cy5oFcBq5qXbgdFCjKHLUvCstu35tWKzOfvlHbVPLv+lIYDFbmUQrm70tLsWVlv/itbe7TQJNAsNIYE0BuG6DNlUnM43BZVOVXddG2u8mgSaBJoEmgSaBTVECDcDNoFYbgJtBpTSWmgSaBJoEmgSaBGZIAg3AzZAykpUG4FIS7dgk0CTQJNAk0CTQJNBPAg3A9ZPKKl9rAG6VFdCqbxJoEmgSaBJoEphxCawJADfjMmzsNQk0CTQJNAk0CTQJNAlMVQINwE1V3K2yJoEmgSaBJoEmgSaBJoHxJdAA3PgybBSaBJoEmgSaBJoEmgSaBKYqgQbgpiruVlmTQJNAk0CTQJNAk0CTwPgSaABufBk2Ck0CTQJNAk0CTQJNAk0CU5VAA3BTFXerrEmgSaBJoEmgSaBJoElgfAk0ADe+DBuFJoEmgSaBJoEmgSaBJoGpSqABuKmKu1XWJNAk0CTQJNAk0CTQJDC+BBqAG1+GjUKTQJNAk0CTQJNAk0CTwFQl0ADcVMXdKmsSaBJoEmgSaBJoEmgSGF8CDcCNL8NGoUmgSaBJoEmgSaBJoElgqhJoAG6q4m6VNQk0CTQJNAk0CTQJNAmML4EG4MaXYaPQJNAk0CTQJNAk0CTQJDBVCTQAN1Vxt8qaBJoEmgSaBJoEmgSaBMaXQANw48uwUWgSaBJoEmgSaBJoEmgSmKoEGoCbqrhbZU0CTQJNAk0CTQJNAk0C40ugAbjxZdgoNAk0CTQJNAk0CTQJNAlMVQINwE1V3K2yJoEmgSaBJoEmgSaBJoHxJdAA3PgybBSaBJoEmgSaBJoEmgSaBKYqgQbgpiruVlmTQJNAk0CTQJNAk0CTwPgSaABufBk2Ck0CTQJNAk0CTQJNAk0CU5VAA3BTFXerrEmgSaBJoEmgSaBJoElgfAk0ADe+DBuFJoEmgSaBJoEmgSaBJoGpSqABuKmKu1XWJNAk0CTQJNAk0CTQJDC+BBqAG1+GjUKTQJNAk0CTQJNAk0CTwFQl0ADcVMXdKmsSaBJoEmgSaBJoEmgSGF8CDcCNL8NGoUmgSaBJoEmgSaBJoElgqhJoAG6q4m6VNQk0CTQJNAk0CTQJNAmML4EG4MaXYaPQJNAk0CTQJNAk0CTQJDBVCTQAN1Vxt8qaBJoEmgSaBJoEmgSaBMaXQANw48uwUWgSaBJoEmgSaBJoEmgSmKoEGoCbqrhbZU0CTQJNAk0CTQJNAk0C40ugAbjxZdgoNAk0CTQJNAk0CTQJNAlMVQINwE1V3K2yJoEmgSaBJoEmgSaBJoHxJdAA3PgybBSaBJoEmgSaBJoEmgSaBKYqgQbgpiruVlmTQJNAk0CTQJNAk0CTwPgS+P9qS6EwmjLaPgAAAABJRU5ErkJggg==" alt="Time to Transfer" /></p>
<ul>
<li>
<p>각 데이터 크기 별 전송에 걸리는 시간</p>
</li>
<li>
<p>온라인 데이터 전송에서의 문제점</p>
<ul>
<li>제한된 연결성</li>
<li>제한된 대역폭(bandwidth)</li>
<li>높은 네트워크 비용</li>
<li>공유되는 대역폭(회선을 최대화 할 수 없음)</li>
<li>연결 안정성</li>
</ul>
</li>
<li>
<p>AWS Snow Family: <strong>데이터 마이그레이션을 수행하기 위한 오프라인 디바이스</strong></p>
<ul>
<li>만약, 네트워크를 통한 데이터 전송에 1주 이상 걸린다면, Snowball 디바이스를 사용하자!</li>
</ul>
</li>
</ul>
<h3 id="snow-family---snowball-edge"><a class="header" href="#snow-family---snowball-edge">Snow Family - Snowball Edge</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/snowball/latest/developer-guide/images/Snowball-Edge-Image.png" alt="Snowball Edge" /></p>
<ul>
<li>물리적인 데이터 전송 솔루션: AWS에서의 TB, PB 단위의 데이터를 안팎으로 이동</li>
<li>네트워크를 통한 데이터 이동(+ 네트워크 요금 지불)에 대한 대안</li>
<li>각 데이터 전송 작업에 대해 요금 지불</li>
<li>블록 스토리지와 S3 호환 가능한 오브젝트 스토리지를 제공</li>
<li><strong>Snowball Edge Storage Optimized</strong>
<ul>
<li><strong>80TB HDD</strong> 저장소로, 블록 볼륨과 S3 호환 가능한 오브젝트 스토리지</li>
</ul>
</li>
<li><strong>Snowball Edge Compute Optimized</strong>
<ul>
<li><strong>42TB HDD 또는 28TB NVMe</strong> 저장소로, 블록 볼륨과 S3 호환 가능한 오브젝트 스토리지</li>
</ul>
</li>
<li>사례: 큰 데이터에 대한 클라우드 마이그레이션, 데이터센터(DC) 폐기, 장애 복구</li>
</ul>
<h3 id="snow-family---aws-snowcone--snowcone-ssd"><a class="header" href="#snow-family---aws-snowcone--snowcone-ssd">Snow Family - AWS Snowcone &amp; Snowcone SSD</a></h3>
<p><img src="https://mms.businesswire.com/media/20200617005657/en/799138/4/4440824_AWS_Snowcone_E_Ink_Label.jpg" alt="Snowcone" /></p>
<ul>
<li><strong>견고하고 안전한, 열악한 환경도 견뎌낼 수 있는 작고 휴대 가능한 컴퓨터</strong></li>
<li>가벼움 (4.5파운드, 2.1kg)</li>
<li><strong>Snowcone</strong> - 8TB HDD 저장소</li>
<li><strong>Snowcone SSD</strong> - 14TB SSD 저장소</li>
<li>Snowball을 쓰기 적합하지 않은 경우라면 Snowcone을 사용 (공간 제약적인 환경)</li>
<li>자체적인 배터리 / 케이블을 준비해야함</li>
<li>오프라인으로 AWS에 재전송할 수 있고, 데이터 전송을 위해 인터넷에 연결하여 <strong>AWS DataSync</strong>를 사용할 수도 있음</li>
</ul>
<h3 id="snow-family---aws-snowmobile"><a class="header" href="#snow-family---aws-snowmobile">Snow Family - AWS Snowmobile</a></h3>
<p><img src="https://d0.awsstatic.com/recap-page/Photo_AWS_Snowmobile_1024.jpg" alt="Snowmobile" /></p>
<ul>
<li>EB(엑사바이트) 단위의 데이터를 전송 (1EB = 1,000PB = 1,000,000TBs)</li>
<li>각 Snowmobile은 100PB의 용량을 가짐 (병렬로 여러개 사용)</li>
<li>높은 보안: 온도 관리, GPS, 24/7 비디오 감시</li>
<li><strong>10PB 이상의 데이터 전송이 필요할때 Snowball보다 유용</strong></li>
</ul>
<h3 id="snow-family---usage-process"><a class="header" href="#snow-family---usage-process">Snow Family - Usage Process</a></h3>
<ol>
<li>AWS 콘솔로부터 Snowball 기기 배송을 요청</li>
<li>서버에서 Snowball 클라이언트 / AWS OpsHub를 설치</li>
<li>Snowball을 서버에 연결하고 클라이언트를 사용하여 파일을 복사</li>
<li>완료된 이후에는 기기를 반납 (적절한 AWS 시설로 배송)</li>
<li>S3 버킷으로 데이터가 로드</li>
<li>Snowball은 완전히 지워짐.</li>
</ol>
<h3 id="snow-family---what-is-edge-computing"><a class="header" href="#snow-family---what-is-edge-computing">Snow Family - What is Edge Computing?</a></h3>
<ul>
<li><strong>엣지 로케이션</strong>에서 생성되는 데이터를 처리
<ul>
<li>엣지 로케이션: 클라우드 환경으로부터 멀리 떨어지거나, 인터넷 환경이 갖추어지지 않은 어디든</li>
</ul>
</li>
<li>이러한 로케이션들은 다음과 같은 문제로 제약을 가짐
<ul>
<li>인터넷 액세스가 존재하지 않거나</li>
<li>컴퓨팅 파워(computing power)에 액세스하기 쉽지 않음</li>
</ul>
</li>
<li>엣지 컴퓨팅을 수행하기 위해 <strong>Snowball Edge / Snowcone</strong> 디바이스를 설치</li>
<li>엣지 컴퓨팅 사례:
<ul>
<li>데이터 전처리</li>
<li>엣지에서의 머신러닝</li>
<li>미디어 스트림 트랜스코딩</li>
</ul>
</li>
<li>결국 (필요한 경우) AWS에 디바이스를 반송할 수 있음 (ex. 데이터 전송 목적)</li>
</ul>
<h3 id="snow-family---edge-computing"><a class="header" href="#snow-family---edge-computing">Snow Family - Edge Computing</a></h3>
<ul>
<li><strong>Snowcone &amp; Snowcone SSD (smaller)</strong>
<ul>
<li>2 CPUs, 4GB 메모리, 유선 또는 무선 액세스</li>
<li>코드를 통한 USB-C 파워 또는 배터리 옵션</li>
</ul>
</li>
<li><strong>Snowball Edge - Compute Optimized</strong>
<ul>
<li><em>104 vCPUs, 416GB 램</em></li>
<li><em>GPU 옵션</em> (비디오 프로세싱 또는 머신 러닝에 유용)</li>
<li><em>28TB NVMe 또는 42TB HDD usable storage</em></li>
</ul>
</li>
<li><strong>Snowball Edge - Storage Optimized</strong>
<ul>
<li><em>최대 40 vCPUs, 80GB 램, 80TB 저장소</em></li>
<li>객체 스토리지 클러스터링 이용 가능</li>
</ul>
</li>
<li>All: EC2 인스턴스 &amp; AWS 람다 함수 실행 가능 (AWS IoT Greengrass 사용)</li>
<li>장기 배포 옵션: 1-3년 할인된 가격</li>
</ul>
<h3 id="snow-family---aws-opshub"><a class="header" href="#snow-family---aws-opshub">Snow Family - AWS OpsHub</a></h3>
<p><img src="https://media.amazonwebservices.com/blog/2020/oh_dash_1.png" alt="AWS OpsHub" /></p>
<ul>
<li>역사적으로, Snow Family 디바이스들을 사용하기 위해서는 CLI를 다루어야 했음</li>
<li>오늘날에는, <strong>AWS OpsHub</strong>(컴퓨터/랩탑에 설치하는 소프트웨어)로 Snow Family 디바이스를 관리할 수 있음
<ul>
<li>단일 또는 클러스터링된 디바이스들을 잠금해제 및 설정</li>
<li>Snow Family 디바이스들에서 인스턴스들을 실행하거나 관리</li>
<li>디바이스 지표(metrics)를 모니터링 (스토리지 용량, 디바이스 내 활성된 인스턴스)</li>
<li>디바이스에서 호환가능한 AWS 서비스 실행 (ex. EC2 인스턴스, AWS DataSync, Network File System(NFS))</li>
</ul>
</li>
</ul>
<h3 id="snow-family---snowball-into-glacier"><a class="header" href="#snow-family---snowball-into-glacier">Snow Family - Snowball into Glacier</a></h3>
<ul>
<li><strong>Snowball 그 자체만으로는 Glacier에 직접 임포트할 수 없음</strong></li>
<li>반드시 S3를 먼저 사용하고, S3 라이프사이클 정책을 조합해야함</li>
</ul>
<h2 id="amazon-fsx"><a class="header" href="#amazon-fsx">Amazon FSx</a></h2>
<h3 id="amazon-fsx---overview"><a class="header" href="#amazon-fsx---overview">Amazon FSx - Overview</a></h3>
<ul>
<li><strong>AWS에서 높은 성능의 써드파티 파일 시스템을 실행</strong></li>
<li>완전 관리형 서비스
<ul>
<li>FSx for Lustre</li>
<li>FSx for Windows File Server</li>
<li>FSx for NetApp ONTAP</li>
<li>FSx for OpenZFS</li>
</ul>
</li>
</ul>
<h3 id="amazon-fsx---for-windows-file-server"><a class="header" href="#amazon-fsx---for-windows-file-server">Amazon FSx - for Windows (File Server)</a></h3>
<ul>
<li><strong>FSx for Windows</strong>는 완전관리형 Windows 파일 시스템 공유 드라이브</li>
<li>SMB 프로토콜 &amp; Windows NTFS 지원</li>
<li>Microsoft Active Directory Integration, ACLs(접근 제어 목록), user quotas</li>
<li><strong>리눅스 EC2 인스턴스에 마운트</strong></li>
<li>**Microsoft의 Distrubted File System (DFS) 네임스페이스 지원 (여러 FS 간에 파일들을 그룹화)</li>
<li>최대 10GB/s, 수백만의 IOPS, 100PB 규모의 데이터까지 확장</li>
<li>스토리지 옵션
<ul>
<li><strong>SSD</strong> - 레이턴시 중점의 워크로드 (데이터베이스, 미디어 프로세싱, 데이터 분석, ...)</li>
<li><strong>HDD</strong> - 넓은 스펙트럼의 워크로드 (홈 디렉토리, CMS, ...)</li>
</ul>
</li>
<li>온-프리미스 인프라에 액세스 가능 (VPN or Direct Connect)</li>
<li>Multi-AZ로 설정 가능 (High availability)</li>
<li>매일 S3로 데이터 백업 - 재해 복구</li>
</ul>
<h3 id="amazon-fsx---for-lustre"><a class="header" href="#amazon-fsx---for-lustre">Amazon FSx - for Lustre</a></h3>
<ul>
<li>Lustre는 병렬 분산형 파일 시스템의 한 종류로, 대규모 컴퓨팅에 사용됨</li>
<li>Lustre = linux + cluster</li>
<li>머신러닝, <strong>고성능 컴퓨팅 (HPC - High Performance Computing)</strong></li>
<li>비디오 프로세싱, 재무 모델링(Financial Modeling), 전자 설계 자동화(Electronic Design Automation)</li>
<li>최대 100GB/s, 수백만의 IOPS, ms 미만의 레이턴시</li>
<li>스토리지 옵션
<ul>
<li><strong>SSD</strong> - 낮은 레이턴시, IOPS 중점의 워크로드, 작고 무작위성인 파일 작업</li>
<li><strong>HDD</strong> -  처리량에 집중적인(throughput-intensive) 워크로드, 크고 순차적인 파일 작업</li>
</ul>
</li>
<li><strong>S3와의 원활한 통합</strong>
<ul>
<li>파일 시스템으로서 S3를 읽을 수 있음 (FSx를 통해서)</li>
<li>컴퓨팅 결과를 S3에 다시 작성할 수 있음 (FSx를 통해서)</li>
</ul>
</li>
<li>온-프리미스 서버로부터 사용될 수 있음 (VPN or Direct Connect)</li>
</ul>
<h3 id="amazon-fsx---file-system-deployment-options"><a class="header" href="#amazon-fsx---file-system-deployment-options">Amazon FSx - File System Deployment Options</a></h3>
<ul>
<li><strong>Scratch File System</strong>
<ul>
<li>임시 저장소</li>
<li>데이터가 복제되지 않음 (파일 서버가 디운되면 사라짐)</li>
<li>High burst (6배 빠름, 200MBps per TiB)</li>
<li>사례: 단기간 프로세싱, 비용 최적화</li>
</ul>
</li>
<li><strong>Persistent File System</strong>
<ul>
<li>장기간 스토리지</li>
<li>동일 AZ 내에 데이터가 복제됨</li>
<li>몇분 안에 failed file들을 교체</li>
<li>사례: 장기간 프로세싱, 민감 데이터</li>
</ul>
</li>
</ul>
<h3 id="amazon-fsx---for-netapp-ontap"><a class="header" href="#amazon-fsx---for-netapp-ontap">Amazon FSx - for NetApp ONTAP</a></h3>
<ul>
<li>AWS에서 관리되는 NetApp ONTAP</li>
<li><strong>NFS, SMB, iSCSI 프로토콜과 호환되는 파일 시스템</strong></li>
<li>ONTAP 또는 NAS에서 실행되는 워크로드를 AWS로 이동</li>
<li>다음과 호환
<ul>
<li>Linux</li>
<li>Windows</li>
<li>MacOS</li>
<li>VMware Cloud on AWS</li>
<li>Amazon Workspaces &amp; AppStream 2.0</li>
<li>Amazon EC2, ECS and EKS</li>
</ul>
</li>
<li>스토리지 자동 축소/확장</li>
<li>스냅샷, 복제, 저비용, 압축 및 데이터 중복 제거</li>
<li><strong>특정 시점 순간 복제(새로운 워크로드에 대한 테스트에 유용함)</strong></li>
</ul>
<h3 id="amazon-fsx---for-openzfs"><a class="header" href="#amazon-fsx---for-openzfs">Amazon FSx - for OpenZFS</a></h3>
<ul>
<li>AWS에서 관리되는 OpenZFS 파일 시스템</li>
<li>오직 NFS와 호환되는 파일 시스템 (v3, v4, v4.1, v4.2)</li>
<li>ZFS에서 실행중인 워크로드를 AWS로 이동</li>
<li>다음과 호환
<ul>
<li>Linux</li>
<li>Windows</li>
<li>MacOS</li>
<li>VMware Cloud on AWS</li>
<li>Amazon Workspaces &amp; AppStream 2.0</li>
<li>Amazon EC2, ECS and EKS</li>
</ul>
</li>
<li>0.5ms 미만의 레이턴시로 최대 1,000,000 IOPS</li>
<li>스냅샷, 압축, 저비용</li>
<li><strong>특정 시점 순간 복제(새로운 워크로드에 대한 테스트에 유용함)</strong></li>
</ul>
<h2 id="storage-gateway"><a class="header" href="#storage-gateway">Storage Gateway</a></h2>
<h3 id="storage-gateway---hybrid-cloud-for-storage"><a class="header" href="#storage-gateway---hybrid-cloud-for-storage">Storage Gateway - Hybrid Cloud for Storage</a></h3>
<ul>
<li>AWS는 &quot;하이브리드 클라우드&quot;를 추진함
<ul>
<li>인프라의 일부는 클라우드로</li>
<li>인프라의 일부는 온-프레미스로</li>
</ul>
</li>
<li>이렇게 하는 이유는
<ul>
<li>장기적인 클라우드 마이그레이션</li>
<li>보안 요구사항 준수</li>
<li>규정 준수</li>
<li>IT 전략</li>
</ul>
</li>
<li>S3는 (EFS/NFS와 다르게) 독점적인 스토리지 기술인데, 어떻게 S3 데이터를 온-프레미스로 내보낼 수 있을까?</li>
<li>그 역할을 해주는 것이 바로 <em>AWS Storage Gateway</em></li>
</ul>
<h3 id="storage-gateway---aws-storage-cloud-native-options"><a class="header" href="#storage-gateway---aws-storage-cloud-native-options">Storage Gateway - AWS Storage Cloud Native Options</a></h3>
<ul>
<li>Block - AWS EBS, EC2 Instance Store</li>
<li>File - AWS EFS, AWS FSx</li>
<li>Object - AWS S3, AWS Glacier</li>
</ul>
<h3 id="storage-gateway---overview"><a class="header" href="#storage-gateway---overview">Storage Gateway - Overview</a></h3>
<ul>
<li>
<p>온-프레미스 데이터와 클라우드 데이터 간의 브릿지</p>
</li>
<li>
<p><strong>사례</strong>:</p>
<ul>
<li>재해 복구</li>
<li>백업 &amp; 복원</li>
<li>계층형 스토리지 (tiered storage)</li>
<li>온-프레미스 캐시 &amp; 낮은 레이턴시의 파일 액세스</li>
</ul>
</li>
<li>
<p><strong>Storage Gateway 종류</strong>:</p>
<ul>
<li><strong>S3 File Gateway</strong></li>
<li><strong>FSx File Gateway</strong></li>
<li><strong>Volume Gateway</strong></li>
<li><strong>Tape Gateway</strong></li>
</ul>
</li>
</ul>
<h3 id="storage-gateway---s3-file-gateway"><a class="header" href="#storage-gateway---s3-file-gateway">Storage Gateway - S3 File Gateway</a></h3>
<ul>
<li>NFS와 SMB 프로토콜을 사용하여 접근 가능한 설정된 S3 버킷</li>
<li><strong>가장 최근에 사용된 데이터는 file gateway 내에 캐시됨</strong></li>
<li>S3 Standard, S3 Standard IA, S3 One Zone A, S3 Intelligent Tiering 지원 (Glacier 제외)</li>
<li><strong>라이프사이클 정책을 통해 S3 Glacier로 전환 가능</strong></li>
<li>각각의 File Gateway에 IAM 역할을 정의하여 버킷에 액세스</li>
<li>이용자 인증을 위해 SMB 프로토콜은 Active Directory(AD)와 연동됨</li>
</ul>
<h3 id="storage-gateway---fsx-file-gateway"><a class="header" href="#storage-gateway---fsx-file-gateway">Storage Gateway - FSx File Gateway</a></h3>
<ul>
<li>FSx for Window File Server에 대한 네이티브 액세스</li>
<li><strong>자주 액세스되는 데이터에 대한 로컬 캐시</strong> (사실 상 이를 사용하는 주된 이유)</li>
<li>Windows 네이티브 호환성 (SMB, NTFS, Active Directory, ...)</li>
<li>그룹 파일 공유와 홈 디렉토리에 유용함</li>
</ul>
<h3 id="storage-gateway---volume-gateway"><a class="header" href="#storage-gateway---volume-gateway">Storage Gateway - Volume Gateway</a></h3>
<ul>
<li>iSCSI 프로토콜을 사용하는 S3 지원 블록 스토리지</li>
<li>EBS 스냅샷을 지원하여 온-프레미스 볼륨을 복원하는데 도움을 줌</li>
<li><strong>Cached volumes</strong>: 가장 최근에 액세스된 데이터에 대해 낮은 레이턴시를 보장</li>
<li><strong>Stored volumes</strong>: 전체 데이터셋이 온-프레미스이며, S3로 스케줄된 백업(scheduled backup)</li>
</ul>
<h3 id="storage-gateway---tape-gateway"><a class="header" href="#storage-gateway---tape-gateway">Storage Gateway - Tape Gateway</a></h3>
<ul>
<li>일부 회사는 놀랍게도(?) 실물 테이프를 사용하는 백업 프로세스를 보유함</li>
<li>Tape Gateway는 동일한 프로세스를 클라우드에서 수행할 수 있도록 함</li>
<li>S3와 Glacier가 지원되는 Virtual Tape Library(VTL)</li>
<li>기존에 존재하는 tape-based 프로세스를 사용하여 데이터를 백업 (+ iSCSI 인터페이스)</li>
<li>주요 백업 소프트웨어 업체와 협력</li>
</ul>
<h3 id="storage-gateway---hardware-appliance"><a class="header" href="#storage-gateway---hardware-appliance">Storage Gateway - Hardware appliance</a></h3>
<ul>
<li>Storage Gateway를 사용한다는 것은 온-프레미스 가상화가 필요하다는 것을 의미함</li>
<li>그렇지 않은 경우, <strong>Storage Gateway Hardware Appliance</strong>를 사용할 수도 있음</li>
<li>amazon.com에서 구매</li>
<li>File Gateway, Volume Gateway, Tape Gateway와 함께 사용</li>
<li>요구되는 CPU, 메모리, 네트워크, SSD 캐시 리소스를 보유하고 있음</li>
<li>소규모 데이터 센터를 두고 매일 NFS 백업을 하기에 유용함</li>
</ul>
<h3 id="storage-gateway---summary"><a class="header" href="#storage-gateway---summary">Storage Gateway - Summary</a></h3>
<p><img src="https://d1.awsstatic.com/pdp-how-it-works-assets/product-page-diagram_AWS-Storage-Gateway_HIW@2x.6df96d96cdbaa61ed3ce935262431aabcfb9e52d.png" alt="Storage Gateway Summary" /></p>
<h2 id="aws-transfer-family"><a class="header" href="#aws-transfer-family">AWS Transfer Family</a></h2>
<p><img src="https://d1.awsstatic.com/cloud-storage/product-page-diagram_AWS-Transfer-Family_HIW-Diagram.4af0b3b19477f22bc7e37995c43cf833b6db0ce9.png" alt="Transfer Family" /></p>
<ul>
<li>S3 또는 FTP 프로토콜을 사용하는 EFS 안팎으로 데이터를 전송할 수 있는 완전 관리형 서비스</li>
<li>지원 프로토콜
<ul>
<li>**AWS Transfer for FTP (File Transfer Protocol (FTP))</li>
<li>**AWS Transfer for FTPS (File Transfer Protocol over SSL (FTPS))</li>
<li>**AWS Transfer for SFTP (Secure File Transfer Protocol (SFTP))</li>
</ul>
</li>
<li>관리형 인프라, 확장 가능, 신뢰 가능, 고가용성 ~ High Available (multi-AZ)</li>
<li>시간 별 프로비전된 엔드포인트마다 + 데이터 전송 GB 단위에 따라 비용 지불</li>
<li>기존에 존재하는 인증 시스템과 호환됨 (Microsoft Active Directory, LDAP, Okta, Amazon Cognito, custom)</li>
<li>사례: 파일 공유, 공용 데이터셋, CRM, ERP, ...</li>
</ul>
<h2 id="aws-datasync"><a class="header" href="#aws-datasync">AWS DataSync</a></h2>
<ul>
<li>많은 양의 데이터를 넘기거나, 받는 경우
<ul>
<li>온-프레미스 또는 다른 클라우드로부터 AWS로 이동 (NFS, SMB, HDFS, S3 API...) - 연결을 수행하기 위한 <strong>에이전트 필요</strong></li>
<li>AWS에서 AWS (다른 스토리지 서비스로) - 에이전트 필요 없음</li>
</ul>
</li>
<li>다음과 동기화 가능
<ul>
<li>S3 (어떤 storage class든 - Glacier 포함)</li>
<li>EFS</li>
<li>FSx (Windows, Lustre, NetApp, OpenZFS...)</li>
</ul>
</li>
<li>복제 작업을 시간마다/일마다/주마다 수행할 수 있음</li>
<li><strong>파일 권한과 메타데이터가 보존됨</strong> (NFS POSIX, SMB...)</li>
<li>하나의 에이전트 작업은 10Gbps를 사용할 수 있으며, 대역폭 한계(bandwidth limit)를 설정할 수 있음</li>
</ul>
<h3 id="aws-datasync---nfs--smb-to-aws-s3-efs-fsx"><a class="header" href="#aws-datasync---nfs--smb-to-aws-s3-efs-fsx">AWS DataSync - NFS / SMB to AWS (S3, EFS, FSx...)</a></h3>
<p><img src="https://d1.awsstatic.com/Digital%20Marketing/House/Editorial/products/DataSync/Product-Page-Diagram_AWS-DataSync_On-Premises-to-AWS%402x.8769b9dea1615c18ee0597b236946cbe0103b2da.png" alt="NFS/SMB to AWS" /></p>
<h3 id="aws-datasync---transfer-between-aws-storage-services"><a class="header" href="#aws-datasync---transfer-between-aws-storage-services">AWS DataSync - Transfer between AWS storage services</a></h3>
<p><img src="https://d1.awsstatic.com/Digital%20Marketing/House/Editorial/products/DataSync/Product-Page-Diagram_AWS-DataSync-to-AWS-Storage-Services%402x.c9ae72a5d796feed1fd562b968fc133f9e66eec2.png" alt="AWS to AWS" /></p>
<h2 id="storage-comparison"><a class="header" href="#storage-comparison">Storage Comparison</a></h2>
<ul>
<li><strong>S3</strong>: 객체 스토리지</li>
<li><strong>S3 Glacier</strong>: 객체 아카이빙</li>
<li><strong>EBS volumes</strong>: 한번에 하나의 EC2 인스턴스에만 존재하는 네트워크 스토리지</li>
<li><strong>Instance Storge</strong>: EC2 인스턴스에 대한 실물 스토리지 (High IOPS)</li>
<li><strong>EFS</strong>: 리눅스 인스턴스, POSIX 파일시스템을 위한 네트워크 파일 시스템</li>
<li><strong>FSx for Windows</strong>: Windows servers를 위한 네트워크 파일 시스템</li>
<li><strong>FSx for Lustre</strong>: 고성능 컴퓨팅 리눅스 파일 시스템</li>
<li><strong>FSx for NetApp ONTAP</strong>: 높은 OS 호환성</li>
<li><strong>FSx for OpenZFS</strong>: 관리형 ZFS 파일 시스템</li>
<li><strong>Storage Gateway</strong>: S3 &amp; FSx File Gateway, Volume Gateway (캐시 &amp; 보관), Tape Gateway</li>
<li><strong>Transfer Family</strong>: S3 또는 EFS 상위의 FTP, FTPS, SFTP 인터페이스</li>
<li><strong>DataSync</strong>: 온-프레미스 to AWS 또는 AWS to AWS 데이터 싱크를 스케줄</li>
<li><strong>Snowcone / Snowball / Snowmobile</strong>: 거대한 양의 물리적인 데이터를 클라우드로 이동</li>
<li><strong>Database</strong>: 구체적인 워크로드 수행을 위함, 인덱싱 또는 쿼링</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="decoupling-applications"><a class="header" href="#decoupling-applications">Decoupling Applications</a></h1>
<ul>
<li>여러 개의 애플리케이션을 배포하기 시작할 때, 필연적으로 애플리케이션들이 서로 소통해야할 필요가 생김</li>
<li>이 때, 애플리케이션 간의 커뮤니케이션을 구현하는데 있어 두 가지 패턴이 있음
<ol>
<li>동기 커뮤니케이션 (Synchronous communications ~ application to application)</li>
<li>비동기 / 이벤트 기반 커뮤니케이션 (Asynchronous / Event based ~ application to queue to application)</li>
</ol>
</li>
<li>애플리케이션 간의 동기적인 커뮤니케이션은 갑작스러운 트래픽 급증이 있는 상황에서 문제가 될 수 있음
<ul>
<li>만약, 일반적으로 10개 정도로 비디오 인코딩 작업을 처리하던 애플리케이션에서 갑자기 1000개의 요청을 처리하게 되면?</li>
</ul>
</li>
<li>이러한 경우에 대비하기 위해, 애플리케이션은 **디커플링(decouple)**을 하는 것이 좋음
<ul>
<li>SQS: queue 모델</li>
<li>SNS: pub/sub 모델</li>
<li>Kinesis: 실시간 스트리밍 모델</li>
</ul>
</li>
<li>위의 서비스들은 애플리케이션과는 독립적으로 스케일링을 수행할 수 있음</li>
</ul>
<h2 id="sqs"><a class="header" href="#sqs">SQS</a></h2>
<h3 id="whats-a-queue"><a class="header" href="#whats-a-queue">What's a queue?</a></h3>
<p><img src="https://hands-on.cloud/wp-content/uploads/2023/01/A-Quick-Intro-To-Amazon-Simple-Queue-Service-SQS-Processing-messages-1024x451.png?ezimgfmt=rs:372x164/rscb1/ngcb1/notWebP" alt="SQS queue" /></p>
<h3 id="sqs---standard-queue"><a class="header" href="#sqs---standard-queue">SQS - Standard Queue</a></h3>
<ul>
<li>오래된 서비스 (거의 10년 가까이)</li>
<li>주로 <strong>애플리케이션 디커플링</strong>에 사용되는 완전 관리형 서비스</li>
<li>속성:
<ul>
<li>무제한 처리량(throughput), 큐 내 메시지 갯수에 제한이 없음</li>
<li>메시지의 기본 보관 기관: 4일, 최대 14일</li>
<li>낮은 레이턴시 (publish / receive에 10ms 미만)</li>
<li>각 메시지 전송에 256kb 제한</li>
</ul>
</li>
<li>메시지 중복이 발생할 수 있음 (At-least-once delivery에 의해, 가끔 발생할 수 있음)</li>
<li>메시지 순서가 올바르지 않을 수 있음 (Best-effort message ~ 메시지 순서를 최대한 지키려 노력하긴 하지만, 보장하진 않음)</li>
</ul>
<h3 id="sqs---producing-messages"><a class="header" href="#sqs---producing-messages">SQS - Producing Messages</a></h3>
<ul>
<li>SDK를 사용하여 SQS로 메시지 생산 (SendMessage API)</li>
<li>해당 메시지는 consumer가 삭제하기 전까지 SQS 내에 지속됨</li>
<li>메시지 보관 기간: 기본 4일, 최대 14일</li>
<li>예시: 처리해야할 주문을 보내는 경우
<ul>
<li>Order id</li>
<li>Customer id</li>
<li>Any attributes</li>
</ul>
</li>
<li>SQS standard: 무제한 처리량(throughput)</li>
</ul>
<h3 id="sqs---consuming-messages"><a class="header" href="#sqs---consuming-messages">SQS - Consuming Messages</a></h3>
<ul>
<li>Consumers (EC2 인스턴스, 서버 또는 AWS Lambda)</li>
<li>메시지를 받기 위한 SQS 폴링(Poll) - 한번에 최대 10개의 메시지 수신</li>
<li>메시지 처리 (ex. 받은 메시지를 RDS DB로 insert)</li>
<li>DeleteMessage API를 사용하여 메시지 삭제</li>
</ul>
<h3 id="sqs---multiple-ec2-instances-consumers"><a class="header" href="#sqs---multiple-ec2-instances-consumers">SQS - Multiple EC2 Instances Consumers</a></h3>
<ul>
<li>Consumer들은 메시지 수신/처리를 병렬적으로 수행</li>
<li>At-least-once delivery</li>
<li>Best-effort message ordering</li>
<li>Consumer들은 메시지를 처리한 이후에는 삭제함</li>
<li>메시지 처리량(throughput)을 향상시키기 위해 Consumer를 수평적으로 스케일링할 수 있음</li>
</ul>
<h3 id="sqs---with-auto-scaling-group-asg"><a class="header" href="#sqs---with-auto-scaling-group-asg">SQS - with Auto Scaling Group (ASG)</a></h3>
<p><img src="https://velog.velcdn.com/images/combi_jihoon/post/9f35b7bb-15a1-47e5-8739-2e117a5d7cd5/image.png" alt="SQS with ASG" /></p>
<ul>
<li>SQS 큐에 있는 메시지 갯수에 따라 CloudWatch 알람을 통해 ASG로 적절히 스케일링 할 수 있음</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*APII-Xi0GFGm1VAzmy1X-A.png" alt="Transaction Can be lost" /></p>
<ul>
<li>애플리케이션에 과부하가 온다면 일부 트랜잭션이 손실될 수 있음</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*doE7co618SwwqE3ANr9HFQ.png" alt="SQS as a buffer to database writes" /></p>
<ul>
<li>SQS 큐를 버퍼로 둘 때, 이는 무한하게 확장 가능하기 때문에, 어떻게든 트랜잭션이 결국 처리된다는 것을 보장할 수 있음</li>
<li>다만, 클라이언트에게 트랜잭션 결과를 바로 보여주어야 하는 경우엔 부적합할 수 있음</li>
</ul>
<h3 id="sqs---decouple-between-application-tiers"><a class="header" href="#sqs---decouple-between-application-tiers">SQS - <strong>decouple</strong> between application tiers</a></h3>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*5JW1sSEyd0eotW-XBY_B7Q.png" alt="Decouple between application tiers" /></p>
<p><img src="https://docs.aws.amazon.com/images/prescriptive-guidance/latest/modernization-integrating-microservices/images/integrating-diagram3.png" alt="Decouple messaging pattern" /></p>
<h3 id="sqs---security"><a class="header" href="#sqs---security">SQS - Security</a></h3>
<ul>
<li><strong>Encryption</strong>:
<ul>
<li>HTTPS API를 이용한 in-flight 암호화</li>
<li>KMS 키를 이용한 At-rest 암호화</li>
<li>클라이언트가 자체적인 암호화/복호화를 수행하고자 원한다면 클라이언트 측 암호화도 가능</li>
</ul>
</li>
<li><strong>Access Controls</strong>: SQS API에 대한 액세스를 조정하는 IAM 정책</li>
<li><strong>SQS Access Policies</strong> (S3 버킷 정책과 유사)
<ul>
<li>서로 다른 계정 간의 SQS 큐에 액세스해야 하는 경우 유용함</li>
<li>다른 서비스 (SNS, S3...)가 SQS 큐에 작성해야 하는 경우 유용함</li>
</ul>
</li>
</ul>
<h3 id="sqs---message-visibility-timeout"><a class="header" href="#sqs---message-visibility-timeout">SQS - Message Visibility Timeout</a></h3>
<p><img src="https://docs.aws.amazon.com/images/AWSSimpleQueueService/latest/SQSDeveloperGuide/images/sqs-visibility-timeout-diagram.png" alt="Message visibility timeout" /></p>
<ul>
<li>메시지가 consumer에 의해 폴링된 이후에는 다른 consumer들에게 <strong>보이지 않는</strong> 상태가 됨</li>
<li>기본적으로, &quot;message visibility timeout&quot;은 <strong>30초</strong>
<ul>
<li>이는 즉, 메시지 처리를 30초 내에 해야한다는 의미</li>
</ul>
</li>
<li>message visibility timeout이 지난 이후에야, 메시지는 SQS에서 <strong>보이는</strong> 상태가 됨</li>
<li>만약, visibility timeout 내에 메시지가 처리되지 않는다면, 위의 사진 예시의 경우 해당 메시지는 <strong>두번</strong>씩 처리가 됨</li>
<li>consumer는 이에 따라, 만약 visibility timeout보다 메시지 처리 시간이 더 걸린다면, <strong>ChangeMessageVisibility API</strong>를 호출하여 더 시간을 가질 수 있음</li>
<li>visibility timeout이 너무 크다면 (hours), consumer에 문제가 발생했을 때, 재처리(re-processing)에 많은 시간이 걸림</li>
<li>visibility timeout이 너무 작다면 (seconds), 중복 처리가 발생할 수 있음</li>
</ul>
<h3 id="sqs---long-polling"><a class="header" href="#sqs---long-polling">SQS - Long Polling</a></h3>
<ul>
<li>consumer가 큐(queue ~ 대기열)로부터 메시지 요청을 보낼 때, 아직 큐에 있지 않은 메시지가 도착할 때까지 선택적으로 <strong>기다릴</strong> 수 있음</li>
<li>이를 Long Polling이라고 함</li>
<li><strong>Long Polling은 SQS에 이루어지는 API 호출 횟수를 감소시켜, 애플리케이션의 효율성과 레이턴시를 개선함</strong></li>
<li>wait time은 1초에서 20초 사이로 설정 가능 (20초 권장)</li>
<li>Long Polling은 Short Polling보다 선호됨</li>
<li>Long Polling은 큐 레벨에서 활성화되거나, <strong>WaitTimeSeconds</strong>를 통해 API 레벨에서 활성화될 수 있음</li>
</ul>
<h3 id="sqs---fifo-queue"><a class="header" href="#sqs---fifo-queue">SQS - FIFO Queue</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2018/05/01/sqs_fifo_blog_img5.png" alt="SQS FIFO" /></p>
<ul>
<li>FIFO = First In First Out (큐 내 메시지의 순서)</li>
<li>제한적인 처리량(throughput): 배칭(batching)없이 300msg/s, 배칭있는 경우 3000msg/s</li>
<li>Exactly-once send capability (중복 제거)</li>
<li>Consumer의 처리 순서를 보장할 수 있음</li>
</ul>
<h2 id="sns"><a class="header" href="#sns">SNS</a></h2>
<ul>
<li>만약 하나의 메시지를 많은 receiver들에게 전달하고자 한다면 어떻게 해야 할까?</li>
<li>하나의 애플리케이션이 각각의 receiver들에게 직접 메시지를 전달하는 방법도 있겠지만, 이 경우, receiver가 추가될 때마다 일일이 애플리케이션 코드를 수정해야 하는 문제가 발생</li>
<li>이를 해결하기 위한 방법이 Pub/Sub(게시/구독) 패턴</li>
</ul>
<p><img src="https://d1.awsstatic.com/Product-Page-Diagram_Amazon-SNS_Event-Driven-SNS-Compute%402x.03cb54865e1c586c26ee73f9dff0dc079125e9dc.png" alt="Pub/Sub Pattern with SNS" /></p>
<h3 id="sns---overview"><a class="header" href="#sns---overview">SNS - Overview</a></h3>
<ul>
<li><strong>event producer</strong>는 오직 하나의 SNS topic에만 메시지를 보냄</li>
<li><strong>event receiver</strong>(구독)는 원하는 만큼 많이 둘 수 있음</li>
<li>해당 topic을 구독하는 각 subscriber(= receiver)는 모든 메시지를 수신함 (메시지 필터 기능을 쓰지 않는다면)</li>
<li>각 topic 별로 최대 12,500,000 구독을 할 수 있음</li>
<li>최대 100,000 topic</li>
</ul>
<h3 id="sns---sns-integrates-with-a-lot-of-aws-services"><a class="header" href="#sns---sns-integrates-with-a-lot-of-aws-services">SNS - SNS integrates with a lot of AWS services</a></h3>
<ul>
<li>여러 AWS 서비스들이 알림(notification)을 위해 직접 SNS에 데이터를 전송할 수 있음</li>
</ul>
<h3 id="sns---how-to-publish"><a class="header" href="#sns---how-to-publish">SNS - How to publish</a></h3>
<ul>
<li>
<p>Topic Publish (SDK 사용)</p>
<ul>
<li>토픽 생성</li>
<li>(하나 혹은 여러 개의) 구독 생성</li>
<li>토픽을 구독</li>
</ul>
</li>
<li>
<p>Direct Publish (모바일 앱 SDK 사용)</p>
<ul>
<li>플랫폼 애플리케이션 생성</li>
<li>플랫폼 엔드포인트 생성</li>
<li>플랫폼 엔드포인트를 구독</li>
<li>Google GCM, Apple APNS, Amazon ADM 등과 호환</li>
</ul>
</li>
</ul>
<h3 id="sns---security"><a class="header" href="#sns---security">SNS - Security</a></h3>
<ul>
<li>
<p><strong>Encryption</strong>:</p>
<ul>
<li>HTTPS API를 통한 In-flight encryption</li>
<li>KMS 키를 통한 At-rest encryption</li>
<li>클라이언트가 자체적으로 암호화/복호화를 원하는 경우 클라이언트 측 암호화 가능</li>
</ul>
</li>
<li>
<p><strong>Access Controls</strong>: SNS API로의 액세스를 조정하는 IAM 정책</p>
</li>
<li>
<p><strong>SNS Access Policies</strong> (S3 버킷 정책과 유사)</p>
<ul>
<li>서로 다른 계정 간의 SNS 토픽에 액세스해야 하는 경우 유용함</li>
<li>다른 서비스(SNS, S3...)가 SQS 토픽에 작성해야 하는 경우 유용함</li>
</ul>
</li>
</ul>
<h2 id="sns--sqs"><a class="header" href="#sns--sqs">SNS + SQS</a></h2>
<h3 id="fan-out"><a class="header" href="#fan-out">Fan Out</a></h3>
<p><img src="https://miro.medium.com/v2/resize:fit:723/1*DRrTtdyah9NHwR0VCm6MWA.png" alt="Fan Out" /></p>
<ul>
<li>SNS에 한번 푸쉬하고, 모든 SQS 큐를 구독자로 두어 이를 수신하도록 하는 방법</li>
<li>완전히 디커플링할 수 있음 / 데이터 손실 없음</li>
<li>SQS는 다음과 같은 것들을 처리: Data Persistence(데이터 지속성), 지연 시간이 존재하는 처리 &amp; 동일 작업의 수행</li>
<li>시간이 지남에 따라 더 많은 SQS 구독자를 추가할 수 있음</li>
<li>SQS 큐의 <strong>Access Policy</strong>가 SNS에게 쓰기 권한을 허용하는지 확인할 것</li>
<li>Cross-Region Delivery: SQS 큐는 다른 리전에서도 동작함</li>
</ul>
<h3 id="fan-out---application-s3-events-to-multiple-queues"><a class="header" href="#fan-out---application-s3-events-to-multiple-queues">Fan Out - Application: S3 Events to multiple queues</a></h3>
<ul>
<li><strong>event type(e.g., object create)</strong> 과 <strong>prefix(e.g., images/)</strong>
<ul>
<li>오직 하나의 <strong>S3 Event rule</strong>만 가질 수 있음</li>
</ul>
</li>
<li>만약 여러 개의 SQS 큐에 동일한 S3 이벤트를 전달하고자 한다면, fan-out을 사용
<ul>
<li>SQS 큐 뿐만 아니라, Lambda로도 가능</li>
</ul>
</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2022/05/23/fanout-S3-simple-usecase-diagram.png" alt="s3 fan out" /></p>
<h3 id="application-sns-to-amazon-s3-through-kinesis-data-firehose"><a class="header" href="#application-sns-to-amazon-s3-through-kinesis-data-firehose">Application: SNS to Amazon S3 through Kinesis Data Firehose</a></h3>
<ul>
<li>SNS는 Kinesis로도 전송할 수 있으며, 이를 통해 아래와 같은 솔루션 아키텍처를 가질 수도 있음</li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/sns/latest/dg/images/firehose-architecture-s3.png" alt="S3 through Kinesis Data Firehose" /></p>
<h3 id="sns---fifo-topic"><a class="header" href="#sns---fifo-topic">SNS - FIFO Topic</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2020/07/07/pub_sub_messaging.png" alt="SNS FIFO" /></p>
<ul>
<li>FIFO = First In First Out (토픽 내 메시지의 순서)</li>
<li>SQS FIFO와 유사한 기능
<ul>
<li>메시지 그룹 ID 기반으로 <strong>정렬</strong> (동일한 그룹 내 모든 메시지가 정렬됨)</li>
<li>Deduplication ID 또는 Content Based Deduplication를 통한 <strong>중복제거</strong></li>
</ul>
</li>
<li><strong>오직 SQS FIFO 큐만을 구독자로 둘 수 있음</strong></li>
<li>제한된 처리량 (SQS FIFO와 동일한 처리량)</li>
</ul>
<h3 id="sns---sns-fifo--sqs-fifo-fan-out"><a class="header" href="#sns---sns-fifo--sqs-fifo-fan-out">SNS - SNS FIFO + SQS FIFO: Fan Out</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2020/07/07/sns_fifo_two_subscriptions-1024x422.png" alt="FIFO Fan Out" /></p>
<ul>
<li>Fan Out + 정렬 + 중복 제거가 모두 필요한 상황에서 사용</li>
</ul>
<h3 id="sns---message-filtering"><a class="header" href="#sns---message-filtering">SNS - Message Filtering</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2022/11/21/Payload-filtering-example.png" alt="SNS message filtering" /></p>
<ul>
<li>SNS 토픽의 구독 대상들에게 전달되는 메시지를 필터링 하는 데에 사용하는 JSON 정책</li>
<li>별도로 필터 정책이 없는 경우, 모든 메시지를 받게 됨</li>
</ul>
<h2 id="kinesis"><a class="header" href="#kinesis">Kinesis</a></h2>
<h3 id="kinesis---overview"><a class="header" href="#kinesis---overview">Kinesis - Overview</a></h3>
<ul>
<li>실시간으로 데이터를 <strong>수집, 처리, 분석</strong>하기 쉽게 만들어 줌</li>
<li>실시간으로 다음과 같은 데이터들을 수집:
<ul>
<li>애플리케이션 로그</li>
<li>통계, 지표</li>
<li>웹사이트 클릭스트림</li>
<li>IoT 원격 측정 데이터</li>
</ul>
</li>
<li><strong>Kinesis Data Streams</strong>: 데이터 스트림을 캡처, 처리, 보관</li>
<li><strong>Kinesis Data Firehose</strong>: 데이터 스트림을 AWS 데이터 스토어로 불러옴</li>
<li><strong>Kinesis Data Analytics</strong>: SQL 또는 Apache Flink로 데이터 스트림 분석</li>
<li><strong>Kinesis Video Streams</strong>: 비디오 스트림을 캡처, 처리, 보관</li>
</ul>
<h3 id="kinesis-data-streams"><a class="header" href="#kinesis-data-streams">Kinesis Data Streams</a></h3>
<p><img src="https://docs.aws.amazon.com/images/streams/latest/dev/images/architecture.png" alt="Kinesis Data Streams" /></p>
<ul>
<li>1일 ~ 365일 동안 보관</li>
<li>데이터를 재처리(재실행)할 수 있음</li>
<li>일단 데이터가 Kinesis로 삽입되고 나면, 삭제될 수 없음 (immutability)</li>
<li>동일한 파티션을 공유하는 데이터는 동일한 샤드로 이동 (ordering)</li>
<li>Producers: AWS SDK, Kinesis Producer Library (KPL), Kinesis Agent</li>
<li>Consumers:
<ul>
<li>직접 작성: Kinesis Client Library (KCL), AWS SDK</li>
<li>관리형: AWS Lambda, Kinesis Data Firehose, Kinesis Data Analytics</li>
</ul>
</li>
</ul>
<h3 id="kinesis-data-streams---capacity-modes"><a class="header" href="#kinesis-data-streams---capacity-modes">Kinesis Data Streams - Capacity Modes</a></h3>
<ul>
<li><strong>Provisioned mode</strong>:
<ul>
<li>프로비저닝 및 스케일링될 샤드의 개수를 직접 또는 API를 통해 선택</li>
<li>각 샤드는 입력에 1MB/s (또는 매초 1000 레코드)</li>
<li>갹 사드는 출력에 2MB/s (classic 또는 enhanced fan-out consumer의 경우)</li>
<li>매 시간 프로비전된 샤드 마다 비용 지불</li>
</ul>
</li>
<li><strong>On-demand mode</strong>:
<ul>
<li>프로비저닝이나 용량을 관리할 필요가 없음</li>
<li>기본 용량으로 프로비전됨 (4MB/s 또는 매초 4000 레코드 입력)</li>
<li>지난 30일 동안 관측한 최대 처리량에 기반하여 자동 스케일링</li>
<li>시간 당 스트림 &amp; GB 당 데이터 in/out에 따라 비용 지불</li>
</ul>
</li>
</ul>
<h3 id="kinesis-data-streams---security"><a class="header" href="#kinesis-data-streams---security">Kinesis Data Streams - Security</a></h3>
<ul>
<li>IAM 정책을 통한 Control Access / Authorization</li>
<li>HTTPS 엔드포인트를 통한 in-flight encryption</li>
<li>KMS를 통한 at-rest encryption</li>
<li>클라이언트 측에서 데이터 암호화/복호화 가능 (더 어렵긴 함)</li>
<li>Kinesis가 VPC에 액세스할 수 있도록 하는 VPC Endpoint</li>
<li>CloudTrail을 통한 모니터링 API 호출</li>
</ul>
<h3 id="kinesis-data-firehose"><a class="header" href="#kinesis-data-firehose">Kinesis Data Firehose</a></h3>
<p><img src="https://d1.awsstatic.com/pdp-how-it-works-assets/product-page-diagram_Amazon-KDF_HIW-V2-Updated-Diagram@2x.6e531854393eabf782f5a6d6d3b63f2e74de0db4.png" alt="Kinesis Data Firehose" /></p>
<h3 id="kinesis-data-firehose---overview"><a class="header" href="#kinesis-data-firehose---overview">Kinesis Data Firehose - Overview</a></h3>
<ul>
<li>완전 관리형 서비스, 관리할 필요 없음, 자동 스케일링, 서버리스
<ul>
<li>AWS: Redshift / S3 / OpenSearch</li>
<li>3rd party partner: Splunk / MongoDB / DataDog / NewRelic / ...</li>
<li>Custom: 어떤 HTTP 엔드포인트로든 전송 가능</li>
</ul>
</li>
<li>Firehose를 통해 전송된 데이터 당 비용 지불</li>
<li><strong>거의 실시간 (= 실시간 아님)</strong>
<ul>
<li>전체 배치(full batch)가 아닌 경우 최소 60초의 레이턴시 가짐</li>
<li>또는 한번에 최소 1MB가 넘는 경우 약간 기다려야 함</li>
</ul>
</li>
<li>여러 데이터 포맷, conversion, transformation, compression을 지원</li>
<li><strong>AWS 람다를 통해 커스텀 데이터 변환 가능</strong></li>
<li><strong>백업 S3 버킷으로 failed 또는 모든 데이터를 전송 가능</strong></li>
</ul>
<h3 id="kinesis-data-stream-vs-firehose"><a class="header" href="#kinesis-data-stream-vs-firehose">Kinesis Data Stream vs Firehose</a></h3>
<ul>
<li>Kinesis Data Streams
<ul>
<li>대규모 수집을 위한 스트리밍 서비스</li>
<li>커스텀 코드 작성 (producer / consumer)</li>
<li>실시간 (~200ms)</li>
<li>스케일링 관리 (샤드 스플리팅 / 머징 ~ merging)</li>
<li>1일 ~ 365일 동안 보관되는 데이터 스토리지</li>
<li>리플레이 기능 지원</li>
</ul>
</li>
<li>Kinesis Data Firehose
<ul>
<li>S3 / Redshift / OpenSearch / 써드파티 / 커스텀 HTTP로 스트리밍 데이터 로드</li>
<li>완전 관리형</li>
<li>거의 실시간 (버퍼 시간 최소 60초)</li>
<li>자동 스케일링</li>
<li>데이터 스토리지 없음</li>
<li>리플레이 기능 지원하지 않음</li>
</ul>
</li>
</ul>
<h2 id="ordering-data"><a class="header" href="#ordering-data">Ordering Data</a></h2>
<h3 id="ordering-data---kinesis"><a class="header" href="#ordering-data---kinesis">Ordering Data - Kinesis</a></h3>
<ul>
<li>만약 AWS에 길 위 100대 트럭(<code>truck_1</code>, <code>truck_2</code>, ...)의 GPS 위치를 주기적으로 전송해야 한다고 생각해보자</li>
<li>여기서 트럭의 위치를 추적하기 위해, 각 트럭마다 순서대로 데이터를 consume하고자 하고자 한다</li>
<li>어떻게 Kinesis에 데이터를 전송해야 할까?
<ul>
<li>답은 <strong><code>truck_id</code>를 &quot;Partion Key&quot; 값으로 사용하는 것</strong>이다.</li>
<li><strong>똑같은 key는 항상 똑같은 shard에 저장되기 때문</strong></li>
</ul>
</li>
</ul>
<h3 id="ordering-data---into-sqs"><a class="header" href="#ordering-data---into-sqs">Ordering Data - into SQS</a></h3>
<ul>
<li>SQS standard에서는 정렬이 없음</li>
<li>SQS FIFO의 경우, Group ID를 사용하지 않는다면 메시지는 도착한 순서대로 consume되며, <strong>이는 오직 하나의 consumer에 의해 이루어짐</strong></li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2018/05/01/sqs_fifo_blog_img3-1024x256.png" alt="SQS FIFO Ordering 1" />
<img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2018/05/02/sqs_fifo_blog_img4-1024x256.png" alt="SQS FIFO Ordering 2" /></p>
<ul>
<li>consumer의 개수를 늘리면서, 또 메시지가 서로 관련되어 있을 때 그룹화 하는 것도 원한다면
<ul>
<li><strong>Group ID</strong>를 사용해야 함 (Kinesis에서의 Partition Key와 유사함)</li>
</ul>
</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2018/05/02/sqs_fifo_blog_img6-1-1024x341.png" alt="SQS FIFO using message group" /></p>
<h3 id="ordering-data---kinesis-vs-sqs-ordering"><a class="header" href="#ordering-data---kinesis-vs-sqs-ordering">Ordering Data - Kinesis vs SQS Ordering</a></h3>
<ul>
<li><strong>100개의 트럭, 5 Kinesis shards, 1 SQS FIFO가 있다고 가정</strong></li>
<li>*<strong>Kinesis Data Streams</strong>:
<ul>
<li>평균적으로 각 샤드 당 20개의 트럭 데이터</li>
<li>각 샤드 내에서 데이터를 정렬하게 됨</li>
<li>5개의 샤드가 있으므로, 병렬로 처리할 수 있는 최대 consumer 수는 5개
<ul>
<li>이에 따라, 최대 5MB/s를 수신할 수 있음</li>
</ul>
</li>
</ul>
</li>
<li><strong>SQS FIFO</strong>
<ul>
<li>오직 하나의 SQS FIFO 큐</li>
<li>100개의 Group ID</li>
<li>최대 100개의 consumer 가질 수 있음 (Group ID가 100개이기 때문)</li>
<li>매초 최대 300개의 메시지를 가질 수 있음 (또는, 배치를 사용할 경우 3000)</li>
</ul>
</li>
</ul>
<h2 id="sqs-vs-sns-vs-kinesis"><a class="header" href="#sqs-vs-sns-vs-kinesis">SQS vs SNS vs Kinesis</a></h2>
<ul>
<li>
<p><strong>SQS</strong></p>
<ul>
<li>consumer가 데이터를 pull해야함</li>
<li>데이터는 consume되고 나면 삭제되어야 함</li>
<li>원하는 만큼 많은 워커(= consumer)들을 가질 수 있음</li>
<li>처리량을 프로비전 할 필요 없음</li>
<li>오직 FIFO 큐를 통해서 정렬을 보장할 수 있음</li>
<li>개별 메시지 딜레이 기능</li>
</ul>
</li>
<li>
<p><strong>SNS</strong></p>
<ul>
<li>여러 subscriber들에게 데이터를 push</li>
<li>최대 12,500,000 subscriber</li>
<li>데이터는 지속(persist)되지 않음 (전송되지 않으면 사라짐)</li>
<li>Pub/Sub (게시/구독)</li>
<li>최대 100,000 topic</li>
<li>처리량을 프로비전 할 필요 없음</li>
<li>SQS와 함께 사용하여 fan-out 아키텍처 패턴을 구성할 수 있음</li>
<li>SQS FIFO를 위한 FIFO 기능</li>
</ul>
</li>
<li>
<p><strong>Kinesis</strong></p>
<ul>
<li>Standard: 데이터 pull
<ul>
<li>샤드마다 2MB</li>
</ul>
</li>
<li>Enhanced-fan out: 데이터 push
<ul>
<li>consumer별 샤드마다 2MB</li>
</ul>
</li>
<li>데이터 리플레이 가능</li>
<li>실시간 빅데이터 분석과 ETL(Extract, Transform, Load) 목적</li>
<li>샤드 레벨에서 정렬됨</li>
<li>X일 이후 데이터가 만료됨</li>
<li>Provisioned mode 또는 On-demand capacity mode 선택</li>
</ul>
</li>
</ul>
<h2 id="amazon-mq"><a class="header" href="#amazon-mq">Amazon MQ</a></h2>
<ul>
<li>SQS, SNS는 클라우드 네이티브 서비스: AWS 독점(proprietary) 프로토콜</li>
<li>온-프레미스를 통해 동작하는 기존 애플리케이션들은 다음과 같은 프로토콜을 사용했을 것임
<ul>
<li>MQTT, AMQP, STOMP, Openwire, WSS</li>
</ul>
</li>
<li><strong>클라우드로 마이그레이팅 할 때</strong>, 애플리케이션을 SQS, SNS로 아예 다시 엔지니어링 하는 대신, Amazon MQ를 사용할 수 있음</li>
<li><strong>Amazon MQ는 RabbitMQ, ActiveMQ에 대한 관리형 메시지 브로커 서비스</strong></li>
<li>Amazon MQ은 SQS/SNS만큼 스케일링 할 수 없음</li>
<li>Amazon MQ는 서버 위에서 동작하며, 장애 대처를 위해 Multi-AZ로 실행할 수 있음</li>
<li>Amazon MQ queue 기능(~SQS)과, topic 기능(~SNS)를 모두 갖추고 있음</li>
</ul>
<h3 id="amazon-mq---high-availability"><a class="header" href="#amazon-mq---high-availability">Amazon MQ - High Availability</a></h3>
<p><img src="https://docs.aws.amazon.com/images/amazon-mq/latest/developer-guide/images/amazon-mq-activemq-broker-architecture-active-standby.png" alt="MQ High Availability" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<h3 id="docker---what-is-docker"><a class="header" href="#docker---what-is-docker">Docker - What is Docker?</a></h3>
<ul>
<li>Docker는 앱을 배포하기 위한 소프트웨어 개발 플랫폼</li>
<li>앱이 <strong>컨테이너</strong>에 패키지되어 어떤 OS에서든지 실행 가능함</li>
<li>앱은 어디서 실행하든 동일하게 실행됨
<ul>
<li>어떤 머신이든 동작</li>
<li>호환성 이슈 없음</li>
<li>예측 가능한 동작</li>
<li>작업 감소</li>
<li>유지 및 배포가 쉬움</li>
<li>어떤 언어/OS/기술과도 호환됨</li>
</ul>
</li>
<li>사례:
<ul>
<li>마이크로서비스 아키텍처</li>
<li>온-프레미스에서 AWS 클라우드로 앱을 리프트-앤-시프트(lift-and-shift)</li>
</ul>
</li>
</ul>
<h3 id="docker---where-are-docker-images-stored"><a class="header" href="#docker---where-are-docker-images-stored">Docker - Where are Docker images stored?</a></h3>
<ul>
<li>도커 이미지들은 도커 저장소(repositories)에 저장됨
<ul>
<li><strong>Docker Hub</strong> (<a href="https://hub.docker.com">https://hub.docker.com</a>)
<ul>
<li><strong>Public</strong> repo</li>
<li>여러 기술 또는 OS를 위한 베이스 이미지들을 사용 (e.g., Ubuntu, MySQL, ...)</li>
</ul>
</li>
<li><strong>Amazon ECR</strong> (<strong>Amazon Elastic Container Registry</strong>)
<ul>
<li><strong>Private</strong> repo</li>
<li><strong>Public</strong> repo (**Amazon ECR Public Gallery - <a href="https://gallery.ecr.aws">https://gallery.ecr.aws</a>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="docker---docker-vs-virtual-machines"><a class="header" href="#docker---docker-vs-virtual-machines">Docker - Docker vs. Virtual Machines</a></h3>
<ul>
<li>Docker는 &quot;일종의&quot; 가상화 기술이긴 하지만, 정확하게는 다름</li>
<li>Resources가 호스트와 공유됨 =&gt; 하나의 서버에 여러 컨테이너가 존재</li>
</ul>
<p><img src="https://i.ytimg.com/vi/TvnZTi_gaNc/maxresdefault.jpg" alt="Docker vs VM" /></p>
<h3 id="docker---docker-containers-management-os-aws"><a class="header" href="#docker---docker-containers-management-os-aws">Docker - Docker Containers Management os AWS</a></h3>
<ul>
<li><strong>Amazon Elastic Container Service (Amazon ECS)</strong>
<ul>
<li>아마존의 자체적인 컨테이너 플랫폼</li>
</ul>
</li>
<li><strong>Amazon Elastic Kubernetes Services (Amazon EKS)</strong>
<ul>
<li>아마존의 관리형 쿠버네티스 (오픈 소스)</li>
</ul>
</li>
<li><strong>AWS Fargate</strong>
<ul>
<li>아마존의 자체적인 서버리스 컨테이너 플랫폼</li>
<li>ECS, EKS와 호환</li>
</ul>
</li>
<li><strong>Amazon ECR</strong>
<ul>
<li>컨테이너 이미지를 저장</li>
</ul>
</li>
</ul>
<h2 id="amazon-ecs"><a class="header" href="#amazon-ecs">Amazon ECS</a></h2>
<p><img src="https://d1.awsstatic.com/product-page-diagram_Amazon-ECS%402x.0d872eb6fb782ddc733a27d2bb9db795fed71185.png" alt="ECS" /></p>
<h3 id="ecs---ec2-launch-type"><a class="header" href="#ecs---ec2-launch-type">ECS - EC2 Launch Type</a></h3>
<ul>
<li>ECS = Elastic Container Service</li>
<li>AWS에 도커 컨테이너를 실행 = ECS 클러스터에서 <strong>ECS Task</strong>를 실행</li>
<li><strong>EC2 Launch Type</strong>: <strong>반드시 인프라(EC2 인스턴스)를 프로비전 &amp; 유지 해야함</strong></li>
<li>각 EC2 인스턴스는 반드시 ECS Agent를 실행하여 ECS 클러스터에 등록해야 함</li>
<li>AWS가 컨테이너의 시작/중지를 맡아서 함</li>
</ul>
<h3 id="ecs---fargate-launch-type"><a class="header" href="#ecs---fargate-launch-type">ECS - Fargate Launch Type</a></h3>
<ul>
<li>AWS에 도커 컨테이너를 실행</li>
<li><strong>인프라를 프로비전하지 않음</strong> (<strong>EC2 인스턴스를 관리할 필요 없음</strong>)</li>
<li><strong>서버리스</strong>!</li>
<li>task를 정의하기만 하면 됨</li>
<li>내가 필요한 CPU / RAM에 따라 AWS는 단순히 ECS Task를 실행해줄 뿐임</li>
<li>스케일링을 위해서는 그냥 task의 갯수를 늘리면 됨, 쉬움 -&gt; EC2 인스턴스 필요 없음</li>
</ul>
<h3 id="ecs---iam-roles-for-ecs"><a class="header" href="#ecs---iam-roles-for-ecs">ECS - IAM Roles for ECS</a></h3>
<ul>
<li>
<p><strong>EC2 Instance Profile (EC2 Launch Type only)</strong>:</p>
<ul>
<li><strong>ECS agent</strong>가 사용함</li>
<li>ECS 서비스를 위한 API 호출</li>
<li>CloudWatch 로그에 컨테이너 로그를 전송</li>
<li>ECR로부터 도커 이미지를 가져옴</li>
<li>Secret Manager 또는 SSM Parameter Store에 있는 민감한 데이터를 참조</li>
</ul>
</li>
<li>
<p><strong>ECS Task Role</strong>:</p>
<ul>
<li>각 task에 특정한 role이 부여되도록 허용</li>
<li>각기 다른 ECS 서비스에 다른 role들을 사용</li>
<li>Task Role은 <strong>task definition</strong>을 통해 정의됨</li>
</ul>
</li>
</ul>
<h3 id="ecs---load-balancer-integrations"><a class="header" href="#ecs---load-balancer-integrations">ECS - Load Balancer Integrations</a></h3>
<ul>
<li>**Application Load Balancer(ALB)**가 지원되며, 거의 대부분의 상황에 적합함</li>
<li>**Network Load Balancer(NLB)**는 높은 처리량 / 높은 성능이 요구되는 사례에 추천, 또는 AWS Private Link와 함께 쓰기 위해 사용</li>
<li>Elastic Load Balancer 역시 지원되지만, 추천되지는 않음 (고급 기능을 사용할 수 없음 - Fargate 불가)</li>
</ul>
<h3 id="ecs---data-volumes-efs"><a class="header" href="#ecs---data-volumes-efs">ECS - Data Volumes (EFS)</a></h3>
<ul>
<li>ECS task에 EFS 파일 시스템을 마운트</li>
<li><strong>EC2</strong>와 <strong>Fargate</strong> launch type 모두와 호환</li>
<li>어떤 AZ에서 task가 실행되든 간에 EFS 파일 시스템 내에서 동일한 데이터를 공유함</li>
<li><strong>Fargate + EFS = Serverless</strong></li>
<li>사례: 내 컨테이너에 대해 multi-AZ 간에 공유되는 스토리지를 지속해야 하는 경우</li>
<li>노트: S3는 파일 시스템으로 마운트될 수 없음</li>
</ul>
<h3 id="ecs---auto-scaling"><a class="header" href="#ecs---auto-scaling">ECS - Auto Scaling</a></h3>
<ul>
<li>자동으로 ECS task의 desired number를 증가/감소</li>
<li>Amazon ECS Auto Scaling은 <strong>AWS Application Auto Scaling</strong>을 사용
<ul>
<li>ECS Service 평균 CPU 사용률</li>
<li>ECS Service 평균 메모리 사용률 - RAM에 따른 스케일링</li>
<li>각 타겟 별 ALB 요청 수 - ALB로부터 통계 전달받음</li>
</ul>
</li>
<li><strong>Target Tracking</strong> - 특정 CloudWatch 통계의 target value에 기반하여 스케일링</li>
<li><strong>Step Scaling</strong> - 특정 CloudWatch Alarm에 기반하여 스케일링</li>
<li><strong>Scheduled Scaling</strong> - 특정 날짜/시간에 기반하여 스케일링 (예측 가능한 변경의 경우)</li>
<li>ECS Service Auto Scaling (task 레벨) != EC2 Auto Scaling (EC2 인스턴스 레벨)</li>
<li>Fargate Auto Scaling은 훨씬 설정이 쉬움 (<strong>서버리스</strong>이기 때문)</li>
</ul>
<h3 id="ecs---launch-type--auto-scaling-ec2-instances"><a class="header" href="#ecs---launch-type--auto-scaling-ec2-instances">ECS - Launch Type ~ Auto Scaling EC2 Instances</a></h3>
<ul>
<li>기반에 놓인 EC2 인스턴스를 추가함으로써 ECS Service Scaling을 수용</li>
<li><strong>Auto Scaling Group Scaling</strong>
<ul>
<li>CPU 사용량에 기반하여 ASG를 스케일링</li>
<li>시간이 지남에 따라 EC2 인스턴스 추가</li>
</ul>
</li>
<li><strong>ECS Cluster Capacity Provider</strong>
<ul>
<li>ECS task를 위한 인프라에 대한 프로비저닝과 스케일링을 자동으로 처리하기 위해 사용</li>
<li>Auto Scaling Group과 짝지어서 사용</li>
<li>용량이 부족할 때 EC2 인스턴스를 추가 (CPU, RAM...)</li>
</ul>
</li>
</ul>
<h3 id="ecs---solutions-architectures"><a class="header" href="#ecs---solutions-architectures">ECS - Solutions Architectures</a></h3>
<p><img src="https://practical-aws.dev/p/container-ecs-event-bridge-scheduled/group-container-ecs-event-bridge-scheduled-architecture.png" alt="ECS with EventBridge" /></p>
<p><img src="https://imgur.com/6YLbKsU.png" alt="ECS with SQS" /></p>
<h2 id="ecr"><a class="header" href="#ecr">ECR</a></h2>
<ul>
<li>ECR = Elastic Container Registry</li>
<li>AWS에 도커 이미지를 저장 및 관리</li>
<li><strong>Private</strong> 또는 <strong>Public</strong> repo (<strong>Amazon ECR Public Gallery</strong> ~ <a href="https://gallery.ecr.aws">https://gallery.ecr.aws</a>)</li>
<li>ECS와 완전히 호환됨, S3 지원</li>
<li>IAM을 통해 액세스 관리 (권한 에러 =&gt; policy 문제)</li>
<li>이미지 취약성 스캐닝(image vulnerability scanning), 버저닝, 이미지 태그, 이미지 라이프사이클 지원</li>
</ul>
<h2 id="amazon-eks"><a class="header" href="#amazon-eks">Amazon EKS</a></h2>
<h3 id="eks---overview"><a class="header" href="#eks---overview">EKS - Overview</a></h3>
<ul>
<li>EKS = Elastic <strong>Kubernetes</strong> Service</li>
<li><strong>AWS에서의 관리형 쿠버네티스 클러스터를 실행하는 방법</strong></li>
<li>쿠버네티스?
<ul>
<li>컨테이너형(보통은 Docker) 애플리케이션을 자동 배포, 스케일링, 관리해주기 위한 오픈소스 시스템</li>
</ul>
</li>
<li>ECS의 대체제로 쓰일 수 있고, 유사한 목표를 지녔으나 API가 다름</li>
<li>EKS는
<ul>
<li><strong>EC2</strong>로 워커 노드를 배포할 수도 있고</li>
<li><strong>Fargate</strong>로 서버리스 컨테이너 배포를 할 수도 있음</li>
</ul>
</li>
<li><strong>사례</strong>:
<ul>
<li>온-프레미스 또는 다른 클라우드를 통해서 이미 쿠버네티스를 사용하고 있어 이를 AWS에 마이그레이션하고자 하는 경우</li>
</ul>
</li>
<li><strong>쿠버네티스는 클라우드에 구애받지 않음(cloud-agnostic)</strong> (어떤 클라우드에서건 사용될 수 있음 - Azure, GCP, ...)</li>
</ul>
<h3 id="eks---diagram"><a class="header" href="#eks---diagram">EKS - Diagram</a></h3>
<p><img src="https://d1.awsstatic.com/partner-network/QuickStart/datasheets/amazon-eks-on-aws-architecture-diagram.64cf0e40c45ade8107daf6a3ef5e2e05134d9a4b.png" alt="EKS Diagram" /></p>
<h3 id="eks---node-types"><a class="header" href="#eks---node-types">EKS - Node Types</a></h3>
<ul>
<li><strong>Managed Node Groups</strong>
<ul>
<li>노드(EC2 인스턴스)를 생성 및 관리해줌</li>
<li>노드는 EKS가 관리하는 ASG의 일부</li>
<li>On-Demand 또는 Spot Instance 지원</li>
</ul>
</li>
<li><strong>Self-Managed Nodes</strong>
<ul>
<li>노드를 직접 생성하여, EKS 클러스터에 등록하고, ASG가 이를 관리하도록 함</li>
<li>prebuilt AMI를 사용할 수 있음 - Amazon EKS Optimized AMI</li>
<li>On-Demand 또는 Spot Instance 지원</li>
</ul>
</li>
<li><strong>AWS Fargate</strong>
<ul>
<li>별도의 유지관리 필요 없음; 노드 관리가 필요 없음</li>
</ul>
</li>
</ul>
<h3 id="eks---data-volumes"><a class="header" href="#eks---data-volumes">EKS - Data Volumes</a></h3>
<ul>
<li>EKS 클러스터에 <strong>StorageClass</strong> manifest를 정의할 필요 있음</li>
<li>Container Storage Interface(CSI) 호환 드라이버를 활용함</li>
<li>다음을 지원
<ul>
<li>Amazon EBS</li>
<li>Amazon EFS (Fargate 지원)</li>
<li>Amazon FSx for Lustre</li>
<li>Amazon FSx for NetApp ONTAP</li>
</ul>
</li>
</ul>
<h2 id="aws-app-runner"><a class="header" href="#aws-app-runner">AWS App Runner</a></h2>
<ul>
<li>웹 앱과 API 규모에 맞게 쉡개 배포해주는 완전 관리형 서비스</li>
<li>별도의 인프라 경험이 없어도 됨</li>
<li>소스 코드 또는 컨테이너 이미지만 있으면 됨</li>
<li>자동으로 웹 앱을 빌드 &amp; 배포</li>
<li>다음 내용들을 자동으로 처리
<ul>
<li>스케일링</li>
<li>고가용성(HA)</li>
<li>로드 밸런서</li>
<li>암호화</li>
</ul>
</li>
<li>VPC 액세스 지원</li>
<li>DB, 캐시, 메시지 큐 서비스와 연결됨</li>
<li>사례: 웹앱, API, 마이크로서비스, 빠른 프로덕션 배포</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="serverless"><a class="header" href="#serverless">Serverless</a></h1>
<h2 id="whats-serverless"><a class="header" href="#whats-serverless">What's serverless?</a></h2>
<ul>
<li>서버리스는 개발자들이 더 이상 서버를 관리할 필요가 없다는 새로운 패러다임</li>
<li>그냥 코드 / 함수를 배포</li>
<li>초기에는 Serverless == FaaS (Fucntion as a Service)</li>
<li>서버리스는 AWS Lambda로부터 시작되었으나, 이제는 그 외의 것들도 포함하기 시작함: 데이터베이스, 메시징, 스토리지 등등...</li>
<li><strong>서버리스가 말그대로 서버가 없음을 의미하지는 않음</strong>
<ul>
<li>서버를 관리 / 프로비저닝할 필요가 없다는 의미</li>
</ul>
</li>
</ul>
<h2 id="serverless-in-aws"><a class="header" href="#serverless-in-aws">Serverless in AWS</a></h2>
<ul>
<li>AWS Lambda</li>
<li>DynamoDB</li>
<li>AWS Cognito</li>
<li>AWS API Gateway</li>
<li>Amazon S3</li>
<li>AWS SNS &amp; SQS</li>
<li>AWS Kinesis Data Firehose</li>
<li>Aurora Serverless</li>
<li>Step Functions</li>
<li>Fargate</li>
</ul>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<h3 id="aws-lambda---why-aws-lambda"><a class="header" href="#aws-lambda---why-aws-lambda">AWS Lambda - Why AWS Lambda</a></h3>
<ul>
<li>Amazon EC2
<ul>
<li>클라우드에 있는 가상 서버</li>
<li>RAM / CPU에 의해 제한됨</li>
<li>끊임없이 실행됨</li>
<li>스케일링 -&gt; 서버의 추가/제거를 중재</li>
</ul>
</li>
<li>Amazon Lambda
<ul>
<li>가상 <strong>함수</strong> - 관리할 서버가 따로 없음</li>
<li>시간에 제약 - <strong>짧게 실행</strong></li>
<li><strong>온-디맨드</strong>로 실행됨</li>
<li><strong>스케일링이 자동으로 이루어짐</strong></li>
</ul>
</li>
</ul>
<h3 id="aws-lambda---benefits-of-aws-lambda"><a class="header" href="#aws-lambda---benefits-of-aws-lambda">AWS Lambda - Benefits of AWS Lambda</a></h3>
<ul>
<li>간단한 요금 책정
<ul>
<li>각 요청과 컴퓨팅 시간을 기반으로 지불</li>
<li>프리티어 - 1,000,000 AWS Lambda 요청 &amp; 400,000 GB의 컴퓨팅 시간</li>
</ul>
</li>
<li>전체 AWS 서비스들와 호환</li>
<li>여러 프로그래밍 언어와 호환</li>
<li>AWS CloudWatch를 통해 쉽게 모니터링</li>
<li>각 함수 별로 리소스 할당을 쉽게 할 수 있음 (최대 10GB RAM)</li>
<li>RAM을 상승시키면 CPU와 네트워크 성능도 향상됨</li>
</ul>
<h3 id="aws-lambda---language-support"><a class="header" href="#aws-lambda---language-support">AWS Lambda - Language support</a></h3>
<ul>
<li>Node.js (JS)</li>
<li>Python</li>
<li>Java (Java 8 compatible)</li>
<li>C# (.NET Core)</li>
<li>Golang</li>
<li>C# / Powershell</li>
<li>Ruby</li>
<li>Custom Runtime API (커뮤니티 지원, ex. Rust)</li>
<li>Lambda Container Image
<ul>
<li>컨테이너 이미지가 반드시 Lambda Runtime API를 구현해야 함</li>
<li>그 외의 임의의 Docker 이미지를 실행하는 데에는 ECS / Fargate가 선호됨</li>
</ul>
</li>
</ul>
<h3 id="aws-lambda---integrations-main-ones"><a class="header" href="#aws-lambda---integrations-main-ones">AWS Lambda - Integrations Main ones</a></h3>
<ul>
<li>API Gateway</li>
<li>Kinesis</li>
<li>DynamoDB</li>
<li>S3</li>
<li>CloudFront</li>
<li>CloudWatch Events EventBridge</li>
<li>CloudWatch Logs</li>
<li>SNS</li>
<li>SQS</li>
<li>Cognito</li>
</ul>
<h3 id="aws-lambda---pricing-example"><a class="header" href="#aws-lambda---pricing-example">AWS Lambda - Pricing Example</a></h3>
<ul>
<li>각 <strong>호출</strong>마다:
<ul>
<li>첫 1,000,000개의 요청은 무료</li>
<li>그 이후의 1,000,000 요청마다 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0.20</span><span class="mopen">(</span><span class="mord hangul_fallback">각요청마다</span></span></span></span>0.0000002)</li>
</ul>
</li>
<li>각 <strong>이용시간</strong>마다: (1ms 단위로)
<ul>
<li>매 달 400,000GB-seconds의 컴퓨팅 시간에 대해선 무료
<ul>
<li>== 1GB RAM인 함수로 400,000초</li>
<li>== 128MB RAM인 함수로 3,200,000초</li>
</ul>
</li>
<li>그 이후의 사용량에 대해서는 600,000GB-seconds에 대해 1.00</li>
</ul>
</li>
<li>결론적으로, <strong>매우 싸기</strong> 때문에 <strong>인기가 많음</strong></li>
</ul>
<h3 id="aws-lambda---limits-to-know--per-region"><a class="header" href="#aws-lambda---limits-to-know--per-region">AWS Lambda - Limits to Know ~ <strong>per region</strong></a></h3>
<ul>
<li><strong>Execution</strong>:
<ul>
<li>메모리 할당: 128MB ~ 10GB (1MB 단위)</li>
<li>최대 실행 시간: 900s (15분)</li>
<li>환경 변수 (4KB)</li>
<li>&quot;함수 컨테이너(function container)&quot;의 디스크 할당량 (in /tmp): 512MB ~ 10GB</li>
<li>동시 실행: 1000 (증가 가능)</li>
</ul>
</li>
<li><strong>Deployment</strong>
<ul>
<li>람다 함수 배포 사이즈 (.zip으로 압축): 50MB</li>
<li>비압축 배포 사이즈 (code + dependencies): 250MB</li>
<li>시작 시 다른 파일들을 불러오고자 한다면 <code>/tmp</code> 디렉토리를 사용할 수 있음</li>
<li>환경 변수 사이즈: 4KB</li>
</ul>
</li>
</ul>
<h3 id="aws-lambda---customization-at-the-edge"><a class="header" href="#aws-lambda---customization-at-the-edge">AWS Lambda - Customization At The Edge</a></h3>
<ul>
<li>많은 최신 애플리케이션은 엣지에서 어떤 형태의 로직을 실행함</li>
<li><strong>Edge Function</strong>:
<ul>
<li>CloudFront 배포에 작성 및 연결된 코드</li>
<li>레이턴시를 줄이기 위해 이용자에게 가까운 위치에서 실행됨</li>
</ul>
</li>
<li>CloudFront는 두 가지 타입의 방법을 제시
<ul>
<li><strong>CloudFront Functions</strong></li>
<li><strong>Lambda@Edge</strong></li>
</ul>
</li>
<li>별도로 서버를 관리할 필요 없고, 글로벌로 배포됨</li>
<li>사례: CDN 컨텐츠를 커스터마이징</li>
<li>사용할 때에만 비용 지불</li>
<li>완전한 서버리스</li>
</ul>
<h3 id="aws-lambda---cloudfront-functions--lambdaedge--use-cases"><a class="header" href="#aws-lambda---cloudfront-functions--lambdaedge--use-cases">AWS Lambda - CloudFront Functions &amp; Lambda@Edge ~ Use Cases</a></h3>
<ul>
<li>웹사이트 보안 &amp; 프라이버시</li>
<li>엣지에 동적 웹 앱 배포</li>
<li>SEO</li>
<li>오리진 및 데이터 센터 간에 지능적인 라우팅</li>
<li>엣지에서 봇 차단(bot mitigation)</li>
<li>실시간 이미지 변환</li>
<li>A/B 테스팅</li>
<li>이용자 인증(authentication) 및 권한 부여(authorization)</li>
<li>이용자 우선순위 지정</li>
<li>이용자 트래킹 &amp; 분석</li>
</ul>
<h3 id="cloudfront-functions"><a class="header" href="#cloudfront-functions">CloudFront Functions</a></h3>
<ul>
<li>JS로 작성되는 가벼운 함수</li>
<li>지연 시간에 민감한, 대규모 CDN 커스터마이징에 적합</li>
<li>ms 미만의 startup 시간, <strong>초당 million(백만개) 요청</strong></li>
<li>viewer 요청과 응답을 변경하는 데에 사용
<ul>
<li><strong>Viewer Request</strong>: CloudFront가 viewer로부터 요청을 받은 후</li>
<li><strong>Viewer Response</strong>: CloudFront가 viewer로 응답을 보내기 전</li>
</ul>
</li>
</ul>
<h3 id="lambdaedge"><a class="header" href="#lambdaedge">Lambda@Edge</a></h3>
<ul>
<li>NodeJS 또는 Python을 통해 작성되는 람다 함수</li>
<li><strong>초당 1000개의 요청</strong> 수준으로 스케일링 가능</li>
<li>CloudFront 요청/응답을 변경하기 위해 사용:
<ul>
<li><strong>Viewer Request</strong> - CloudFront가 viewer로부터 요청을 받은 이후</li>
<li><strong>Origin Request</strong> - CloudFront가 origin으로 요청을 보내기 전</li>
<li><strong>Origin Response</strong> - CloudFront가 origin으로부터 응답을 받은 이후</li>
<li><strong>Viewer Response</strong> - CloudFront가 viewer로 응답을 보내기 전</li>
</ul>
</li>
<li>함수를 AWS 리전(us-east-1)에서 생성한 다음, CloudFront가 해당 위치로 복제</li>
</ul>
<h3 id="cloudfront-functions-vs-lambdaedge"><a class="header" href="#cloudfront-functions-vs-lambdaedge">CloudFront Functions vs. Lambda@Edge</a></h3>
<ul>
<li><strong>CloudFront Functions</strong>
<ul>
<li>Cache key normalization
<ul>
<li>요청 attributes들을 변환(헤더, 쿠키, 쿼리스트링, URL)하여 최적의 캐시 키를 생성</li>
</ul>
</li>
<li>Header manipulation
<ul>
<li>요청 또는 응답에서 HTTP 헤더를 삽입/수정/삭제</li>
</ul>
</li>
<li>URL 재작성 또는 리다이렉트</li>
<li>요청 인증 &amp; 권한 부여
<ul>
<li>요청 허용/거부를 위해 이용자 생성 토큰(ex. JWT)을 생성 및 검증</li>
</ul>
</li>
</ul>
</li>
<li><strong>Lambda@Edge</strong>
<ul>
<li>더 긴 실행 시간 (몇 ms)</li>
<li>조정 가능한 CPU 또는 메모리</li>
<li>써드파티 라이브러리에 의존 (ex. 다른 AWS 서비스에 접근하기 위해 AWS SDK 사용)</li>
<li>네트워크 액세스를 통해 처리에 필요한 외부 서비스를 사용</li>
<li>파일 시스템 액세스 또는 HTTP 요청의 바디에 액세스</li>
</ul>
</li>
</ul>
<h3 id="aws-lambda---by-default"><a class="header" href="#aws-lambda---by-default">AWS Lambda - by default</a></h3>
<ul>
<li>기본적으로, 람다 함수는 내가 보유한 VPC의 외부에서 실행됨 (AWS가 소유한 VPC에서)</li>
<li>그래서 내 VPC에 있는 리소스들에 액세스할 수 없음 (RDS, ElastiCache, internal ELB...)</li>
</ul>
<h3 id="aws-lambda---in-vpc"><a class="header" href="#aws-lambda---in-vpc">AWS Lambda - in VPC</a></h3>
<ul>
<li>반드시 VPC ID, 서브넷, Security Group을 정의해야 함</li>
<li>Lambda가 내 서브넷 내에 ENI(Elastic Network Interface)를 생성함</li>
</ul>
<h3 id="aws-lambda---with-rds-proxy"><a class="header" href="#aws-lambda---with-rds-proxy">AWS Lambda - with RDS Proxy</a></h3>
<ul>
<li>만약 Lambda 함수가 데이터베이스에 직접 연결된다면, 부하가 높은 상태에서 너무 많은 DB open이 일어날 것임</li>
<li>RDS Proxy
<ul>
<li>DB 연결을 풀링 및 공유함으로써 scalability 향상</li>
<li>failover 시간을 66% 감소시키고, 연결을 보존함으로써 availability 향상</li>
<li>IAM 인증을 적용하고 Secret Manager에 자격증명을 보관함으로써 security 향상</li>
</ul>
</li>
<li><strong>람다 함수는 반드시 VPC에 배포되어야 함</strong> -&gt; *<strong>RDS Proxy는 절대로 public하게 접근가능해서는 안되기 때문</strong></li>
</ul>
<h3 id="aws-lambda---invoking-lambda-from-rds--aurora"><a class="header" href="#aws-lambda---invoking-lambda-from-rds--aurora">AWS Lambda - Invoking Lambda from RDS &amp; Aurora</a></h3>
<ul>
<li>DB 인스턴스 내에서 람다 함수를 호출</li>
<li>DB 내에서 <strong>데이터 이벤트</strong>를 처리할 수 있음</li>
<li><strong>RDS for PostgreSQL과 Aurora MySQL</strong>을 지원</li>
<li>DB 인스턴스에서 <strong>Lambda 함수로 향하는 아웃바운드 트래픽을 반드시 허용해야 함</strong> (Public, NAT GW, VPC Endpoints)</li>
<li><strong>DB 인스턴스는 반드시 Lambda 함수를 실행하기 위해 요구되는 권한을 갖고 있어야 함</strong> (Lambda Resource-based Policy &amp; IAM Policy)</li>
</ul>
<h3 id="rds-event-notifications"><a class="header" href="#rds-event-notifications">RDS Event Notifications</a></h3>
<ul>
<li>DB 인스턴스 자체에 대한 정보(생성, 중지, 시작, ..)를 알려주는 Notification</li>
<li>데이터 자체에 대한 정보는 얻을 수 없음</li>
<li>다음의 이벤트 카테고리들을 구독:
<ul>
<li><strong>DB instance, DB snapsho, DB Parameter Group, DB Security Group, RDS Proxy, Custom Engine Version</strong></li>
</ul>
</li>
<li>거의 실시간 이벤트 (최대 5분)</li>
<li>SNS로 알림을 전달하거나 EventBridge를 통해 이벤트를 구독</li>
</ul>
<h2 id="amazon-dynamodb"><a class="header" href="#amazon-dynamodb">Amazon DynamoDB</a></h2>
<ul>
<li>multi AZ로 replication을 함으로써 고가용성(high availability)을 지닌 완전 관리형 DB</li>
<li>NoSQL DB (Not RDB) - transaction 지원</li>
<li>많은 양의 워크로드에 대해서도 스케일링 가능, 분산형 DB</li>
<li>매초 1 million 요청, 1 trillion 행, 100TB 스토리지</li>
<li>빠르고, 일관적인 성능 (single-digit ms)</li>
<li>보안, 인증 및 관리를 위해 IAM 지원</li>
<li>낮은 비용, 자동 스케일링 기능</li>
<li>유지보수하거나 패칭(patch)할 필요 없음, 항상 available함</li>
<li>Standard &amp; Infrequent Access (IA) Table Class</li>
</ul>
<h3 id="dynamodb---basics"><a class="header" href="#dynamodb---basics">DynamoDB - Basics</a></h3>
<ul>
<li>DynamoDB는 <strong>Table</strong>들로 구성</li>
<li>각 테이블은 <strong>Primary Key</strong>를 가짐 (생성 시점에 반드시 결정되어야 함)</li>
<li>각 테이블은 무한한 개수의 Item(= row)를 가질 수 있음</li>
<li>각 아이템은 <strong>attribute</strong>를 가짐 (추후에도 추가될 수 있음 - null일 수 있음)</li>
<li>한 아이템의 최대 크기는 <strong>400KB</strong></li>
<li>다음의 데이터 타입들이 지원됨:
<ul>
<li><strong>Scalar Types</strong> - String, Number, Binary, Boolean, Null</li>
<li><strong>Document Types</strong> - List, Map</li>
<li><strong>Set Types</strong> - String Set, Number Set, Binary Set</li>
</ul>
</li>
<li><strong>결국, DynamoDB에서는 빠르게 스키마를 발전시킬 수 있음</strong></li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2018/09/10/dynamodb-partition-key-1.gif" alt="DynamoDB Table Example" /></p>
<h3 id="dynamodb---readwrite-capacity-modes"><a class="header" href="#dynamodb---readwrite-capacity-modes">DynamoDB - Read/Write Capacity Modes</a></h3>
<ul>
<li>
<p>테이블 가용량(capcity)을 어떻게 관리할 것인지를 설정 (read/write throughput)</p>
</li>
<li>
<p><strong>Provisioned Mode (기본)</strong></p>
<ul>
<li>초당 read/write 개수를 정의</li>
<li>미리 capacity를 계획해야 함</li>
<li><strong>프로비전된</strong> Read Capacity Unit(RCU)와 Write Capacity Units(WC)만큼 비용 지불</li>
<li>RCU &amp; WCU에 대한 <strong>오토 스케일링</strong> 모드를 추가할 수 있음</li>
</ul>
</li>
<li>
<p><strong>On-Demand Mode</strong></p>
<ul>
<li>워크로드에 따라 자동으로 R/W가 스케일링됨</li>
<li>따로 capacity를 계획하지 않아도 됨</li>
<li>사용한 만큼 더 많은 비용 지불</li>
<li><strong>예측이 불가능한</strong> 워크로드,  <strong>steep sudden spikes</strong>에 유용함,</li>
</ul>
</li>
</ul>
<h3 id="dynamodb---dynamodb-accelerator-dax"><a class="header" href="#dynamodb---dynamodb-accelerator-dax">DynamoDB - DynamoDB Accelerator (DAX)</a></h3>
<ul>
<li>DynamoDB를 위한 fully-managed, highly available, seamless 인-메모리 캐시</li>
<li><strong>캐싱을 통해 읽기 혼잡도를 해결하는데 도움</strong></li>
<li><strong>캐시된 데이터에 대해 ms 단위 레이턴시</strong></li>
<li>별도의 애플리케이션 로직 수정을 요구하지 않음 (기존 DynamoDB API들과 호환됨)</li>
<li>캐시에 5분의 TTL (기본)</li>
</ul>
<h3 id="dynamodb---dynamodb-accelerator-dax-vs-elasticache"><a class="header" href="#dynamodb---dynamodb-accelerator-dax-vs-elasticache">DynamoDB - DynamoDB Accelerator (DAX) vs. ElastiCache</a></h3>
<ul>
<li>Amazon ElasticCache
<ul>
<li>aggregatio 결과를 저장</li>
</ul>
</li>
<li>DynamoDB Accelerator (DAX)
<ul>
<li>개별 오브젝트 캐시</li>
<li>캐시를 쿼리 &amp; 스캔</li>
</ul>
</li>
</ul>
<h3 id="dynamodb---stream-processing"><a class="header" href="#dynamodb---stream-processing">DynamoDB - Stream Processing</a></h3>
<ul>
<li>테이블에서의 item 수정(create/update/delete)의 ordered stream</li>
<li>사례:
<ul>
<li>실시간 변화에 대한 반응 (이용자들에게 welcome email 전송)</li>
<li>실시간 사용 분석</li>
<li>파생(derivative) 테이블에 insert</li>
<li>cross-region replication 수행</li>
<li>DynamoDB 테이블의 변경에 따른 AWS Lambda 실행</li>
</ul>
</li>
<li><strong>DynamoDB Streams</strong>
<ul>
<li>24시간 보존</li>
<li>제한된 수의 consumer</li>
<li>AWS Lambda Trigger 또는 DynamoDB Stream Kinesis adapter를 통해 처리</li>
</ul>
</li>
<li><strong>Kinesis Data Streams (newer)</strong>
<ul>
<li>1년 보존</li>
<li>많은 수의 consumer</li>
<li>AWS Lambda, Kinesis Data Analytics, Kinesis Data Firehose, AWS Glue Streaming ETL 등을 통해 처리</li>
</ul>
</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2021/05/06/DDB-Design-patterns-v1.3.jpg" alt="DynamoDB Streams" /></p>
<h3 id="dynamodb---global-tables"><a class="header" href="#dynamodb---global-tables">DynamoDB - Global Tables</a></h3>
<ul>
<li>여러 리전 내에 DynamoDB 테이블을 <strong>낮은 레이턴시</strong>로 액세스 가능한 상태로 만들어 줌</li>
<li>Active-Active replication</li>
<li>어떤 리전에서든 <strong>READ</strong>, <strong>WRTIE</strong>작업을 수행할 수 있음</li>
<li>전제조건(pre-requisite)으로, DynamoDB Stream이 활성화되어 있어야 함</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2018/12/20/Globeimage.png" alt="DynamoDB Global Table" /></p>
<h3 id="dynamodb---time-to-live-ttl"><a class="header" href="#dynamodb---time-to-live-ttl">DynamoDB - Time To Live (TTL)</a></h3>
<ul>
<li>만료(expiry) 타임스탬프가 지나면 아이템을 삭제</li>
<li>사례:
<ul>
<li>오직 현재 item들만 보유함으로써 저장된 데이터 줄이기</li>
<li>규제 의무(regulatory obligations) 준수</li>
<li>웹 세션 핸들링</li>
</ul>
</li>
</ul>
<h3 id="dynamodb---backups-for-disaster-recovery"><a class="header" href="#dynamodb---backups-for-disaster-recovery">DynamoDB - Backups for disaster recovery</a></h3>
<ul>
<li>point-in-time recovery(PITR)를 통한 지속적인 백업
<ul>
<li>지난 35일 동안 선택적으로 활성화</li>
<li>Point-in-time recovery -&gt; 백업 기간 내라면 어느 시점이건 가능</li>
<li>recovery 작업은 새로운 테이블을 생성함</li>
</ul>
</li>
<li>On-demand backups
<ul>
<li>명시적으로 삭제하기 전까지 장기 보존을 위해 전체 백업</li>
<li>성능이나 레이턴시에 영향을 끼치지 않음</li>
<li>AWS Backup 내에서 설정하거나 관리할 수 있음 (리전 간 복사 가능)</li>
<li>recovery 작업은 새로운 테이블을 생성함</li>
</ul>
</li>
</ul>
<h3 id="dynamodb---inregration-with-amazon-s3"><a class="header" href="#dynamodb---inregration-with-amazon-s3">DynamoDB - Inregration with Amazon S3</a></h3>
<ul>
<li>
<p><strong>S3로 내보내기 (PITR 활성화 필수) ~ export</strong></p>
<ul>
<li>최근 35일 동안의 어느 시점이건 실행 가능</li>
<li>테이블의 읽기 가용량에 영향을 끼치지 않음</li>
<li>DynamoDB의 상위에서 데이터 분석을 수행</li>
<li>감사(audit)를 위해 스냅샷을 유지</li>
<li>DynamoDB로 다시 가져오기 전에 S3 데이터 위에 ETL(Extract, Load, Transfer)을 수행</li>
<li>Dynamo JSON 또는 ION 포맷으로 내보내기</li>
</ul>
</li>
<li>
<p><strong>S3로부터 가져오기 ~ import</strong></p>
<ul>
<li>CSV, Dynamo JSON 또는 ION 포맷으로 임포트</li>
<li>어떤 write capacity도 소비하지 않음</li>
<li>새로운 테이블을 생성함</li>
<li>임포트 에러 발생 시 CloudWatch 로그로 로깅됨</li>
</ul>
</li>
</ul>
<h2 id="aws-api-gateway"><a class="header" href="#aws-api-gateway">AWS API Gateway</a></h2>
<h3 id="api-gateway---overview"><a class="header" href="#api-gateway---overview">API Gateway - Overview</a></h3>
<ul>
<li>AWS Lambda + API Gateway: 관리가 필요한 인프라가 없음</li>
<li>WebSocker 프로토콜 지원</li>
<li>API 버저닝 (v1, v2, ...)</li>
<li>저마다 다른 환경(dev, test, prod..) 처리</li>
<li>보안 처리 - 인증 및 권한 부여</li>
<li>API 키 생성, 요청 쓰로틀링 처리</li>
<li>빠른 API 정의를 위한 Swagger / Open API 가져오기</li>
<li>요청/응답 검증 및 변환</li>
<li>SDK 및 API 사양(specification) 생성</li>
<li>API 응답 캐시</li>
</ul>
<h3 id="api-gateway---integrations-high-level"><a class="header" href="#api-gateway---integrations-high-level">API Gateway - Integrations High Level</a></h3>
<ul>
<li><strong>Lambda Function</strong>
<ul>
<li>람다 함수 실행</li>
<li>AWS 람다를 통한 REST API 백엔드를 노출(expose)시키는 쉬운 방법</li>
</ul>
</li>
<li><strong>HTTP</strong>
<ul>
<li>백엔드에 HTTP 엔드포인트를 노출</li>
<li>사례: 온-프레미스에서의 내부 HTTP API, ALB...</li>
<li>왜? - 속도 제한, 캐싱, 이용자 인증, API 키, 등등..</li>
</ul>
</li>
<li><strong>AWS Service</strong>
<ul>
<li>API Gateway를 통한 어떤 AWS API든 노출</li>
<li>사례: AWS Step Function workflow 실행, SQS에 메시지 전송</li>
<li>왜? - 인증 추가, 공개 배포, 속도 제한...</li>
</ul>
</li>
</ul>
<h3 id="api-gateway---endpoint-types"><a class="header" href="#api-gateway---endpoint-types">API Gateway - Endpoint Types</a></h3>
<ul>
<li><strong>Edge-Optimized (기본)</strong>:
<ul>
<li>글로벌 클라이언트 대상</li>
<li>CloudFront 엣지 로케이션을 통해 요청이 라우트됨 (latency 상승)</li>
<li>API Gateway 자체는 여전히 하나의 리전에 존재함</li>
</ul>
</li>
<li><strong>Regional</strong>:
<ul>
<li>동일한 리전 내에 있는 클라이언트 대상</li>
<li>CloudFront와 매뉴얼하게 조합될 수 있음 (캐싱 전략 및 배포에 대해 더 많은 제어 가능)</li>
</ul>
</li>
<li><strong>Private</strong>:
<ul>
<li>인터페이스 VPC 엔드포인트(ENI)를 통해, 오직 내 VPC로부터만 액세스가 가능함</li>
<li>액세스를 정의하는 리소스 정책(resource policy)을 사용</li>
</ul>
</li>
</ul>
<h3 id="api-gateway---security"><a class="header" href="#api-gateway---security">API Gateway - Security</a></h3>
<ul>
<li><strong>User Authentication</strong> ~ 아래의 것들을 사용
<ul>
<li>IAM Roles (내부적인 애플리케이션에 유용)</li>
<li>Cognito (외부 이용자들을 식별 ~ ex. mobile users)</li>
<li>Custom Authorizer (직접 로직 작성)</li>
</ul>
</li>
<li><strong>Custom Domain Name HTTPS</strong> ~ AWS Certificate Manager(ACM)과 함께 사용
<ul>
<li>Edge-Optimized 엔드포인트를 사용하는 경우, 반드시 인증서가 <strong>us-east-1</strong>에 있어야 함</li>
<li>Regional 엔드포인트를 사용하는 경우, 반드시 API Gateway가 위치한 리전에 인증서가 있어야 함</li>
<li>Route 53 내에 CNAME 또는 A 레코드가 반드시 설정되어야 함</li>
</ul>
</li>
</ul>
<h2 id="aws-step-functions"><a class="header" href="#aws-step-functions">AWS Step Functions</a></h2>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/14/03_architecture_diagram.png" alt="Step functions" /></p>
<ul>
<li>람다 함수를 오케스트레이션하기 위해 서버리스의 시각적인 워크플로를 구축</li>
<li><strong>기능</strong>: sequence, parallel, conditions, timeouts, error handling, ...</li>
<li>EC2, ECS, 온-프레미스 서버, API 게이트웨이, SQS 큐 등과 호환</li>
<li>human approval한 기능을 만들 수 있음</li>
<li><strong>사례</strong>: 주문 처리, 데이터 프로세싱, 웹 애플리케이션, 어떤 워크플로든지</li>
</ul>
<h2 id="amazon-cognito"><a class="header" href="#amazon-cognito">Amazon Cognito</a></h2>
<ul>
<li>웹/모바일 애플리케이션과 상호작용하는 이용자들을 식별하기 위함</li>
<li><strong>Cognito User Pools</strong>:
<ul>
<li>애플리케이션 이용자들에 대한 로그인(sign in) 기능</li>
<li>API Gateway &amp; ALB와 호환</li>
</ul>
</li>
<li><strong>Cognito Identity Pools (Federated Identity)</strong>:
<ul>
<li>이용자들에게 AWS credential을 부여하여 AWS 리소스들에 직접 액세스할 수 있도록 함</li>
<li>Cognito User pool을 ID 공급자로서 활용</li>
</ul>
</li>
<li><strong>Cognito vs IAM</strong>: &quot;hundreds of users&quot;, &quot;mobile users&quot;, &quot;authenticate with SAML&quot;</li>
</ul>
<h3 id="cognito---cognito-user-poolscup--user-features"><a class="header" href="#cognito---cognito-user-poolscup--user-features">Cognito - Cognito User Pools(CUP) ~ User Features</a></h3>
<ul>
<li>웹/모바일 앱 이용자에 대한 서버리스 DB 생성</li>
<li>간단하게 로그인: Username (or email) / password</li>
<li>패스워드 리셋 기능</li>
<li>이메일 &amp; 휴대폰 번호 인증</li>
<li>MFA 인증</li>
<li>Federated Identities: 페이스북 이용자, Google 이용자, SAML...</li>
</ul>
<h3 id="cognito---cognito-user-poolscup--integrations"><a class="header" href="#cognito---cognito-user-poolscup--integrations">Cognito - Cognito User Pools(CUP) ~ Integrations</a></h3>
<ul>
<li>CUP는 <strong>API Gateway</strong>와 <strong>Application Load Balancer</strong>와 호환됨</li>
</ul>
<h3 id="cognito---cognito-identity-pools-federated-identities"><a class="header" href="#cognito---cognito-identity-pools-federated-identities">Cognito - Cognito Identity Pools (Federated Identities)</a></h3>
<ul>
<li><strong>이용자가 임시 AWS 자격 증명을 얻을 수 있도록 이용자들의 ID를 가져옴</strong></li>
<li>이용자 소스는 Cognito User Pools나 그외의 써드 파티 로그인 등이 될 수 있음</li>
<li><strong>이용자들은 직접 또는 API Gateway를 통해 AWS 서비스들에 액세스할 수 있음</strong></li>
<li>IAM 정책은 Cognito 내에 정의된 credential에 적용됨</li>
<li>세밀한 컨트롤(fine grained control)을 위해 user_id에 기반하여 커스터마이징 할 수 있음</li>
<li>따로 정의해두지 않으면 인증 이용자, 게스트 이용자들에게는 <strong>Default IAM role</strong>이 적용됨</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/cognito/latest/developerguide/images/scenario-cup-cib.png" alt="Cognito Identity Pools" /></p>
<h3 id="cognito---cognito-identity-pools--row-level-security-in-dynamodb"><a class="header" href="#cognito---cognito-identity-pools--row-level-security-in-dynamodb">Cognito - Cognito Identity Pools ~ Row Level Security in DynamoDB</a></h3>
<pre><code class="language-json">{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Action&quot;: [
                &quot;dynamodb:DeleteItem&quot;,
                &quot;dynamodb:GetItem&quot;,
                &quot;dynamodb:PutItem&quot;,
                &quot;dynamodb:Query&quot;,
                &quot;dynamodb:UpdateItem&quot;
            ],
            &quot;Resource&quot;: [&quot;arn:aws:dynamodb:*:*:table/MyTable&quot;],
            &quot;Condition&quot;: {
                &quot;ForAllValues:StringEquals&quot;: {
                    &quot;dynamodb:LeadingKeys&quot;: [&quot;{cognito-identity.amazonaws.com:sub}&quot;] // &lt;-- HERE
                }
            }
        }
    ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="databases"><a class="header" href="#databases">Databases</a></h1>
<h2 id="choosing-the-right-batabase"><a class="header" href="#choosing-the-right-batabase">Choosing the right batabase</a></h2>
<ul>
<li>AWS에는 선택 가능한 수많은 종류의 관리형 데이터베이스가 있음</li>
<li>아키텍처에 기반하여 올바른 DB를 선택:
<ul>
<li>어떤 형태의 워크로드를 수행하는가? - Read-heavy / write-heavy / balanced?</li>
<li>Throughput이 요구 되는가?</li>
<li>하루 동안에 스케일링 또는 변동(fluctuate)가 요구되는가?</li>
<li>데이터가 얼마나 많이, 얼마나 오래 보관되는가? 더 커질 예정인가? 평균 오브젝트 사이즈는? 액세스 처리는 어떻게 할 것인가?</li>
<li>데이터 지속성(durability)은 어떤가? 데이터의 신뢰할 수 있는 출처는 어디인가?</li>
<li>레이턴시 요구사항은 어떤가? 여러 이용자가 동시에 이용할 수 있는가?</li>
<li>데이터 모델은? 어떻게 데이터를 쿼리할 것인가? joins? structured? semi-structured?</li>
<li>강한 스키마를 갖는가? 더 유연해야 하는가? 리포팅과 검색은? RDBMS / NoSQL?</li>
<li>라이센스 비용은? Aurora 같은 클라우드 네이티브 DB로 옮길 가능성이 있나?</li>
</ul>
</li>
</ul>
<h2 id="database-types"><a class="header" href="#database-types">Database Types</a></h2>
<ul>
<li><strong>RDBMS (= SQL / OLTP)</strong>: RDS, Aurora - join 작업에 유용</li>
<li><strong>NoSQL - no joins, no SQL</strong>: DynamoDB(~JSON), ElastiCache (key/value pairs), Neptune (graphs), DocumentDB (for MongoDB), Keyspaces (for Apache Cassandra)</li>
<li><strong>Object Store</strong>: S3 (큰 오브젝트의 경우) / Glacier (백업 / 아카이빙 용도)</li>
<li><strong>Data Warehouse (= SQL Analytics / BI)</strong>: Redshift (OLAP), Athena, EMR</li>
<li><strong>Search</strong>: OpenSearch (JSON) - 자유 텍스트, 비정형 검색(unstructured searches)</li>
<li><strong>Graph</strong>: Amazon Neptune - 데이터 간의 관계 표시</li>
<li><strong>Ledger</strong>: Amazon Quantum Ledger Database</li>
<li><strong>Time series</strong>: Amazon Timestream</li>
</ul>
<h2 id="amazon-rds---summary"><a class="header" href="#amazon-rds---summary">Amazon RDS - Summary</a></h2>
<ul>
<li>관리형 PostgreSQL / MySQL / Oracle / SQL Server / MariaDB / 커스텀</li>
<li>프로비전된 RDS 인스턴스 사이즈와 EBS Volume 타입 &amp; 사이즈</li>
<li>스토리지에 대한 가용량(capacity)를 오토 스케일링</li>
<li>Read Replica와 Multi AZ 지원</li>
<li>IAM, Security Groups, KMS, SSL in transit을 통한 보안</li>
<li>Point-in-time 복구 기능으로 자동 백업 (최대 35일까지)</li>
<li>장기 복구를 위한 수동 DB 스냅샷</li>
<li>유지보수 관리 및 예약 (downtime 포함)</li>
<li>IAM 인증 및 Secret Manager와의 호환</li>
<li>RDS 인스턴스에 접근 및 커스터마이징하기 위하여 RDS Custom 사용 가능 (Oracle &amp; SQL Server)</li>
</ul>
<blockquote>
<p><strong>사례</strong>: 관계형 데이터셋 저장(RDBMS / OLTP), SQL 쿼리와 트랜잭션을 수행해야 하는 경우</p>
</blockquote>
<h2 id="amazon-aurora---summary"><a class="header" href="#amazon-aurora---summary">Amazon Aurora - Summary</a></h2>
<ul>
<li>PostgreSQL / MySQL과 호환가능한 API, 스토리지와 컴퓨팅 분리</li>
<li>Storage: 데이터가 3개의 AZ에 걸쳐 6개의 replica에 저장됨 - high available, self-healing, auto-scaling</li>
<li>Compute: multi-AZ를 통한 DB 인스턴스 클러스터, Read Replica에 대한 오토 스케일링</li>
<li>Cluster: writer와 reader DB 인스턴스에 대한 커스텀 엔드포인트</li>
<li>RDS와 동일한 보안 / 모니터링 / 유지보수 기능</li>
<li>Aurora의 백업 및 복원 옵션
<ul>
<li><strong>Aurora Serverless</strong> - 예측 불가능한 / 간헐적(intermittent) 워크로드, capacity planning 필요없음</li>
<li><strong>Aurora Multi-Master</strong> - 지속적인 write 장애 조치를 위함 (high write availability)</li>
<li><strong>Aurora Global</strong>: 각 리전마다 최대 16개의 DB 읽기 인스턴스, 1초 이하로 걸리는 스토리지 복제</li>
<li><strong>Aurora Machine Learning</strong>: SageMaker와 Comprehend를 통해 Aurora에서 ML을 수행</li>
<li><strong>Aurora Database Cloning</strong>: 기존에 존재하는 클러스터를 통해 새 크러스터를 만듬, 스냅샷 복구보다 빠름</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>사례</strong>: RDS와 동일하지만, 유지보수에 대한 신경이 덜하고 / 더 유연하며 / 더 성능 좋고 / 더 많은 기능을 보유</p>
</blockquote>
<h2 id="amazon-elasticache---summary"><a class="header" href="#amazon-elasticache---summary">Amazon ElastiCache - Summary</a></h2>
<ul>
<li>관리형 Redis / Memcached (RDS와 유사하지만, 캐시를 위한 것임)</li>
<li>인-메모리 데이터 스토어, ms 미만의 레이턴시</li>
<li>반드시 EC2 인스턴스 타입을 프로비전</li>
<li>클러스터링(Redis)과, Multi AZ, Read Replica (sharding)을 지원</li>
<li>IAM, Security Groups, KMS, Redis Auth를 통한 보안</li>
<li>백업 / 스냅샷 / Point-in-time 복구 기능</li>
<li>유지보수 관리 및 예약</li>
<li><strong>활용하기 위해서는 애플리케이션 코드에 대한 변경이 필요함</strong></li>
</ul>
<blockquote>
<p><strong>사례</strong>: Key/Value 스토어, 빈번한 read / 적은 write, DB 쿼리 결과 캐싱, 웹사이트 세션 데이터 저장, SQL은 쓸 수 없음</p>
</blockquote>
<h2 id="amazon-dynamodb---summary"><a class="header" href="#amazon-dynamodb---summary">Amazon DynamoDB - Summary</a></h2>
<ul>
<li>AWS 독점의 관리형 서버리스 NoSQL 데이터베이스, ms 단위 레이턴시</li>
<li>capacity mode:
<ul>
<li>provisioned capacity (오토 스케일링 옵션 있음)</li>
<li>on-demand capacity</li>
</ul>
</li>
<li>key/value 스토어로서 ElastiCache 대체 가능 (ex. TTL 기능을 사용하여 세션 데이터 저장)</li>
<li>기본적으로 High Available, Multi AZ이며, 읽기/쓰기 작업이 분리(decoupled)되어 있고, 트랜잭션 기능 있음</li>
<li>읽기 작업 캐싱을 위한 DAX cluster - ms 단위의 읽기 레이턴시</li>
<li>IAM을 통해 보안, 인증, 권한 부여 처리</li>
<li>이벤트 처리: DynamoDB Stream은 AWS Lambda 또는 Kinesis Data Stream과 호환됨</li>
<li>Global Table 기능: active-active 셋업</li>
<li>최대 35일까지 PITR(point-in-time recovery)를 통한 자동 백업, 또는 on-demand 백업</li>
<li>Read Capacity Unit(RCU) 없이도 PITR window 내에서 S3로 내보내기 가능, WCU(Write Capacity Unit) 없이도 S3로부터 가져오기 가능</li>
<li><strong>빠르게 발전하는 스키마에 유용함</strong></li>
</ul>
<blockquote>
<p><strong>사례</strong>: 서버리스 애플리케이션 개발 (데이터가 작을 때, &lt; 100KB), 분산된 서버리스 캐시</p>
</blockquote>
<h2 id="amazon-s3---summary"><a class="header" href="#amazon-s3---summary">Amazon S3 - Summary</a></h2>
<ul>
<li>오브젝트에 대한 key/value 스토어</li>
<li>오브젝트가 큰 경우에 유용, 여러 개의 작은 오브젝트들에는 썩 좋지 않음</li>
<li>서버리스이고, 무한하게 확장하며, 최대 오브젝트 사이즈는 5TB, 버저닝 기능 있음</li>
<li><strong>Tiers</strong>: S3 Standard, S3 Infrequent Access, S3 Intelligent, S3 Glacier + lifecycle policy</li>
<li><strong>Features</strong>: Versioning, Encryption, Replication, MFA-Delete, Access Logs, ...</li>
<li><strong>Security</strong>: IAM, Bucket Policies, ACL, Access Points, Object Lambda, CORS, Object/Vault Lock</li>
<li><strong>Encryption</strong>: SSE-S3, SSE-KMS, SSE-C, client-side, TLS in transit, default encryption</li>
<li><strong>Batch operations</strong>: S3 Batch를 이용해 오브젝트들에 대한 배치 작업, S3 Inventory를 사용해 파일 리스팅</li>
<li><strong>Performance</strong>: Multi-part upload, S3 Transfer Acceleration, S3 Select</li>
<li><strong>Automation</strong>: S3 Event Notifications (SNS, SQS, Lambda, EventBridge)</li>
</ul>
<blockquote>
<p><strong>사례</strong>: 정적 파일, 거대한 파일들에 대한 key-value 스토어, 웹사이트 호스팅</p>
</blockquote>
<h2 id="documentdb"><a class="header" href="#documentdb">DocumentDB</a></h2>
<ul>
<li>Aurora가 PostgreSQL / MySQL의 AWS 구현 버전이었다면, <strong>DocumentDB는 MongoDB를 위한 AWS 구현 버전</strong> (<strong>이것도 NoSQL</strong>)</li>
<li>MongoDB는 JSON 데이터를 저장, 쿼리, 인덱싱하기 위해 사용됨</li>
<li>Aurora의 배포 컨셉(deployment concept)과 유사함</li>
<li>완전 관리형이며, 3개의 AZ에 복제함으로써 highly available</li>
<li>DocumentDB 스토리지는 10GB씩 자동으로 확장됨, 최대 64TB</li>
<li>초당 수백만(million) 건의 요청이 발생하는 워크로드에 맞게 자동으로 확장됨</li>
</ul>
<h2 id="amazon-neptune"><a class="header" href="#amazon-neptune">Amazon Neptune</a></h2>
<ul>
<li>완전 관리형 <strong>그래프</strong>(graph) 데이터베이스</li>
<li><strong>소셜 네트워크</strong>와 같은 <strong>graph dataset</strong>에 사용됨
<ul>
<li>user는 friend들을 가짐</li>
<li>post는 comments들을 가짐</li>
<li>comment는 user로부터 like를 가짐</li>
<li>user는 post를 share하거나 like를 함</li>
</ul>
</li>
<li>3개의 AZ에 걸쳐있고, 최대 15개의 read replica를 통해 highly available함</li>
<li>서로 강하게 연결되어 있는 데이터셋들을 사용하는 애플리케이션을 빌드 및 실행
<ul>
<li>이러한 복잡하고 어려운 쿼리들에 최적화됨</li>
</ul>
</li>
<li>최대 10억(billion)개의 관계(relation)을 저장하며, 그래프 쿼리를 ms단위로 수행할 수 있음</li>
<li>multi AZ에 replication을 두어 Highly available함</li>
<li>지식 그래프(knowledge graphs ~ ex. Wikepedia), 사기 감지(fraud detaction), 추천 엔진, 소셜 네트워킹에 유용함</li>
</ul>
<h2 id="amazon-keyspaces-for-apache-cassandra"><a class="header" href="#amazon-keyspaces-for-apache-cassandra">Amazon Keyspaces (for Apache Cassandra)</a></h2>
<ul>
<li>Apache Cassandra - 오픈소스 NoSQL 분산형 데이터베이스</li>
<li>관리형 Apache Cassandra 호환 데이터베이스 서비스</li>
<li>서버리스, scalable, high available, fully managed by AWS</li>
<li>애플리케이션 트래픽에 기반하여 테이블 개수를 자동으로 scale up/down</li>
<li>테이블은 multi AZ로 3번 복제됨</li>
<li>CQL(Cassandra Query Language) 사용</li>
<li>어떤 스케일링이든 한자릿수 ms 레이턴시, 매초 1000개의 요청</li>
<li>Capacity: on-demand mode 또는 provision mode(오토 스케일링 가능)</li>
<li>암호화, 백업, 최대 35일까지 Point-In-Time Recovery 가능</li>
</ul>
<blockquote>
<p>사례: IoT 디바이스 정보 저장, 시계열(time-series) 데이터</p>
</blockquote>
<h2 id="amazon-qldb"><a class="header" href="#amazon-qldb">Amazon QLDB</a></h2>
<ul>
<li>
<p>QLDB - Quantum Ledger Database</p>
</li>
<li>
<p>ledger - <strong>금융 거래(financial transactions)를 기록하는 장부</strong></p>
</li>
<li>
<p>완전 관리형, 서버리스, HA, Replication across 3 AZ</p>
</li>
<li>
<p>시간이 지나도 <strong>애플리케이션 데이터에 이루어진 모든 변화의 히스토리를 리뷰</strong>해야하는 경우에 사용</p>
</li>
<li>
<p><strong>Immutable</strong> 시스템: 어떤 항목도 삭제되거나 수정될 수 없음, 암호화 검증 가능(cryptographically verifiable)</p>
</li>
<li>
<p>일반적인 ledger 블록체인 프레임워크보다 2-3배 더 좋은 성능, SQL로 데이터 조작</p>
</li>
<li>
<p>Amazon Managed Blockchain과의 차이: <strong>탈중앙화(decentralization) 컴포넌트가 아님</strong>, 금융 규체 규칙(financial regulation rules)에 따름</p>
</li>
</ul>
<h2 id="amazon-timestream"><a class="header" href="#amazon-timestream">Amazon Timestream</a></h2>
<ul>
<li><strong>시계열(time series) 데이터베이스</strong></li>
<li>완전 관리형, 빠름, scalable, 서버리스</li>
<li>자동으로 capacity를 scale up/down</li>
<li>매일 1조(trillion)개의 이벤트를 저장 및 분석</li>
<li>1000배 빠름 &amp; 관계형 DB보다 1/10의 비용</li>
<li>예약 쿼리(Scheduled queries), 다중 측정 레코드(multi-measure records), SQL 호환성</li>
<li>Data storage tiering: 최근의 데이터는 메모리에 저장되고, 과거 데이터는 비용 효율적인 스토리지에 저장됨</li>
<li>빌트인 시계열 분석 함수 (실시간으로 데이터에 대한 패턴을 파악하는데 도움을 줌)</li>
<li>in-transit 암호화, at-rest 암호화</li>
</ul>
<blockquote>
<p>사례: IoT 앱, 운영 앱, 실시간 분석, ...</p>
</blockquote>
<p><img src="https://d2908q01vomqb2.cloudfront.net/887309d048beef83ad3eabf2a79a64a389ab1c9f/2021/07/06/DBB-1453-image001.png" alt="Timestream architecture example" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="data--analytics"><a class="header" href="#data--analytics">Data &amp; Analytics</a></h1>
<h2 id="amazon-athena"><a class="header" href="#amazon-athena">Amazon Athena</a></h2>
<ul>
<li>S3에 저장된 데이터를 분석하기 위한 <strong>서버리스</strong> 쿼리 서비스</li>
<li>파일을 쿼리하기 위해 표준 SQL 언어를 사용 (Presto)</li>
<li>CSV, JSON, ORC, Avro, Parquest 지원</li>
<li>비용: 스캔된 데이터 1TB당 5.00</li>
<li>일반적으로 Amazon Quicksight와 함께 사용하여 리포트/대쉬보드 생성</li>
<li><strong>사례</strong>: 비즈니스 인텔리전스 / 분석 / VPC Flow Logs, ELB Logs, <strong>CloudTrail trails</strong> 등에 대한 리포팅 &amp; 분석 &amp; 쿼리</li>
<li><strong>팁</strong>: 서버리스 SQL로 S3 내 데이터를 분석하고 싶다? -&gt; Athena를 쓴다!</li>
</ul>
<h3 id="athena---performance-improvement"><a class="header" href="#athena---performance-improvement">Athena - Performance Improvement</a></h3>
<ul>
<li>비용 절감을 위해서는 <strong>columnar data</strong>를 사용할 것 (스캔이 덜 일어남)
<ul>
<li>Apache Parquet 또는 ORC 추천</li>
<li>높은 성능 향상</li>
<li>Parquet 또는 ORC로 데이터를 변환하려면 Glue를 사용</li>
</ul>
</li>
<li>더 작은 검색을 위해 <strong>데이터 압축</strong> (bzip2, gzip, lz4, snappy, zlip, zstd...)</li>
<li>가상 컬럼을 쉽게 쿼리하기 위해 S3 내 데이터셋을 <strong>파티션</strong>
<ul>
<li>s3://yourBucket/pathToTable
<ul>
<li>/&lt;PARTITION_COLUMN_NAME&gt;=&lt;VALUE&gt;
<ul>
<li>/&lt;PARTITION_COLUMN_NAME&gt;=&lt;VALUE&gt;
<ul>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ex. <code>s3://athena-examples/flight/parquet/year=1991/month=1/day=1/</code></li>
</ul>
</li>
<li>오버헤드를 줄이기 위해서는 <strong>큰 파일</strong>(&gt; 128MB)을 사용</li>
</ul>
<h3 id="athena---federated-query"><a class="header" href="#athena---federated-query">Athena - Federated Query</a></h3>
<ul>
<li>관계형/비관계형/오브젝트/커스텀 데이터 소스(AWS든 온-프레미스든)에 저장된 데이터 전반에 SQL 쿼리를 실행할 수 있음</li>
<li>Data Source Connector를 사용하여 AWS Lambda가 Federated Queries를 실행하도록 할 수 있음 (e.g., CloudWatch logs, DynamoDB, RDS, ...)</li>
<li>그 결과도 S3에 다시 저장</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/11/27/AthenaQueryPic1.png" alt="Federated Query" /></p>
<h2 id="redshift"><a class="header" href="#redshift">Redshift</a></h2>
<ul>
<li>Redshift는 PostgreSQL 기반이지만, <strong>OLTP(online transaction processing)를 위해 사용되는 것이 아님</strong></li>
<li><strong>OLAP</strong>임 - <strong>online analytical processing</strong> (분석 및 데이터 웨어하우싱)</li>
<li>다른 데이터 웨어하우스보다 10배의 성능 &amp; PB(페타바이트) 단위로 확장</li>
<li><strong>Columnar</strong> storage of data (row 기반 대신) &amp; 병렬 쿼리 엔진</li>
<li>프로비전된 인스턴스에 기반하여 비용 지불</li>
<li>쿼리 수행에 SQL 인터페이스 사용 가능</li>
<li>Amazon Quicksight 또는 Tableau와 같은 BI(Business intelligence) 툴과 호환</li>
<li><strong>vs Athena</strong>: 인덱싱 덕분에 쿼리 / 조인 / 병합(aggregation)이 더 빠름</li>
</ul>
<h3 id="redshift---cluster"><a class="header" href="#redshift---cluster">Redshift - Cluster</a></h3>
<p><img src="https://editor.analyticsvidhya.com/uploads/298992.png" alt="Redshift Cluster Example" /></p>
<ul>
<li>Leader node: 쿼리 플래닝, 결과 병합 목적</li>
<li>Compute node: 쿼리 수행, leader node에게 결과 전달</li>
<li>미리 노드 사이즈를 프로비전해야함</li>
<li>비용 절감을 위해 Reserved Instance 사용할 수 있음</li>
</ul>
<h3 id="redshift---snapshots--dr"><a class="header" href="#redshift---snapshots--dr">Redshift - Snapshots &amp; DR</a></h3>
<ul>
<li><strong>Redshift는 대부분의 클러스터에 단일 AZ이지만, 일부 클러스터에 Multi-AZ 모드를 보유함</strong></li>
<li>스냅샷은 클러스터 하나의 point-in-time 백업이며, 내부적으로 S3에 저장됨</li>
<li>스냅샷은 incremental함 (변경이 이루어진 것만 저장됨)</li>
<li><strong>새 클러스터</strong>로 스냅샷을 복구할 수 있음</li>
<li>Automated: 매 8시간, 매 5GB, 또는 스케줄에 따라, retention을 설정</li>
<li>Manual: 스냅샷을 직접 삭제하기 전까지 보존됨</li>
<li><strong>Amazon Redshift가 자동으로 클러스터의 스냅샷(automated or manual)을 다른 AWS 리전으로 복사하도록 설정할 수 있음 (disaster recovery)</strong></li>
</ul>
<h3 id="redshift---loading-data-into-redshift"><a class="header" href="#redshift---loading-data-into-redshift">Redshift - Loading data into Redshift</a></h3>
<ul>
<li><strong>insert 작업은 거대하게 처리하는 편이 훨씬 좋음</strong></li>
<li>다음을 통해 데이터를 가져올 수 있음
<ul>
<li>Amazon Kinesis Data Firehose - S3 copy를 통해</li>
<li>S3 Bucket - 인터넷 또는 VPC를 통해서</li>
<li>EC2 Instance (/w JDBC driver) ~ 배치 단위로 데이터 write를 하는게 더 좋음</li>
</ul>
</li>
</ul>
<h3 id="redshift---spectrum"><a class="header" href="#redshift---spectrum">Redshift - Spectrum</a></h3>
<ul>
<li>이미 S3에 있는 데이터를 따로 가져오지 않고도 쿼리</li>
<li><strong>쿼리를 시작하기 위해 사용가능한 Redshift 클러스터를 보유해야함</strong></li>
<li>쿼리는 수천개의 Redshift Spectrum 노드에 전달됨</li>
</ul>
<h2 id="amazon-opensearch-service"><a class="header" href="#amazon-opensearch-service">Amazon OpenSearch Service</a></h2>
<ul>
<li><strong>Amazon OpenSearch = Amazon ElasticSearch의 후속 서비스 (이름이 바뀜)</strong></li>
<li>DynamoDB에서, 쿼리 작업은 반드시 primary key나 index를 포함해야 함</li>
<li><strong>OpenSearch로, 어떤 필드든 검색 가능하고, 심지어 부분 일치에 대한 검색도 가능함</strong></li>
<li>다른 DB를 보완하는 역할로 OpenSearch를 사용하는 것이 일반적임</li>
<li>인스턴스들의 클러스터가 필요함 (서버리스가 아님)</li>
<li>기본적으로는 SQL을 지원하지 않음 (플러그인을 통해 활성화할 수는 있음)</li>
<li>Kinesis Data Firehose, AWS IoT, CloudWatch Log와 호환됨</li>
<li>Cognito &amp; IAM, KMS 암호화, TLS를 통해 보안</li>
<li>OpenSearch Dashboards(시각화)가 함께 제공됨</li>
</ul>
<h2 id="amazon-emr"><a class="header" href="#amazon-emr">Amazon EMR</a></h2>
<ul>
<li>EMR - Elastic MapReduce</li>
<li>EMR은 **Hadoop 클러스터(빅데이터)**를 만드는 것을 도와 방대한 양의 데이터를 분석/처리하는 것에 도움을 줌</li>
<li>클러스터는 <strong>몇 백개의 EC2 인스턴스</strong>들로 이루어질 수 있음</li>
<li>EMR은 Apache Spark, HBase, Presto, Flink와 함께 번들로 제공됨</li>
<li>EMR이 모든 프로비저닝과 설정을 처리해줌</li>
<li>오토 스케일링 및 Spot instance와 호환됨</li>
</ul>
<blockquote>
<p><strong>사례</strong>: 데이터 처리, 머신 러닝, 웹 인덱싱, 빅 데이터..</p>
</blockquote>
<h3 id="emr---node-types--purchasing"><a class="header" href="#emr---node-types--purchasing">EMR - Node types &amp; purchasing</a></h3>
<ul>
<li><strong>Master Node</strong>: 클러스터 관리, 좌표계(coordinate), health 관리 - 장기적으로 실행</li>
<li><strong>Core Node</strong>: task 실행 및 데이터 저장 - 장기적으로 실행</li>
<li><strong>Task Node (선택적)</strong>: 오직 task 실행 목적 - 주로 Spot</li>
<li><strong>Purchasing options</strong>:
<ul>
<li>On-demand: reliable, predictable ~ 종료되지 않음</li>
<li>Reserved (최소 1년): 비용 절감 (가능한 상황이라면 EMR은 이 쪽을 자동으로 사용)</li>
<li>Spot Instances: 가격이 쌈, 종료될 가능성 있음, less reliable</li>
</ul>
</li>
<li>long-running 클러스터 또는 transient(일시적인) 클러스터를 가질 수 있음</li>
</ul>
<h2 id="amazon-quicksight"><a class="header" href="#amazon-quicksight">Amazon QuickSight</a></h2>
<ul>
<li><strong>인터렉티브 대시보드를 만들기 위한 서버리스 머신러닝 기반의 business intelligence 서비스</strong></li>
<li>빠름, 자동 확장 가능, 임베디드 가능, 세션 당 비용 지불</li>
<li>사례:
<ul>
<li>비즈니스 분석</li>
<li>시각화 구축</li>
<li>ad-hoc 분석 수행</li>
<li>데이터를 통한 비즈니스 인사이트 획득</li>
</ul>
</li>
<li>RDS, Aurora, Athena, Redshift, S3... 등과 호환</li>
<li>QuickSight로 데이터를 가져올 경우 <strong>SPICE 엔진을 통한 인-메모리 계산</strong></li>
<li>Enterprise edition: Column-Level security(CLS) 설정 가능</li>
</ul>
<p><img src="https://d1.awsstatic.com/quicksight-refresh-2021/laptopMockup.06b3b5e4cf2be72f62d30bb5998649e3c93f7400.png" alt="Quicksight" /></p>
<h3 id="quicksight---대시보드--분석"><a class="header" href="#quicksight---대시보드--분석">QuickSight - 대시보드 &amp; 분석</a></h3>
<ul>
<li>이용자 정의(standard version), 그룹 정의(enterprise version)
<ul>
<li>여기서 정의된 이용자 &amp; 그룹들은 오직 QuickSight 내에서만 존재, IAM이 아님!</li>
</ul>
</li>
<li>대쉬보드?
<ul>
<li>공유가 가능한 읽기 전용 스냅샷</li>
<li>분석에 대한 설정이 보존됨 (필터링, 파라미터, 컨트롤, 정렬)</li>
</ul>
</li>
<li><strong>이용자나 그룹에게 분석이나 대시보드를 공유할 수 있음</strong></li>
<li>대시보드를 공유하려면, 먼저 반드시 게시(publish)를 해야함</li>
<li>대시보드를 보는 이용자들은 그 아래 놓인 데이터도 확인할 수 있음</li>
</ul>
<h2 id="aws-glue"><a class="header" href="#aws-glue">AWS Glue</a></h2>
<ul>
<li>관리형 ETL (extract, transform, load) 서비스</li>
<li>분석을 위해 데이터를 준비/변형하는데 유용함</li>
<li>완전한 <strong>서버리스</strong> 서비스</li>
</ul>
<h3 id="glue---data-catalog"><a class="header" href="#glue---data-catalog">Glue - Data Catalog</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/glue/latest/dg/images/PopulateCatalog-overview.png" alt="Glue Data Catalog Example" /></p>
<h3 id="glue---thinks-to-know-at-a-high-level"><a class="header" href="#glue---thinks-to-know-at-a-high-level">Glue - thinks to know at a high-level</a></h3>
<ul>
<li><strong>Glue Job Bookmarks</strong>: 기존 데이터의 재처리(re-processing)을 방지</li>
<li><strong>Glue Elastic Views</strong>:
<ul>
<li>SQL을 통해 여러 데이터 스토어들 간에 데이터를 결합/복제</li>
<li>커스텀 코드 없음, Glue가 소스 데이터 내 변화를 감지함, 서버리스</li>
<li>&quot;virtual table&quot; 활용 (materialized view)</li>
</ul>
</li>
<li><strong>Glue DataBrew</strong>: pre-built transformation으로 데이터를 정리 및 정규화</li>
<li><strong>Glue Studio</strong>: Glue에서의 ETL 작업들을 생성/실행/모니터링하기 위한 GUI</li>
<li><strong>Glue Streaming ETL</strong>(built on Apache Spark Structured Streaming): Kinesis Data Streaming, Kafka, MSK(관리형 Kafka)와 호환</li>
</ul>
<h2 id="aws-lake-formation"><a class="header" href="#aws-lake-formation">AWS Lake Formation</a></h2>
<ul>
<li><strong>Data lake = 분석 목적으로 모든 데이터들을 모아두는 중앙 위치(central place)</strong></li>
<li>며칠 만에 <strong>data lake</strong>를 쉽게 설정할 수 있도록 해주는 완전 관리형 서비스</li>
<li>Data Lake에다 데이터를 발견, 정화, 변형, 수집</li>
<li>직접 처리하기 복잡한 여러 작업들(collecting, cleansing, moving, catalog data, ...)을 자동화시켜줌, 중복 제거(ML Transform을 사용)</li>
<li>data lake 내에서 구조화/비구조화 데이터를 결합</li>
<li><strong>out-of-the-box source blueprints</strong>: S3, RDS, Relational &amp; NoSQL DB...</li>
<li><strong>애플리케이션에 대한 Fine-grained Access Control</strong>(<strong>row/column level</strong>)</li>
<li><strong>AWS Glue</strong>를 기반으로 구축</li>
</ul>
<p><img src="https://d1.awsstatic.com/diagrams/Lake-formation-HIW.9ea3fab3b2ac697a42ae7a805b986278ffd4f41e.png" alt="AWS Lake Formation" /></p>
<h2 id="kinesis-data-analytics"><a class="header" href="#kinesis-data-analytics">Kinesis Data Analytics</a></h2>
<h3 id="kinesis-data-analytics---for-sql-applications"><a class="header" href="#kinesis-data-analytics---for-sql-applications">Kinesis Data Analytics - for SQL applications</a></h3>
<ul>
<li>SQL로 <strong>Kinesis Data Streams &amp; Firehose</strong>에서 실시간 분석</li>
<li>Amazon S3에서 스트리밍 데이터를 풍부하게 하기 위해 레퍼런스 데이터를 추가</li>
<li>완전 관리형, 프로비전해야하는 서버 없음</li>
<li>자동 스케일링</li>
<li>실제 사용률에 기반하여 비용 지불</li>
<li>Output:
<ul>
<li>Kinesis Data Streams: 실시간 분석 쿼리의 결과에 대한 stream을 생성</li>
<li>Kinesis Data Firehose: 목적지(destination)에 분석 쿼리 결과를 전송</li>
</ul>
</li>
<li>사례:
<ul>
<li>시계열 분석</li>
<li>실시간 대시보드</li>
<li>실시간 통계</li>
</ul>
</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/05/19/KinesisAnalyticsStudio-1.png" alt="Kinesis DA for SQL application" /></p>
<h3 id="kinesis-data-analytics---for-apache-flink"><a class="header" href="#kinesis-data-analytics---for-apache-flink">Kinesis Data Analytics - for Apache Flink</a></h3>
<ul>
<li>스트리밍 데이터 처리 및 분석을 위해 Flink(Java, Scala or SQL)를 사용</li>
<li>AWS 내에서 관리되는 클러스터에 Apach Flink 애플리케이션을 실행
<ul>
<li>프로비전된 컴퓨팅 리소스, 병렬 컴퓨팅, 자동 스케일링</li>
<li>애플리케이션 백업 (체크포인트와 스냅샷으로 구현)</li>
<li>어떤 Apache Flink 프로그래밍 기능이든 사용 가능</li>
<li>Flink는 Firehose로부터 결과를 읽어올 수 없음 (이 경우 Kinesis Analytics for SQL을 사용해야 함)</li>
</ul>
</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2021/07/01/BDB1684-image001.jpg" alt="Kinesis DA for Apache Flink" /></p>
<h2 id="amazon-managed-streaming-for-apache-kafka-amazon-msk"><a class="header" href="#amazon-managed-streaming-for-apache-kafka-amazon-msk">Amazon Managed Streaming for Apache Kafka (Amazon MSK)</a></h2>
<ul>
<li>Amazon Kinesis의 대체제</li>
<li>AWS에서의 완전 관리형 Apache Kafka
<ul>
<li>클러스터를 생성/수정/삭제하도록 해줌</li>
<li>MSK는 Kafka broker 노드와 Zookeeper 노드를 생성 &amp; 관리해줌</li>
<li>내 VPC 내에 MSK 클러스터를 배포, multi-AZ (최대 3개 ~ HA)</li>
<li>일반적인 Apache Kafka 장애로부터 자동 복구</li>
<li><strong>원하는 기간만큼</strong> EBS 볼륨에 데이터를 저장</li>
</ul>
</li>
<li><strong>MSK Serverless</strong>
<ul>
<li>capacity를 관리하지 않고도 MSK에 Apache Kafka를 실행</li>
<li>MSK가 자동으로 리소스 프로비저닝 / 컴퓨팅 및 스토리지 스케일링을 처리해줌</li>
</ul>
</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2018/03/02/Kafka1_600px.png" alt="Apache Kafka on AWS" /></p>
<h3 id="kinesis-data-streams-vs-amazon-msk"><a class="header" href="#kinesis-data-streams-vs-amazon-msk">Kinesis Data Streams vs. Amazon MSK</a></h3>
<ul>
<li>Kinesis Data Streams
<ul>
<li>메시지 사이즈가 1MB로 제한</li>
<li>샤드로 데이터 스트리밍</li>
<li>샤드 스플리팅 &amp; 머징</li>
<li>TLS in-flight 암호화</li>
<li>KMS at-rest 암호화</li>
</ul>
</li>
<li>Amazon MSK
<ul>
<li>기본 1MB, 더 높게 설정 가능 (ex. 10MB)</li>
<li>Kafka Topics with Partition</li>
<li>Topic에만 파티션 추가 가능</li>
<li>PLAINTEXT 또는 TLS in-flight 암호화</li>
<li>KMS at-rest 암호화</li>
</ul>
</li>
</ul>
<h3 id="amazon-msk-consumers"><a class="header" href="#amazon-msk-consumers">Amazon MSK Consumers</a></h3>
<ul>
<li>Kinesis Data Analytics for Apache Flink</li>
<li>AWS Glue - Apache Spark streaming으로 ETL 작업 스트리밍</li>
<li>Lambda</li>
<li>직접 구축한 애플리케이션 (ex. EC2/ECS/EKS)</li>
</ul>
<h2 id="big-data-ingestion-pipeline"><a class="header" href="#big-data-ingestion-pipeline">Big Data Ingestion Pipeline</a></h2>
<ul>
<li>완전한 서버리스로 수집 파이프라인을 구축하고 싶을 때</li>
<li>실시간으로 데이터를 수집하고 싶을 때</li>
<li>데이터 변형을 하고 싶을 때</li>
<li>SQL로 변형된 데이터를 쿼리하고 싶을 때</li>
<li>쿼리를 통해 생성된 리포트를 S3에 두고 싶을 때</li>
<li>데이터를 웨어하우스로 불러와 대시보드를 만들고 싶을 때</li>
</ul>
<h3 id="big-data-ingestion-pipeline-discussion"><a class="header" href="#big-data-ingestion-pipeline-discussion">Big Data Ingestion Pipeline discussion</a></h3>
<ul>
<li>IoT Core는 IoT 디바이스로부터 데이터를 수확(harvest)할 수 있게 해줌</li>
<li>Kinesis는 실시간 데이터 수집에 유용</li>
<li>Firehose는 거의 실시간(1분) 내로 S3에 데이터를 전송하도록 해줌</li>
<li>Lambda는 Firehose와 함께 사용하여 데이터 변형을 할 수 있게 해줌</li>
<li>S3는 SQS로 notification을 트리거할 수 있음</li>
<li>Lambda는 SQS를 구독할 수 있음 (S3 -&gt; Lambda로 connecter를 둘 수 있음)</li>
<li>Athena는 서버리스 SQL 서비스로, 분석 결과를 S3에 보관할 수 있음</li>
<li>리포팅 버킷(reporting bucket)은 분석된 데이터들을 포함하게 되며, 이는 AWS QuickSight, Redshift 같은 리포팅 툴과 함께 사용할 수 있음</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="machine-learning-1"><a class="header" href="#machine-learning-1">Machine Learning</a></h1>
<h2 id="amazon-rekognition"><a class="header" href="#amazon-rekognition">Amazon Rekognition</a></h2>
<ul>
<li>ML을 통해 <strong>이미지와 비디오</strong>에서 오브젝트, 사람, 텍스트, 장면을 인식</li>
<li><strong>얼굴 분석</strong> 및 <strong>얼굴 검색</strong> - 이용자 검증, 사람 수 카운팅</li>
<li>familiar face 데이터베이스 생성 또는 유명인사와 비교</li>
<li><strong>사례</strong>:
<ul>
<li>labeling</li>
<li>컨텐츠 관리</li>
<li>텍스트 감지</li>
<li>얼굴 감지 및 분석 (성별, 나이 범위, 감정...)</li>
<li>얼굴 검색 및 검증</li>
<li>유명인사 인식</li>
<li>pathing (ex. 스포츠 게임 분석)</li>
</ul>
</li>
</ul>
<h3 id="amazon-rekognition---content-moderation"><a class="header" href="#amazon-rekognition---content-moderation">Amazon Rekognition - Content Moderation</a></h3>
<ul>
<li>부적절하거나, 원치 않는, 혹은 공격적인 컨텐츠를 감지 (이미지, 비디오)</li>
<li>더 안전한 이용자 경험을 보장하기 위해 소셜미디어, 방송 미디어, 광고, e-커머스에서 사용</li>
<li><strong>플래그될 항목에 대한 최소 신뢰도 임계값(minimum confidence threshold)를 설정</strong></li>
<li>Amazon Augmented AI(A2I) 내에서</li>
<li>수동 검토를 위해 민감한 컨텐츠에 플래그 지정</li>
<li>규정 준수를 도와줌</li>
</ul>
<h2 id="amazon-transcribe"><a class="header" href="#amazon-transcribe">Amazon Transcribe</a></h2>
<ul>
<li><strong>자동으로 speech-to-text 변환을 해줌</strong></li>
<li>**automatic speech recognition(ASR)**이라고 불리는 <strong>딥러닝 처리</strong>를 통해 speech-to-text를 빠르고 정확하게 수행할 수 있음</li>
<li><strong>Redaction를 통해 자동으로 개인 식별 정보(Personally Identifiable Information ~ PII)를 제거</strong></li>
<li><strong>multi-lingual audio를 통해 언어 자동 감지</strong></li>
<li>사례:
<ul>
<li>이용자 서비스 전화 트랜스크립트(transcribe)</li>
<li>선택 캡션 및 자막 자동화</li>
<li>완전 검색 가능한 아카이브를 위해 미디어 에셋에 대한 메타데이터 생성</li>
</ul>
</li>
</ul>
<h2 id="amazon-polly"><a class="header" href="#amazon-polly">Amazon Polly</a></h2>
<ul>
<li>딥러닝을 통해 text-to-speech 변환</li>
<li>애플리케이션이 말을 할 수 있도록 할 수 있음</li>
</ul>
<h3 id="amazon-polly---lexicon--ssml"><a class="header" href="#amazon-polly---lexicon--ssml">Amazon Polly - Lexicon &amp; SSML</a></h3>
<ul>
<li><strong>Pronunciation lexicons</strong>으로 특정 단어의 발음을 커스터마이징 할 수 있음
<ul>
<li>Stylized words: St3ph4ne =&gt; &quot;Stephane&quot;</li>
<li>Acronyms: AWS =&gt; &quot;Amazon Web Services&quot;</li>
</ul>
</li>
<li><strong>Speech Synthesis Markup Language</strong>(<strong>SSML</strong>)로 마크업 가능 - 더 많은 커스터마이징
<ul>
<li>특정 단어나 문장을 강조</li>
<li>음성 기호대로 발음</li>
<li>숨쉬기, 속삭이기 추가</li>
<li>뉴스 캐스터 화법 사용</li>
</ul>
</li>
</ul>
<h2 id="amazon-translate"><a class="header" href="#amazon-translate">Amazon Translate</a></h2>
<ul>
<li>자연스럽고 정확한 <strong>언어 번역</strong></li>
<li>컨텐츠의 로컬라이징을 하도록 도와줌 - 웹사이트 또는 애플리케이션
<ul>
<li><strong>국제 이용자</strong>를 위해, 또는 거대한 양의 텍스트를 효율적으로 번역하기 위해 사용</li>
</ul>
</li>
</ul>
<h2 id="amazon-lex--connect"><a class="header" href="#amazon-lex--connect">Amazon Lex &amp; Connect</a></h2>
<ul>
<li><strong>Amazon Lex</strong>: Alexa에 사용되는 것과 동일한 기술
<ul>
<li>Automatic Speech Recognition(ASR)을 사용하여 speech-to-text</li>
<li>텍스트와 호출자(caller)의 의도를 인식하는 Natural Language Understanding</li>
<li>챗봇, 콜센터 봇 생성에 유용</li>
</ul>
</li>
<li><strong>Amazon Connect</strong>:
<ul>
<li>전화를 받고, 응대 플로우를 만들 수 있는 <strong>가상 문의 센터</strong></li>
<li>다른 CRM 시스템이나 AWS와 호환될 수 있음</li>
<li>선불 결제 없음, 전통적인 문의 센터 솔루션들보다 80% 저렴함</li>
</ul>
</li>
</ul>
<h2 id="amazon-comprehend"><a class="header" href="#amazon-comprehend">Amazon Comprehend</a></h2>
<ul>
<li>**자연어 처리(NLP ~ Natural Language Processing)**을 위해 사용</li>
<li>완전 관리형 서버리스 서비스</li>
<li>텍스트에서 인사이트 및 관계 파악
<ul>
<li>텍스트에서 사용하는 언어</li>
<li>핵심 문구, 장소, 사람, 브랜드, 이벤트 등을 추출</li>
<li>텍스트의 긍정/부정 인식</li>
<li>tokenization와 parts of speech(품사)를 통해 텍스트 분석</li>
<li>주제 별로 텍스트 파일 모음을 자동으로 구성</li>
</ul>
</li>
<li>사례:
<ul>
<li>이용자 반응(이메일)을 분석하여 긍정/부정적 경험 여부 판단</li>
<li>Comprehend가 발견할 topic을 기반으로 아티클들을 생성 및 그룹화</li>
</ul>
</li>
</ul>
<h2 id="amazon-comprehend-medical"><a class="header" href="#amazon-comprehend-medical">Amazon Comprehend Medical</a></h2>
<ul>
<li>비정형 clinical 텍스트 내에서 유용한 정보를 감지하고 반환해줌
<ul>
<li>의사 소견</li>
<li>퇴원 요약</li>
<li>테스트 결과</li>
<li>케이스 노트</li>
</ul>
</li>
<li><strong>Protected Health Information(PHI)를 감지하기 위해 NLP를 사용</strong> - DetectPHI API</li>
<li>S3 내에 문서 보관, Kinesis Data Firehose로 실시간 데이터 분석, 또는 Amazon Transcribe로 환자 나레이션을 텍스트로 변환하여 Amazon Comprehend Medical이 분석할 수 있도록 함</li>
</ul>
<h2 id="amazon-sagemaker"><a class="header" href="#amazon-sagemaker">Amazon SageMaker</a></h2>
<ul>
<li>개발자 / 데이터 사이언티스트가 ML 모델을 만들 수 있도록 해주는 완전 관리형 서비스</li>
<li>일반적으로 ML 모델링을 하는 모든 과정을 한 곳에서 수행하고, 또 서버를 프로비저닝하는 것은 상당히 어렵기 때문</li>
</ul>
<h2 id="amazon-forecast"><a class="header" href="#amazon-forecast">Amazon Forecast</a></h2>
<ul>
<li>ML을 기반으로 매우 정확한 기상 예측을 전달하는 완전 관리형 서비스</li>
<li>예시: 우의 판매량 예측</li>
<li>데이터 자체를 살펴보는 것보다 50% 정확</li>
<li>예측 시간을 몇 달에서 몇 시간으로 단축</li>
<li>사례: 제품 수요 예측, 재무 설계, 리소스 계획</li>
</ul>
<h2 id="amazon-kendra"><a class="header" href="#amazon-kendra">Amazon Kendra</a></h2>
<ul>
<li>머신러닝 기반의 완전 관리형 <strong>문서 검색 서비스</strong></li>
<li>문서 내에서 답을 추출 (text, pdf, HTML, PowerPoint, MS Word, FAQs...)</li>
<li>자연어 검색 기능</li>
<li>이용자 인터랙션/피드백을 통해 학습하여 선호하는 결과가 나오도록 촉진 (Incremental Learning ~ 점진 학습)</li>
<li>검색 결과를 수동으로 미세 조정하는 기능 (데이터 중요도, 신선도, 커스텀...)</li>
</ul>
<h2 id="amazon-personalize"><a class="header" href="#amazon-personalize">Amazon Personalize</a></h2>
<ul>
<li>실시간으로 개인화된 추천을 전달하는 앱을 구성하기 위한 완전 관리형 ML 서비스</li>
<li>사례: 개인화된 상품 추천/re-ranking, 맞춤형 다이렉트 마케팅
<ul>
<li>사례: 이용자가 정원관리 툴을 샀을 때, 다음에 살만한 제품을 추천</li>
</ul>
</li>
<li>Amazon.com에도 동일한 기술이 사용됨</li>
<li>기존 웹사이트, 애플리케이션, SMS, 이메일 마케팅 시스템과도 호환</li>
<li>며칠 내로 구현 가능, 몇 달까지도 안걸림(ML 솔루션을 빌드, 학습, 배포할 필요 없음)</li>
<li>사례: 소매점, 미디어 및 엔터테인먼트</li>
</ul>
<h2 id="amazon-textract"><a class="header" href="#amazon-textract">Amazon Textract</a></h2>
<ul>
<li>AI와 ML을 통해 스캔된 문서로부터 텍스트, 손글씨, 데이터를 자동으로 추출</li>
<li>form과 테이블로부터 데이터 추출</li>
<li>어떤 타입의 문서든 읽기 및 처리 가능 (PDFs, images, ...)</li>
<li>사례:
<ul>
<li>금융 서비스 (e.g., 청구서, 금융 리포트)</li>
<li>헬스케어 (e.g., 진료 기록, 보험 청구)</li>
<li>공공 부문  (e.g., 세금 신고서, ID 문서, 여권)</li>
</ul>
</li>
</ul>
<h2 id="aws-machine-learning---summary"><a class="header" href="#aws-machine-learning---summary">AWS Machine Learning - Summary</a></h2>
<ul>
<li><strong>Rekognition</strong>: 얼굴 감지, 라벨링, 유명인사 인식</li>
<li><strong>Transcribe</strong>: speech-to-text (ex. subtitles)</li>
<li><strong>Polly</strong>: text-to-speech</li>
<li><strong>Translate</strong>: 번역</li>
<li><strong>Lex</strong>: 챗봇 빌드</li>
<li><strong>Connect</strong>: 클라우드 문의 센터</li>
<li><strong>Comprehend</strong>: 자연어 처리</li>
<li><strong>SageMaker</strong>: 모든 개발자/데이터 사이언티스트를 위한 머신 러닝</li>
<li><strong>Forecast</strong>: 높은 정확도의 기상 예측</li>
<li><strong>Kendra</strong>: ML 기반의 검색 엔진</li>
<li><strong>Personalize</strong> 실시간 개인 추천</li>
<li><strong>Textract</strong>: 문서 내 텍스트 및 데이터 감지</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="monitoring--audit"><a class="header" href="#monitoring--audit">Monitoring &amp; Audit</a></h1>
<h2 id="amazon-cloudwatch-metrics"><a class="header" href="#amazon-cloudwatch-metrics">Amazon CloudWatch Metrics</a></h2>
<ul>
<li>CloudWatch는 AWS의 모든 서비스에 대한 metric를 제공함</li>
<li><strong>Metric</strong>은 모니터링할 변수를 의미 (CPUUtilization, Networkln...)</li>
<li>metric은 <strong>namespace</strong>에 속하게 됨</li>
<li><strong>Dimension</strong>은 metric의 attribute (instance id, envrionment, etc...)</li>
<li>각 metric 당 최대 30 dimension</li>
<li>metric은 <strong>timestamps</strong>를 가짐</li>
<li>metric의 CloudWatch 대시보드를 만들 수 있음</li>
<li><strong>CloudWatch Custom Metrics</strong>를 만들 수 있음 (ex. RAM)</li>
</ul>
<h3 id="cloudwatch-metric-streams"><a class="header" href="#cloudwatch-metric-streams">CloudWatch Metric Streams</a></h3>
<ul>
<li>낮은 레이턴시로 원하는 목적지(destination)로 CloudWatch metric을 지속적으로 스트리밍할 수 있음 (<strong>거의 실시간 전송</strong>, 낮은 레이턴시)
<ul>
<li>Amazon Kinesis Data Firehose (=&gt; 이후 목적지로)</li>
<li>써드파티 서비스 제공자: Datadog, Dynatrace, New Relic, Splunk, Sumo Logic...</li>
</ul>
</li>
<li>옵션을 통해 metric의 하위 집합만 스트리밍하도록 <strong>metric을 필터링</strong>할 수 있음</li>
</ul>
<h2 id="cloudwatch-logs"><a class="header" href="#cloudwatch-logs">CloudWatch Logs</a></h2>
<ul>
<li><strong>Log groups</strong>: 임의의 이름, 주로 애플리케이션</li>
<li><strong>Log stream</strong>: 애플리케이션 / 로그 파일 / 컨테이너 내 인스턴스</li>
<li>로그 만료 정책 (만기 X, 30일 등등)</li>
<li><strong>CloudWatch Log는 다음으로 로그를 전송할 수 있음</strong>:
<ul>
<li>Amazon S3 (내보내기)</li>
<li>Kinesis Data Streams</li>
<li>Kinesis Data Firehose</li>
<li>AWS Lambda</li>
<li>OpenSearch</li>
</ul>
</li>
</ul>
<h3 id="cloudwatch-logs---sources"><a class="header" href="#cloudwatch-logs---sources">CloudWatch Logs - Sources</a></h3>
<ul>
<li>SDK, CloudWatch Logs Agent, CloudWatch Unified Agent</li>
<li>Elastic Beanstalk: 애플리케이션으로부터의 log 컬렉션</li>
<li>ECS: 컨테이너로부터의 컬렉션</li>
<li>AWS Lambda: 함수 로그로부터의 컬렉션</li>
<li>VP Flow Logs: VPC 별 로그</li>
<li>API Gateway</li>
<li>필터 기반의 CloudTrail</li>
<li>Route53: DNS 쿼리 로그</li>
</ul>
<h3 id="cloudwatch-logs---metric-filters--insights"><a class="header" href="#cloudwatch-logs---metric-filters--insights">CloudWatch Logs - Metric Filters &amp; Insights</a></h3>
<ul>
<li>CloudWatch Logs는 필터 표현식(filter expressions)을 사용할 수 있음
<ul>
<li>ex. 한 로그 내 특정 IP를 찾아내기</li>
<li>ex. 로그 내에서 &quot;ERROR&quot; 발생 카운팅하기</li>
</ul>
</li>
<li>CloudWatch alarm을 트리거할 수 있도록 metric filter 사용</li>
<li>CloudWatch Logs Insights는 로그를 쿼리하거나, CloudWatch Dashboard에 쿼리를 추가하는 데 사용될 수 있음</li>
</ul>
<h3 id="cloudwatch-logs---s3-export"><a class="header" href="#cloudwatch-logs---s3-export">CloudWatch Logs - S3 Export</a></h3>
<ul>
<li>로그 데이터는 내보내기가 가능해지기까지 <strong>최대 12시간</strong>까지 걸릴 수 있음</li>
<li>API 호출은 <strong>CreateExportTask</strong></li>
<li>실시간과는 거리가 멀기 때문에, 실시간 처리가 필요하다면 대신 Logs Subscription을 쓸 것</li>
</ul>
<h3 id="cloudwatch-logs---subscriptions"><a class="header" href="#cloudwatch-logs---subscriptions">CloudWatch Logs - Subscriptions</a></h3>
<p><img src="https://cloudwellserved.com/wp-content/uploads/2020/06/kinesis1.png" alt="CloudWatch Logs Subscriptions Example" /></p>
<h3 id="cloudwatch-logs---for-ec2"><a class="header" href="#cloudwatch-logs---for-ec2">CloudWatch Logs - for EC2</a></h3>
<ul>
<li>기본적으로, 로그는 EC2 머신에서 CloudWatch로 이동하지 않음</li>
<li>EC2가 로그 파일을 전송하길 원한다면 CloudWatch agent를 써야함</li>
<li>IAM 권한이 적절한지 확인 필요함</li>
<li>CloudWatch log agent는 온-프레미스에서도 설정 가능</li>
</ul>
<h2 id="cloudwatch-logs-agent--unified-agent"><a class="header" href="#cloudwatch-logs-agent--unified-agent">CloudWatch Logs Agent &amp; Unified Agent</a></h2>
<ul>
<li>가상 서버를 위한 것 (EC2 인스턴스, 온-프레미스 서버)</li>
<li><strong>CloudWatch Logs Agent</strong>
<ul>
<li>구버전 agent</li>
<li>오직 CloudWatch Log에 전송 가능</li>
</ul>
</li>
<li><strong>CloudWatch Unified Agent</strong>
<ul>
<li>RAM, 프로세스 등 추가적인 시스템 레벨 metric도 수집</li>
<li>로그를 수집하여 CloudWatch Log에 전송</li>
<li>SSM Parameter Store를 통해 중앙화된 설정</li>
</ul>
</li>
</ul>
<h3 id="cloudwatch-unified-agent---metrics"><a class="header" href="#cloudwatch-unified-agent---metrics">CloudWatch Unified Agent - Metrics</a></h3>
<ul>
<li>리눅스 서버 / EC2 인스턴스에서 직접 수집
<ul>
<li><strong>CPU</strong> (active, ugest, idle, system, user, steal)</li>
<li><strong>Disk metrics</strong> (free, used, total), Disk IO (writes, reads, bytes, iops)</li>
<li><strong>RAM</strong> (free, inactive, used, total, cached)</li>
<li><strong>Netstat</strong> (TCP/UDP 연결 수, net packets, bytes)</li>
<li><strong>Processes</strong> (total, dead, bloqued, idle, running, sleep)</li>
<li><strong>Swap Space</strong> (free, used, used %)</li>
</ul>
</li>
<li>기억할 것: EC2에서의 기본 제공 metric - disk, CPU, network (high level)</li>
</ul>
<h2 id="cloudwatch-alarms"><a class="header" href="#cloudwatch-alarms">CloudWatch Alarms</a></h2>
<ul>
<li>Alarm은 어떤 metric에 대한 알림을 트리거하기 위해 사용</li>
<li>다양한 옵션 (샘플링, %, max, min, etc...)</li>
<li>Alarm States:
<ul>
<li><code>OK</code></li>
<li><code>INSUFFICIENT_DATA</code></li>
<li><code>ALARM</code></li>
</ul>
</li>
<li>Period:
<ul>
<li>metric을 평가하는데 걸리는 초단위 시간</li>
<li>고해상도 커스텀 metric: 10초, 30초, 60초의 배수</li>
</ul>
</li>
</ul>
<h3 id="cloudwatch-alarm---targets"><a class="header" href="#cloudwatch-alarm---targets">CloudWatch Alarm - Targets</a></h3>
<ul>
<li>EC2 인스턴스를 중지 / 종료 / 재부팅 / 복구</li>
<li>오토 스케일링 동작을 트리거</li>
<li>SNS에 알림 전송 (lambda를 통해 거의 뭐든 처리 가능)</li>
</ul>
<h3 id="cloudwatch-alarm---composition-alarm"><a class="header" href="#cloudwatch-alarm---composition-alarm">CloudWatch Alarm - Composition Alarm</a></h3>
<ul>
<li>CloudWatch Alarm은 하나의 metric에서 동작</li>
<li><strong>Composition Alarm은 여러 개의 alarm들에 기반한 상태를 모니터링</strong></li>
<li>AND 또는 OR 조건</li>
<li>복잡한 composite alarm을 생성하여 alarm noise를 줄이는데 도움을 줌</li>
</ul>
<h3 id="cloudwatch-alarm---ec2-instance-recovery"><a class="header" href="#cloudwatch-alarm---ec2-instance-recovery">CloudWatch Alarm - EC2 Instance Recovery</a></h3>
<ul>
<li><strong>Status Check</strong>:
<ul>
<li>Instance status = EC2 VM 체크</li>
<li>System status = 기반 하드웨어 체크</li>
</ul>
</li>
<li><strong>Recovery</strong>: 동일한 private/public/elastic IP, 동일한 메타데이터, 동일한 placement group</li>
</ul>
<h3 id="cloudwatch-alarm-good-to-know"><a class="header" href="#cloudwatch-alarm-good-to-know">CloudWatch Alarm: good to know</a></h3>
<ul>
<li>Alarm은 CloudWatch Logs Metrics Filter에 기반하여 생성될 수 있음</li>
<li>alarm과 notification을 테스트해보기 위해 CLI를 사용해서 alarm state를 변경할 수 있음</li>
</ul>
<blockquote>
<p><code>aws cloudwatch set-alarm-state --alarm-name &quot;myalarm&quot; --state-value ALARM --state-reason &quot;testing purposes&quot;</code></p>
</blockquote>
<h2 id="amazon-eventbridge-formerly-cloudwatch-events"><a class="header" href="#amazon-eventbridge-formerly-cloudwatch-events">Amazon EventBridge (formerly CloudWatch Events)</a></h2>
<ul>
<li>Schedule: 크론잡 (Cron Jobs - scheduled scripts)</li>
<li>Event Pattern: 이벤트 규칙을 통해 서비스가 수행하는 작업에 반응</li>
<li>Lambda 함수 트리거, SQS/SNS 메시지 전송</li>
</ul>
<h3 id="amazon-eventbridge-rules"><a class="header" href="#amazon-eventbridge-rules">Amazon EventBridge Rules</a></h3>
<ul>
<li>Source에서 이벤트가 발생 (ex. EC2 인스턴스 시작, S3 오브젝트 업로드 등..)</li>
<li>위의 이벤트들이 필터링(선택 사항)되어 EventBridge로 전달</li>
<li>전달된 이벤트는 JSON 형태가 되어 destination으로 전달</li>
</ul>
<pre><code class="language-json">{
  &quot;version&quot;: &quot;0&quot;,
  &quot;id&quot;: &quot;6a7e8feb-b491&quot;,
  &quot;detail-type&quot;: &quot;EC2 Instance State-change Notification&quot;,
  // ...
}
</code></pre>
<h3 id="amazon-eventbridge---event-bus"><a class="header" href="#amazon-eventbridge---event-bus">Amazon EventBridge - Event Bus</a></h3>
<ul>
<li>몇가지 종류의 Event Bus
<ul>
<li>Default Event Bus - AWS Services</li>
<li>Partner Event Bus - AWS Saas Partners (ex. Zendesk, Datadog)</li>
<li>Custom Event Bus - Custom Apps</li>
</ul>
</li>
<li>event bus들은 Resource-based Policy를 통해 다른 AWS 계정들로부터도 액세스 가능함</li>
<li>event bus에 전달된 이벤트들(전체 또는 필터)은 <strong>아카이빙</strong>할 수 있음 (무기한 또는 기간 설정)</li>
<li><strong>아카이빙된 이벤트를 재실행</strong>할 수 있는 기능</li>
</ul>
<h3 id="amazon-eventbridge---schema-registry"><a class="header" href="#amazon-eventbridge---schema-registry">Amazon EventBridge - Schema Registry</a></h3>
<ul>
<li>EventBridge는 event bus 내에서 이벤트를 분석하여 **스키마(schema)**를 유추할 수 있음</li>
<li><strong>Schema Registry</strong>는 애플리케이션을 위해, 이벤트 버스 내에서 데이터가 어떻게 구성될지 미리 알 수 있게 해주는 코드를 생성할 수 있도록 함</li>
<li>Schema는 버저닝될 수 있음</li>
</ul>
<h3 id="amazon-eventbridge---resource-based-policy"><a class="header" href="#amazon-eventbridge---resource-based-policy">Amazon EventBridge - Resource-based Policy</a></h3>
<ul>
<li>특정 Event Bus 내 권한을 관리</li>
<li>예시: 다른 AWS 계정 또는 AWS 리전으로부터의 이벤트를 허용/거부</li>
<li>사례: 내 AWS Organization에서 일어나는 모든 이벤트들을 하나의 AWS 계정 또는 AWS 리전으로 통합</li>
</ul>
<h2 id="cloudwatch-insights"><a class="header" href="#cloudwatch-insights">CloudWatch Insights</a></h2>
<h3 id="cloudwatch-insights---container"><a class="header" href="#cloudwatch-insights---container">CloudWatch Insights - Container</a></h3>
<ul>
<li>컨테이너로부터 <strong>메트릭과 로그</strong>를 수집/병합/요약</li>
<li>다음 서비스에서의 컨테이너에 적용 가능
<ul>
<li>Amazon ECS</li>
<li>Amazon EKS</li>
<li>Kubernetes platforms on EC2</li>
<li>Fargate (both for ECS and EKS)</li>
</ul>
</li>
<li>Amazon EKS와 Kubernetes의 경우, CloudWatch Insights는 컨테이너 검색을 위해 CloudWatch Agent의 컨테이너화 버전을 사용함</li>
</ul>
<h3 id="cloudwatch-insights---lambda"><a class="header" href="#cloudwatch-insights---lambda">CloudWatch Insights - Lambda</a></h3>
<ul>
<li>AWS Lambda에서 동작하는 서버리스 애플리케이션에 대한 모니터링 / 트러블슈팅 솔루션</li>
<li>CPU 시간, 메모리, 디스크, 네트워크를 포함한 시스템 레벨 메트릭을 수집/병합/요약</li>
<li>콜드 스타트, lambda 워커 종료와 같은 진단 정보(diagnostic information)도 수집/병합/요약</li>
<li>Lambda Insights가 Lambda Layer로 제공됨</li>
</ul>
<h3 id="cloudwatch-insights---contributor"><a class="header" href="#cloudwatch-insights---contributor">CloudWatch Insights - Contributor</a></h3>
<ul>
<li>로그 데이터를 분석하여 contributor 데이터를 표시하는 시계열 데이터를 생성
<ul>
<li><strong>top-N contributor에 대한 메트릭</strong>을 볼 수 있음</li>
<li>unique contributor의 전체 수와 그들의 사용 내역</li>
</ul>
</li>
<li>top talker를 찾고, 누가/어떤 것이 시스템 성능에 영향을 미치는지 이해하는데에 도움</li>
<li>어떤 AWS 생성 로그와도 호환 (VPC, DNS, etc...)</li>
<li>사례:
<ul>
<li>bad host 찾기</li>
<li><strong>제일 네트워크 사용량이 많은 이용자 찾기</strong></li>
<li>가장 많은 에러가 발생하는 URL 찾기</li>
</ul>
</li>
<li>룰을 처음부터 구축할 수도 있고, 혹은 AWS에서 만들어진 샘플 룰을 사용할 수도 있음 - <strong>내 CloudWatch Log를 활용</strong></li>
<li>CloudWatch는 또한 다른 AWS 서비스로부터의 메트릭을 분석하는데 사용할 수 있는 빌트인 룰을 제공함</li>
</ul>
<h3 id="cloudwatch-insights---application"><a class="header" href="#cloudwatch-insights---application">CloudWatch Insights - Application</a></h3>
<ul>
<li><strong>모니터되고 있는 애플리케이션에서 예측되는 잠재적인 문제를 보여주고, 진행중인 문제를 격리하기 위한 도움을 주는 자동화된 대시보드를 제공</strong></li>
<li>일부 기술만 적용된 EC2 인스턴스에서 애플리케이션을 실행할 수 있음 (Java, .NET, Microsoft IIS Web Server, databases...)</li>
<li>또, 다른 AWS를 사용할 수 있음 (ex. Amazon EBS, RDS, ELB, ASG, Lambda, SQS, DynamoDB, S3 bucket, ECS, EKS, SNS, API Gateway...)</li>
<li>SageMaker를 내부적으로 사용</li>
<li>애플리케이션 health에 대한 가시성을 향상시켜 트러블슈팅 및 애플리케이션 오류 수정에 걸리는 시간을 줄여줌</li>
<li>Amazon EventBridge와 SSM OpsCenter에 발견된 사항과 경고를 전달할 수 있음</li>
</ul>
<h3 id="cloudwatch-insights-and-operatonal-visibility"><a class="header" href="#cloudwatch-insights-and-operatonal-visibility">CloudWatch Insights and Operatonal Visibility</a></h3>
<ul>
<li>CloudWatch Container Insights
<ul>
<li>ECS, EKS, Kubernetes on EC2, Fargate, 쿠버네티스의 경우 agent 필요</li>
<li>Metrics와 logs</li>
</ul>
</li>
<li>CloudWatch Lambda Insights
<ul>
<li>서버리스 애플리케이션을 트러블슈팅하기 위한 구체적인 메트릭</li>
</ul>
</li>
<li>CloudWatch Contributors Insights
<ul>
<li>CloudWatch Logs를 통해 &quot;Top-N&quot; 기여자를 발견</li>
</ul>
</li>
<li>CloudWatch Application Insights
<ul>
<li>애플리케이션과, 그와 관련된 AWS 서비스를 트러블슈팅하기 위한 자동화된 대시보드</li>
</ul>
</li>
</ul>
<h2 id="aws-cloudtrail"><a class="header" href="#aws-cloudtrail">AWS CloudTrail</a></h2>
<ul>
<li><strong>AWS 계정에 대한 governance, compliance, audit을 제공</strong></li>
<li>CloudTrail은 기본적으로 활성화</li>
<li>아래로부터 이루어진 <strong>내 AWS 계정으로 이루어진 이벤트 / API 호출 내역</strong>을 가져올 수 있음
<ul>
<li>콘솔</li>
<li>SDK</li>
<li>CLI</li>
<li>AWS Services</li>
</ul>
</li>
<li>CloudTrail로부터 CloudWatch Log 또는 S3로 로그를 전달할 수 있음</li>
<li><strong>모든 리전 (기본) 또는 단일 리전에 적용 가능</strong></li>
<li>AWS에서 리소스가 삭제된 경우, 먼저 CloudTrail을 살펴볼 것!</li>
</ul>
<h3 id="aws-cloudtrail---events"><a class="header" href="#aws-cloudtrail---events">AWS CloudTrail - Events</a></h3>
<ul>
<li><strong>Management Events</strong>:
<ul>
<li>AWS 계정 내 리소스에 이루어진 작업</li>
<li>예시:
<ul>
<li>보안 설정 (IAM <code>AttachRolePolicy</code>)</li>
<li>라우팅 데이터에 대한 룰 설정 (Amazon EC2 <code>CreateSubnet</code>)</li>
<li>로깅 설정 (AWS CloudTrail <code>CreateTrail</code>)</li>
</ul>
</li>
<li><strong>기본적으로, CloudTrail은 Management Events들을 로그하도록 설정되어 있음</strong></li>
<li><strong>Write Events</strong>(리소스에 대한 수정)과 <strong>Read Events</strong>(리소스를 수정하지 않음)를 구분할 수 있음</li>
</ul>
</li>
<li><strong>Data Events</strong>:
<ul>
<li><strong>기본적으로, Data Events들은 로그되지 않음</strong> (<strong>대용량 작업이기 때문</strong>)</li>
<li>Amazon S3의 오브젝트 레벨 활동 (ex. <code>GetObject</code>, <code>DeleteObject</code>, <code>PutObject</code>): Read Events와 Write Event 구분 가능</li>
<li>AWS Lambda 함수 실행 활동 (<code>Invoke</code> API)</li>
</ul>
</li>
<li><strong>CloudTrail Insights Events</strong>: 아래에서 설명</li>
</ul>
<h3 id="aws-cloudtrail---insights"><a class="header" href="#aws-cloudtrail---insights">AWS CloudTrail - Insights</a></h3>
<ul>
<li><strong>CloudTrail Insight의 활성화로 계정 내 일어난 일반적이지 않은 활동을 감지할 수 있음</strong>
<ul>
<li>부정확한 리소스 프로비저닝</li>
<li>서비스 한도 초과</li>
<li>AWS IAM 액션의 폭발적인 증가</li>
<li>정기적인 유지보수 활동의 부재</li>
</ul>
</li>
<li>CloudTrail은 기준점을 잡기 위해 일반적인 management event들을 분석</li>
<li>이후, <strong>일반적이지 않은 패턴을 탐색하기 위해 지속적으로 write event를 분석</strong>
<ul>
<li>이상 징후는 CloudTrail 콘솔 내에 나타남</li>
<li>이벤트는 S3에 전달됨</li>
<li>EventBridge 이벤트가 생성됨 (자동화가 필요한 경우)</li>
</ul>
</li>
</ul>
<h3 id="aws-cloudtrail---retention"><a class="header" href="#aws-cloudtrail---retention">AWS CloudTrail - Retention</a></h3>
<ul>
<li>Event들은 CloudTrail 내에 90일 동안 보관됨</li>
<li>이벤트를 그 이상 보관하려면, S3에 이를 로깅 (이후 Athena를 통해 분석 가능)</li>
</ul>
<h2 id="aws-config"><a class="header" href="#aws-config">AWS Config</a></h2>
<ul>
<li>AWS 리소스의 **compliance(규정)**를 준수하고 기록하도록 도와줌</li>
<li>시간에 따른 설정과 변경을 기록하는데 도움</li>
<li>AWS Config으로 해결할 수 있는 것들
<ul>
<li>내 Security group에 제한이 없는 SSH 액세스가 존재하는가?</li>
<li>내 버킷에 public access가 존재하는가?</li>
<li>시간이 지나면서 내 ALB 설정이 바뀐 적이 있는가?</li>
</ul>
</li>
<li>어떤 변경이든 경고(SNS notifications)를 받도록 할 수 있음</li>
<li>AWS Config은 리전 별 서비스</li>
<li>리전과 계정 간에 통합할 수도 있음</li>
<li>설정 데이터를 S3에 보관할 수 있음 (Athena로 분석될 수 있음)</li>
</ul>
<h3 id="aws-config---config-rules"><a class="header" href="#aws-config---config-rules">AWS Config - Config Rules</a></h3>
<ul>
<li>AWS에 의해 관리되는 config rule을 사용할 수 있음 (75개 이상)</li>
<li>커스텀 config rule을 사용할 수 있음 (반드시 AWS Lambda로 정의되어야 함)
<ul>
<li>ex. 모든 EBS 디스크가 gp2 타입이 맞는지 체크</li>
<li>ex. 모든 EC2 인스턴스가 t2.micro가 맞는지 체크</li>
</ul>
</li>
<li>Rule 자체도 평가 및 트리거될 수 있음
<ul>
<li>config이 변경될 때마다</li>
<li>And / Or: 일정 시간 간격으로</li>
</ul>
</li>
<li><strong>AWS Config Rules는 어떤 동작이 발생하는 것 자체를 막진 않음 (no deny)</strong></li>
<li><strong>Pricing</strong>: 프리티어 없음, 리전 별로 기록된 configuration item마다 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0.003</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord hangul_fallback">리전별</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">ee</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord hangul_fallback">마다</span></span></span></span>0.001</li>
</ul>
<h3 id="aws-config---resource"><a class="header" href="#aws-config---resource">AWS Config - Resource</a></h3>
<ul>
<li>시간 경과에 따른 리소스의 규정 확인</li>
<li>시간 경과에 따른 리소스 설정 확인</li>
<li>시간 경과에 따른 CloudTrail API 호출 확인</li>
</ul>
<h3 id="aws-config---remediations"><a class="header" href="#aws-config---remediations">AWS Config - Remediations</a></h3>
<ul>
<li>SSM Automation Documents을 통해 비규격(non-compliant) 리소스에 대한 수정을 자동화</li>
<li>AWS-Managed Automation Documents를 사용하거나 커스텀 Automation Documents를 생성
<ul>
<li>팁: Lambda 함수를 실행하는 커스텀 Automation Documents를 만들 수 있음</li>
</ul>
</li>
<li>만약 리소스가 auto-remediation이 수행된 이후에도 여전히 규정을 준수하지 않는 상태라면, <strong>Remediation Retries</strong>를 설정할 수 있음</li>
</ul>
<h3 id="aws-config---notifications"><a class="header" href="#aws-config---notifications">AWS Config - Notifications</a></h3>
<ul>
<li>AWS 리소스가 비규격 상태일 때, EventBridge를 사용하여 notification을 트리거</li>
<li>설정 변화와 규정 준수에 대한 상태 알림을 SNS로 전송할 수 있음
<ul>
<li>모든 이벤트가 전달되며, SNS 필터링 또는 클라이언트 사이드 필터링을 적용할 수 있음</li>
</ul>
</li>
</ul>
<h2 id="cloudwatch-vs-cloudtrail-vs-config"><a class="header" href="#cloudwatch-vs-cloudtrail-vs-config">CloudWatch vs. CloudTrail vs. Config</a></h2>
<ul>
<li>CloudWatch
<ul>
<li>퍼포먼스 모니터링 (메트릭, CPU, 네트워크 등) &amp; 대시보드</li>
<li>Events &amp; Alerting</li>
<li>로그 병합 &amp; 분석</li>
</ul>
</li>
<li>CloudTrail
<ul>
<li>계정 내 일어난 모든 API 호출을 기록</li>
<li>특정 리소스에 대한 trail을 정의</li>
<li>글로벌 서비스</li>
</ul>
</li>
<li>Config
<ul>
<li>설정 변경을 기록</li>
<li>리소스들의 규정(compliance) 준수 여부를 판단</li>
<li>변경과 규정 준수에 대한 타임라인 제공</li>
</ul>
</li>
</ul>
<h3 id="cloudwatch-vs-cloudtrail-vs-config---for-an-elastic-load-balancer"><a class="header" href="#cloudwatch-vs-cloudtrail-vs-config---for-an-elastic-load-balancer">CloudWatch vs. CloudTrail vs. Config - For an Elastic Load Balancer</a></h3>
<ul>
<li>CloudWatch:
<ul>
<li>들어오는(incoming) 연결 metric을 모니터링</li>
<li>시간 경과에 따른 에러 코드 비율을 %로 시각화</li>
<li>로드 밸런서 성능에 대한 아이디어를 얻기 위해 대시보드를 구축</li>
</ul>
</li>
<li>Config:
<ul>
<li>로드 밸런서의 Security Group 룰을 트래킹</li>
<li>로드 밸런서의 설정 변경을 트래킹</li>
<li>SSL 인증서가 항상 로드 밸런서에 할당되도록 보장 (compliance)</li>
</ul>
</li>
<li>CloudTrail:
<ul>
<li>API 호출을 통해 누가 로드 밸런서를 변경했는지 트래킹</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="iam-advanced"><a class="header" href="#iam-advanced">IAM Advanced</a></h1>
<h2 id="aws-organizations"><a class="header" href="#aws-organizations">AWS Organizations</a></h2>
<ul>
<li>글로벌 서비스</li>
<li>여러 AWS 계정을 관리할 수 있도록 해줌
<ul>
<li>메인 계정 = 관리 계정 (Management account)</li>
<li>그 외의 계정 = 멤버 계정 (Member account)</li>
</ul>
</li>
<li>멤버 계정들은 한 organization의 일부가 될 수 있음</li>
<li>모든 계정 간에 청구서를 통합(consolidate)할 수 있음 - single payment method</li>
<li>통합 이용을 통한 비용적 이득 (EC2, S3에 대한 볼륨 할인)</li>
<li><strong>계정 간에 Reserved Instances나 Savings Plans 할인을 공유할 수 있음</strong></li>
<li>AWS 계정 생성을 자동화하기 위해 API를 활용할 수 있음</li>
</ul>
<h3 id="aws-organizations---organizational-units-ou--examples"><a class="header" href="#aws-organizations---organizational-units-ou--examples">AWS Organizations - Organizational Units (OU) ~ Examples</a></h3>
<p><img src="https://towardsthecloud.com/wp-content/uploads/aws-organizations-structure-1024x933.webp" alt="OU Example" /></p>
<h3 id="aws-organizations---pros"><a class="header" href="#aws-organizations---pros">AWS Organizations - Pros</a></h3>
<ul>
<li><strong>Advantages</strong>
<ul>
<li>다중 계정 vs 한 계정 내 여러 VPC ~ 계정을 여러개 둠으로써 보안 측면에서 더 나음</li>
<li>비용 청구 목적으로 태깅(tagging) 표준을 둘 수 있음</li>
<li>모든 계정에 대해 CloudTrail을 활성화하고, 중앙 S3 계정에 로그들을 보낼 수 있음</li>
<li>중앙 로깅 계정에 CloudWatch 로그를 전송</li>
<li>관리 목적으로 Cross Account Role을 구축할 수 있음</li>
</ul>
</li>
<li><strong>Security: Service Control Policies (SCP)</strong>
<ul>
<li>User 또는 Role 역할을 제한하기 위해 IAM 정책을 OU 또는 계정 단위로 적용할 수 있음</li>
<li>SCP는 관리 계정에 적용할 수 없음 (full admin power)</li>
<li>반드시 explicit allow를 가져야 함 (기본적으로는 아무것도 허용하지 않음 - IAM처럼)</li>
</ul>
</li>
</ul>
<h3 id="aws-organiazations---scp-examples--blocklist-and-allowlist-strategies"><a class="header" href="#aws-organiazations---scp-examples--blocklist-and-allowlist-strategies">AWS Organiazations - SCP Examples ~ Blocklist and Allowlist strategies</a></h3>
<ul>
<li>기본적으로 모든 액션을 허용하고(ex. <code>AllowsAllActions</code>), 일부 권한에 대해 Deny 시키는 방법을 쓰거나 ~ Blocklist</li>
<li>기본적으로 모든 액션을 막아두고(별도로 권한 부여하지 않음), 일부 권한을 Allow 시키는 방법을 쓸 수 있음 ~ Allowlist</li>
</ul>
<h2 id="iam-conditions"><a class="header" href="#iam-conditions">IAM Conditions</a></h2>
<ul>
<li><strong>aws:SourceIp</strong>: API 호출이 이루어지는 클라이언트 IP를 제한</li>
</ul>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Deny&quot;,
      &quot;Action&quot;: &quot;*&quot;,
      &quot;Resource&quot;: &quot;*&quot;,
      &quot;Condition&quot;: {
        &quot;NotIpAddress&quot;: {
          &quot;aws:SourceIp&quot;: [&quot;192.0.2.0/24&quot;]
        }
      }
    }
  ]
}
</code></pre>
<ul>
<li><strong>aws:RequestedRegion</strong>: API 호출이 이루어지는 지역을 제한</li>
</ul>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Deny&quot;,
      &quot;Action&quot;: [&quot;ec2:*&quot;, &quot;rds:*&quot;, &quot;dynamodb:*&quot;],
      &quot;Resource&quot;: &quot;*&quot;,
      &quot;Condition&quot;: {
        &quot;StringEquals&quot;: {
          &quot;aws:RequestedRegion&quot;: [&quot;eu-central-1&quot;, &quot;eu-west-1&quot;]
        }
      }
    }
  ]
}
</code></pre>
<ul>
<li><strong>ec2:ResourceTag</strong>: 태그를 기반으로 제한</li>
</ul>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [&quot;ec2:StartInstances&quot;, &quot;ec2:StopInstances&quot;],
      &quot;Resource&quot;: &quot;arn:aws:ec2:us-east-1:123456789012:instance/*&quot;,
      &quot;Condition&quot;: {
        &quot;StringEquals&quot;: {
          &quot;ec2:ResourceTag/Project&quot;: &quot;DataAnalytics&quot;,
          &quot;aws:PrincipalTag/Department&quot;: &quot;Data&quot;
        }
      }
    }
  ]
}
</code></pre>
<ul>
<li><strong>aws:MultiFactorAuthPresent</strong>: MFA를 강제</li>
</ul>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: &quot;ec2:*&quot;,
      &quot;Resource&quot;: &quot;*&quot;,
    },
    {
      &quot;Effect&quot;: &quot;Deny&quot;,
      &quot;Action&quot;: [&quot;ec2:StartInstances&quot;, &quot;ec2:TerminateInstances&quot;],
      &quot;Resource&quot;: &quot;*&quot;,
      &quot;Condition&quot;: {
        &quot;BoolIfExists&quot;: {
          &quot;aws:MultiFactorAuthPresent&quot;: false
        }
      }
    }
  ]
}
</code></pre>
<h2 id="iam-for-s3"><a class="header" href="#iam-for-s3">IAM for S3</a></h2>
<ul>
<li><strong>s3:ListBucket</strong> 권한은 <strong>arn:aws:s3:::test</strong>에 적용됨
<ul>
<li>버킷 레벨의 권한</li>
</ul>
</li>
<li><strong>s3:GetObject</strong>, <strong>s3:PutObject</strong>, <strong>s3:DeleteObject</strong>는 <b>arn:awn:s3:::test/*</b>에 적용됨
<ul>
<li>오브젝트 레벨의 권한</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [&quot;s3:ListBucket&quot;],
      &quot;Resource&quot;: &quot;arn:aws:s3:::test&quot;,
    },
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [
        &quot;s3:PutObject&quot;,
        &quot;s3:GetObject&quot;,
        &quot;s3:DeleteObject&quot;
      ],
      &quot;Resource&quot;: &quot;arn:aws:s3:::test/*&quot;,
    }
  ]
}
</code></pre>
<h2 id="resource-policies--awsprincipalorgid"><a class="header" href="#resource-policies--awsprincipalorgid">Resource Policies &amp; aws:PrincipalOrgID</a></h2>
<ul>
<li><strong>aws:PrincipalOrgID</strong>는 특정 AWS Organization 멤버 계정의 액세스 권한을 제한하기 위하여 리소스 정책 내에 사용됨</li>
</ul>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [&quot;s3:PutObject&quot;, &quot;s3:GetObject&quot;],
      &quot;Resource&quot;: &quot;arn:aws:s3:::2022-financial-data/*&quot;,
      &quot;Condition&quot;: {
        &quot;StringEquals&quot;: {
          &quot;aws:PrincipalOrgID&quot;: [&quot;o-yyyyyyyyyy&quot;]
        }
      }
    }
  ]
}
</code></pre>
<h2 id="iam-roles-vs-resource-based-policies"><a class="header" href="#iam-roles-vs-resource-based-policies">IAM Roles vs. Resource Based Policies</a></h2>
<ul>
<li>
<p>Cross account의 경우:</p>
<ul>
<li>하나의 리소스에 resource-based policy를 부여할 수 있음 (ex. S3 bucket policy)</li>
<li>또는 IAM Role을 proxy로 사용할 수 있음</li>
</ul>
</li>
<li>
<p><strong>Role(이용자, 애플리케이션 또는 서비스)을 가정할 때는, 기존의 권한을 포기하고 role에 할당된 권한을 가져오게 됨</strong></p>
</li>
<li>
<p>Resource-based policy를 사용할 때는, 기존의 권한을 포기하지 않아도 됨</p>
<ul>
<li><strong>사례</strong>:
<ul>
<li>accountA에 속한 이용자가 accountA에 있는 DynamoDB 테이블을 스캔하여 accountB에 있는 S3 버킷에 덤프해야 할 때는 Resource-based policy를 사용해야 함</li>
</ul>
</li>
<li>지원 대상: Amazon S3 버킷, SNS 토픽, SQS 큐 등등...</li>
</ul>
</li>
</ul>
<h3 id="iam-roles-vs-resource-based-policies---amazon-eventbridge--security"><a class="header" href="#iam-roles-vs-resource-based-policies---amazon-eventbridge--security">IAM Roles vs. Resource Based Policies - Amazon EventBridge ~ Security</a></h3>
<ul>
<li>rule이 동작할 때는, 타겟에 대한 권한이 필요하며 이는 다음의 두가지 형태가 될 수 있음
<ul>
<li>Resource-based policy: Lambda, SNS, SQS, CloudWatch Logs, API Gateway...</li>
<li>IAM Role: Kinesis stream, Systems Manager Run Command, ECS task...</li>
</ul>
</li>
</ul>
<h2 id="iam-permission-boundaries"><a class="header" href="#iam-permission-boundaries">IAM Permission Boundaries</a></h2>
<ul>
<li>IAM Permission Boundaries는 User 또는 Role에 의해 지원됨 (Group은 아님)</li>
<li>이는 IAM 엔티티가 가질 수 있는 최대 권한을 설정하도록 managed policy를 사용할 수 있게 해주는 고급 기능</li>
<li>예시: 아래처럼 S3, CloudWatch, EC2에 대한 권한을 허용하는 IAM Permission Boundary를 설정해둔 상태에서, 추가로 아래의 <code>iam:CreateUser</code>를 허용하도록 하더라도, 이는 효과가 없음 (추가 권한을 가질 수 없음)</li>
</ul>
<pre><code class="language-json">// IAM Permission Boundary
{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [&quot;s3:*&quot;, &quot;cloudwatch:*&quot;, &quot;ec2:*&quot;],
      &quot;Resource&quot;: &quot;*&quot;
    }
  ]
}
</code></pre>
<pre><code class="language-json">// IAM Permissions Through IAM Policy
{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: &quot;iam:CreateUser&quot;,
      &quot;Resource&quot;: &quot;*&quot;
    }
  ]
}
</code></pre>
<p><img src="https://docs.aws.amazon.com/images/IAM/latest/UserGuide/images/EffectivePermissions-rbp-boundary-id.png" alt="Permission Boundaries Example" /></p>
<h3 id="iam-permission-boundaries---use-cases"><a class="header" href="#iam-permission-boundaries---use-cases">IAM Permission Boundaries - Use Cases</a></h3>
<ul>
<li>permission boundary 내에 있는 비관리자(non-admin)에게 권한을 위임 (ex. 새 IAM user 생성)</li>
<li>모든 개발자들에게 직접 정책을 할당하도록 허용하여 권한을 관리할 수 있도록 하면서도, 권한을 에스컬레이션(escalate)할 수는 없도록 막을 수 있음 (ex. 스스로 어드민을 부여해버린다던가)</li>
<li>한 특정 이용자에게 제한을 걸기에 유용함 (Organizations &amp; SCP를 사용하여 전체 계정을 다루는 대신)</li>
</ul>
<h3 id="iam-policy-evaluation-logic"><a class="header" href="#iam-policy-evaluation-logic">IAM Policy Evaluation Logic</a></h3>
<p><img src="https://docs.aws.amazon.com/images/IAM/latest/UserGuide/images/PolicyEvaluationHorizontal111621.png" alt="IAM Policy Evaluation Logic" /></p>
<h3 id="example-iam-policy"><a class="header" href="#example-iam-policy">Example IAM Policy</a></h3>
<pre><code class="language-json">{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Action&quot;: &quot;sqs:*&quot;,
      &quot;Effect&quot;: &quot;Deny&quot;,
      &quot;Resource&quot;: &quot;*&quot;
    },
    {
      &quot;Action&quot;: [
        &quot;sqs:DeleteQueue&quot;
      ],
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Resource&quot;: &quot;*&quot;
    }
  ]
}
</code></pre>
<ul>
<li><code>sqs:CreateQueue</code>를 수행할 수 있는가?
<ul>
<li><strong>아니오</strong></li>
</ul>
</li>
<li><code>sqs:DeleteQueue</code>를 수행할 수 있는가?
<ul>
<li><strong>아니오</strong></li>
</ul>
</li>
<li><code>ec2:DescribeInstances</code>를 수행할 수 있는가?
<ul>
<li><strong>아니오</strong></li>
</ul>
</li>
</ul>
<h2 id="aws-iam-identity-center-successor-to-aws-single-sign-on"><a class="header" href="#aws-iam-identity-center-successor-to-aws-single-sign-on">AWS IAM Identity Center (Successor to AWS Single Sign-On)</a></h2>
<ul>
<li>아래 모든 것들을 하나의 로그인(single sign-on)으로 통일할 수 있음
<ul>
<li><strong>AWS Organization 내에 있는 AWS 계정</strong></li>
<li>비즈니스 클라우드 애플리케이션 (e.g., Salesforce, Box, Microsoft 365, ...)</li>
<li>SAML2.0 사용 애플리케이션</li>
<li>EC2 Windows Instances</li>
</ul>
</li>
<li>Identity Providers (ID 공급자)
<ul>
<li>IAM Identity Center 내 빌트인 Identity Store</li>
<li>써드파티: Active Directory(AD), OneLogin, Okta...</li>
</ul>
</li>
</ul>
<h3 id="aws-iam-identity-center---fine-grained-permissions-and-assignments"><a class="header" href="#aws-iam-identity-center---fine-grained-permissions-and-assignments">AWS IAM Identity Center - Fine-grained Permissions and Assignments</a></h3>
<ul>
<li>
<p><strong>Multi-Account Permissions</strong></p>
<ul>
<li>AWS Organization 내에 있는 여러 AWS 계정 간의 액세스 관리</li>
<li>Permission Sets - 이용자 및 그룹의 AWS 액세스 권한을 정의하기 위한 하나 이상의 IAM Policy 컬렉션</li>
</ul>
</li>
<li>
<p><strong>Application Assignments</strong></p>
<ul>
<li>여러 SAML 2.0 비즈니스 애플리케이션에 대한 SSO 액세스 (Salesforce, Box, Microsoft 365...)</li>
<li>URL, 인증서, 메타데이터 입력이 필수적임</li>
</ul>
</li>
<li>
<p><strong>Attribute-Based Access Control (ABAC)</strong></p>
<ul>
<li>IAM Identity Center Identity Store에 저장된 이용자의 속성(attribute)에 기반한 Fine-grained permission</li>
<li>예시: cost center, title, locale, ...</li>
<li>사례: 일단 한번만 권한을 정의한 다음에는 속성이 변경될 때마다 AWS 액세스가 수정되도록 할 수 있음</li>
</ul>
</li>
</ul>
<h2 id="aws-directory-services"><a class="header" href="#aws-directory-services">AWS Directory Services</a></h2>
<h3 id="what-is-microsoft-active-directory-ad"><a class="header" href="#what-is-microsoft-active-directory-ad">What is Microsoft Active Directory (AD)?</a></h3>
<ul>
<li>AD Domain Services가 있는 모든 Windows Server에서 볼 수 있음</li>
<li><strong>objects</strong>에 대한 데이터베이스: 이용가 계정, 컴퓨터, 프린터, 파일 공유, 보안 그룹</li>
<li>보안 관리, 계정 생성, 권한 할당을 중앙에서 관리</li>
<li>Object들은 <strong>tree</strong>안에 구성됨</li>
<li>여러 tree의 그룹은 <strong>forest</strong>가 됨</li>
</ul>
<h3 id="aws-directory-services---types"><a class="header" href="#aws-directory-services---types">AWS Directory Services - Types</a></h3>
<ul>
<li><strong>AWS Managed Microsoft AD</strong>
<ul>
<li>AWS 내에 자체적인 AD를 생성, 로컬에서 이용자들을 관리, MFA 지원</li>
<li>온-프레미스 AD와 &quot;신뢰 가능한&quot; 연결을 구성할 수 있음</li>
</ul>
</li>
<li><strong>AD Connector</strong>
<ul>
<li>온-프레미스 AD로 리다이렉트하는 Directory Gateway (proxy)로, MFA 지원</li>
<li>온-프레미스 AD에서 이용자들을 관리</li>
</ul>
</li>
<li><strong>Simple AD</strong>
<ul>
<li>AWS 내 AD와 호환되는 관리형 디렉토리</li>
<li>온-프레미스 AD와는 합칠 수 없음</li>
</ul>
</li>
</ul>
<h3 id="aws-identity-center---active-directory-setup"><a class="header" href="#aws-identity-center---active-directory-setup">AWS Identity Center - Active Directory Setup</a></h3>
<ul>
<li><strong>AWS Managed Microsoft AD (Directory Service)에 연결</strong>
<ul>
<li>즉시 사용 가능한 통합</li>
</ul>
</li>
<li><strong>직접 관리하는 Directory에 연결</strong>
<ul>
<li>AWS Managed Microsoft AD를 사용해 Two-way Trust Relationship을 구축</li>
<li>또는 AD Connector를 생성하여 프록시 구성</li>
</ul>
</li>
</ul>
<h2 id="aws-control-tower"><a class="header" href="#aws-control-tower">AWS Control Tower</a></h2>
<ul>
<li>
<p>베스트 프랙티스에 맞게 <strong>multi-account AWS 환경에서 안전하고 규정을 준수하도록 설정 및 관리</strong>를 할 수 있도록 해주는 쉬운 방법</p>
</li>
<li>
<p>AWS Control Tower는 계정 생성을 위해 AWS Organization을 사용</p>
</li>
<li>
<p>이점:</p>
<ul>
<li>몇 번의 클릭으로 환경을 구축할 수 있도록 자동화</li>
<li>guardrail을 통해 사용 중인 정책 관리를 자동화</li>
<li>정책 위반을 감지하고 이를 수정</li>
<li>인터랙티브 대시보드를 통해 규정 준수 내용을 모니터링</li>
</ul>
</li>
</ul>
<h3 id="aws-control-tower---guardrails"><a class="header" href="#aws-control-tower---guardrails">AWS Control Tower - Guardrails</a></h3>
<ul>
<li>내 ControlTower 환경에 현재 진행중인 거버넌스(governance)를 전달 (모든 AWS Accounts에)
<ul>
<li><strong>Preventive Guardrail</strong> - <strong>SCP(Service Control Policies)를 사용</strong> (e.g., 모든 계정 내 리전을 제한)</li>
<li><strong>Detective Guardrail</strong> - <strong>AWS Config을 사용</strong> (e.g., 태그가 되지 않은 리소스들을 파악)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="security--encryption"><a class="header" href="#security--encryption">Security &amp; Encryption</a></h1>
<h2 id="why-encryption"><a class="header" href="#why-encryption">Why encryption?</a></h2>
<h3 id="encryption-in-flight-ssl"><a class="header" href="#encryption-in-flight-ssl"><strong>Encryption in flight (SSL)</strong></a></h3>
<ul>
<li>데이터가 전송되기 전에 암호화되고, 받은 이후에 복호화</li>
<li>SSL 인증서가 암호화를 도움 (HTTPS)</li>
<li>Encryption in flight는 MITM (man in the middle attack)이 일어나지 않음을 보장해줌
<ul>
<li>MITM? - 공격자가 이용자의 인터넷 서버와 트래픽의 목적지 사이에 끼어들어 전송을 가로채는 공격</li>
</ul>
</li>
</ul>
<h3 id="server-side-encryption-at-rest"><a class="header" href="#server-side-encryption-at-rest"><strong>Server side encryption at rest</strong></a></h3>
<ul>
<li>서버가 데이터를 전송받은 이후 이를 암호화</li>
<li>서버측에서 데이터를 전송하기 전에 복호화</li>
<li>하나의 키(보통 data key)를 통해 암호화된 형태로 저장</li>
<li>암호화/복호화 키는 반드시 어딘가에서 관리되는 오브젝트여야 하며, 서버가 여기에 반드시 접근 할 수 있어야 함</li>
</ul>
<h3 id="client-side-encryption"><a class="header" href="#client-side-encryption"><strong>Client side encryption</strong></a></h3>
<ul>
<li>데이터가 클라이언트를 통해 암호화되고, 서버 측에서는 이를 복호화할 일이 없음</li>
<li>복호화 역시 데이터를 넘겨받은 클라이언트 측에서 이루어짐</li>
<li>서버 쪽에서는 데이터를 복호화할 수 없어야 함</li>
<li>Envelope Encryption을 활용할 수 있음</li>
</ul>
<h2 id="aws-kms-key-management-service"><a class="header" href="#aws-kms-key-management-service">AWS KMS (Key Management Service)</a></h2>
<ul>
<li>AWS 서비스에서 &quot;암호화&quot;와 관련된 내용을 들었다면 대부분은 KMS와 관련된 것</li>
<li>AWS가 암호화 키를 관리해 줌</li>
<li>권한 처리를 위해 IAM과 호환</li>
<li>데이터에 대한 액세스를 통제하는 쉬운 방법</li>
<li>CloudTrail을 통해 KMS 키 사용을 감시할 수 있음</li>
<li>대부분의 AWS 서비스에서 원활하게 호환됨 (EBS, S3, RDS, SSM...)</li>
<li><strong>절대로 secret을 plaintext로 저장하지 말 것, 특히 코드에서!</strong>
<ul>
<li>KMS 키 암호화는 API 호출을 통해서도 가능 (SDK, CLI)</li>
<li>암호화된 secret은 코드 또는 환경 변수에 저장될 수 있음</li>
</ul>
</li>
</ul>
<h3 id="kms-keys-types"><a class="header" href="#kms-keys-types">KMS Keys Types</a></h3>
<ul>
<li>
<p><strong>KMS Keys는 KMS Customer Master Key의 새로운 이름</strong></p>
</li>
<li>
<p><strong>대칭키 (AES-256 Keys)</strong></p>
<ul>
<li>하나의 키로 암호화/복호화 가능</li>
<li>KMS를 이용하는 AWS 서비스는 대칭 CMKs(Customer Managed Keys)를 이용함</li>
<li>절대로 복호화된 KMS 키에 액세스할 수는 없음 (사용하려면 반드시 KMS API를 호출해야 함)</li>
</ul>
</li>
<li>
<p><strong>비대칭키 (RSA &amp; ECC key pairs)</strong></p>
<ul>
<li>Public Key(암호화)와 Private Key(복호화)가 한쌍</li>
<li>암호화/복호화에 사용하거나, 서명/확인 작업에 사용</li>
<li>Public Key는 다운로드 가능하지만, 복호화된 Private Key에는 액세스할 수 없음</li>
<li>사례: KMS API를 호출할 수 없는 AWS 외부 이용자를 통해 이루어진 암호화</li>
</ul>
</li>
<li>
<p>KMS 키의 종류</p>
<ul>
<li>AWS Owned Key (무료): SS3-S3, SSE-SQS, SSE-DDB (기본 키)</li>
<li>AWS Managed Key: <strong>무료</strong> (aws/service-name ~ ex. aws/rds 또는 aws/ebs)</li>
<li>Customer managed keys created in KMS: <strong>한달에 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">mana</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">eys</span><span class="mord mathnormal">im</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord hangul_fallback">반드시대칭키</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord hangul_fallback">한달에</span></span></span></span>1</strong></li>
<li>+ KMS에 대한 API 호출에 따라 비용 지불 (0.03 / 10000 호출당)</li>
</ul>
</li>
<li>
<p>Automatic Key rotation:</p>
<ul>
<li>AWS-managed KMS Key: 매년마다 자동으로 이루어짐</li>
<li>Customer-managed KMS Key: (반드시 활성화됨) 매년마다 자동으로 이루어짐</li>
<li>Imported KMS Key: alias를 통해 가능할 때마다 수동으로만 로테이션</li>
</ul>
</li>
</ul>
<h3 id="copying-snapshots-across-regions"><a class="header" href="#copying-snapshots-across-regions">Copying Snapshots across regions</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/volume-reencrypt.png" alt="Copying Snapshots across regions with KMS" /></p>
<h3 id="kms-key-policies"><a class="header" href="#kms-key-policies">KMS Key Policies</a></h3>
<ul>
<li>
<p>KMS 키에 대한 액세스를 통제, S3로 치자면 bucket policies와 유사함</p>
</li>
<li>
<p>차이점: Key Policy 없이는 액세스를 관리할 수 없음</p>
</li>
<li>
<p><strong>Default KMS Key Policy</strong>:</p>
<ul>
<li>구체적인 KMS Key Policy를 전달하지 않았을 때 생성</li>
<li>루트 User(전체 AWS 계정)에게 키에 대한 완전한 액세스 권한을 부여</li>
</ul>
</li>
<li>
<p><strong>Custom KMS Key Policy</strong>:</p>
<ul>
<li>KMS Key에 액세스할 수 있는 User, Role을 정의</li>
<li>키를 관리할 수 있는 대상을 정의</li>
<li>내 KMS 키에 대해 계정 간 액세스를 구현하는 데에 유용</li>
</ul>
</li>
</ul>
<h3 id="copying-snapshots-across-accounts"><a class="header" href="#copying-snapshots-across-accounts">Copying Snapshots across accounts</a></h3>
<ol>
<li>스냅샷을 생성하여 직접 보유한 KMS 키(Customer Managed Key)로 암호화</li>
<li><strong>cross-account 액세스 권한을 허용하도록 KMS Key Policy를 부여</strong> (하단 참조)</li>
<li>암호화된 스냅샷을 공유</li>
<li>(타겟에서) 스냅샷의 복제본을 생성하고, 이를 계정 내 CMK(Customer Managed Key)로 암호화</li>
<li>스냅샷으로부터 볼륨을 생성</li>
</ol>
<pre><code class="language-json">{
  &quot;Sid&quot;: &quot;Allow use of the key with destination account&quot;,
  &quot;Effect&quot;: &quot;Allow&quot;,
  &quot;Principal&quot;: {
    &quot;AWS&quot;: &quot;arn:aws:iam::TARGET-ACCOUNT-ID:role/ROLENAME&quot;
  },
  &quot;Action&quot;: [
    &quot;kms:Decrypt&quot;,
    &quot;kms:CreateGrant&quot;
  ],
  &quot;Resource&quot;: &quot;*&quot;,
  &quot;Condition&quot;: {
    &quot;StringEquals&quot;: {
      &quot;kms:ViaService&quot;: &quot;ec2.REGION.amazonaws.com&quot;,
      &quot;kms:CallerAccount&quot;: &quot;TARGET-ACCOUNT-ID&quot;
    }
  }
}
</code></pre>
<h2 id="kms-multi-region-keys"><a class="header" href="#kms-multi-region-keys">KMS Multi-Region Keys</a></h2>
<p><img src="https://docs.aws.amazon.com/images/kms/latest/developerguide/images/multi-region-keys.png" alt="KMS Multi-Region Keys" /></p>
<ul>
<li>다른 AWS 리전에서도 상호 교환이 가능한 동일 KMS Key</li>
<li>Multi-Region key는 동일한 key ID, key material, automatic rotation을 가짐</li>
<li>한 리전에서 암호화하고, 다른 리전에서 복호화할 수 있음</li>
<li>다시 암호화하거나, 크로스 리전 API 호출을 수행할 필요 없음</li>
<li>KMS Multi-Region은 글로벌하지 않음 (Primary + Replicas)</li>
<li>각각의 Multi-Region Key는 <strong>독립적으로</strong> 관리됨</li>
<li><strong>사례</strong>: 글로벌 클라이언트 사이드 암호화, 글로벌 DynamoDB 또는 글로벌 Aurora 암호화</li>
</ul>
<h3 id="dynamodb-global-tables-and-kms-multi-region-keys---client-side-encryption"><a class="header" href="#dynamodb-global-tables-and-kms-multi-region-keys---client-side-encryption">DynamoDB Global Tables and KMS Multi-Region Keys - Client-Side encryption</a></h3>
<ul>
<li><strong>Amazon DynamoDB Encryption Client</strong>를 사용하는 DynamoDB 테이블 내에 클라이언트 측에서 특정 attribute만 암호화할 수 있음</li>
<li>GlobalTables와 함께 사용되어, 클라이언트 측에서 암호화된 데이터는 다른 리전으로도 복제됨</li>
<li>만약 Multi-Region Key를 사용한다면, 이를 DynamoDB Global 테이블과 동일한 리전에 복제하여 해당 리전 내 클라이언트들이 클라이언트 복호화를 수행하기 위해 KMS API을 낮은 레이턴시로 호출할 수 있게됨</li>
<li>클라이언트 측 암호화를 통해 특정한 필드만 보호할 수 있고, 오직 API 키에 액세스 권한을 보유한 클라이언트만 복호화를 수행하도록 보장할 수 있음</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/22d200f8670dbdb3e253a90eee5098477c95c23d/2021/06/15/Encrypt-global-data-ForSocialr.jpg" alt="DynamoDB Global Tables and KMS Multi-Region Keys" /></p>
<h3 id="global-aurora-and-kms-multi-region-keys---client-side-encryption"><a class="header" href="#global-aurora-and-kms-multi-region-keys---client-side-encryption">Global Aurora and KMS Multi-Region Keys - Client-Side encryption</a></h3>
<ul>
<li><strong>AWS Encryption SDK</strong>를 통해 Aurora 테이블 내 특정 attribute를 클라이언트 측 암호화 할 수 있음</li>
<li>Aurora Global Table과 함께 사용하여, 클라이언트 측 암호화된 데이터를 다른 리전에 복제</li>
<li>만약 Multi-Region Key를 사용한다면, Global Aurora DB와 동일한 리전에 복제하여 해당 리전 내 클라이언트들이 클라이언트 복호화를 수행하기 위해 KMS API을 낮은 레이턴시로 호출할 수 있게됨</li>
<li>클라이언트 측 암호화를 통해 특정한 필드만 보호할 수 있고, 오직 API 키에 액세스 권한을 보유한 클라이언트만 복호화를 수행하도록 보장할 수 있으며, <strong>심지어 DB 어드민으로부터도 특정 필드를 보호할 수 있음</strong></li>
</ul>
<p><img src="https://velog.velcdn.com/images/jungmyeong96/post/ee17c8bd-5734-45e2-b0f6-a193becd75fb/image.png" alt="Global Aurora and KMS Multi-Region Keys" /></p>
<h2 id="s3-replication-encryption-considerations"><a class="header" href="#s3-replication-encryption-considerations">S3 Replication Encryption Considerations</a></h2>
<ul>
<li><strong>기본적으로 암호화되지 않은 오브젝트와 SSE-S3로 암호회된 오브젝트가 복제됨</strong></li>
<li>SSE-C(Customer provided key)로 암호화된 오브젝트는 복제될 수 없음</li>
<li><strong>SSE-KMS로 암호화된 오브젝트들의 경우</strong>, 옵션을 활성화해야함
<ul>
<li>타겟 버킷 내에 오브젝트를 암호화하기 위해 어떤 KMS 키를 쓸 것인지 명시</li>
<li>타겟 키를 위한 KMS Key Policy를 적용</li>
<li>소스 KMS Key에 대한 복호화를 위해 <code>kms:Decrypt</code>와 타겟 KMS Key에 대한 암호화를 위해 <code>kms:Encrypt</code>를 가진 IAM Role이 필요함</li>
<li>KMS 쓰로틀링 에러가 발생할 수 있으며, 이 경우 Service Quota의 증가를 요청할 수 있음</li>
</ul>
</li>
<li><strong>Multi-Region AWS KMS Keys를 사용할 수는 있으나, 아직까지는 Amazon S3에서 이를 independent key로 다루고 있음 (오브젝트들은 여전히 복호화/암호화 처리가 될 것임)</strong></li>
</ul>
<h2 id="ami-sharing-process-encrypted-via-kms"><a class="header" href="#ami-sharing-process-encrypted-via-kms">AMI Sharing Process Encrypted via KMS</a></h2>
<ol>
<li>AMI in Source Account는 Source Account로부터 KMS Key로 암호화됨</li>
<li>이미지 속성을 수정하여, 타겟 AWS 계정에 <strong>Launch Permission</strong>을 반드시 추가</li>
<li>AMI 참조 스냅샷을 암호화하는 데 사용한 KMS Key를 타겟 계정 또는 IAM Role와 반드시 공유</li>
<li>IAM Role 또는 타겟 계정 내 User는 반드시 DescribeKey, ReEcrypted, CreateGrant, Decrypt에 대한 권한을 보유해야 함</li>
<li>AMI로부터 EC2 인스턴스를 실행할 때, 원한다면 타겟 계정은 본인 계정 내 새로운 KMS Key를 정의해서 볼륨을 새로 암호화할 수 있음</li>
</ol>
<h2 id="ssm-parameter-store"><a class="header" href="#ssm-parameter-store">SSM Parameter Store</a></h2>
<ul>
<li>configuration 및 secrets를 위한 안전한 스토리지</li>
<li>KMS를 통한 암호화 (선택 사항)</li>
<li>serverless, scalable, durable, easy SDK</li>
<li>configuration / secrets에 대한 버전 트래킹</li>
<li>IAM을 통해 보안</li>
<li>Amazon EventBridge를 통한 알림</li>
<li>CloudFormation과 호환</li>
</ul>
<h3 id="ssm-parameter-store-hierarchy"><a class="header" href="#ssm-parameter-store-hierarchy">SSM Parameter Store Hierarchy</a></h3>
<ul>
<li>/my-department/
<ul>
<li>my-app/
<ul>
<li>dev/ ~ Dev Lambda 함수 내 <code>GetParameters</code> 또는 <code>GetParametersByPath</code> API 사용
<ul>
<li>db-url</li>
<li>db-password</li>
</ul>
</li>
<li>prod/ ~ Prod Lambda 함수 내 <code>GetParameters</code> 또는 <code>GetParametersByPath</code> API 사용
<ul>
<li>db-url</li>
<li>db-password</li>
</ul>
</li>
</ul>
</li>
<li>other-app/</li>
</ul>
</li>
<li>/other-department/</li>
<li>/aws/reference/secretsmanager/secret_ID_in_Secrets_Manager</li>
<li>/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 (public)</li>
</ul>
<table id="w810aac21c12c17b9c11">
  <thead>
    <tr>
        <th></th>
        <th>Standard</th>
        <th>Advanced</th>
    </tr>
  </thead>
  <tbody>
    <tr>
        <td>
            <p>Total number of parameters allowed</p>
            <p>(per AWS account and AWS Region)</p>
        </td>
        <td>
            <p>10,000</p>
        </td>
        <td>
            <p>100,000</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>Maximum size of a parameter value</p>
        </td>
        <td>
            <p>4 KB</p>
        </td>
        <td>
            <p>8 KB</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>Parameter policies available</p>
        </td>
        <td>
            <p>No</p>
        </td>
        <td>
            <p>Yes</p>
        </td>
    </tr>
    <tr>
        <td>
            <p>Cost</p>
        </td>
        <td>
            <p>No additional charge</p>
        </td>
        <td>
            <p>Charges apply</p>
        </td>
    </tr>
  </tbody>
</table>
<h3 id="parameters-policies-for-advanced-parameters"><a class="header" href="#parameters-policies-for-advanced-parameters">Parameters Policies (for advanced parameters)</a></h3>
<ul>
<li>
<p>파라미터에 TTL을 할당(만료일자)하여 패스워드와 같은 민감 데이터를 수정 또는 삭제하도록 강제할 수 있음</p>
</li>
<li>
<p>동시에 여러 개의 정책 할당 가능</p>
</li>
<li>
<p>Expiration (to delete a parameter)</p>
</li>
</ul>
<pre><code class="language-json">{
  &quot;Type&quot;: &quot;Expiration&quot;,
  &quot;Version&quot;: &quot;1.0&quot;,
  &quot;Attributes&quot;: {
    &quot;Timestamp&quot;: &quot;2020-12-02T21:34:33.000Z&quot;
  }
}
</code></pre>
<ul>
<li>ExpirationNotification (EventBridge)</li>
</ul>
<pre><code class="language-json">{
  &quot;Type&quot;: &quot;ExpirationNotification&quot;,
  &quot;Version&quot;: &quot;1.0&quot;,
  &quot;Attributes&quot;: {
    &quot;Before&quot;: &quot;15&quot;,
    &quot;Unit&quot;: &quot;Days&quot;
  }
}
</code></pre>
<ul>
<li>NoChangeNotification (EventBridge)</li>
</ul>
<pre><code class="language-json">{
  &quot;Type&quot;: &quot;NoChangeNotification&quot;,
  &quot;Version&quot;: &quot;1.0&quot;,
  &quot;Attributes&quot;: {
    &quot;After&quot;: &quot;20&quot;,
    &quot;Unit&quot;: &quot;Days&quot;
  }
}
</code></pre>
<h2 id="aws-secrets-manager"><a class="header" href="#aws-secrets-manager">AWS Secrets Manager</a></h2>
<ul>
<li>secrets들을 저장하기 위한 새로운 서비스</li>
<li>매 X일 마다 <strong>secret의 rotation</strong>을 강제하는 기능</li>
<li>rotation 작업에 있어 secret의 생성을 자동화 (Lambda 사용)</li>
<li><strong>Amazon RDS</strong>(MySQL, PostgreSQL, Aurora)와 호환</li>
<li>KMS를 통해 secret 암호화</li>
<li>대부분은 RDS와 함께 사용</li>
</ul>
<h3 id="aws-secrets-manager---multi-region-secrets"><a class="header" href="#aws-secrets-manager---multi-region-secrets">AWS Secrets Manager - Multi-Region Secrets</a></h3>
<ul>
<li>여러 AWS 리전 간에 secret을 복제</li>
<li>Secrets Manager는 primary Secret에 싱크를 맞춘 read replica를 보유</li>
<li>read replica Secret을 standalone Secret으로 승격시킬 수 있음</li>
<li>사례: Multi-region 앱, 재해 복구 전략, multi-region DB...</li>
</ul>
<p><img src="https://disaster-recovery.workshop.aws/images/secretmanager-architecture.png" alt="AWS Secrets Manager multi region secret" /></p>
<h2 id="aws-certificate-manager-acm"><a class="header" href="#aws-certificate-manager-acm">AWS Certificate Manager (ACM)</a></h2>
<ul>
<li>**TLS Certificates(인증서)**들을 쉽게 프로비저닝, 관리, 배포</li>
<li>웹사이트에서의 in-flight 암호화를 제공 (HTTPS)</li>
<li>public/private TLS 인증서를 모두 지원</li>
<li>public TLS 인증서의 경우 무료</li>
<li>자동으로 TLS 인증서 갱신</li>
<li>다음과 호환 (TLS 인증서 가져오기)
<ul>
<li>Elastic Load Balancers (CLB, ALB, NLB)</li>
<li>CloudFront Distributions</li>
<li>APIs on API Gateway</li>
</ul>
</li>
<li>EC2에는 ACM을 사용할 수 없음 (can't be extracted)</li>
</ul>
<p><img src="https://i.stack.imgur.com/eNLr3.png" alt="ACM Example on ELB" /></p>
<h3 id="acm---requesting-public-certificates"><a class="header" href="#acm---requesting-public-certificates">ACM - Requesting Public Certificates</a></h3>
<ol>
<li>
<p>인증서에 도메인 네임들을 추가</p>
<ul>
<li>Fully Qualified Domain Name (FQDN): <code>corp.example.com</code></li>
<li>Wildcard Domain: <code>*.example.com</code></li>
</ul>
</li>
<li>
<p>Validation 방식 선택: DNS Validation 또는 Email Validation</p>
<ul>
<li>DNS Validation이 자동화 목적으로 선호됨</li>
<li>Email Validation은 WHOIS DB 내에 있는 contact 주소로 이메일이 전송됨</li>
<li>DNS Validation은 DNS 설정 내 CNAME 레코드를 활용함 (ex. Route53)</li>
</ul>
</li>
<li>
<p>검증에 몇 시간 정도가 소요됨</p>
</li>
<li>
<p>Public 인증서는 자동 갱신에 등록됨</p>
<ul>
<li>ACM에서 생성한 모든 인증서는 만료 60일 전에 자동으로 갱신됨</li>
</ul>
</li>
</ol>
<h3 id="acm---importing-public-certificates"><a class="header" href="#acm---importing-public-certificates">ACM - Importing Public Certificates</a></h3>
<ul>
<li>ACM 외부에서 인증서를 생성하고, 이를 import하여 사용할 수 있는 옵션</li>
<li><strong>자동 갱신 불가</strong>, 반드시 만료 전에 새 인증서를 import 해야함</li>
<li>만료 45일 전부터 <strong>ACM이 매일 만료 이벤트를 전송함</strong>
<ul>
<li>시작 일자는 변경 가능</li>
<li>해당 이벤트는 EventBridge에 나타남</li>
</ul>
</li>
<li><strong>AWS Config</strong>은 인증서 만료를 체크하기 위해 <code>acm-certificate-expiration-check</code>란 이름으로 관리되는 rule을 가짐 (날짜는 설정 가능)</li>
</ul>
<h3 id="api-gateway---endpoint-types-1"><a class="header" href="#api-gateway---endpoint-types-1">API Gateway - Endpoint Types</a></h3>
<ul>
<li><strong>Edge-Optimized (기본)</strong>: 글로벌 클라이언트용
<ul>
<li>CloudFront Edge location을 통해 요청이 라우트됨 (레이턴시 향상)</li>
<li>API Gateway는 여전히 오직 하나의 리전에만 있음</li>
</ul>
</li>
<li><strong>Regional</strong>:
<ul>
<li>동일한 리전 내 클라이언트들을 위한 것</li>
<li>CloudFront와 매뉴얼하게 조합할 수 있음 (캐싱 전략 및 배포를 더 많이 통제할 수 있음)</li>
</ul>
</li>
<li><strong>Private</strong>:
<ul>
<li>인터페이스 VPC 엔드포인트(ENI)를 통해 내 VPC를 통해서만 액세스 할 수 있음</li>
<li>액세스를 정의하기 위해 Resource Policy를 사용</li>
</ul>
</li>
</ul>
<h3 id="acm---integration-with-api-gateway"><a class="header" href="#acm---integration-with-api-gateway">ACM - Integration with API Gateway</a></h3>
<ul>
<li>API Gateway 내에 <strong>Custom Domain Name</strong>을 생성</li>
<li><strong>Edge-Optimized</strong> (기본): 글로벌 클라이언트용
<ul>
<li>CloudFront Edge location을 통해 요청이 라우트됨 (레이턴시 향상)</li>
<li>API Gateway는 여전히 오직 하나의 리전에만 있음</li>
<li><strong>TLS 인증서는 반드시 CloudFront와 동일한 리전에 있어야 함</strong> (= <code>us-east-1</code>)</li>
<li>이후 CNAME 또는 A-Alias 레코드를 설정 (A-Alias 쪽이 선호)</li>
</ul>
</li>
<li><strong>Regional</strong>:
<ul>
<li>동일한 리전 내 클라이언트들을 위한 것</li>
<li><strong>TLS 인증서는 반드시 API Stage와 동일한 리전 내 API Gateway에서 import되어야 함</strong></li>
<li>이후 CNAME 또는 A-Alias 레코드를 설정 (A-Alias 쪽이 선호)</li>
</ul>
</li>
</ul>
<h2 id="aws-waf---web-application-firewall"><a class="header" href="#aws-waf---web-application-firewall">AWS WAF - Web Application Firewall</a></h2>
<ul>
<li>일반적인 웹 취약점(exploit)으로부터 웹 애플리케이션을 보호 (layer 7)</li>
<li><strong>layer 7은 HTTP</strong> (vs layer 4는 TCP/UDP)</li>
<li>다음에 배포 가능
<ul>
<li>Application Load Balancer</li>
<li>API Gateway</li>
<li>CloudFront</li>
<li>AppSync GraphQL API</li>
<li>Cognito User Pool</li>
</ul>
</li>
</ul>
<h3 id="aws-waf---web-acl"><a class="header" href="#aws-waf---web-acl">AWS WAF - Web ACL</a></h3>
<ul>
<li>Web ACL (Web Access Control List) Rules:
<ul>
<li><strong>IP Set</strong>: <strong>최대 10,000 IP 주소</strong> - 더 많은 IP를 할당하려 한다면 여러 Rule을 추가하면 됨</li>
<li><strong>SQL injection</strong>과 <strong>Cross-Site Scripting</strong>(<strong>XSS</strong>)같은 일반적인 공격으로부터 HTTP 헤더/바디, 또는 URI 스트링을 보호</li>
<li>크기 제한, <strong>geo-match</strong> (<strong>block countries</strong>)</li>
<li><strong>Rate-based rules</strong> (이벤트 발생 횟수 카운팅) - <strong>DDoS 보호</strong></li>
</ul>
</li>
<li>Web ACL은 CloudFront를 제외하고는 Regional하게 적용</li>
<li>Rule Group = <strong>Web ACL에 추가될 수 있는 Rule의 재사용 가능한 집합</strong></li>
</ul>
<h3 id="aws-waf---fixed-ip-while-using-waf-with-a-load-balancer"><a class="header" href="#aws-waf---fixed-ip-while-using-waf-with-a-load-balancer">AWS WAF - Fixed IP while using WAF with a Load Balancer</a></h3>
<ul>
<li>WAF는 NLB(Network Load Balancer)를 지원하지 않음 (layer 4)</li>
<li>ALB에 WAF를 활성화하려면 고정 IP(fixed IP)가 요구되며, 이를 위해 Global Accelerator가 필요</li>
</ul>
<h2 id="aws-shield-protect-from-ddos-attack"><a class="header" href="#aws-shield-protect-from-ddos-attack">AWS Shield: protect from DDoS attack</a></h2>
<ul>
<li><strong>DDoS</strong>: Distributed Denial of Service - 동시에 많은 요청을 보내는 것</li>
<li><strong>AWS Shield Standard</strong>:
<ul>
<li>모든 AWS 고객들에 대해 무료로 활성화되는 서비스</li>
<li>SYN/UDP Floods, Reflection attacks 또는 그 외의 layer 3/layer 4 공격에 대한 보호</li>
</ul>
</li>
<li><strong>AWS Shield Advanced</strong>:
<ul>
<li>선택적인 DDoS 완화(mitigation) 서비스 (organization별 매달 3,000)</li>
<li><em>AC2, ELB, CloudFront, Global Accelerator, Route 53</em>에 대한 보다 정교한 공격에 대한 보호</li>
<li>AWS DDoS response team(DRP)과 항상 연결</li>
<li>DDoS로 인한 usage spike 동안에 발생하는 높은 비용으로부터 보호</li>
<li>Shield Advanced의 automatic application layer DDoS mitigation이 자동으로 AWS WAF Rule을 생성/평가/배포하여 layer 7 공격을 완화</li>
</ul>
</li>
</ul>
<h2 id="aws-firewall-manager"><a class="header" href="#aws-firewall-manager">AWS Firewall Manager</a></h2>
<ul>
<li><strong>AWS Organization 내 모든 계정에 대한 Rule을 관리</strong></li>
<li>Security Policy: security rule에 대한 common set
<ul>
<li>WAF Rule (ALB, API Gateway, CloudFront)</li>
<li>AWS Shield Advanced (ALB, CLB, NLB, Elastic IP, CloudFront)</li>
<li>Security Groups for EC2, ALB and ENI resources in VPC</li>
<li>AWS Network Firewall (VPC 레벨)</li>
<li>Amazon Route 53 Resolver DNS Firewall</li>
<li>리전 레벨에서 생성된 Policy</li>
</ul>
</li>
<li><strong>내 Organization 내에 존재하거나 추후 추가될 모든 계정에서 생성되는 새 리소스들에 Rule이 적용됨(compliance에 유용함)</strong></li>
</ul>
<h2 id="waf-vs-firewall-manager-vs-shield"><a class="header" href="#waf-vs-firewall-manager-vs-shield">WAF vs. Firewall Manager vs. Shield</a></h2>
<ul>
<li><strong>WAF, Sheild, Firewall Manager은 모두 보안을 위해 함께 사용됨</strong></li>
<li>WAF에서는 Web ACL Rule을 정의함</li>
<li>리소스에 대한 세분화된 보호를 원한다면 WAF의 단독 사용이 적절한 선택임</li>
<li>만약, AWS WAF가 계정 간에 사용되어야 하거나, WAF 설정을 빠르게 하고 싶거나, 새 리소스에 대한 보호를 자동화하고 싶으면, AWS WAF에 Firewall Manager를 사용</li>
<li>Shield Advanced는 AWS WAF에 추가로 Shield Response Team(SRT)로부터의 전담(dedicated) 지원과 고급 리포팅 같은 추가적인 기능을 제공함</li>
<li>반복적인 DDoS 공격에 취약한 상황이라면, Shield Advanced의 구매를 고려할 것</li>
</ul>
<h2 id="aws-best-practices-for-ddos-resiliency"><a class="header" href="#aws-best-practices-for-ddos-resiliency">AWS Best Practices for DDoS Resiliency</a></h2>
<p><img src="https://docs.aws.amazon.com/images/whitepapers/latest/aws-best-practices-ddos-resiliency/images/ddos-resilient-architecture.jpg" alt="AWS Best Practives for DDoS Resiliency" /></p>
<ul>
<li><strong>Edge Location Mitigation (BP1, BP3)</strong>
<ul>
<li><strong>BP1 - CloudFront</strong>
<ul>
<li>웹 애플리케이션이 엣지에서 전달됨</li>
<li>일반적인 DDoS 공격으로부터 보호 (SYN floods, UDP reflections...)</li>
</ul>
</li>
<li><strong>BP1 - Global Accelerator</strong>
<ul>
<li>엣지로부터 애플리케이션 액세스</li>
<li>DDoS 보호를 위한 Shield와 연동됨</li>
<li>만약 CloudFront와 백엔드가 호환되지 않는 경우 유용함</li>
</ul>
</li>
<li><strong>BP3 - Route 53</strong>
<ul>
<li>엣지에서 Domain Name Resolution</li>
<li>DNS에서 DDoS 보호 매커니즘이 적용되어 있음</li>
</ul>
</li>
</ul>
</li>
<li><strong>Infrastructure layer defense (BP1, BP3, BP6)</strong>
<ul>
<li>EC2를 높은 트래픽으로부터 보호</li>
<li>Global Accelerator, Route 53, CloudFront, Elastic Load Balancing을 포함</li>
</ul>
</li>
<li><strong>Amazon EC2 with Auto Scaling (BP7)</strong>
<ul>
<li>flash crowd 또는 DDoS 공격을 포함한 갑작스러운 트래픽 급증에 따른 스케일링을 도와줌</li>
</ul>
</li>
<li><strong>Elastic Load Balancing (BP6)</strong>
<ul>
<li>ELB가 급증하는 트래픽에 맞춰 스케일링을 수행하고, 이에 따라 트래픽을 여러 EC2 인스턴스로 분산시킴</li>
</ul>
</li>
<li><strong>Application Layer Defense</strong>
<ul>
<li><strong>악성 웹 요청에 대한 감지 및 필터링(BP1, BP2)</strong>
<ul>
<li>CloudFront는 정적 컨텐츠를 캐시하고 이를 엣지 로케이션에서 전달하도록 하여 백엔드를 보호</li>
<li>AWS WAF는 CloudFront와 ALB에 사용되어 요청 시그니처에 기반하여 요청을 필터링하거나 블록할 수 있음</li>
<li>WAF의 rate-based rule은 악성 행위자(bad actor)에 대한 IP를 자동으로 블록</li>
<li>CloudFront는 특정 지역을 블록할 수 있음</li>
</ul>
</li>
<li><strong>Shield Advanced (BP1, BP2, BP6)</strong>
<ul>
<li>Shield Advanced automatic application layer DDos mitigation은 layer 7 공격을 완화하기 위해 자동으로 AWS WAF Rule을 생성/평가/배포</li>
</ul>
</li>
</ul>
</li>
<li><strong>Attack surface reduction</strong>
<ul>
<li><strong>AWS 리소스 난독화(obfuscating) (BP1, BP4, BP6)</strong>
<ul>
<li>CloudFront, API Gateway, Elastic Load Balancing을 사용하여 백엔드 리소스(Lambda 함수, EC2 인스턴스)를 감춤</li>
</ul>
</li>
<li><strong>Security Groups and Network ACLs (BP5)</strong>
<ul>
<li>Security Group과 NACL을 통해 서브넷이나 ENI레벨에서 특정 IP에서 일어나는 트래픽을 필터링</li>
<li>Elastic IP도 AWS Shield Advanced를 통해 보호됨</li>
</ul>
</li>
<li><strong>API 엔드포인트를 보호 (BP4)</strong>
<ul>
<li>EC2, Lambda를 다른 곳에 숨김</li>
<li>Edge-optimized mode 또는 CloudFront + regional mode (DDoS에 대한 더 많은 통제)</li>
<li>WAF + API Gateway: burst limit, 헤더 필터링, API key 사용을 강제</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="amazon-guardduty"><a class="header" href="#amazon-guardduty">Amazon GuardDuty</a></h2>
<ul>
<li>AWS 계정 보호를 위해 인공지능으로 위협 감지</li>
<li>머신러닝 알고리즘, 이상징후 감지(anomaly detection), 써드파티 데이터 사용</li>
<li>One Click 활성화 (30 days trial), 소프트웨어 설치 필요 없음</li>
<li>Input Data들에는 다음이 포함:
<ul>
<li><strong>CloudTrail Events Logs</strong> - 비정상적인 API 호출, 무단 배포
<ul>
<li><strong>CloudTrail Management Events</strong> - VPC 서브넷 생성, trail 생성..</li>
<li><strong>CloudTrail S3 Data Events</strong> - 오브젝트 get/list/delete...</li>
</ul>
</li>
<li><strong>VPC Flow Logs</strong> - 비정상적인 내부 트래픽, 비정상적인 IP 주소</li>
<li><strong>DNS Logs</strong> - DNS 쿼리 내에서 인코딩된 데이터를 전송하는 손상된 EC2 인스턴스</li>
<li><strong>Kubernetes Audit Logs</strong> - 의심스러운 활동 및 잠재적인 EKS 클러스터 손상</li>
</ul>
</li>
<li>발견 시 알림이 전달될 수 있도록 <strong>EventBridge Rule</strong>을 설정 가능
<ul>
<li>EventBridge rule을 AWS Lambda 또는 SNS로 향하게 할 수 있음</li>
</ul>
</li>
<li><strong>CryptoCurrency 공격을 보호할 수 있음</strong> (<strong>이를 위한 전용 검색 보유</strong>)</li>
</ul>
<p><img src="https://d1.awsstatic.com/Security/Amazon-GuardDuty/Amazon-GuardDuty_HIW.057a144483974cb73ab5f3f87a50c7c79f6521fb.png" alt="Amazon GuardDuty" /></p>
<h2 id="amazon-inspector"><a class="header" href="#amazon-inspector">Amazon Inspector</a></h2>
<ul>
<li><strong>자동화된 보안 평가(automated security assessments)</strong></li>
<li><strong>For EC2 Instances</strong>
<ul>
<li><strong>AWS System Manager (SSM) 에이전트</strong> 활용</li>
<li><strong>의도치 않은 네트워크 접근 가능성</strong>에 대한 분석</li>
<li>실행 중인 OS에 대한 <strong>known vulnerabilities</strong>을 파악</li>
</ul>
</li>
<li><strong>For Container Images push to Amazon ECR</strong>
<ul>
<li>푸시된 컨테이너 이미지에 대한 평가</li>
</ul>
</li>
<li><strong>For Lambda Functions</strong>
<ul>
<li>함수 코드와 패키지 의존성의 취약성을 파악</li>
<li>배포된 함수에 대한 평가</li>
</ul>
</li>
<li>AWS Security Hub에 리포팅 &amp; 호환 가능</li>
<li>Amazon Event Bridge로 결과 전송</li>
</ul>
<h3 id="what-does-amazon-inspector-evaluate"><a class="header" href="#what-does-amazon-inspector-evaluate">What does Amazon Inspector evaluate?</a></h3>
<ul>
<li><strong>중요</strong>: <strong>오직 EC2 인스턴스, 컨테이너 이미지 &amp; Lambda 함수에 대해서만 적용 가능</strong></li>
<li>필요하다면 인프라에 대해 지속적인 스캐닝 가능</li>
<li>패키지 취약점 (EC2, ECR &amp; Lambda) - database of CVE(Common Vulnerabilities and Exposures)</li>
<li>네트워크 도달 범위 ~ Network Reachability (EC2)</li>
<li>우선 순위에 따라 모든 취약점과 관련한 risk score를 제공</li>
</ul>
<h2 id="amazon-macie"><a class="header" href="#amazon-macie">Amazon Macie</a></h2>
<ul>
<li>Amazon Macie는 완전 관리형 데이터 보안 및 데이터 프라이버시 서비스
<ul>
<li><strong>머신러닝과 패턴 매칭을 통해 AWS 내 민감한 데이터를 발견 및 보호</strong></li>
</ul>
</li>
<li>Macie는 <strong>개인 식별 정보(PII ~ Personally Identifiable Information)과 같은 민감한 데이터를 파악하고 경고해줌</strong></li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2021/05/25/bdb1118-archive-deletion-macie-1.png" alt="Amazon Macie Example" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="networking---vpc"><a class="header" href="#networking---vpc">Networking - VPC</a></h1>
<h2 id="understanding-cidr---ipv4"><a class="header" href="#understanding-cidr---ipv4">Understanding CIDR - IPv4</a></h2>
<ul>
<li>
<p><strong>CIDR(Classless Inter-Domain Routing)</strong> - IP 주소 할당 방법</p>
</li>
<li>
<p><strong>Security Groups</strong> Rule과 AWS 네트워킹에서 일반적으로 사용됨</p>
</li>
<li>
<p>IP 주소의 범위를 정의하는 것을 도와줌</p>
<ul>
<li><code>WW.XX.YY.ZZ/32</code> -&gt; 단일 IP</li>
<li><code>0.0.0.0/0</code> -&gt; 모든 IP</li>
<li><code>192.168.0.0/26</code> -&gt; <code>192.168.0.0</code> ~ <code>192.168.0.63</code> (64개의 IP 주소)</li>
</ul>
</li>
<li>
<p>CIDR은 두 부분으로 나뉨</p>
<ul>
<li><strong>Base IP</strong>
<ul>
<li>범위에 포함될 IP (<code>XX.XX.XX.XX</code>)</li>
<li>ex. <code>10.0.0.0</code>, <code>192.168.0.0</code>, ...</li>
</ul>
</li>
<li><strong>Subnet Mask</strong>
<ul>
<li>IP 내에서 얼마나 많은 bit가 바뀔 수 있는지를 정의</li>
<li>ex. <code>/0</code>, <code>/24</code>, <code>/32</code></li>
<li>두 가지 형태가 될 수 있음
<ul>
<li><code>/8</code> &lt;-&gt; <code>255.0.0.0</code></li>
<li><code>/16</code> &lt;-&gt; `255.255.0.0</li>
<li><code>/24</code> &lt;-&gt; <code>255.255.255.0</code></li>
<li><code>/32</code> &lt;-&gt; <code>255.255.255.255</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Subnet Mask는 기본적으로 기본 IP로부터 얼마나 추가적인 값들을 허용할지 나타내는 부분이다.</p>
<ul>
<li>예시
<ul>
<li><code>192.168.0.0/32</code> =&gt; 1개의 IP 허용 (2^0) =&gt; <code>192.168.0.0</code></li>
<li><code>192.168.0.0/31</code> =&gt; 2개의 IP 허용 (2^1) =&gt; <code>192.168.0.0</code> ~ <code>192.168.0.1</code></li>
<li><code>192.168.0.0/24</code> =&gt; 256개의 IP 허용 (2^8) =&gt; <code>192.168.0.0</code> ~ <code>192.168.0.255</code></li>
<li><code>0.0.0.0/0</code> =&gt; 모든 IP 허용 (2^32) =&gt; <code>0.0.0.0</code> ~ <code>255.255.255.255</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>주로 사용되는 경우</p>
<ul>
<li><code>/32</code> - 어떤 octet도 바뀔 수 없음</li>
<li><code>/24</code> - 마지막 octet이 바뀔 수 있음</li>
<li><code>/16</code> - 뒤의 두 octet이 바뀔 수 있음</li>
<li><code>/8</code> - 뒤의 세 octet이 바뀔 수 있음</li>
<li><code>/0</code> - 모든 octet이 바뀔 수 있음</li>
</ul>
</li>
</ul>
<p><img src="https://f4n3x6c5.stackpathcdn.com/article/getting-started-with-vpc-virtual-private-cloud-part2/Images/1.png" alt="Octet Example" /></p>
<ul>
<li>헷갈린다면 CIDR를 IP 주소 범위로 변환해주는 사이트도 있으니 <a href="https://www.ipaddressguide.com/cidr">참고</a></li>
</ul>
<h2 id="public-vs-private-ip-ipv4"><a class="header" href="#public-vs-private-ip-ipv4">Public vs. Private IP (IPv4)</a></h2>
<ul>
<li>IANA(Internet Assigned Numbers Authority)가 public / private 주소 사용을 위해 특정 IPv4 주소 블록을 설정해뒀음</li>
<li><strong>Private IP</strong>는 다음의 특정 값들만 허용됨:
<ul>
<li><code>10.0.0.0</code> ~ <code>10.255.255.255</code> (<code>10.0.0.0/8</code>) -&gt; 대규모 네트워크</li>
<li><code>172.16.0.0</code> ~ <code>172.31.255.255</code> (<code>172.16.0.0/12</code>) -&gt; <strong>AWS 기본 VPC의 범위</strong></li>
<li><code>192.168.0.0</code> ~ <code>192.168.255.255</code> (<code>192.168.0.0/16</code>) -&gt; ex. 홈 네트워크</li>
</ul>
</li>
<li>인터넷 상에서 그 외의 나머지 IP 주소들은 모두 Public IP</li>
</ul>
<h2 id="default-vpc-walkthrough"><a class="header" href="#default-vpc-walkthrough">Default VPC Walkthrough</a></h2>
<ul>
<li>모든 새 AWS 계정들은 기본 VPC를 가짐</li>
<li>새로운 EC2 인스턴스들은 별도로 서브넷을 지정하지 않는다면 기본 VPC로 실행됨</li>
<li>기본 VPC는 인터넷 연결이 되어있고, 그 안의 모든 EC2 인스턴스들은 public IPv4 주소를 갖게 됨</li>
<li>public/private IPv4 DNS 네임을 가질 수 있음</li>
</ul>
<h2 id="vpc-in-aws---ipv4"><a class="header" href="#vpc-in-aws---ipv4">VPC in AWS - IPv4</a></h2>
<ul>
<li><strong>VPC - Virtual Private Cloud</strong></li>
<li>하나의 AWS 리전 내에 여러 VPC들을 둘 수 있음 (리전 별 최대 5개 ~ soft limit)</li>
<li>VPC 별 CIDR은 최대 5개이며, 각 CIDR의 경우:
<ul>
<li>최소 사이즈 <code>/28</code> (16개의 IP 주소)</li>
<li>최대 사이즈 <code>/16</code> (65536개의 IP 주소)</li>
</ul>
</li>
<li>VPC는 private이기 때문에, 오직 Private IPv4 주소만 허용됨:
<ul>
<li><code>10.0.0.0</code> ~ <code>10.255.255.255</code> (<code>10.0.0.0/8</code>)</li>
<li><code>172.16.0.0</code> ~ <code>172.31.255.255</code> (<code>172.16.0.0/12</code>)</li>
<li><code>192.168.0.0</code> ~ <code>192.168.255.255</code> (<code>192.168.0.0/16</code>)</li>
</ul>
</li>
<li><strong>내 VPC CIDR은 내 다른 네트워크와 겹쳐선 안됨 (ex. 회사의 IP 주소)</strong></li>
</ul>
<h2 id="vpc---subnet-ipv4"><a class="header" href="#vpc---subnet-ipv4">VPC - Subnet (IPv4)</a></h2>
<ul>
<li>AWS 리소스들은 각 서브넷 별로 **5개의 IP 주소 (first 4 &amp; last 1)**를 예약해둠</li>
<li>이 5개의 IP 주소는 사용할 수 없고, EC2 인스턴스에 할당될 수도 없음</li>
<li>예시: 만약 CIDR 블록이 <code>10.0.0.0/24</code>라면, 예약되는 IP 주소들은 다음과 같음
<ul>
<li><code>10.0.0.0</code> - Network Address</li>
<li><code>10.0.0.1</code> - AWS에 의해 예약, VPC 라우터 용도</li>
<li><code>10.0.0.2</code> - AWS에 의해 예약, Amazon에서 제공하는 DNS에 매핑</li>
<li><code>10.0.0.3</code> - AWS에 의해 예약, 추후 사용 용도</li>
<li><code>10.0.0.255</code> - Network Broadcast Address로, AWS에서는 VPC에서 broadcast를 지원하지 않기 때문에, 예약되어 있음</li>
</ul>
</li>
<li><strong>시험 팁</strong>: 만약 EC2 인스턴스에 29개의 IP 주소가 필요하다면?
<ul>
<li><code>/27</code> 사이즈의 서브넷을 둘 수 없음 (32개 IP 주소 ~ 32 - 5 = 27 &lt; 29)</li>
<li><code>/26</code> 사이즈의 서브넷을 골라야 함 (64개 IP 주소 ~ 64 - 5 = 59 &gt; 29)</li>
</ul>
</li>
</ul>
<h2 id="internet-gateway-igw"><a class="header" href="#internet-gateway-igw">Internet Gateway (IGW)</a></h2>
<ul>
<li>VPC 내에 있는 리소스(e.g., EC2 인스턴스)들의 인터넷 연결을 허용</li>
<li>수평적 확장 &amp; highly available &amp; 중복(redundant)</li>
<li>반드시 VPC와는 별도로 생성되어야 함</li>
<li>하나의 VPC는 오직 하나의 IGW에 연결될 수 있으며, 반대의 경우도 마찬가지</li>
<li>Internet Gateway 그 자체만으로는 인터넷 액세스를 허용하지 않음
<ul>
<li>반드시 Route table도 함께 수정되어야 함!</li>
</ul>
</li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/vpc/latest/userguide/images/internet-gateway-basics.png" alt="Internet Gateway Example" /></p>
<h2 id="bastion-hosts"><a class="header" href="#bastion-hosts">Bastion Hosts</a></h2>
<ul>
<li>private EC2 인스턴스에 SSH 연결을 사용하고 싶을 때 Bastion Host를 사용할 수 있음</li>
<li>bastion은 다른 private 서브넷들에 연결되어 있는 public 서브넷</li>
<li><strong>Bastion Host security group은 반드시 제한된 CIDR의 22번 포트로부터 인바운드만 허용해야 함</strong>
<ul>
<li>ex. 회사의 <strong>public CIDR</strong></li>
</ul>
</li>
<li><strong>EC2 인스턴스의 Security Group</strong>은 반드시 Bastion Host의 Security Group을 허용하거나, Bastion host의 <strong>private IP</strong>를 허용해야 함</li>
</ul>
<p><img src="https://cloudacademy.com/wp-content/uploads/2015/11/aws-bastion-host-1.png" alt="Bastion Host" /></p>
<h2 id="nat-instance-outdated-but-still-at-the-exam"><a class="header" href="#nat-instance-outdated-but-still-at-the-exam">NAT Instance (<strong>outdated</strong>, but still at the exam)</a></h2>
<ul>
<li><strong>NAT = Network Address Translation</strong></li>
<li>private 서브넷 내의 EC2 인스턴스들이 인터넷에 연결될 수 있도록 해줌</li>
<li>반드시 public 서브넷 내에서 실행되어야 함</li>
<li>다음 EC2 설정을 반드시 비활성화 해야함: <strong>Source / destination Check</strong></li>
<li>연결할 Elastic IP가 반드시 필요함</li>
<li>private 서브넷으로부터의 트래픽을 NAT 인스턴스로 라우팅하도록 Route Table이 반드시 설정되어야 함</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/images/nat-instance_updated.png" alt="NAT Instance Example" /></p>
<h3 id="nat-instance---comments"><a class="header" href="#nat-instance---comments">NAT Instance - Comments</a></h3>
<ul>
<li>사전에 설정되어 있는(pre-configured) Amazon Linux AMI를 사용할 수 있음
<ul>
<li>공식 지원은 2020/12/31에 끝났음</li>
</ul>
</li>
<li>기본적으로는 Highly Available 및 resilient setup이 제공되지 않음
<ul>
<li>multi-AZ에 ASG를 만들고, resilient user-data script를 생성할 필요가 있음</li>
</ul>
</li>
<li>인터넷 트래픽 대역폭(bandwidth)는 EC2 인스턴스 유형에 따라 다름</li>
<li>반드시 Security group &amp; Rule을 관리해야함:
<ul>
<li>인바운드:
<ul>
<li>private 서브넷으로부터 오는 HTTP/HTTPS 트래픽을 허용</li>
<li>홈 네트워크로부터의 SSH 연결(Internet Gateway를 통한 액세스)을 허용</li>
</ul>
</li>
<li>아웃바운드:
<ul>
<li>인터넷으로의 HTTP/HTTPS 트래픽을 허용</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="nat-gateway"><a class="header" href="#nat-gateway">NAT Gateway</a></h2>
<ul>
<li>AWS가 관리하는 NAT, 높은 대역폭, high availability, 관리 불필요</li>
<li>사용한 시간과 대역폭에 따라 비용 지불</li>
<li>NAT Gateway는 특정 AZ에 생성되며, Elastic IP를 사용</li>
<li>동일한 서브넷 내 EC2 인스턴스에서 사용될 수는 없음 (다른 서브넷을 통해서만 가능)</li>
<li>IGW(Internet Gateway)가 필요함 (Private Subnet =&gt; NATGW =&gt; IGW)</li>
<li>5Gbps의 대역폭, 최대 45Gbps로 스케일 업</li>
<li>따로 Security Group을 관리해야 하거나 필요하지 않음</li>
</ul>
<h3 id="nat-gateway-with-high-availability"><a class="header" href="#nat-gateway-with-high-availability">NAT Gateway with High Availability</a></h3>
<ul>
<li><strong>NAT Gateway는 단일 AZ 내에서 resilient함</strong></li>
<li>내결함성(fault-tolerance)를 위해서는 반드시 <strong>여러 AZ</strong> 내에 <strong>여러 NAT Gateway</strong>들을 생성해야함</li>
<li>cross-AZ failover가 필요 없음 -&gt; AZ가 다운되면 NAT가 필요하지 않기 때문</li>
</ul>
<h3 id="nat-gateway-vs-nat-instance"><a class="header" href="#nat-gateway-vs-nat-instance">NAT Gateway vs. NAT Instance</a></h3>
<ul>
<li><a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-comparison.html">참고</a></li>
</ul>
<h2 id="network-access-control-list-nacl"><a class="header" href="#network-access-control-list-nacl">Network Access Control List (NACL)</a></h2>
<ul>
<li>NACL은 <strong>서브넷</strong> 안팎으로 오가는 트래픽을 관리하는 일종의 방화벽</li>
<li><strong>서브넷 별로 하나의 NACL</strong>이 있고, 새로운 서브넷에는 <strong>Default NACL</strong>이 할당됨</li>
<li><strong>NACL Rules</strong>를 정의:
<ul>
<li>Rule에는 번호가 지정(1~32766), 낮은 번호일 수록 더 높은 우선순위</li>
<li>첫번째로 일치하는 규칙을 기반으로 결정을 내림</li>
<li>ex. 만약 #100번 규칙으로 <code>10.0.0.10/32</code>를 <strong>허용</strong>했다면, #200번 규칙으로 <code>10.0.0.10/32</code>에 대해 <strong>거부</strong>했다면, 해당 IP 주소에 대해서는 허용될 것임</li>
<li>마지막 Rule은 아스터리스크(<code>*</code>)이며, 아무런 규칙도 매칭되지 않을 경우 요청을 거부</li>
<li>AWS에서는 100 단위로 규칙을 추가할 것을 추천함</li>
</ul>
</li>
<li>새로 생성된 NACL의 경우 모든 경우에 대해 거부</li>
<li>NACL은 서브넷 레벨에서 특정 IP 주소를 블록하기에 아주 좋은 방법</li>
</ul>
<h3 id="default-nacl"><a class="header" href="#default-nacl">Default NACL</a></h3>
<ul>
<li>할당된 서브넷에 대한 모든 인바운드/아웃바운드를 허용함</li>
<li><strong>Default NACL을 수정하지 말 것</strong>, 대신에 커스텀 NACL을 새로 생성해야함</li>
</ul>
<h3 id="ephemeral-ports-임시-포트"><a class="header" href="#ephemeral-ports-임시-포트">Ephemeral Ports (임시 포트)</a></h3>
<ul>
<li>두 엔드포인트 간에 연결이 이루어지려면, 반드시 포트를 사용해야 함</li>
<li>클라이언트가 <strong>defined port</strong>(= fixed port)로 연결하고, <strong>ephemeral port</strong>(임시 포트)에서 응답을 내보냄</li>
<li>운영체제가 다르다면, 포트의 범위도 다르게 사용함
<ul>
<li>예시
<ul>
<li>IANA &amp; MS Windows 10 -&gt; 49152 ~ 65535</li>
<li>Many Linux Kernels -. 32768 ~ 60999</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nacl-with-ephemeral-ports"><a class="header" href="#nacl-with-ephemeral-ports">NACL with Ephemeral Ports</a></h3>
<ul>
<li><a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html#nacl-ephemeral-ports">참고</a></li>
</ul>
<h3 id="securiy-group-vs-nacls"><a class="header" href="#securiy-group-vs-nacls">Securiy Group vs. NACLs</a></h3>
<p><img src="https://clouds.geant.org/wp-content/uploads/2019/01/security6.png" alt="NACL vs SG" /></p>
<h2 id="vpc-peering"><a class="header" href="#vpc-peering">VPC Peering</a></h2>
<ul>
<li>AWS 네트워크를 통해 두 VPC 간에 private하게 연결을 할 수 있게 해줌</li>
<li>마치 두 VPC가 동일한 네트워크에 있는 것처럼 동작하게 만듬</li>
<li>중복되는 CIDR을 가져선 안됨</li>
<li>VPC Peering 연결은 <strong>transitive</strong>(전이적)하지 않음 (반드시 VPC 간에 서로 직접 연결되어야 함)</li>
<li><strong>EC2 인스턴스들이 서로 상호작용할 수 있도록 하려면 각각의 VPC 서브넷 안에 있는 Route Table을 업데이트 해야만 함</strong></li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/whitepapers/latest/aws-vpc-connectivity-options/images/image14.png" alt="VPC Peering" /></p>
<h3 id="vpc-peering---goot-to-know"><a class="header" href="#vpc-peering---goot-to-know">VPC Peering - Goot to know</a></h3>
<ul>
<li><strong>서로 다른 AWS 계정/리전</strong> 내에서도 VPC 간에 VPC Peering 연결을 생성할 수 있음</li>
<li>피어링된 VPC 내에서는 Security Group을 서로 참조할 수 있음 (동일한 리전 내 cross account 가능)</li>
</ul>
<h2 id="vpc-endpoints-aws-privatelink"><a class="header" href="#vpc-endpoints-aws-privatelink">VPC Endpoints (AWS PrivateLink)</a></h2>
<ul>
<li>모든 AWS 서비스는 공개적으로 노출 (public URL)</li>
<li>VPC Endpoints (powered by AWS PrivateLink)는 public 인터넷 대신 <strong>private network</strong>를 사용하여 AWS 서비스들을 연결할 수 있도록 해줌</li>
<li>redundant, 수평적 확장</li>
<li>AWS 서비스들에 액세스 하기 위해 IGW, NATGW 같은 것들을 사용할 필요가 없어짐</li>
<li>문제가 발생했을 경우:
<ul>
<li>VPC에서 DNS 설정을 확인</li>
<li>Route Table을 확인</li>
</ul>
</li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/whitepapers/latest/building-scalable-secure-multi-vpc-network-infrastructure/images/aws-privatelink.png" alt="VPC Endpoints" /></p>
<h2 id="types-of-endpoints"><a class="header" href="#types-of-endpoints">Types of Endpoints</a></h2>
<ul>
<li><strong>Interface Endpoints (powered by PrivateLink)</strong>
<ul>
<li>ENI(private IP 주소)를 엔트리 포인트(반드시 Security Group 연결 필요)로 프로비저닝</li>
<li>대부분의 AWS 서비스들을 지원</li>
<li>시간 당 비용 + 처리되는 데이터 GB당 비용</li>
</ul>
</li>
<li><strong>Gateway Endpoints</strong>
<ul>
<li>게이트웨이를 프로비저닝하며, <strong>반드시 이를 Route Table 내에서 타겟으로 사용해야 함</strong> (<strong>Security Group 사용이 필요 없음</strong>)</li>
<li>S3와 DynamoDB를 지원</li>
<li>무료</li>
</ul>
</li>
</ul>
<h3 id="gateway-or-interface-endpoint-for-s3"><a class="header" href="#gateway-or-interface-endpoint-for-s3">Gateway or Interface Endpoint for S3?</a></h3>
<ul>
<li><strong>Gateway가 거의 대부분의 경우 더 선호됨</strong></li>
<li>비용 측면: Gateway Interface는 무료인 반면 Interface Endpoint는 비용 필요</li>
<li>Interface Endpoint는 온-프레미스 혹은 다른 VPC/리전으로부터의 액세스가 필요한 경우에 선호됨</li>
</ul>
<h2 id="vpc-flow-logs"><a class="header" href="#vpc-flow-logs">VPC Flow Logs</a></h2>
<ul>
<li>내 인터페이스로 이동하는 IP 트래픽들에 대한 정보를 캡처:
<ul>
<li>VPC Flow Logs</li>
<li>Subnet Flow Logs</li>
<li>Elastic Network Interface (ENI) Flow Logs</li>
</ul>
</li>
<li>모니터링 &amp; 연결 이슈에 대한 트러블슈팅에 도움</li>
<li>Flow Logs 데이터는 S3, CloudWatch Logs, Kinesis Data Firehose로 보낼 수 있음</li>
<li>AWS에서 관리되는 인터페이스로부터의 네트워크 정보도 캡처:
<ul>
<li>ELB, RDS, ElastiCache, Redshift, WorkSpaces, NATGW, Transit Gateway..</li>
</ul>
</li>
</ul>
<h3 id="vpc-flow-logs-syntax"><a class="header" href="#vpc-flow-logs-syntax">VPC Flow Logs Syntax</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2019/08/13/2019-08-13_10-41-04.png" alt="VPC Flow Logs Syntax" /></p>
<ul>
<li><strong>srcaddr &amp; dstaddr</strong> - 문제가 있는 IP를 파악하는 데에 도움</li>
<li><strong>srcport &amp; dstport</strong> - 문제가 있는 포트를 파악하는 데에 도움</li>
<li><strong>Action</strong> - Security Group / NACL에 따른 요청 성공/실패 여부</li>
<li>사용 패턴 / 악의적 행동에 대한 분석을 위해 사용할 수 있음</li>
<li>S3의 Athena 또는 CloudWatch Log Insights를 통해 VPC Flow Log를 쿼리할 수 있음</li>
<li><a href="https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html">Flow Log 예시</a></li>
</ul>
<h3 id="vpc-flow-logs---troubleshoot-sg--nacl-issues"><a class="header" href="#vpc-flow-logs---troubleshoot-sg--nacl-issues">VPC Flow Logs - Troubleshoot SG &amp; NACL Issues</a></h3>
<ul>
<li><strong>ACTION 필드를 확인하자!</strong>
<ul>
<li><strong>Incoming Request</strong>의 경우
<ul>
<li>인바운드 REJECT =&gt; NACL 또는 SG</li>
<li>인바운드 ACCEPT, 아웃바운드 REJECT =&gt; NACL</li>
</ul>
</li>
<li><strong>Outgoing Requests</strong>의 경우
<ul>
<li>아웃바운드 REJECT =&gt; NACL 또는 SG</li>
<li>아웃바운드 ACCEPT, 인바운드 REJECT =&gt; NACL</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="vpc-flow-logs---architectures"><a class="header" href="#vpc-flow-logs---architectures">VPC Flow Logs - Architectures</a></h3>
<ul>
<li>VPC Flow Logs -&gt; CloudWatch Logs -&gt; CloudWatch Contributor Insights</li>
<li>VPC Flow Logs -&gt; CloudWatch Logs -&gt; CloudWatch Alarm -&gt; Amazon SNS</li>
<li>VPC Flow Logs -&gt; S3 Bucket -&gt; Amazon Athena -&gt; Amazon QuickSight</li>
</ul>
<h2 id="aws-site-to-site-vpn"><a class="header" href="#aws-site-to-site-vpn">AWS Site-to-Site VPN</a></h2>
<ul>
<li><strong>Virtual Private Gateway (VGW)</strong>
<ul>
<li>VPN 연결 시 AWS 측의 VPN concentrator</li>
<li>VGW를 생성 후 Site-to-Site VPN 연결을 생성하고 싶은 VPC에 연결</li>
<li>ASN(Autonomous System Number)를 커스터마이징 할 수 있음</li>
</ul>
</li>
<li><strong>Customer Gateway (CGW)</strong>
<ul>
<li>VPN 연결의 customer 측 소프트웨어 애플리케이션 또는 <a href="https://docs.aws.amazon.com/vpn/latest/s2svpn/your-cgw.html">실제 디바이스</a></li>
</ul>
</li>
</ul>
<h3 id="site-to-site-vpn-connections"><a class="header" href="#site-to-site-vpn-connections">Site-to-Site VPN Connections</a></h3>
<ul>
<li><strong>Customer Gateway Devices (On-Premises)</strong>
<ul>
<li><strong>어떤 IP 주소를 사용하는가?</strong>
<ul>
<li>Customer Gateway 디바이스에 대한 Public Internet-routable IP 주소를 사용</li>
<li>만약 NAT traversal(NAT-T)가 활성화된 NAT 디바이스라면, NAT 디바이스의 public IP 주소를 사용</li>
</ul>
</li>
</ul>
</li>
<li><strong>중요한 과정</strong>: 내 서브넷과 연결된 Route Table 내 Virtual Private Gateway에 대한 <strong>Route Propagation</strong>을 활성화해야 함</li>
<li>온-프레미스로부터 EC2 인스턴스를 ping해야 한다면, Security Group의 인바운드로 ICMP 프로토콜을 추가하였는지 확인해야 함</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/vpn/latest/s2svpn/images/vpn-basic-diagram.png" alt="Site-to-Site VPN Connection" /></p>
<h3 id="aws-vpn-cloudhub"><a class="header" href="#aws-vpn-cloudhub">AWS VPN CloudHub</a></h3>
<ul>
<li>여러 VPN 연결을 보유한 경우, 여러 사이트 간의 보안 연결을 제공</li>
<li>다른 로케이션 간의 주요 또는 보조 네트워크 연결을 위한 저비용 hub-and-spoke 모델 (VPN Only)</li>
<li>VPN 연결이므로, public 인터넷을 통해 연결됨</li>
<li>설정하려면 동일한 VGW에 여러 VPN을 연결하고, dynamic routing을 설정하고 Route Table을 구성</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/vpn/latest/s2svpn/images/AWS_VPN_CloudHub-diagram.png" alt="AWS VPN CloudHub" /></p>
<h2 id="direct-connect-dx"><a class="header" href="#direct-connect-dx">Direct Connect (DX)</a></h2>
<ul>
<li>원격 네트워크에서 내 VPC로 전용 <strong>private</strong> 연결을 할 수 있게 해줌</li>
<li>전용 연결은 반드시 내 Direct Connect와 AWS Direct Connection 로케이션 사이에 구성되어야 함</li>
<li>VPC에 Virtual Private Gateway를 설정해야 함</li>
<li>하나의 연결로 public 리소스(S3)와 private 리소스(EC2)에 액세스할 수 있음</li>
<li>사례:
<ul>
<li>대역폭 처리량 증가 - 거대한 데이터 셋을 다루는 경우 ~ 더 낮은 비용</li>
<li>보다 일관적인 네트워크 경험 - 실시간 데이터 피드를 사용하는 애플리케이션</li>
<li>하이브리드 환경 (온-프레미스 + 클라우드)</li>
</ul>
</li>
<li>IPv4와 IPv6 모두 지원</li>
</ul>
<h3 id="direct-connect-diagram"><a class="header" href="#direct-connect-diagram">Direct Connect Diagram</a></h3>
<p><img src="https://docs.aws.amazon.com/ko_kr/directconnect/latest/UserGuide/images/direct-connect-overview.png" alt="Direct Connect" /></p>
<h3 id="direct-connect-gateway"><a class="header" href="#direct-connect-gateway">Direct Connect Gateway</a></h3>
<ul>
<li><strong>여러 리전(동일한 계정) 간에 하나 이상의 VPC로 Direct Connect를 설정하고자 한다면 반드시 Direct Connect Gateway를 사용해야 함</strong></li>
</ul>
<p><img src="https://docs.aws.amazon.com/ko_kr/directconnect/latest/UserGuide/images/dx-gateway.png" alt="Direct Connect Gateway" /></p>
<h3 id="direct-connect---connection-types"><a class="header" href="#direct-connect---connection-types">Direct Connect - Connection Types</a></h3>
<ul>
<li>
<p><strong>Dedicated Connections</strong>: 1Gbps, 10Gbps and 100Gbps 가용량</p>
<ul>
<li>customer 전용의 물리적 이더넷 포트</li>
<li>AWS에 먼저 요청을 하고, 이후 AWS Direct Connect Partner로부터 완료됨</li>
</ul>
</li>
<li>
<p><strong>Hosted Connections</strong>: 50Mbps, 500Mbps, 최대 10Gbps</p>
<ul>
<li>AWS Direct Connect Partner를 통해 연결 요청이 이루어짐</li>
<li>가용량(capacity)이 <strong>on-demand로 추가/삭제</strong>될 수 있음</li>
<li>AWS Direct Connect Partner 선택에 따라 1, 2, 5, 10Gbps</li>
</ul>
</li>
<li>
<p>새로운 연결을 구축하는데는 주로 1달 이상 소요됨</p>
</li>
</ul>
<h3 id="direct-connect---encryption"><a class="header" href="#direct-connect---encryption">Direct Connect - Encryption</a></h3>
<ul>
<li>데이터는 전송 중(in transit) <strong>암호화 되지 않지만</strong>, private함</li>
<li>AWS Direct Connect + VPN은 IPsec-encrypted된 private 연결을 제공함</li>
<li>더 추가적인 보안을 챙길 수 있으나, 구축에 있어 좀 더 복잡함</li>
</ul>
<p><img src="https://docs.aws.amazon.com/ja_jp/whitepapers/latest/aws-vpc-connectivity-options/images/image10.png" alt="AWS Direct Connect + VPN" /></p>
<h3 id="direct-connect---resiliency"><a class="header" href="#direct-connect---resiliency">Direct Connect - Resiliency</a></h3>
<ul>
<li><strong>주요 워크로드에 대한 High Resiliency</strong>
<ul>
<li>여러 location들에 대해 하나로 연결</li>
</ul>
</li>
</ul>
<p><img src="https://d1.awsstatic.com/AWS%20Direct%20Connect/Redundancy-Higher.cf97732b85470f0b3616f025f8a3534f95bb1940.png" alt="Direct Connect One connection at multi location" /></p>
<ul>
<li><strong>주요 워크로드에 대한 Maximum Resiliency</strong>
<ul>
<li>하나 이상의 location 내 별도의 장치에서 종료되는 연결들을 분리함으로써 Maximum resilience를 지킬 수 있음</li>
</ul>
</li>
</ul>
<p><img src="https://d1.awsstatic.com/AWS%20Direct%20Connect/Redundancy-Highest.cc18117d65de87b62bf4b8e10db7f980e3ac13fd.png" alt="Direct Connect Maximum Resiliency for Critical Workloads" /></p>
<h3 id="site-to-site-vpn-connection-as-a-backup"><a class="header" href="#site-to-site-vpn-connection-as-a-backup">Site-to-Site VPN connection as a backup</a></h3>
<ul>
<li>Direct Connect가 실패할 경우를 대비하고자 하는 경우
<ul>
<li>백업 Direct Connect 연결을 구축하거나 (비쌈)</li>
<li>Site-to-Site VPN 연결을 구축할 수 있음</li>
</ul>
</li>
</ul>
<h2 id="transit-gateway"><a class="header" href="#transit-gateway">Transit Gateway</a></h2>
<ul>
<li><strong>수천 개의 VPC와 온-프레미스 사이에 transitive(전이적) peering을 구축함으로써 hub-and-spoke(star) 연결을 만듬</strong></li>
<li>리전 별 리소스, cross-region으로 동작할 수 있음</li>
<li>RAM(Resource Access Manager)를 통해 계정 간에 공유 가능</li>
<li>리전 간에 Transit Gateway들을 피어링할 수 있음</li>
<li>Route Tables: 다른 VPC와 소통할 수 있는 VPC들을 제한할 수 있음</li>
<li>Direct Connect 게이트웨이 및 VPC 연결과 호환 가능</li>
<li><strong>IP Multicast</strong> 지원 (다른 어떤 AWS 서비스에서도 지원하지 않음)</li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/whitepapers/latest/building-scalable-secure-multi-vpc-network-infrastructure/images/hub-and-spoke-design.png" alt="Transit Gateway" /></p>
<h3 id="transit-gateway---site-to-site-vpn-ecmp"><a class="header" href="#transit-gateway---site-to-site-vpn-ecmp">Transit Gateway - Site-to-Site VPN ECMP</a></h3>
<ul>
<li>**ECMP = Equal-Cost Multiple-Path routing</li>
<li>여러 최적의 경로를 통해 패킷을 넘기도록 하는 라우팅 전략</li>
<li>사례: <strong>AWS로의 연결 대역폭을 상승시키기 위해</strong> 여러 개의 Site-to-Site VPN 연결을 구축</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/5b384ce32d8cdef02bc3a139d4cac0a22bb029e8/2020/02/02/Single-Tunnel.png" alt="Site-to-Site VPN ECMP" /></p>
<h3 id="transit-gateway---throughput-with-ecmp"><a class="header" href="#transit-gateway---throughput-with-ecmp">Transit Gateway - throughput with ECMP</a></h3>
<ul>
<li>VPN to Virtual Private Gateway
<ul>
<li>하나의 터널로 하나의 VPC에 연결</li>
<li>하나의 터널 -&gt; 1.25Gbps</li>
</ul>
</li>
<li>VPN to Transit Gateway
<ul>
<li>하나의 site-to-site VPN 연결로 여러 개의 VPC에 연결</li>
<li>하나의 site-to-site VPN 연결은 2.5Gbps (ECMP ~ 해당 전략에 두개의 터널이 사용됨)
<ul>
<li>더 많은 site-to-site VPN 연결을 추가할수록 처리량이 증가
<ul>
<li>2개 ~ 5.0Gbps (ECMP)</li>
<li>3개 ~ 7.5Gbps (ECMP)</li>
</ul>
</li>
</ul>
</li>
<li>Transit Gateway를 통해 처리되는 데이터 GB 당 비용 지불</li>
</ul>
</li>
</ul>
<h3 id="transit-gateway---share-direct-connect-between-multiple-accounts"><a class="header" href="#transit-gateway---share-direct-connect-between-multiple-accounts">Transit Gateway - Share Direct Connect between multiple accounts</a></h3>
<p><img src="https://d2908q01vomqb2.cloudfront.net/5b384ce32d8cdef02bc3a139d4cac0a22bb029e8/2021/05/26/updated-Diagram321-Transit-VIF1.png" alt="Share Direct Connect between multiple accounts" /></p>
<h2 id="vpc---traffic-mirroring"><a class="header" href="#vpc---traffic-mirroring">VPC - Traffic Mirroring</a></h2>
<ul>
<li>내 VPC 내에서의 네트워크 트래픽을 캡처 및 검사하도록 해줌</li>
<li>내가 관리하는 보안 appliance로 트래픽을 라우팅</li>
<li>트래픽 캡처
<ul>
<li><strong>From (Source)</strong> - 여러 ENI</li>
<li><strong>To (Targets)</strong> - 하나의 ENI 또는 하나의 NLB</li>
</ul>
</li>
<li>모든 패킷을 캡처 또는 내가 관심있는 패킷만 캡처 (선택적으로 패킷 잘라내기 가능 ~ truncate)</li>
<li>Source와 Target은 동일한 VPC에 있을수도, 다른 VPC에 있을 수도 있음 (VPC Peering)</li>
<li>사례: 컨텐츠 검사, 위협 모니터링, 트러블슈팅...</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/5b384ce32d8cdef02bc3a139d4cac0a22bb029e8/2021/03/08/Slide1.jpeg" alt="VPC Traffic Mirroring" /></p>
<h2 id="ipv6-for-vpc"><a class="header" href="#ipv6-for-vpc">IPv6 for VPC</a></h2>
<ul>
<li>IPv4는 4.3 billon(43억)개의 주소를 제공 (곧 소진될 것)</li>
<li>IPv6는 IPv4의 후속</li>
<li>IPv6는 <strong>3.4 x 10^38</strong> 개의 고유 IP 주소를 제공</li>
<li>모든 IPv6 주소는 public이며, internet-routable함 (= private 범위가 없음)</li>
<li>형태 =&gt; <code>x.x.x.x.x.x.x.x</code> (<em>x</em>는 16진수, 범위는 0000 ~ ffff)</li>
<li>예시:
<ul>
<li><code>2001:db8:3333:4444:5555:6666:7777:8888</code></li>
<li><code>2001:db8:3333:4444:cccc:dddd:eeee:ffff</code></li>
<li><code>::</code> =&gt; 모든 8 segments가 모두 0</li>
<li><code>2001:db8::</code> =&gt; 뒤의 6 segments가 모두 0</li>
<li><code>::1234:5678</code> =&gt; 첫 6 segments가 모두 0</li>
<li><code>2001:db8::1234:5678</code> =&gt; 가운데 4 segments가 모두 0</li>
</ul>
</li>
</ul>
<h3 id="ipv6-in-vpc"><a class="header" href="#ipv6-in-vpc">IPv6 in VPC</a></h3>
<ul>
<li><strong>IPv4는 VPC와 서브넷에서 비활성화될 수는 없음</strong></li>
<li>dual-stack 모드로 작동시키기 위해 IPv6를 활성화할 수는 있음 (모두 public IP 주소)</li>
<li>내 EC2 인스턴스들에서는 최소한 내부 private IPv4와 public IPv6를 갖게 됨</li>
<li>Internet Gateway으로 인터넷과 IPv4 또는 IPv6 양측을 통해 소통할 수 있게됨</li>
</ul>
<p><img src="https://docs.aws.amazon.com/images/whitepapers/latest/ipv6-on-aws/images/internet-access-for-a-vpc-public-subnet.png" alt="IPv6 in VPC" /></p>
<h3 id="ipv6-troubleshooting"><a class="header" href="#ipv6-troubleshooting">IPv6 Troubleshooting</a></h3>
<ul>
<li><strong>IPv4는 VPC와 서브넷에서 비활성화될 수는 없음</strong></li>
<li>따라서, 내 서브넷에서 EC2 인스턴스를 실행할 수 없다면
<ul>
<li>이는 IPv6를 획득할 수 없기 때문이 아니라 (IPv6 공간은 매우 크기 때문)</li>
<li>서브넷 내에서 이용가능한 IPv4이 없기 때문임</li>
</ul>
</li>
<li><strong>해결책</strong>: 내 서브넷에서 새로운 IPv4 CIDR을 생성</li>
</ul>
<h2 id="egress-only-internet-gateway"><a class="header" href="#egress-only-internet-gateway">Egress-only Internet Gateway</a></h2>
<ul>
<li><strong>IPv6만을 사용하고 하고자 할 때 적용</strong></li>
<li>NAT Gateway와 유사하나, IPv6 전용</li>
<li>내 VPC 안에 있는 인스턴스들이 IPv6로 아웃바운드 연결을 할 수 있도록 해줌
<ul>
<li>반면, 인터넷에서는 인스턴스에 IPv6 연결을 할 수 없도록 차단함</li>
</ul>
</li>
<li><strong>반드시 Route Table을 업데이트 해야함</strong></li>
</ul>
<h3 id="ipv6-routing"><a class="header" href="#ipv6-routing">IPv6 Routing</a></h3>
<p><img src="https://velog.velcdn.com/images/chan9708/post/d1e7b1f0-2982-4d8f-83e5-99bab106188d/image.png" alt="IPv6 Routing" /></p>
<h2 id="vpc-section-summary"><a class="header" href="#vpc-section-summary">VPC Section Summary</a></h2>
<ul>
<li><strong>CIDR</strong> - IP 범위</li>
<li><strong>VPC</strong> - Virtual Private Cloud =&gt; IPv4 &amp; IPv6 CIDR의 목록을 정의</li>
<li><strong>Subnets</strong> - 하나의 AZ에 묶임, 하나의 CIDR을 정의</li>
<li><strong>Internet Gateway</strong> - VPC 레벨에서 IPv4 &amp; IPv6 인터넷 액세스를 제공</li>
<li><strong>Route Tables</strong> - 서브넷에서 IGW, VPC Peering 연결, VPC Endpoint 등으로의 라우트를 추가하기 위해서는 반드시 수정</li>
<li><strong>Bastion Host</strong> - private 서브넷 내의 EC2 인스턴스와도 SSH 연결을 수행하기 위해, SSH로 접속할 수 있는 public EC2 인스턴스</li>
<li><strong>NAT Instances</strong> - private 서브넷 내의 EC2 인스턴스에 인터넷 액세스를 부여(구식), 반드시 public 서브넷 내에서 설정되어야 하며, Source/Destination 체크 옵션을 반드시 비활성화 해야함</li>
<li><strong>NAT Gateway</strong> - private EC2 인스턴스에 scalable한 인터넷 액세스를 제공, AWS에 의해 관리되며, IPv4 전용</li>
<li><strong>Private DNS + Route 53</strong> - DNS Resolution + DNS Hostnames (VPC)를 활성화</li>
<li><strong>NACL</strong> - stateless, 인바운드/아웃바운드 서브넷 룰, 임시 포트(Emphemeral Ports)</li>
<li><strong>Security Groups</strong> - stateful, EC2 인스턴스 레벨에서 작업</li>
<li><strong>Reachability Analyzer</strong> - AWS 리소스 간의 네트워크 연결성 테스트를 수행</li>
<li><strong>VPC Peering</strong> - 중복되지 않는 CIDR을 갖는 두 VPC를 연결, 비전이적(non-transitive)</li>
<li><strong>VPC Endpoints</strong> - VPC 내에서 AWS 서비스에 대한 private 액세스를 제공 (S3, DynamoDB, CloudFormation, SSM)</li>
<li><strong>VPC Flow Logs</strong> - VPC / 서브넷 / ENI 레벨에서 설정될 수 있음, 트래픽의 ACCEPT/REJECT 여부 판단, Athena 또는 CloudWatch Log로 공격을 파악하거나 분석을 수행할 수 있음</li>
<li><strong>Site-to-Site VPN</strong> - 데이터센터(DC)에 Customer Gateway, VPC에 Virtual Private Gateway, public 인터넷 간에 Site-to-Site VPN을 설정</li>
<li><strong>AWS VPN CloudHub</strong> - 사이트에 연결하기 위한 hub-and-spoke VPN 모델</li>
<li><strong>Direct Connect</strong> - VPC에 Virtual Private Gateway 설정, AWS Direct Connection Location에 direct private connection 구성</li>
<li><strong>Direct Connect Gateway</strong> - 다른 AWS 리전들 내에 여러 VPC들에 대한 Direct Connect 설정</li>
<li><strong>AWS PrivateLink / VPC Endpoint Services</strong>:
<ul>
<li>내 service VPC에서 customer VPC로 private하게 서비스를 연결</li>
<li>VPC Peering, pulbic Internet, NAT Gateway, Route Table 같은 것이 필요 없음</li>
<li>Network Load Balancer &amp; ENI를 사용해야 함</li>
</ul>
</li>
<li><strong>ClassicLink</strong> - 내 VPC에 EC2와 Classic EC2 인스턴스를 private하게 연결</li>
<li><strong>Transit Gateway</strong> - VPC, VPN &amp; DX에 전이적인(transitive) peering 연결</li>
<li><strong>Traffic Mirroring</strong> - 자세한 분석을 위해 ENI로부터의 네트워크 트래픽을 복사</li>
<li><strong>Egress-only Internet Gateway</strong> - NAT Gateway와 유사하나, IPv6 전용</li>
</ul>
<h2 id="networking-costs-in-aws-per-gb---simplified"><a class="header" href="#networking-costs-in-aws-per-gb---simplified">Networking Costs in AWS per GB - Simplified</a></h2>
<ul>
<li>비용 절약과 더 좋은 네트워크 성능을 위해서는 Public IP 보다 Private IP를 사용하라</li>
<li>최대의 비용 절약을 위해서는 동일한 AZ를 사용 (대신, High Availability와 트레이드 오프)</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWbdP6GTByHg8nPT-aXMTA.png" alt="Network Costs in VPC" /></p>
<h2 id="minimizing-egress-traffic-network-cost"><a class="header" href="#minimizing-egress-traffic-network-cost">Minimizing egress traffic network cost</a></h2>
<ul>
<li><strong>Egress traffic</strong>(송신 트래픽): 아웃바운드 트래픽 (AWS -&gt; 외부)</li>
<li><strong>Ingress traffic</strong>(유입 트래픽): 인바운드 트래픽 (외부 -&gt; AWS, 일반적으로 무료)</li>
<li>비용 절감을 위해서는 가능한 많은 인터넷 트래픽을 AWS 내부에 유지시키는 편이 좋음</li>
</ul>
<h2 id="s3-data-transfer-pricing---analysis-for-usa"><a class="header" href="#s3-data-transfer-pricing---analysis-for-usa">S3 Data Transfer Pricing - Analysis for USA</a></h2>
<ul>
<li><strong>S3 Ingress</strong>: 무료</li>
<li><strong>S3 to Internet</strong>: GB 당 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0.09</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">an</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">A</span><span class="mord mathnormal">cce</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord hangul_fallback">빠른전송시간</span><span class="mopen">(</span><span class="mord">50</span><span class="mspace nobreak"> </span><span class="mord">500</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord hangul_fallback">데이터전송에대한추가비용</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mord hangul_fallback">당</span></span></span></span>0.04 ~ <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0.08</span><span class="mord hangul_fallback">추가</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">Cl</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mord hangul_fallback">당</span></span></span></span>0.00</li>
<li><strong>CloudFront to Internet</strong>: GB 당 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0.085</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mord hangul_fallback">보다약간쌈</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord hangul_fallback">캐싱가능</span><span class="mopen">(</span><span class="mord hangul_fallback">낮은레이턴시</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mord hangul_fallback">요청과관련한비용을낮출수있음</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Cl</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord hangul_fallback">와함께쓰는경우</span><span class="mord">7</span><span class="mord hangul_fallback">배정도쌈</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">ross</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span><span class="mord hangul_fallback">당</span></span></span></span>0.02</li>
</ul>
<h2 id="pricing-nat-gateway-vs-gateway-vpc-endpoint"><a class="header" href="#pricing-nat-gateway-vs-gateway-vpc-endpoint">Pricing: NAT Gateway vs. Gateway VPC Endpoint</a></h2>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*7qj79PNh_dy_zNtX8Qv43Q.png" alt="Gateway VPC Endpoint" /></p>
<ul>
<li>NAT Gateway를 이용하여 Private subnet과 소통하는 것보다, VPC Endpoint를 두는 편이 비용이 훨씬 더 절감</li>
</ul>
<h2 id="network-protection-on-aws"><a class="header" href="#network-protection-on-aws">Network Protection on AWS</a></h2>
<ul>
<li>AWS에서의 네트워크를 보호하기 위해 지금껏 아래와 같은 서비스가 있었음
<ul>
<li>Network Access Control Lists (NACLs)</li>
<li>Amazon VPC security groups</li>
<li>AWS WAF (악성 요청을 보호)</li>
<li>AWS Shield &amp; AWS Shield Advanced</li>
<li>AWS Firewall Manager (cross account로 관리)</li>
</ul>
</li>
<li>VPC 전체를 정교한 방식으로 보호하고자 한다면 어떻게 할까?</li>
</ul>
<h2 id="aws-network-firewall"><a class="header" href="#aws-network-firewall">AWS Network Firewall</a></h2>
<ul>
<li>Amazon VPC 전체를 보호</li>
<li>layer 3부터 layer 7까지 보호</li>
<li>다음의 어떤 형태의 전송이든 검사 가능
<ul>
<li>VPC to VPC 트래픽</li>
<li>인터넷으로의 아웃바운드</li>
<li>인터넷으로부터의 인바운드</li>
<li>Direct Connect 또는 Site-to-Site VPN의 인바운드/아웃바운드</li>
</ul>
</li>
<li>내부적으로, AWS Network Firewall은 AWS Gateway Load Balancer를 사용함</li>
<li>Rule들은 여러 VPC에 적용하기 위해 AWS Firewall Manager에 의해 cross-account로 중앙 집중식(centrally) 관리될 수 있음</li>
</ul>
<h3 id="network-firewall---fine-grained-controls"><a class="header" href="#network-firewall---fine-grained-controls">Network Firewall - Fine Grained Controls</a></h3>
<ul>
<li>1000개의 Rule 지원
<ul>
<li>IP &amp; Port - ex. 10,000개의 IP 필터링</li>
<li>Protocol - ex. 아웃바운드 커뮤니케이션에 대해 SMB 프로토콜만 블록</li>
<li>Stateful domain list rule groups: <code>*.mycorp.com</code> 또는 써드파티 소프트웨어 repo로 향하는 아웃바운드 트래픽을 허용</li>
<li>Regex를 통한 정규표현식 매칭</li>
</ul>
</li>
<li><strong>Traffic Filtering</strong>: Rule과 매칭되는 트래픽을 허용/드롭/경고</li>
<li><strong>Active flow inspection</strong>: 침입 차단 기능으로 네트워크 위협으로부터 보호 (Gateway Load Balancer와 유사하나, AWS에 의해 완전 관리됨)</li>
<li>Rule과 매치된 로그들을 Amazon S3, CloudWatch Logs, Kinesis Data Firehose로 전송</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="disaster-recovery--migrations"><a class="header" href="#disaster-recovery--migrations">Disaster Recovery &amp; Migrations</a></h1>
<ul>
<li>기업의 사업 지속성이나 재정에 부정적인 영향을 끼치는 어떤 상황을 <strong>disaster</strong>라고 함</li>
<li>Disaster recovery (DR)은 disaster에 대비 및 복구를 하는 것을 의미</li>
<li>Disaster recovery의 종류?
<ul>
<li>온-프레미스 =&gt; 온-프레미스: 전통적인 방식의 DR, 매우 비쌈</li>
<li>온-프레미스 =&gt; AWS 클라우드: 하이브리드 방식</li>
<li>AWS Cloud Region A =&gt; AWS Cloud Region B</li>
</ul>
</li>
<li>복구 목표에 대한 두 용어:
<ul>
<li>RPO: Recovery Point Objective</li>
<li>RTO: Recovery Time Objective</li>
</ul>
</li>
</ul>
<h2 id="rpo-and-rto"><a class="header" href="#rpo-and-rto">RPO and RTO</a></h2>
<p><img src="https://d2908q01vomqb2.cloudfront.net/972a67c48192728a34979d9a35164c1295401b71/2022/05/31/ClouldOps_913_1.png" alt="RPO &amp; RTO" /></p>
<h2 id="disaster-recovery-strategies"><a class="header" href="#disaster-recovery-strategies">Disaster Recovery Strategies</a></h2>
<ul>
<li>Backup &amp; Restore</li>
<li>Pilot Light</li>
<li>Warm StandBy</li>
<li>Hot Site / Multi Site Approach</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/fc074d501302eb2b93e2554793fcaf50b3bf7291/2021/04/02/Figure-2.png" alt="Disaster Recovery Strategies" /></p>
<h3 id="backup-and-restore-high-rpo"><a class="header" href="#backup-and-restore-high-rpo">Backup and Restore (High RPO)</a></h3>
<p><img src="https://velog.velcdn.com/images/chan9708/post/e713d1f4-6b80-4417-96ee-9869ad661cb3/image.png" alt="Backup &amp; Restore" /></p>
<h3 id="pilot-light"><a class="header" href="#pilot-light">Pilot Light</a></h3>
<ul>
<li>앱의 작은 버전이 항상 클라우드에서 실행되도록 함</li>
<li>핵심 코어에 유용함 (pilot light)</li>
<li>Backup and Restore와 매우 유사</li>
<li>Backup and Restore보다 빠름 ~ 주요 critical system이 항상 가동 중이기 때문</li>
</ul>
<p><img src="https://static.packt-cdn.com/products/9781838645649/graphics/assets/9bb1d8f6-28c4-4ae0-a198-2709e2a33cc7.png" alt="Pilot Light" /></p>
<h3 id="warm-standby"><a class="header" href="#warm-standby">Warm Standby</a></h3>
<ul>
<li>전체 시스템을 가동 및 실행시키지만, 최소한의 사이즈로 유지함</li>
<li>disaster 발생 시에는 프로덕션의 부하에 맞추어 스케일 업을 수행할 수 있음</li>
</ul>
<p><img src="https://velog.velcdn.com/images/chan9708/post/1dcdc96b-8324-4cb5-9f50-a1cd8d3fdaca/image.png" alt="Warm Standby" /></p>
<h3 id="multi-site--hot-site-approach"><a class="header" href="#multi-site--hot-site-approach">Multi Site / Hot Site Approach</a></h3>
<ul>
<li>매우 낮은 RTO (몇분 또는 몇초 단위) - 매우 비쌈</li>
<li>Full Production Scale이 AWS와 온-프레미스로 실행됨</li>
</ul>
<p><img src="https://velog.velcdn.com/images/chan9708/post/7e3f87f2-5389-47cd-967d-6097eb16a813/image.png" alt="Multi Site / Hot Site Approach" /></p>
<h2 id="disaster-recovery-tips"><a class="header" href="#disaster-recovery-tips">Disaster Recovery Tips</a></h2>
<ul>
<li>
<p><strong>Backup</strong></p>
<ul>
<li>EBS 스냅샷, RDS 자동화 백업 / 스냅샷 등..</li>
<li>정기적인 푸쉬 ~ S3 / S3 IA / Glacier, Lifecycle Policy, Cross Region Replication</li>
<li>온-프레미스의 경우: Snowball 똔느 Storage Gateway</li>
</ul>
</li>
<li>
<p><strong>High Availability</strong></p>
<ul>
<li>리전에서 리전으로 DNS를 마이그레이션하는 경우 Route53을 사용</li>
<li>RDS Multi-AZ, ElastiCache Multi-AZ, EFS, S3</li>
<li>Direct Connect에서는 Site-to-Site VPN을 복구(recovery) 용도로 사용</li>
</ul>
</li>
<li>
<p><strong>Replication</strong></p>
<ul>
<li>RDS Replication (Cross Region), AWS Aurora + Global Databases</li>
<li>온-프레미스에서 RDS로 Database replication</li>
<li>Storage Gateway</li>
</ul>
</li>
<li>
<p><strong>Automation</strong></p>
<ul>
<li>CloudFormation / Elastic Beanstalk ~ 새로운 환경에서 새로 생성</li>
<li>CloudWatch로 alarm이 fail인 경우 EC2 인스턴스를 복구/재부팅</li>
<li>커스터마이징된 자동화를 위해 AWS Lambda 함수를 사용</li>
</ul>
</li>
<li>
<p><strong>Chaos</strong></p>
<ul>
<li>Netflix는 무작위로 EC2를 종료시켜버리는 <a href="https://github.com/netflix/chaosmonkey">Chaos Monkey</a>를 보유하고 있음</li>
</ul>
</li>
</ul>
<h2 id="dms---database-migration-service"><a class="header" href="#dms---database-migration-service">DMS - Database Migration Service</a></h2>
<ul>
<li>빠르고 안전하게 데이터베이스를 AWS로 마이그레이션
<ul>
<li>resilient</li>
<li>self healing</li>
</ul>
</li>
<li>source 데이터베이스는 마이그레이션 중에도 사용가능한 상태가 유지됨</li>
<li>지원:
<ul>
<li>Homogeneous migrations(동종 마이그레이션) ~ ex. Oracle to Oracle</li>
<li>Heterogeneous migrations(이기종 마이그레이션) ~ ex. Microsoft SQL Server to Aurora</li>
</ul>
</li>
<li>CDC를 통해 지속적인 Data Replication</li>
<li>반드시 replication 작업을 수행할 EC2 인스턴스를 생성해야 함</li>
</ul>
<h3 id="dms-sources-and-targets"><a class="header" href="#dms-sources-and-targets">DMS Sources and Targets</a></h3>
<ul>
<li><strong>Sources</strong>:
<ul>
<li>온-프레미스 &amp; EC2 인스턴스 DB
<ul>
<li>Oracle, MS SQL Server, MySQL, MariaDB, PostgreSQL, MongoDB, SAP, DB2</li>
</ul>
</li>
<li>Azure: Azure SQL Database</li>
<li>Amazon RDS: Aurora 포함해서 전부</li>
<li>Amazon S3</li>
<li>DocumentDB</li>
</ul>
</li>
<li><strong>Targets</strong>:
<ul>
<li>온-프레미스 &amp; EC2 인스턴스 DB
<ul>
<li>Oracle, MS SQL Server, MySQL, MariaDB, PostgreSQL, MongoDB, SAP</li>
</ul>
</li>
<li>Amazon RDS</li>
<li>Redshift, DynamoDB, S3</li>
<li>OpenSearch Service</li>
<li>Kinesis Data Streams</li>
<li>Apache Kafka</li>
<li>DocumentDB &amp; Amazon Neptune</li>
<li>Redis &amp; Babelfish</li>
</ul>
</li>
</ul>
<h2 id="aws-schema-conversion-tool-sct"><a class="header" href="#aws-schema-conversion-tool-sct">AWS Schema Conversion Tool (SCT)</a></h2>
<ul>
<li>한 엔진에서 다른 종류의 엔진으로 데이터베이스 스키마를 변환
<ul>
<li>ex. OLTP: (SQL Server or Oracle) to MySQL, PostgreSQL, Aurora</li>
<li>ex. OLAP: (Teradata or Orcale) to Amazon Redshift</li>
</ul>
</li>
<li><strong>동일한 DB 엔진으로 마이그레이션을 해야하는 상황이라면 SCT를 쓸 이유가 없음</strong>
<ul>
<li>ex. 온-프레미스 PostgreSQL =&gt; RDS PostgreSQL</li>
<li>RDS는 플랫폼일 뿐, DB 엔진은 여전히 PostgreSQL</li>
</ul>
</li>
</ul>
<h3 id="dms---continuous-replication"><a class="header" href="#dms---continuous-replication">DMS - Continuous Replication</a></h3>
<p><img src="https://velog.velcdn.com/images/chan9708/post/eef25414-eb76-48e2-95e7-46e6772ced69/image.png" alt="DMS Continous replication" /></p>
<h2 id="rds--aurora-mysql-migrations"><a class="header" href="#rds--aurora-mysql-migrations">RDS &amp; Aurora MySQL Migrations</a></h2>
<ul>
<li>RDS MySQL to Aurora MySQL
<ul>
<li>옵션 1: RDS MySQL로부터 DB 스냅샷을 만들고 MySQL Aurora DB에서 복구</li>
<li>옵션 2: RDS MySQL로부터 Aurora Read Replica를 만들고, replication lag이 0이 되었을 때, 이를 자체 DB 클러스터로 승격시킴 (시간, 비용 추가)</li>
</ul>
</li>
<li>외부의 MySQL to Aurora MySQL
<ul>
<li>옵션 1:
<ul>
<li>Percona XtraBackup으로 S3에서 파일 백업을 생성</li>
<li>S3로부터 Aurora MySQL DB를 생성</li>
</ul>
</li>
<li>옵션 2:
<ul>
<li>Aurora MySQL DB를 생성</li>
<li>mysqldump 유틸을 사용하여 MySQL을 Aurora로 마이그레이션 (S3를 통한 방법보다 느림)</li>
</ul>
</li>
</ul>
</li>
<li>만약 양측의 DB가 모두 실행 및 구동 중이라면 DMS를 사용</li>
</ul>
<h2 id="rds--aurora-postgresql-migrations"><a class="header" href="#rds--aurora-postgresql-migrations">RDS &amp; Aurora postgreSQL Migrations</a></h2>
<ul>
<li>RDS PostgreSQL to Aurora PostgreSQL
<ul>
<li>옵션 1: RDS PostgreSQL로부터 DB 스냅샷을 만들고 PostgreSQL Aurora DB에서 복구</li>
<li>옵션 2: RDS PostgreSQL로부터 Aurora Read Replica를 만들고, replication lag이 0이 되었을 때, 이를 자체 DB 클러스터로 승격시킴 (시간, 비용 추가)</li>
</ul>
</li>
<li>외부의 PostgreSQL to Aurora PostgreSQL
<ul>
<li>백업을 만들고 S3에 넣음</li>
<li>aws_s3 Aurora 익스텐션으로 이를 가져옴</li>
</ul>
</li>
<li>만약 양측의 DB가 모두 실행 및 구동 중이라면 DMS를 사용</li>
</ul>
<h2 id="on-premise-strategy-with-aws"><a class="header" href="#on-premise-strategy-with-aws">On-Premise Strategy with AWS</a></h2>
<ul>
<li>Amazon Linux 2 AMI를 VM으로 다운로드 할 수 있음 (.iso 포맷)
<ul>
<li>VMWare, KVM, VirtualBox (Oracle VM), Microsoft Hyper-V</li>
</ul>
</li>
<li>VM Import / Export
<ul>
<li>기존 애플리케이션을 EC2로 마이그레이션</li>
<li>온-프레미스 VM에 사용하기 위해 DR(Disaster Recovery) repo를 생성하는 전략</li>
<li>EC2에서 온-프레미스로 VM을 export할 수도 있음</li>
</ul>
</li>
<li>AWS Application Discovery Service
<ul>
<li>마이그레이션 계획을 위해 온-프레미스 서버에 대한 정보를 수집</li>
<li>서버 사용률 및 종속성 매핑</li>
<li>AWS Migration Hub로 트래킹</li>
</ul>
</li>
<li>AWS Database Migration Service (DMS)
<ul>
<li>온-프레미스 =&gt; AWS, AWS =&gt; AWS, AWS =&gt; 온-프레미스 복제</li>
<li>다양한 DB 엔진과 호환 (Oracle, MySQL, DynamoDB, etc...)</li>
</ul>
</li>
<li>AWS Server Migration Service (SMS)
<ul>
<li>온-프레미스의 라이브 서버에서 AWS로의 증분 복제 (incremental replication)</li>
</ul>
</li>
</ul>
<h2 id="aws-backup"><a class="header" href="#aws-backup">AWS Backup</a></h2>
<ul>
<li>완전 관리형 서비스</li>
<li>AWS 서비스들의 백업을 중앙 관리 및 자동화</li>
<li>커스텀 스크립트를 생성하거나 수동으로 처리해야할 필요가 없음</li>
<li>지원 서비스:
<ul>
<li>EC2 / EBS</li>
<li>S3</li>
<li>RDS (모든 엔진 지원) / Aurora / DynamoDB</li>
<li>DocumentDB / Neptune</li>
<li>EFS / FSx (Lustre &amp; Windows File Server)</li>
<li>AWS Storage Gateway (Volume Gateway)</li>
</ul>
</li>
<li>cross-region 백업 지원</li>
<li>cross-account 백업 지원</li>
<li>지원 서비스에 대한 PITR(Point-In-Time Recovery) 지원</li>
<li>On-Demand &amp; Scheduled backup</li>
<li>Tag-based backup 정책</li>
<li><strong>Backup Plan</strong>이라는 이름의 백업 정책 생성
<ul>
<li>백업 주기 (매 12시간마다 / 매일 / 매주 / 매월 / cron 표현식 사용)</li>
<li>백업 윈도우</li>
<li>Cold Storage로 전환 (Never / Days / Weeks / Months / Years)</li>
<li>보존 기간 (Always / Days / Weeks / Months / Years)</li>
</ul>
</li>
</ul>
<h3 id="aws-backup-vault-lock"><a class="header" href="#aws-backup-vault-lock">AWS Backup Vault Lock</a></h3>
<ul>
<li>AWS Backup Vault에 저장한 백업들에 대해 WORM (Write Once Read Many) 상태를 강제</li>
<li>백업한 내용을 다음으로부터 보호하기 위한 추가 레이어:
<ul>
<li>의도치 않거나, 악의적인 삭제 작업</li>
<li>보존 기간을 더 짧게 하거나 변경하는 업데이트</li>
</ul>
</li>
<li>이것이 활성화된 경우, 심지어 루트 이용자도 백업을 삭제할 수 없게 됨</li>
</ul>
<h2 id="aws-application-discovery-service"><a class="header" href="#aws-application-discovery-service">AWS Application Discovery Service</a></h2>
<ul>
<li>
<p>온-프레미스 데이터 센터에 대한 정보를 수집함으로써 프로젝트 마이그레이션을 계획</p>
</li>
<li>
<p>서버 사용률(server utilization)과 종속성 매핑은 마이그레이션에 있어 중요함</p>
</li>
<li>
<p><strong>Agentless Discovery (AWS Agentless Discovery Connector)</strong></p>
<ul>
<li>VM 인벤토리, 설정, 성능 히스토리 (CPU / 메모리 / 디스크 사용량)</li>
</ul>
</li>
<li>
<p><strong>Agent-based Discovery (AWS Application Discovery Agent)</strong></p>
<ul>
<li>시스템 구성, 시스템 성능, 실행 프로세스, 시스템 간의 네트워크 연결 세부사항</li>
</ul>
</li>
<li>
<p>결과 데이터는 AWS Migration Hub로 볼 수 있음</p>
</li>
</ul>
<h2 id="aws-application-migration-service-mgn"><a class="header" href="#aws-application-migration-service-mgn">AWS Application Migration Service (MGN)</a></h2>
<ul>
<li>AWS SMS(Server Migration Service)를 대체하는 ClodEndure Migration의 AWS 버전</li>
<li>애플리케이션을 AWS로 마이그레이션하는 작업을 간소화하는 Lift-and-Shift(rehost) 솔루션 서비스</li>
<li>물리적/가상/클라우드 서버들을 AWS에서 네이티브하게 실행되도록 변환해줌</li>
<li>넓은 범위의 플랫폼, OS, 데이터베이스를 지원</li>
<li>최소한의 downtime, 낮은 비용</li>
</ul>
<p><img src="https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2021/04/15/2021-aws-mgn-how-it-works.jpg" alt="AWS MGN" /></p>
<h2 id="transferring-large-amount-of-data-into-aws"><a class="header" href="#transferring-large-amount-of-data-into-aws">Transferring large amount of data into AWS</a></h2>
<ul>
<li><strong>사례</strong>:
<ul>
<li>클라우드로 200TB의 데이터를 전송하려고 함</li>
<li>현재 100Mbps의 인터넷 연결을 보유</li>
</ul>
</li>
<li><strong>Over the internet / Site-to-Site VPN</strong>:
<ul>
<li>즉시 설정 가능</li>
<li>200(TB)*1000(GB)*1000(MB)*8(Mb)/100Mbps = 16,000,000s = 185일</li>
</ul>
</li>
<li><strong>Over direct connect 1Gbps</strong>:
<ul>
<li>한번 설정에 많은 시간이 걸림 (1달 이상)</li>
<li>200(TB)*1000(GB)*8(GB)/1Gbps = 1,600,000s = 18.5일</li>
</ul>
</li>
<li><strong>Over Snowball</strong>:
<ul>
<li>2 ~ 3개의 Snowball을 병렬적으로 받음</li>
<li>E2E 전송에 약 1주일 소요 (제일 빠름)</li>
<li>DMS와 함께 사용할 수 있음</li>
</ul>
</li>
<li><strong>지속적인(on-going) 복제 / 전송의 경우</strong>: Site-to-Site VPN 또는 DX 또는 DMS 또는 DataSync</li>
</ul>
<h2 id="vmware-cloud-on-aws"><a class="header" href="#vmware-cloud-on-aws">VMware Cloud on AWS</a></h2>
<ul>
<li>일부 고객들은 VMware Cloud를 사용해서 본인들의 온-프레미스 데이터 센터를 관리하고 싶어함
<ul>
<li>데이터 센터 용량을 AWS로 확장하려고 하지만, 여전히 VMware Cloud 소프트웨어의 사용은 유지하고 싶은 경우?</li>
<li>VMware Cloud on AWS를 사용하면 됨!</li>
</ul>
</li>
<li>사례
<ul>
<li>VMware vSphere 기반의 워크로드를 AWS로 마이그레이션하고 싶은 경우</li>
<li>프로덕션 워크로드를 VMware vSphere 기반의 private/public/hybrid 클라우드 환경으로 실행하고 싶은 경우</li>
<li>재해 복구 전략을 갖고자 하는 경우</li>
</ul>
</li>
</ul>
<p><img src="https://d1.awsstatic.com/Digital%20Marketing/Webinar/VMware/Product-Page-Diagram_VMware-Cloud-on-AWS%20(1).7e9542eb2ffb98892a81838ac2622fe340650824.png" alt="VMware Cloud on AWS" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="more-solution-architectures"><a class="header" href="#more-solution-architectures">More Solution Architectures</a></h1>
<h2 id="event-processing-in-aws"><a class="header" href="#event-processing-in-aws">Event Processing in AWS</a></h2>
<h3 id="lambda-sns--sqs"><a class="header" href="#lambda-sns--sqs">Lambda, SNS &amp; SQS</a></h3>
<ul>
<li>SQS + Lambda
<ul>
<li>SQS에서 lambda로 poll을 시도하다가, 지속적으로 실패할 경우 무한 루프에 빠질 수 있음</li>
<li>이에 따라 DLQ(Dead Letter Queue)를 설정할 수 있음 (ex. 5번 retry 후 DLQ로 이동)</li>
</ul>
</li>
<li>SQS FIFO + Lambda
<ul>
<li>SQS FIFO의 경우, 순서를 보장하기 때문에, 한번 실패할 경우, 그 다음의 메시지로 넘어가지 않고 블록된 상태가 되버림</li>
<li>이때도 마찬가지로 DLQ를 설정하여 다음 메시지로 넘어갈 수 있도록 대처할 수 있음</li>
</ul>
</li>
<li>SNS + Lambda
<ul>
<li>SNS에서 Lambda로 비동기적으로 메시지를 전송하였으나 Lambda 함수에서의 처리가 이루어지지 않을 때</li>
<li>마찬가지로 몇번의 retry를 시도한 다음, 버리거나(discard), DLQ를 설정하여 SQS로 전달할 수 있음 (이 때는, Lambda 서비스 레벨에서 DLQ를 설정했다는 점에서 앞의 두개와는 차이가 있음)</li>
</ul>
</li>
</ul>
<h3 id="fan-out-pattern-deliver-to-multiple-sqs"><a class="header" href="#fan-out-pattern-deliver-to-multiple-sqs">Fan Out Pattern: deliver to multiple SQS</a></h3>
<ul>
<li>여러 개의 SQS를 둔 경우, 각각의 SQS에다 직접 Message를 PUT할 수도 있으나, 이 경우 아키덱처를 신뢰하기 어려워짐
<ul>
<li>왜? -&gt; x번째 메시지를 처리하던 중 애플리케이션에 문제가 발생한다면, 그 이후의 메시지는 처리되지 않아 끝내 못받게되는 경우가 발생할 수 있음</li>
<li>이 때는 <strong>Fan Out</strong> 패턴을 쓰자!</li>
<li>하나의 SNS를 두고, 이를 여러 SQS가 구독하는 형태</li>
</ul>
</li>
</ul>
<h3 id="s3-event-notifications"><a class="header" href="#s3-event-notifications">S3 Event Notifications</a></h3>
<ul>
<li><code>S3:ObjectCreated</code>, <code>S3:ObjectRemoved</code>, <code>S3:ObjectRestore</code>, <code>S3:Replication</code>...</li>
<li>SQS, SNS, Lambda와 연동하여 사용</li>
<li>오브젝트 명칭 필터링이 가능 (ex. <code>*.jpg</code>)</li>
<li>사례: S3에 업로드된 이미지의 썸네일 생성</li>
<li><strong>원하는 만큼 많이 &quot;S3 이벤트&quot;를 만들 수 있음</strong></li>
<li>S3 Event Notifications는 일반적으로 몇 초 안에 전달되지만, 경우에 따라서는 몇 분 이상 소요될 경우도 있음</li>
</ul>
<h3 id="s3-event-notifications-with-amazon-eventbridge"><a class="header" href="#s3-event-notifications-with-amazon-eventbridge">S3 Event Notifications with Amazon EventBridge</a></h3>
<ul>
<li>JSON Rule을 통한 <strong>고급 필터링</strong> 옵션 (메타데이터, 오브젝트 사이즈, 이름...)</li>
<li><strong>Multiple Destinations</strong> - ex. Step Functions, Kinesis Streams / Firehose...</li>
<li><strong>EventBridge Capabilities</strong> - Archive, Replay Events, Reliable delivery</li>
</ul>
<p><img src="https://da-public-assets.s3.amazonaws.com/thumbnails/patterns/s3-eventbridge-sns-terraform.png" alt="S3 Event Notifications with Amazon EventBridge" /></p>
<h3 id="amazon-eventbridge---intercept-api-calls"><a class="header" href="#amazon-eventbridge---intercept-api-calls">Amazon EventBridge - Intercept API Calls</a></h3>
<ul>
<li>DynamoDB -&gt; CloudTrail -&gt; EventBridge -&gt; SNS</li>
</ul>
<h3 id="api-gateway---aws-service-integration-kinesis-data-streams-example"><a class="header" href="#api-gateway---aws-service-integration-kinesis-data-streams-example">API Gateway - AWS Service Integration Kinesis Data Streams Example</a></h3>
<ul>
<li>Client -&gt; API Gateway -&gt; Kinesis Data Streams -&gt; Kinesis Data Firehose -&gt; Amazon S3</li>
</ul>
<h2 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h2>
<p><img src="https://blog.cloudcraft.co/wp-content/uploads/2020/09/Caching-101-1.png" alt="AWS Caching Strategies" /></p>
<h2 id="blocking-an-ip-address"><a class="header" href="#blocking-an-ip-address">Blocking an IP address</a></h2>
<ul>
<li>가장 쉬운 방법은 NACL(Network Access Control List)을 통해 VPC 레벨에서 원하는 IP 주소에 대해 Deny Rule을 설정 하는 것
<ul>
<li>여기에 EC2 내에 선택적으로 Firewall 소프트웨어를 사용할 수도 있음</li>
</ul>
</li>
<li>ALB의 경우:
<ul>
<li>NACL + ALB 측에서 Security Group을 설정 -&gt; Connection Termination</li>
</ul>
</li>
<li>NLB의 경우:
<ul>
<li>Connection Termination이 없음 -&gt; 곧바로 EC2 인스턴스로 넘어감</li>
</ul>
</li>
<li>ALB + WAF:
<ul>
<li>WAF에서, 좀 더 비싸지만 복잡한 필터링을 구축할 수 있음</li>
<li>WAF는 ALB에다 구축하는 것</li>
</ul>
</li>
<li>ALB + CloudFront WAF:
<ul>
<li>CloudFront 쪽에서 WAF를 이용해 IP 주소를 먼저 필터링</li>
<li>이후, ALB로 넘기는데, 이때는 CloudFront의 Public IP를 통해 접속하는 것이라, 클라이언트의 IP를 알 수가 없어 NACL이 도움이 되지 않음</li>
</ul>
</li>
</ul>
<h2 id="high-performance-computing-hpc"><a class="header" href="#high-performance-computing-hpc">High Performance Computing (HPC)</a></h2>
<ul>
<li>클라우드는 HPC를 수행하기에 완벽한 곳임</li>
<li>언제든지 엄청 많은 수의 리소스들을 생성할 수 있음</li>
<li>더 많은 리소스들을 추가함으로써 결과물의 속도를 높일 수 있음</li>
<li>사용한 시스템 만큼만 값을 지불</li>
<li>Perform genomics, computational chemistry, financial risk modeling, weather prediction, machine learning, deep learning, autonomous driving</li>
<li>HPC를 수행하려면 어떤 서비스를 사용해야 할까?</li>
</ul>
<h3 id="data-management--transfer"><a class="header" href="#data-management--transfer">Data Management &amp; Transfer</a></h3>
<ul>
<li>AWS Direct Connect
<ul>
<li>private 보안 네트워크를 통해 클라우드에 GB/s 수준의 데이터를 이동</li>
</ul>
</li>
<li>Snowball &amp; Snowmobile
<ul>
<li>클라우드에 PB 단위의 데이터 이동</li>
</ul>
</li>
<li>AWS DataSync
<ul>
<li>온-프레미스와 S3, EFS, FSx for Windows 간에 많은 양의 데이터를 이동</li>
</ul>
</li>
</ul>
<h3 id="compute-and-networking"><a class="header" href="#compute-and-networking">Compute and Networking</a></h3>
<ul>
<li>EC2 Instances:
<ul>
<li>CPU optimized, GPU optimized</li>
<li>Spot Instances / Spot Fleets for cost savings + Auto Scaling</li>
</ul>
</li>
<li>EC2 Placement Groups: 더 좋은 네트워크 성능을 위한 <strong>클러스터</strong></li>
<li>EC2 Enhanced Networking (SR-IOV)
<ul>
<li>높은 대역폭, 높은 PPS (Packer Per Second), 낮은 레이턴시</li>
<li>옵션 1: <strong>Elastic Network Adapter (ENA)</strong> ~ 최대 100Gbps</li>
<li>옵션 2: Intel 82599 VF ~ 최대 10Gbps (레거시)</li>
</ul>
</li>
<li><strong>Elastic Fabric Adapter (EFA)</strong>
<ul>
<li>HPC 목적의 향상된 ENA, <strong>Linux</strong>에서만 동작</li>
<li>노드 간의 커뮤니케이션, <strong>강하게 커플링된 워크로드</strong>에 유용함</li>
<li>MPI(Message Passing Interface) 표준 활용</li>
<li>기본 Linux OS를 우회하여, 낮은 레이턴시와 안정적인 전송을 제공</li>
</ul>
</li>
</ul>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<ul>
<li>Instance-attached storage:
<ul>
<li><strong>EBS</strong>: io2 Block Express 사용 시 최대 256,000 IOPS까지 스케일 업</li>
<li><strong>Instance Store</strong>: million(백만) 단위 IOPS까지 스케일링, EC2 인스턴스에 연결, 낮은 레이턴시</li>
</ul>
</li>
<li>Network Storage:
<ul>
<li><strong>Amazon S3</strong>: large blob, 파일 시스템이 아님</li>
<li><strong>Amazon EFS</strong>: 전체 사이즈에 기반하여 IOPS가 스케일링, 또는 IOPS 프로비저닝</li>
<li><strong>Amazon FSx for Lustre</strong>:
<ul>
<li>HPC 최적화된 분산형 파일 시스템, millions of IOPS</li>
<li>Backed by S3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="automation-and-orchestration"><a class="header" href="#automation-and-orchestration">Automation and Orchestration</a></h3>
<ul>
<li>AWS Batch
<ul>
<li><strong>AWS Batch</strong>는 멀티 노트 병렬 작업(여러 <strong>EC2</strong> 인스턴스에 걸쳐 단일 작업을 처리)을 지원</li>
<li>작업을 스케줄링하고, 이에 따른 EC2 인스턴스 실행을 쉽게 할 수 있음</li>
</ul>
</li>
<li>AWS ParallelCluster
<ul>
<li>AWS에서 HPC를 배포하기 위한 오픈소스 클러스터 관리 툴</li>
<li>텍스트 파일로 설정</li>
<li>VPC, 서브넷, 클러스터 타입 및 인스턴스 타입 생성을 자동화</li>
<li><strong>클러스터에서 EFA를 활성화하는 기능</strong> (<strong>네트워크 성능 향상</strong>)</li>
</ul>
</li>
</ul>
<h2 id="high-availability-1"><a class="header" href="#high-availability-1">High Availability</a></h2>
<h3 id="creating-a-highly-available-ec2-instance"><a class="header" href="#creating-a-highly-available-ec2-instance">Creating a highly Available EC2 Instance</a></h3>
<ul>
<li>Highly Available한 인스턴스를 직접 구성하려면
<ul>
<li>Elastic IP</li>
<li>두 개의 EC2 인스턴스
<ul>
<li>Public EC2 (기본)</li>
<li>Standby EC2 (대기 용도)</li>
</ul>
</li>
<li>CloudWatch Event (인스턴스 상태 모니터링 ~ metric에 따라 알람 전달)</li>
<li>Lambda (알람이 일어나면, 대기하던 인스턴스를 실행하고, Elastic IP를 할당)</li>
</ul>
</li>
</ul>
<h3 id="creating-a-highly-available-ec2-instance-with-an-auto-scaling-group"><a class="header" href="#creating-a-highly-available-ec2-instance-with-an-auto-scaling-group">Creating a highly available EC2 instance With an Auto Scaling Group</a></h3>
<ul>
<li><strong>ASG에서 스케일링 설정</strong>
<ul>
<li>ex. 1min, 1max, 1desired, &gt;= 2AZ</li>
</ul>
</li>
<li>Elastic IP를 (Tag에 기반하여) 새 인스턴스에 할당하는 EC2 user data를 세팅
<ul>
<li>EC2 인스턴스 Role이 Elastic IP를 할당하는 API 호출을 허용하고 있어야 함</li>
</ul>
</li>
<li>기존 인스턴스는 제거</li>
</ul>
<h3 id="creating-a-highly-available-ec2-instance-with-asg--ebs"><a class="header" href="#creating-a-highly-available-ec2-instance-with-asg--ebs">Creating a highly available EC2 instance with ASG + EBS</a></h3>
<ul>
<li>ASG에서 Terminate lifecycle hook으로 EC2 인스턴스가 종료되면서 EBS를 스냅샷 (+ 태깅)</li>
<li>이후 새 인스턴스를 실행하면서 (Tag에 기반한) EC2 user data로 EBS 볼륨을 생성하고 ASG Launch lifecycle hook에서 생성한 EBS 볼륨을 인스턴스에 연결</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="osi-model"><a class="header" href="#osi-model">OSI Model</a></h1>
<p>**OSI(Open Systems Interconnection)**은 다양한 통신 시스템이 표준 프로토콜을 사용하여 통신할 수 있도록 하는 국제 표준화 기구에 의해 만들어진 개념적인 모델(conceptual model)이다.</p>
<p>OSI 모델은 컴퓨터 네트워킹에 있어 공용 언어로 볼 수 있으며, 이는 커뮤니케이션 체계를 7개의 추상화된 레이어로 쪼개서 보는 개념에서 출발한다.</p>
<p><img src="https://www.cloudflare.com/img/learning/ddos/what-is-a-ddos-attack/osi-model-7-layers.svg" alt="OSI Layers" /></p>
<h2 id="왜-osi-모델이-중요할까"><a class="header" href="#왜-osi-모델이-중요할까">왜 OSI 모델이 중요할까?</a></h2>
<p>현대의 인터넷은 사실 엄격하게 OSI 모델을 따르지 않음에도 불구하고, OSI 모델은 여전히 네트워크 문제에 대한 트러블슈팅에 매우 용이하다.</p>
<p>노트북에서 인터넷 연결이 안되는 문제, 수천명의 이용자가 사용하는 웹사이트가 다운되는 문제 등등, 이러한 네트워크와 관련된 문제를 쪼개서 문제의 원인을 정확히 파악하는 데에 OSI 모델이 도움을 줄 수 있다. 만약, 어떤 문제가 모델 내 하나의 구체적인 레이어에 국한된 점이라는 것을 파악한다면, 그 외의 불필요한 작업들은 피할 수 있다.</p>
<h2 id="7-the-application-layer"><a class="header" href="#7-the-application-layer">7. The application layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/koKt5UKczRq47xJsexfBV/c1e1b2ab237063354915d16072157bac/7-application-layer.svg" alt="Application Layer" /></p>
<p>이용자와 직접적으로 데이터를 통해 상호작용하는 유일한 레이어다. 웹 브라우저나 이메일 클라이언트와 같은 소프트웨어 애플리케이션들이 이 애플리케이션 레이어에 의존하여 통신을 시작한다.</p>
<p>단, 클라이언트 소프트웨어 애플리케이션이 애플리케이션 레이어의 일부에 해당하는 것은 아니라는 점을 기억하자. 오히려 애플리케이션 레이어는 소프트웨어가 사용자에게 의미있는 데이터를 전달하기 위해 의존하는 프로토콜과 데이터 조작에 대한 책임을 갖는다.</p>
<p>애플리케이션 레이어 프로토콜은 HTTP 뿐만 아니라 SMTP(Simple Mail Transfer Protocol ~ 이메일 커뮤니케이션을 가능하게 하는 프로토콜 중 하나)를 포함한다.</p>
<h2 id="6-the-presentation-layer"><a class="header" href="#6-the-presentation-layer">6. The Presentation Layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/60dPoRIz0Es5TjDDncEp2M/7ad742131addcbe5dc6baa16a93bf189/6-presentation-layer.svg" alt="Presentation Layer" /></p>
<p>애플리케이션 레이어에서 사용될 데이터를 준비하는 역할을 하는 레이어다. 즉, 프레젠테이션 레이어는 애플리케이션이 소비할 수 있는 데이터를 제공한다. 해당 레이어는 변환(translation), 암호화(encryption), 데이터 압축(compression of data)를 담당한다.</p>
<blockquote>
<p>translation - 디바이스마다 다른 인코딩 방식으로 인코딩된 데이터를 변환</p>
<p>encryption - 암호화된 연결을 통해 통신하는 경우, 암호화/복호화를 담당</p>
<p>compression - 애플리케이션 레이어를 통해 넘겨받은 데이터를 아래 층 레이어로 전달하기 전에 압축</p>
</blockquote>
<h2 id="5-the-session-layer"><a class="header" href="#5-the-session-layer">5. The Session Layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/6jFRnaZSuIMoUzSotZXYbG/cc7a47d2b3f8d3e77b9ffbdb8b8d5280/5-session-layer.svg" alt="Session Layer" /></p>
<p>두 디바이스 간의 통신(communication)을 열고 닫는 역할을 하는 레이어다. &quot;세션&quot;은 통신이 열리고 닫히는 시간을 의미한다. 세션 레이어는 세션이 교환되는 모든 데이터를 전송할 수 있을 정도로 세션이 열려있는지 확인하고, 리소스 낭비를 방지하기 위해 세션을 빠르게 닫는다.</p>
<p>또한, 데이터 전송을 체크 포인트를 통해 동기화해주는 역할도 수행한다.</p>
<h2 id="4-the-transport-layer"><a class="header" href="#4-the-transport-layer">4. The Transport Layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/1MGbIKcfXgTjXgW0KE93xK/64b5aa0b8ebfb14d5f5124867be92f94/4-transport-layer.svg" alt="Transport Layer" /></p>
<p>두 디바이스 간의 E2E 통신을 담당하는 레이어다. 세션 레이어로부터 데이터를 넘겨 받아 이것을 세그먼트(segment)라고 하는 덩어리들로 쪼갠 다음 아래 층의 레이어로 전송한다. (Segmentation)</p>
<p>넘겨받는 디바이스 쪽의 해당 레이어에서는 이렇게 세그먼트로 쪼개진 데이터를 다시 소비가 가능한 형태로 재조립(reassembly)하는 역할을 수행한다.</p>
<p>트랜스포트 레이어는 Flow Control과 Error Control의 역할도 수행한다.</p>
<blockquote>
<p>Flow Control - 빠른 연결을 가진 송신자가 느린 연결을 가진 수신자를 압도하지 않도록 하기 위한 최적의 전송 속도를 결정하는 것</p>
<p>Error Control - 데이터 수신이 완료되었는지에 대해 확인하고, 그렇지 못한 경우 재전송을 요청</p>
</blockquote>
<h2 id="3-the-network-layer"><a class="header" href="#3-the-network-layer">3. The Network Layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/76JgEjycZl12c90UByKfJA/d6578bcd7b151c489e61f42227a45713/3-network-layer.svg" alt="Network Layer" /></p>
<p>두 개의 다른 네트워크 간의 데이터 전송을 용이하게 하는 역할을 하는 레이어다. 만약 두 개의 디바이스가 동일한 네트워크 상에서 통신한다면, 네트워크 레이어는 필요없다.</p>
<p>네트워크 레이어는 트랜스포트 레이어로부터 넘겨 받은 세그먼트를 패킷(packet)이라고 하는 더 작은 단위로 쪼갠다. 수신하는 측에서는 거꾸로 이러한 패킷을 재조립해준다.</p>
<p>네트워크 레이어는 또한 데이터가 대상에 도달하기 위한 최적의 물리적 경로를 찾는 역할도 수행하는데, 이를 라우팅(routing)이라고 한다.</p>
<h2 id="2-the-data-link-layer"><a class="header" href="#2-the-data-link-layer">2. The Data Link Layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3MR4mPOwaos80t1annw7BG/8ea1c59ccfa1baf6e9738773daa30450/2-data-link-layer.svg" alt="Data Link Layer" /></p>
<p>데이터 링크 레이어는 네트워크 레이어랑 매우 유사하다. <em>동일한</em> 네트워크의 두 디바이스 간 데이터 전송을 용이하게 한다는 점만 빼면.</p>
<p>데이터 링크 레이어는 네트워크 레이어로부터 패킷을 받아 이것을 프레임(frame)이라고 불리는 더 작은 조각들로 쪼갠다.</p>
<p>데이터 링크 레이어도 인트라 네트워크(intra-network) 통신 내에서의 flow control과 error control의 처리를 담당한다.</p>
<h2 id="1-the-physical-layer"><a class="header" href="#1-the-physical-layer">1. The Physical Layer</a></h2>
<p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/3m1ZkcaaBYHoodrEO3brv2/2819c4db294631b5753cd55de0c01bd9/1-physical-layer.svg" alt="Physical Layer" /></p>
<p>케이블, 스위치와 같은 데이터 전송과 관련된 물리적 장비가 포함되는 레이어다.</p>
<p>데이터가 비트스트림(bit stream ~ 1과 0의 스트링)으로 변환되는 레이어로, 두 디바이스 간 피지컬 레이어는 신호 규칙(signal convention)이 일치해야 양 디바이스 에서의 1과 0을 구별할 수 있게 된다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
